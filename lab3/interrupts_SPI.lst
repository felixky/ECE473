
interrupts_SPI.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00800100  000006b8  0000074c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000006b8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000001c  00800116  00800116  00000762  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000762  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000794  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000028  00000000  00000000  000007d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000c40  00000000  00000000  000007f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000099c  00000000  00000000  00001438  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000044d  00000000  00000000  00001dd4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000e4  00000000  00000000  00002224  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000042a  00000000  00000000  00002308  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000566  00000000  00000000  00002732  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000060  00000000  00000000  00002c98  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  40:	0c 94 7d 02 	jmp	0x4fa	; 0x4fa <__vector_16>
  44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e8 eb       	ldi	r30, 0xB8	; 184
  a0:	f6 e0       	ldi	r31, 0x06	; 6
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a6 31       	cpi	r26, 0x16	; 22
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	21 e0       	ldi	r18, 0x01	; 1
  b4:	a6 e1       	ldi	r26, 0x16	; 22
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	a2 33       	cpi	r26, 0x32	; 50
  be:	b2 07       	cpc	r27, r18
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <main>
  c6:	0c 94 5a 03 	jmp	0x6b4	; 0x6b4 <_exit>

000000ca <__bad_interrupt>:
  ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <spi_init>:
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
  ce:	87 b3       	in	r24, 0x17	; 23
  d0:	87 60       	ori	r24, 0x07	; 7
  d2:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
  d4:	8d b1       	in	r24, 0x0d	; 13
  d6:	8c 65       	ori	r24, 0x5C	; 92
  d8:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
  da:	70 9a       	sbi	0x0e, 0	; 14
  dc:	08 95       	ret

000000de <spi_read>:
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
  de:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
  e0:	77 9b       	sbis	0x0e, 7	; 14
  e2:	fe cf       	rjmp	.-4      	; 0xe0 <spi_read+0x2>
   return SPDR;
  e4:	8f b1       	in	r24, 0x0f	; 15
}
  e6:	08 95       	ret

000000e8 <chk_buttons>:
	be implemented at the same time. Adapted to check all buttons from 
	Ganssel's "Guide to Debouncing" Expects active low pushbuttons on PINA 
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
  e8:	48 2f       	mov	r20, r24
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
  ea:	e8 2f       	mov	r30, r24
  ec:	f0 e0       	ldi	r31, 0x00	; 0
  ee:	99 b3       	in	r25, 0x19	; 25
  f0:	ee 0f       	add	r30, r30
  f2:	ff 1f       	adc	r31, r31
  f4:	e0 5e       	subi	r30, 0xE0	; 224
  f6:	fe 4f       	sbci	r31, 0xFE	; 254
  f8:	20 81       	ld	r18, Z
  fa:	31 81       	ldd	r19, Z+1	; 0x01
  fc:	22 0f       	add	r18, r18
  fe:	33 1f       	adc	r19, r19
 100:	30 6e       	ori	r19, 0xE0	; 224
 102:	89 2f       	mov	r24, r25
 104:	90 e0       	ldi	r25, 0x00	; 0
 106:	02 c0       	rjmp	.+4      	; 0x10c <chk_buttons+0x24>
 108:	95 95       	asr	r25
 10a:	87 95       	ror	r24
 10c:	4a 95       	dec	r20
 10e:	e2 f7       	brpl	.-8      	; 0x108 <chk_buttons+0x20>
 110:	81 70       	andi	r24, 0x01	; 1
 112:	99 27       	eor	r25, r25
 114:	28 2b       	or	r18, r24
 116:	39 2b       	or	r19, r25
 118:	31 83       	std	Z+1, r19	; 0x01
 11a:	20 83       	st	Z, r18
 11c:	81 e0       	ldi	r24, 0x01	; 1
 11e:	21 15       	cp	r18, r1
 120:	30 4f       	sbci	r19, 0xF0	; 240
 122:	09 f0       	breq	.+2      	; 0x126 <chk_buttons+0x3e>
 124:	80 e0       	ldi	r24, 0x00	; 0
  if (state[button] == 0xF000)
    return 1;
return 0;
}
 126:	08 95       	ret

00000128 <segsum>:
Description: takes a 16-bit binary input value and places the appropriate equivalent 
	4 digit BCD segment code in the array segment_data for display. array is 
	loaded at exit as:  |digit3|digit2|colon|digit1|digit0|
Parameters: A sum that willl be decoded
************************************************************************************/
void segsum(uint16_t sum) {
 128:	cf 93       	push	r28
 12a:	ac 01       	movw	r20, r24
  int d0,d1,d2,d3; //,colon, digits;
  //determine how many digits there are 
  //break up decimal sum into 4 digit-segments
  //This block of code takes in the sum and finds the 0-9 value for each of the four led digits  
  if(hex) {
 12c:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <hex>
 130:	88 23       	and	r24, r24
 132:	69 f1       	breq	.+90     	; 0x18e <segsum+0x66>
     d0 = ((sum%256)%16);//1s digit
     d1 = (sum %256)/16; //10s digit
     d2 = sum/256;	 //100s digit. Integer division
     d3 = 0;		 //1000s digit. 1023 will never need this digit

     segment_data[0] = dec_to_7seg[d0]; 
 134:	fa 01       	movw	r30, r20
 136:	ef 70       	andi	r30, 0x0F	; 15
 138:	ff 27       	eor	r31, r31
 13a:	e0 50       	subi	r30, 0x00	; 0
 13c:	ff 4f       	sbci	r31, 0xFF	; 255
 13e:	80 81       	ld	r24, Z
 140:	80 93 16 01 	sts	0x0116, r24	; 0x800116 <__data_end>
     segment_data[1] = dec_to_7seg[d1];
 144:	fa 01       	movw	r30, r20
 146:	ff 27       	eor	r31, r31
 148:	f2 95       	swap	r31
 14a:	e2 95       	swap	r30
 14c:	ef 70       	andi	r30, 0x0F	; 15
 14e:	ef 27       	eor	r30, r31
 150:	ff 70       	andi	r31, 0x0F	; 15
 152:	ef 27       	eor	r30, r31
 154:	e0 50       	subi	r30, 0x00	; 0
 156:	ff 4f       	sbci	r31, 0xFF	; 255
 158:	80 81       	ld	r24, Z
 15a:	80 93 17 01 	sts	0x0117, r24	; 0x800117 <__data_end+0x1>
     segment_data[2] = 0xFF;
 15e:	8f ef       	ldi	r24, 0xFF	; 255
 160:	80 93 18 01 	sts	0x0118, r24	; 0x800118 <__data_end+0x2>
     segment_data[3] = dec_to_7seg[d2];
 164:	e5 2f       	mov	r30, r21
 166:	ff 27       	eor	r31, r31
 168:	e0 50       	subi	r30, 0x00	; 0
 16a:	ff 4f       	sbci	r31, 0xFF	; 255
 16c:	90 81       	ld	r25, Z
 16e:	90 93 19 01 	sts	0x0119, r25	; 0x800119 <__data_end+0x3>
     segment_data[4] = 0xFF;
 172:	80 93 1a 01 	sts	0x011A, r24	; 0x80011a <__data_end+0x4>
     
     if(sum < 0x100)	//Compares the sum to 255
 176:	4f 3f       	cpi	r20, 0xFF	; 255
 178:	51 05       	cpc	r21, r1
 17a:	09 f0       	breq	.+2      	; 0x17e <segsum+0x56>
 17c:	30 f4       	brcc	.+12     	; 0x18a <segsum+0x62>
	segment_data[3] = 0xFF;
 17e:	80 93 19 01 	sts	0x0119, r24	; 0x800119 <__data_end+0x3>
     if(sum < 0x10)	//Compares the sum to 10
 182:	40 31       	cpi	r20, 0x10	; 16
 184:	51 05       	cpc	r21, r1
 186:	08 f4       	brcc	.+2      	; 0x18a <segsum+0x62>
 188:	75 c0       	rjmp	.+234    	; 0x274 <segsum+0x14c>
	segment_data[3] = 0xFF;
     if(sum < 0xA)	//Compares the sum to 10
	segment_data[1] = 0xFF;
  }
   return;
}//segment_sum
 18a:	cf 91       	pop	r28
 18c:	08 95       	ret
     d1 = (((sum % 100) / 10) % 10);	//10's digit
     d2 = (sum / 100) % 10;		//100's digit
     d3 = (sum / 1000) % 10;		//1000's digit

  //This block changes the decimal from just above into 8-bits that can be displayed on the segments 
     segment_data[0] = dec_to_7seg[d0]; 
 18e:	9a 01       	movw	r18, r20
 190:	ad ec       	ldi	r26, 0xCD	; 205
 192:	bc ec       	ldi	r27, 0xCC	; 204
 194:	0e 94 37 03 	call	0x66e	; 0x66e <__umulhisi3>
 198:	96 95       	lsr	r25
 19a:	87 95       	ror	r24
 19c:	96 95       	lsr	r25
 19e:	87 95       	ror	r24
 1a0:	96 95       	lsr	r25
 1a2:	87 95       	ror	r24
 1a4:	9c 01       	movw	r18, r24
 1a6:	22 0f       	add	r18, r18
 1a8:	33 1f       	adc	r19, r19
 1aa:	88 0f       	add	r24, r24
 1ac:	99 1f       	adc	r25, r25
 1ae:	88 0f       	add	r24, r24
 1b0:	99 1f       	adc	r25, r25
 1b2:	88 0f       	add	r24, r24
 1b4:	99 1f       	adc	r25, r25
 1b6:	82 0f       	add	r24, r18
 1b8:	93 1f       	adc	r25, r19
 1ba:	fa 01       	movw	r30, r20
 1bc:	e8 1b       	sub	r30, r24
 1be:	f9 0b       	sbc	r31, r25
 1c0:	e0 50       	subi	r30, 0x00	; 0
 1c2:	ff 4f       	sbci	r31, 0xFF	; 255
 1c4:	80 81       	ld	r24, Z
 1c6:	80 93 16 01 	sts	0x0116, r24	; 0x800116 <__data_end>
     segment_data[1] = dec_to_7seg[d1];
 1ca:	9a 01       	movw	r18, r20
 1cc:	36 95       	lsr	r19
 1ce:	27 95       	ror	r18
 1d0:	36 95       	lsr	r19
 1d2:	27 95       	ror	r18
 1d4:	ab e7       	ldi	r26, 0x7B	; 123
 1d6:	b4 e1       	ldi	r27, 0x14	; 20
 1d8:	0e 94 37 03 	call	0x66e	; 0x66e <__umulhisi3>
 1dc:	fc 01       	movw	r30, r24
 1de:	f6 95       	lsr	r31
 1e0:	e7 95       	ror	r30
 1e2:	24 e6       	ldi	r18, 0x64	; 100
 1e4:	2e 9f       	mul	r18, r30
 1e6:	c0 01       	movw	r24, r0
 1e8:	2f 9f       	mul	r18, r31
 1ea:	90 0d       	add	r25, r0
 1ec:	11 24       	eor	r1, r1
 1ee:	9a 01       	movw	r18, r20
 1f0:	28 1b       	sub	r18, r24
 1f2:	39 0b       	sbc	r19, r25
 1f4:	ad ec       	ldi	r26, 0xCD	; 205
 1f6:	bc ec       	ldi	r27, 0xCC	; 204
 1f8:	0e 94 37 03 	call	0x66e	; 0x66e <__umulhisi3>
 1fc:	96 95       	lsr	r25
 1fe:	87 95       	ror	r24
 200:	96 95       	lsr	r25
 202:	87 95       	ror	r24
 204:	96 95       	lsr	r25
 206:	87 95       	ror	r24
 208:	dc 01       	movw	r26, r24
 20a:	a0 50       	subi	r26, 0x00	; 0
 20c:	bf 4f       	sbci	r27, 0xFF	; 255
 20e:	8c 91       	ld	r24, X
 210:	80 93 17 01 	sts	0x0117, r24	; 0x800117 <__data_end+0x1>
     segment_data[2] = 0xFF;
 214:	cf ef       	ldi	r28, 0xFF	; 255
 216:	c0 93 18 01 	sts	0x0118, r28	; 0x800118 <__data_end+0x2>
     segment_data[3] = dec_to_7seg[d2];
 21a:	9f 01       	movw	r18, r30
 21c:	ad ec       	ldi	r26, 0xCD	; 205
 21e:	bc ec       	ldi	r27, 0xCC	; 204
 220:	0e 94 37 03 	call	0x66e	; 0x66e <__umulhisi3>
 224:	96 95       	lsr	r25
 226:	87 95       	ror	r24
 228:	96 95       	lsr	r25
 22a:	87 95       	ror	r24
 22c:	96 95       	lsr	r25
 22e:	87 95       	ror	r24
 230:	9c 01       	movw	r18, r24
 232:	22 0f       	add	r18, r18
 234:	33 1f       	adc	r19, r19
 236:	88 0f       	add	r24, r24
 238:	99 1f       	adc	r25, r25
 23a:	88 0f       	add	r24, r24
 23c:	99 1f       	adc	r25, r25
 23e:	88 0f       	add	r24, r24
 240:	99 1f       	adc	r25, r25
 242:	82 0f       	add	r24, r18
 244:	93 1f       	adc	r25, r19
 246:	e8 1b       	sub	r30, r24
 248:	f9 0b       	sbc	r31, r25
 24a:	e0 50       	subi	r30, 0x00	; 0
 24c:	ff 4f       	sbci	r31, 0xFF	; 255
 24e:	80 81       	ld	r24, Z
 250:	80 93 19 01 	sts	0x0119, r24	; 0x800119 <__data_end+0x3>
     segment_data[4] = dec_to_7seg[d3];

  //blank out leading zero digits and determine number of digits
     if(sum < 0x3E8)	//Compares the sum to 1000
 254:	48 3e       	cpi	r20, 0xE8	; 232
 256:	83 e0       	ldi	r24, 0x03	; 3
 258:	58 07       	cpc	r21, r24
 25a:	88 f4       	brcc	.+34     	; 0x27e <segsum+0x156>
	segment_data[4] = 0xFF;
 25c:	c0 93 1a 01 	sts	0x011A, r28	; 0x80011a <__data_end+0x4>
     if(sum < 0x64)	//Compares the sum to 100
 260:	44 36       	cpi	r20, 0x64	; 100
 262:	51 05       	cpc	r21, r1
 264:	08 f0       	brcs	.+2      	; 0x268 <segsum+0x140>
 266:	91 cf       	rjmp	.-222    	; 0x18a <segsum+0x62>
	segment_data[3] = 0xFF;
 268:	c0 93 19 01 	sts	0x0119, r28	; 0x800119 <__data_end+0x3>
     if(sum < 0xA)	//Compares the sum to 10
 26c:	4a 30       	cpi	r20, 0x0A	; 10
 26e:	51 05       	cpc	r21, r1
 270:	08 f0       	brcs	.+2      	; 0x274 <segsum+0x14c>
 272:	8b cf       	rjmp	.-234    	; 0x18a <segsum+0x62>
     segment_data[4] = 0xFF;
     
     if(sum < 0x100)	//Compares the sum to 255
	segment_data[3] = 0xFF;
     if(sum < 0x10)	//Compares the sum to 10
	segment_data[1] = 0xFF;
 274:	8f ef       	ldi	r24, 0xFF	; 255
 276:	80 93 17 01 	sts	0x0117, r24	; 0x800117 <__data_end+0x1>
	segment_data[3] = 0xFF;
     if(sum < 0xA)	//Compares the sum to 10
	segment_data[1] = 0xFF;
  }
   return;
}//segment_sum
 27a:	cf 91       	pop	r28
 27c:	08 95       	ret
  //This block changes the decimal from just above into 8-bits that can be displayed on the segments 
     segment_data[0] = dec_to_7seg[d0]; 
     segment_data[1] = dec_to_7seg[d1];
     segment_data[2] = 0xFF;
     segment_data[3] = dec_to_7seg[d2];
     segment_data[4] = dec_to_7seg[d3];
 27e:	9a 01       	movw	r18, r20
 280:	36 95       	lsr	r19
 282:	27 95       	ror	r18
 284:	36 95       	lsr	r19
 286:	27 95       	ror	r18
 288:	36 95       	lsr	r19
 28a:	27 95       	ror	r18
 28c:	a5 ec       	ldi	r26, 0xC5	; 197
 28e:	b0 e2       	ldi	r27, 0x20	; 32
 290:	0e 94 37 03 	call	0x66e	; 0x66e <__umulhisi3>
 294:	ac 01       	movw	r20, r24
 296:	52 95       	swap	r21
 298:	42 95       	swap	r20
 29a:	4f 70       	andi	r20, 0x0F	; 15
 29c:	45 27       	eor	r20, r21
 29e:	5f 70       	andi	r21, 0x0F	; 15
 2a0:	45 27       	eor	r20, r21
 2a2:	9a 01       	movw	r18, r20
 2a4:	ad ec       	ldi	r26, 0xCD	; 205
 2a6:	bc ec       	ldi	r27, 0xCC	; 204
 2a8:	0e 94 37 03 	call	0x66e	; 0x66e <__umulhisi3>
 2ac:	96 95       	lsr	r25
 2ae:	87 95       	ror	r24
 2b0:	96 95       	lsr	r25
 2b2:	87 95       	ror	r24
 2b4:	96 95       	lsr	r25
 2b6:	87 95       	ror	r24
 2b8:	9c 01       	movw	r18, r24
 2ba:	22 0f       	add	r18, r18
 2bc:	33 1f       	adc	r19, r19
 2be:	88 0f       	add	r24, r24
 2c0:	99 1f       	adc	r25, r25
 2c2:	88 0f       	add	r24, r24
 2c4:	99 1f       	adc	r25, r25
 2c6:	88 0f       	add	r24, r24
 2c8:	99 1f       	adc	r25, r25
 2ca:	82 0f       	add	r24, r18
 2cc:	93 1f       	adc	r25, r19
 2ce:	48 1b       	sub	r20, r24
 2d0:	59 0b       	sbc	r21, r25
 2d2:	fa 01       	movw	r30, r20
 2d4:	e0 50       	subi	r30, 0x00	; 0
 2d6:	ff 4f       	sbci	r31, 0xFF	; 255
 2d8:	80 81       	ld	r24, Z
 2da:	80 93 1a 01 	sts	0x011A, r24	; 0x80011a <__data_end+0x4>
	segment_data[3] = 0xFF;
     if(sum < 0xA)	//Compares the sum to 10
	segment_data[1] = 0xFF;
  }
   return;
}//segment_sum
 2de:	cf 91       	pop	r28
 2e0:	08 95       	ret

000002e2 <bars>:
Description:This function reads in the button board and updates the 
	LEDs on the bargraph through the serial port.
Parameters: NA
**********************************************************************/
void bars() {
   DDRA = 0x00;				//Set all as inputs
 2e2:	1a ba       	out	0x1a, r1	; 26
   PORTA = 0xFF;			//Pull up resistors
 2e4:	8f ef       	ldi	r24, 0xFF	; 255
 2e6:	8b bb       	out	0x1b, r24	; 27
   PORTB |= PINB | 0x70;		//Enable tristate buffer
 2e8:	86 b3       	in	r24, 0x16	; 22
 2ea:	98 b3       	in	r25, 0x18	; 24
 2ec:	80 67       	ori	r24, 0x70	; 112
 2ee:	89 2b       	or	r24, r25
 2f0:	88 bb       	out	0x18, r24	; 24
 2f2:	e0 e2       	ldi	r30, 0x20	; 32
 2f4:	f1 e0       	ldi	r31, 0x01	; 1

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
 2f6:	20 e0       	ldi	r18, 0x00	; 0
 2f8:	30 e0       	ldi	r19, 0x00	; 0
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
 2fa:	61 e0       	ldi	r22, 0x01	; 1
 2fc:	70 e0       	ldi	r23, 0x00	; 0
 2fe:	05 c0       	rjmp	.+10     	; 0x30a <bars+0x28>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
 300:	2f 5f       	subi	r18, 0xFF	; 255
 302:	3f 4f       	sbci	r19, 0xFF	; 255
 304:	28 30       	cpi	r18, 0x08	; 8
 306:	31 05       	cpc	r19, r1
 308:	39 f1       	breq	.+78     	; 0x358 <bars+0x76>
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
 30a:	99 b3       	in	r25, 0x19	; 25
 30c:	40 81       	ld	r20, Z
 30e:	51 81       	ldd	r21, Z+1	; 0x01
 310:	44 0f       	add	r20, r20
 312:	55 1f       	adc	r21, r21
 314:	89 2f       	mov	r24, r25
 316:	90 e0       	ldi	r25, 0x00	; 0
 318:	02 2e       	mov	r0, r18
 31a:	02 c0       	rjmp	.+4      	; 0x320 <bars+0x3e>
 31c:	95 95       	asr	r25
 31e:	87 95       	ror	r24
 320:	0a 94       	dec	r0
 322:	e2 f7       	brpl	.-8      	; 0x31c <bars+0x3a>
 324:	81 70       	andi	r24, 0x01	; 1
 326:	99 27       	eor	r25, r25
 328:	84 2b       	or	r24, r20
 32a:	95 2b       	or	r25, r21
 32c:	90 6e       	ori	r25, 0xE0	; 224
 32e:	81 93       	st	Z+, r24
 330:	91 93       	st	Z+, r25
  if (state[button] == 0xF000)
 332:	81 15       	cp	r24, r1
 334:	90 4f       	sbci	r25, 0xF0	; 240
 336:	21 f7       	brne	.-56     	; 0x300 <bars+0x1e>
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
 338:	cb 01       	movw	r24, r22
 33a:	02 2e       	mov	r0, r18
 33c:	02 c0       	rjmp	.+4      	; 0x342 <bars+0x60>
 33e:	88 0f       	add	r24, r24
 340:	99 1f       	adc	r25, r25
 342:	0a 94       	dec	r0
 344:	e2 f7       	brpl	.-8      	; 0x33e <bars+0x5c>
 346:	90 93 1e 01 	sts	0x011E, r25	; 0x80011e <mult+0x1>
 34a:	80 93 1d 01 	sts	0x011D, r24	; 0x80011d <mult>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
 34e:	2f 5f       	subi	r18, 0xFF	; 255
 350:	3f 4f       	sbci	r19, 0xFF	; 255
 352:	28 30       	cpi	r18, 0x08	; 8
 354:	31 05       	cpc	r19, r1
 356:	c9 f6       	brne	.-78     	; 0x30a <bars+0x28>
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
 358:	88 b3       	in	r24, 0x18	; 24
 35a:	18 ba       	out	0x18, r1	; 24
   if(mult == 128){			//Button 8 toggles base 10 and 16
 35c:	80 91 1d 01 	lds	r24, 0x011D	; 0x80011d <mult>
 360:	90 91 1e 01 	lds	r25, 0x011E	; 0x80011e <mult+0x1>
 364:	80 38       	cpi	r24, 0x80	; 128
 366:	91 05       	cpc	r25, r1
 368:	09 f4       	brne	.+2      	; 0x36c <bars+0x8a>
 36a:	40 c0       	rjmp	.+128    	; 0x3ec <bars+0x10a>
      hex = !(hex);			//on the LED display
   }
   if(mult > 4) {			//I only want values from the
 36c:	80 91 1d 01 	lds	r24, 0x011D	; 0x80011d <mult>
 370:	90 91 1e 01 	lds	r25, 0x011E	; 0x80011e <mult+0x1>
 374:	05 97       	sbiw	r24, 0x05	; 5
 376:	20 f0       	brcs	.+8      	; 0x380 <bars+0x9e>
      mult = 0;				//first three buttons
 378:	10 92 1e 01 	sts	0x011E, r1	; 0x80011e <mult+0x1>
 37c:	10 92 1d 01 	sts	0x011D, r1	; 0x80011d <mult>
   }
   //This switch statement is used to enable a 'toggle' functionality
   //so that modes can be selected an deselected
   switch(mult) {
 380:	80 91 1d 01 	lds	r24, 0x011D	; 0x80011d <mult>
 384:	90 91 1e 01 	lds	r25, 0x011E	; 0x80011e <mult+0x1>
 388:	82 30       	cpi	r24, 0x02	; 2
 38a:	91 05       	cpc	r25, r1
 38c:	09 f4       	brne	.+2      	; 0x390 <bars+0xae>
 38e:	4e c0       	rjmp	.+156    	; 0x42c <__LOCK_REGION_LENGTH__+0x2c>
 390:	84 30       	cpi	r24, 0x04	; 4
 392:	91 05       	cpc	r25, r1
 394:	99 f1       	breq	.+102    	; 0x3fc <bars+0x11a>
 396:	81 30       	cpi	r24, 0x01	; 1
 398:	91 05       	cpc	r25, r1
 39a:	c1 f0       	breq	.+48     	; 0x3cc <bars+0xea>
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
         break;
      default:
	 mode_sel = mode_sel;		//no/invalid button press
 39c:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <mode_sel>
 3a0:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <mode_sel+0x1>
 3a4:	90 93 15 01 	sts	0x0115, r25	; 0x800115 <mode_sel+0x1>
 3a8:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <mode_sel>
   }   
   mult = 0;				//clear mult for next pass
 3ac:	10 92 1e 01 	sts	0x011E, r1	; 0x80011e <mult+0x1>
 3b0:	10 92 1d 01 	sts	0x011D, r1	; 0x80011d <mult>

   DDRA = 0xFF;				//Set A to alloutputs
 3b4:	8f ef       	ldi	r24, 0xFF	; 255
 3b6:	8a bb       	out	0x1a, r24	; 26
   SPDR = mode_sel;			//Write mode to the Bargraph
 3b8:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <mode_sel>
 3bc:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <mode_sel+0x1>
 3c0:	8f b9       	out	0x0f, r24	; 15
   while(bit_is_clear(SPSR, SPIF)){}	
 3c2:	77 9b       	sbis	0x0e, 7	; 14
 3c4:	fe cf       	rjmp	.-4      	; 0x3c2 <bars+0xe0>
   PORTB |= (1<<PB0);			//Rgclk high on bargraph
 3c6:	c0 9a       	sbi	0x18, 0	; 24
   PORTB &= 0xFE;			//Rgclk low on bargraph
 3c8:	c0 98       	cbi	0x18, 0	; 24
   
return ;
 3ca:	08 95       	ret
   }
   //This switch statement is used to enable a 'toggle' functionality
   //so that modes can be selected an deselected
   switch(mult) {
      case 1:
	 if((mode_sel ^ mult) == 0){	//XOR to see if they are the same
 3cc:	40 91 14 01 	lds	r20, 0x0114	; 0x800114 <mode_sel>
 3d0:	50 91 15 01 	lds	r21, 0x0115	; 0x800115 <mode_sel+0x1>
 3d4:	20 91 1d 01 	lds	r18, 0x011D	; 0x80011d <mult>
 3d8:	30 91 1e 01 	lds	r19, 0x011E	; 0x80011e <mult+0x1>
 3dc:	42 17       	cp	r20, r18
 3de:	53 07       	cpc	r21, r19
 3e0:	09 f7       	brne	.-62     	; 0x3a4 <bars+0xc2>
	 else
	    mode_sel = 2;		//If not, then change mode
         break;
      case 4:
	 if((mode_sel ^ mult) && (mode_sel != 1)){//if cur &prev are diff
	    mode_sel = 0;//and prev isn't = 1 then two modes are selected
 3e2:	10 92 15 01 	sts	0x0115, r1	; 0x800115 <mode_sel+0x1>
 3e6:	10 92 14 01 	sts	0x0114, r1	; 0x800114 <mode_sel>
 3ea:	e0 cf       	rjmp	.-64     	; 0x3ac <bars+0xca>
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      hex = !(hex);			//on the LED display
 3ec:	90 91 1f 01 	lds	r25, 0x011F	; 0x80011f <hex>
 3f0:	81 e0       	ldi	r24, 0x01	; 1
 3f2:	91 11       	cpse	r25, r1
 3f4:	33 c0       	rjmp	.+102    	; 0x45c <__LOCK_REGION_LENGTH__+0x5c>
 3f6:	80 93 1f 01 	sts	0x011F, r24	; 0x80011f <hex>
 3fa:	b8 cf       	rjmp	.-144    	; 0x36c <bars+0x8a>
	 }
	 else
	    mode_sel = 2;		//If not, then change mode
         break;
      case 4:
	 if((mode_sel ^ mult) && (mode_sel != 1)){//if cur &prev are diff
 3fc:	20 91 14 01 	lds	r18, 0x0114	; 0x800114 <mode_sel>
 400:	30 91 15 01 	lds	r19, 0x0115	; 0x800115 <mode_sel+0x1>
 404:	80 91 1d 01 	lds	r24, 0x011D	; 0x80011d <mult>
 408:	90 91 1e 01 	lds	r25, 0x011E	; 0x80011e <mult+0x1>
 40c:	28 17       	cp	r18, r24
 40e:	39 07       	cpc	r19, r25
 410:	31 f0       	breq	.+12     	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
 412:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <mode_sel>
 416:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <mode_sel+0x1>
 41a:	01 97       	sbiw	r24, 0x01	; 1
 41c:	11 f7       	brne	.-60     	; 0x3e2 <bars+0x100>
	    mode_sel = 0;//and prev isn't = 1 then two modes are selected
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
 41e:	84 e0       	ldi	r24, 0x04	; 4
 420:	90 e0       	ldi	r25, 0x00	; 0
 422:	90 93 15 01 	sts	0x0115, r25	; 0x800115 <mode_sel+0x1>
 426:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <mode_sel>
 42a:	c0 cf       	rjmp	.-128    	; 0x3ac <bars+0xca>
	 }
	 else
	    mode_sel = 1;		//If not, then change mode
         break;
      case 2:
	 if((mode_sel ^ mult) && (mode_sel != 1)){//if cur &prev are diff
 42c:	20 91 14 01 	lds	r18, 0x0114	; 0x800114 <mode_sel>
 430:	30 91 15 01 	lds	r19, 0x0115	; 0x800115 <mode_sel+0x1>
 434:	80 91 1d 01 	lds	r24, 0x011D	; 0x80011d <mult>
 438:	90 91 1e 01 	lds	r25, 0x011E	; 0x80011e <mult+0x1>
 43c:	28 17       	cp	r18, r24
 43e:	39 07       	cpc	r19, r25
 440:	31 f0       	breq	.+12     	; 0x44e <__LOCK_REGION_LENGTH__+0x4e>
 442:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <mode_sel>
 446:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <mode_sel+0x1>
 44a:	01 97       	sbiw	r24, 0x01	; 1
 44c:	51 f6       	brne	.-108    	; 0x3e2 <bars+0x100>
	    mode_sel = 0;//and prev isn't = 1 then two modes are selected
	 }
	 else
	    mode_sel = 2;		//If not, then change mode
 44e:	82 e0       	ldi	r24, 0x02	; 2
 450:	90 e0       	ldi	r25, 0x00	; 0
 452:	90 93 15 01 	sts	0x0115, r25	; 0x800115 <mode_sel+0x1>
 456:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <mode_sel>
 45a:	a8 cf       	rjmp	.-176    	; 0x3ac <bars+0xca>
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      hex = !(hex);			//on the LED display
 45c:	80 e0       	ldi	r24, 0x00	; 0
 45e:	80 93 1f 01 	sts	0x011F, r24	; 0x80011f <hex>
 462:	84 cf       	rjmp	.-248    	; 0x36c <bars+0x8a>

00000464 <read_encoder>:
   int8_t value = 0x00;
   uint8_t ec_a;
   uint8_t ec_b;

   //Shift_LD_N low
   PORTE &= 0x00;	//Begining of SHIFT_LD_N pulse. It is low here
 464:	83 b1       	in	r24, 0x03	; 3
 466:	13 b8       	out	0x03, r1	; 3
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 468:	87 ec       	ldi	r24, 0xC7	; 199
 46a:	90 e0       	ldi	r25, 0x00	; 0
 46c:	01 97       	sbiw	r24, 0x01	; 1
 46e:	f1 f7       	brne	.-4      	; 0x46c <read_encoder+0x8>
 470:	00 c0       	rjmp	.+0      	; 0x472 <read_encoder+0xe>
 472:	00 00       	nop
   _delay_us(50);
   PORTE |= 0xFF;	//End of SHIFT_LD_N pulse. back to high
 474:	83 b1       	in	r24, 0x03	; 3
 476:	8f ef       	ldi	r24, 0xFF	; 255
 478:	83 b9       	out	0x03, r24	; 3
   PORTD &= 0x00;	//CLK_INH low
 47a:	82 b3       	in	r24, 0x12	; 18
 47c:	12 ba       	out	0x12, r1	; 18
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
 47e:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
 480:	77 9b       	sbis	0x0e, 7	; 14
 482:	fe cf       	rjmp	.-4      	; 0x480 <read_encoder+0x1c>
   return SPDR;
 484:	9f b1       	in	r25, 0x0f	; 15
   _delay_us(50);
   PORTE |= 0xFF;	//End of SHIFT_LD_N pulse. back to high
   PORTD &= 0x00;	//CLK_INH low

   encoder_value = spi_read();
   PORTD |= 0x02;	//CLK_INH high
 486:	91 9a       	sbi	0x12, 1	; 18
   value = mode_sel;
 488:	60 91 14 01 	lds	r22, 0x0114	; 0x800114 <mode_sel>
 48c:	70 91 15 01 	lds	r23, 0x0115	; 0x800115 <mode_sel+0x1>
 490:	86 2f       	mov	r24, r22
   ec_a = encoder_value & 0x03;  //Only grabs these bits 0000_0011
 492:	49 2f       	mov	r20, r25
 494:	43 70       	andi	r20, 0x03	; 3
   ec_b = encoder_value & 0x0C;  //Only grabs these bits 0000_1100 
 496:	9c 70       	andi	r25, 0x0C	; 12
   ec_b = (ec_b >> 2);
 498:	96 95       	lsr	r25
 49a:	96 95       	lsr	r25

   if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
 49c:	20 91 31 01 	lds	r18, 0x0131	; 0x800131 <EC_a_prev>
 4a0:	e4 2f       	mov	r30, r20
 4a2:	f0 e0       	ldi	r31, 0x00	; 0
 4a4:	02 2e       	mov	r0, r18
 4a6:	00 0c       	add	r0, r0
 4a8:	33 0b       	sbc	r19, r19
 4aa:	e2 17       	cp	r30, r18
 4ac:	f3 07       	cpc	r31, r19
 4ae:	91 f0       	breq	.+36     	; 0x4d4 <read_encoder+0x70>
      if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
 4b0:	20 91 31 01 	lds	r18, 0x0131	; 0x800131 <EC_a_prev>
 4b4:	21 11       	cpse	r18, r1
 4b6:	02 c0       	rjmp	.+4      	; 0x4bc <read_encoder+0x58>
 4b8:	41 30       	cpi	r20, 0x01	; 1
 4ba:	39 f0       	breq	.+14     	; 0x4ca <read_encoder+0x66>
         value = value;
      }
      else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
 4bc:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <EC_a_prev>
 4c0:	81 11       	cpse	r24, r1
 4c2:	02 c0       	rjmp	.+4      	; 0x4c8 <read_encoder+0x64>
 4c4:	42 30       	cpi	r20, 0x02	; 2
 4c6:	91 f0       	breq	.+36     	; 0x4ec <read_encoder+0x88>
	 value = -(value); 
      }
      else	//If not one of the state changes above, do nothing
	 value = 0;
 4c8:	80 e0       	ldi	r24, 0x00	; 0
      }
      else
	 value = 0;
   }
//Saves previous values into volatile variables
EC_a_prev = ec_a;
 4ca:	40 93 31 01 	sts	0x0131, r20	; 0x800131 <EC_a_prev>
EC_b_prev = ec_b;
 4ce:	90 93 30 01 	sts	0x0130, r25	; 0x800130 <EC_b_prev>

return value;
}
 4d2:	08 95       	ret
      }
      else	//If not one of the state changes above, do nothing
	 value = 0;
   }
   else {	//This is for encoder B
      if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
 4d4:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <EC_b_prev>
 4d8:	21 11       	cpse	r18, r1
 4da:	02 c0       	rjmp	.+4      	; 0x4e0 <read_encoder+0x7c>
 4dc:	91 30       	cpi	r25, 0x01	; 1
 4de:	a9 f3       	breq	.-22     	; 0x4ca <read_encoder+0x66>
         value = value; 
      }
      else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
 4e0:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <EC_b_prev>
 4e4:	81 11       	cpse	r24, r1
 4e6:	f0 cf       	rjmp	.-32     	; 0x4c8 <read_encoder+0x64>
 4e8:	92 30       	cpi	r25, 0x02	; 2
 4ea:	71 f7       	brne	.-36     	; 0x4c8 <read_encoder+0x64>
	 value = -(value);
 4ec:	86 2f       	mov	r24, r22
 4ee:	81 95       	neg	r24
      }
      else
	 value = 0;
   }
//Saves previous values into volatile variables
EC_a_prev = ec_a;
 4f0:	40 93 31 01 	sts	0x0131, r20	; 0x800131 <EC_a_prev>
EC_b_prev = ec_b;
 4f4:	90 93 30 01 	sts	0x0130, r25	; 0x800130 <EC_b_prev>

return value;
}
 4f8:	08 95       	ret

000004fa <__vector_16>:
	update the mode and bargraph. Then I change the sum based on	
	the value returned from the encoder reading. Sum is then bounded
	from 0-1023. 1023+1=1 and 0-any number > 0 = 1023.
Parameters: NA
**********************************************************************/
ISR(TIMER0_OVF_vect) {
 4fa:	1f 92       	push	r1
 4fc:	0f 92       	push	r0
 4fe:	0f b6       	in	r0, 0x3f	; 63
 500:	0f 92       	push	r0
 502:	11 24       	eor	r1, r1
 504:	0b b6       	in	r0, 0x3b	; 59
 506:	0f 92       	push	r0
 508:	2f 93       	push	r18
 50a:	3f 93       	push	r19
 50c:	4f 93       	push	r20
 50e:	5f 93       	push	r21
 510:	6f 93       	push	r22
 512:	7f 93       	push	r23
 514:	8f 93       	push	r24
 516:	9f 93       	push	r25
 518:	af 93       	push	r26
 51a:	bf 93       	push	r27
 51c:	ef 93       	push	r30
 51e:	ff 93       	push	r31
      bars();      
 520:	0e 94 71 01 	call	0x2e2	; 0x2e2 <bars>
      sum = sum + read_encoder();
 524:	0e 94 32 02 	call	0x464	; 0x464 <read_encoder>
 528:	20 91 1b 01 	lds	r18, 0x011B	; 0x80011b <sum>
 52c:	30 91 1c 01 	lds	r19, 0x011C	; 0x80011c <sum+0x1>
 530:	28 0f       	add	r18, r24
 532:	31 1d       	adc	r19, r1
 534:	87 fd       	sbrc	r24, 7
 536:	3a 95       	dec	r19
 538:	30 93 1c 01 	sts	0x011C, r19	; 0x80011c <sum+0x1>
 53c:	20 93 1b 01 	sts	0x011B, r18	; 0x80011b <sum>
      if(sum>1023)
 540:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <sum>
 544:	90 91 1c 01 	lds	r25, 0x011C	; 0x80011c <sum+0x1>
 548:	81 15       	cp	r24, r1
 54a:	94 40       	sbci	r25, 0x04	; 4
 54c:	64 f0       	brlt	.+24     	; 0x566 <__vector_16+0x6c>
	sum = sum % 1023;
 54e:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <sum>
 552:	90 91 1c 01 	lds	r25, 0x011C	; 0x80011c <sum+0x1>
 556:	6f ef       	ldi	r22, 0xFF	; 255
 558:	73 e0       	ldi	r23, 0x03	; 3
 55a:	0e 94 23 03 	call	0x646	; 0x646 <__divmodhi4>
 55e:	90 93 1c 01 	sts	0x011C, r25	; 0x80011c <sum+0x1>
 562:	80 93 1b 01 	sts	0x011B, r24	; 0x80011b <sum>
      if(sum<0)
 566:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <sum>
 56a:	90 91 1c 01 	lds	r25, 0x011C	; 0x80011c <sum+0x1>
 56e:	97 ff       	sbrs	r25, 7
 570:	06 c0       	rjmp	.+12     	; 0x57e <__vector_16+0x84>
	sum = 1023; //No overflow. If less than 0 always go to 1023.
 572:	8f ef       	ldi	r24, 0xFF	; 255
 574:	93 e0       	ldi	r25, 0x03	; 3
 576:	90 93 1c 01 	sts	0x011C, r25	; 0x80011c <sum+0x1>
 57a:	80 93 1b 01 	sts	0x011B, r24	; 0x80011b <sum>

}
 57e:	ff 91       	pop	r31
 580:	ef 91       	pop	r30
 582:	bf 91       	pop	r27
 584:	af 91       	pop	r26
 586:	9f 91       	pop	r25
 588:	8f 91       	pop	r24
 58a:	7f 91       	pop	r23
 58c:	6f 91       	pop	r22
 58e:	5f 91       	pop	r21
 590:	4f 91       	pop	r20
 592:	3f 91       	pop	r19
 594:	2f 91       	pop	r18
 596:	0f 90       	pop	r0
 598:	0b be       	out	0x3b, r0	; 59
 59a:	0f 90       	pop	r0
 59c:	0f be       	out	0x3f, r0	; 63
 59e:	0f 90       	pop	r0
 5a0:	1f 90       	pop	r1
 5a2:	18 95       	reti

000005a4 <main>:
	and while loop are defined. The LED display is updated continuously 
	in the loop.
Parameters: NA
**********************************************************************/
int main() {
   TIMSK |= (1<<TOIE0);			//enable interrupts
 5a4:	87 b7       	in	r24, 0x37	; 55
 5a6:	81 60       	ori	r24, 0x01	; 1
 5a8:	87 bf       	out	0x37, r24	; 55
   TCCR0 |= (1<<CS02) | (1<<CS00);	//normal mode, prescale by 128
 5aa:	83 b7       	in	r24, 0x33	; 51
 5ac:	85 60       	ori	r24, 0x05	; 5
 5ae:	83 bf       	out	0x33, r24	; 51
 
   DDRC |= 0xFF; 
 5b0:	84 b3       	in	r24, 0x14	; 20
 5b2:	9f ef       	ldi	r25, 0xFF	; 255
 5b4:	94 bb       	out	0x14, r25	; 20
   DDRB |= 0xF0;				//PB4-6 is SEL0-2, PB7 is PWM
 5b6:	87 b3       	in	r24, 0x17	; 23
 5b8:	80 6f       	ori	r24, 0xF0	; 240
 5ba:	87 bb       	out	0x17, r24	; 23
   DDRE |= 0x40;				//PE6 is SHIFT_LD_N
 5bc:	16 9a       	sbi	0x02, 6	; 2
   DDRD |= 0x0B;				//PE1 is CLK_INH and PE2 is SRCLK
 5be:	81 b3       	in	r24, 0x11	; 17
 5c0:	8b 60       	ori	r24, 0x0B	; 11
 5c2:	81 bb       	out	0x11, r24	; 17
   PORTC |= 0x00;
 5c4:	85 b3       	in	r24, 0x15	; 21
 5c6:	85 bb       	out	0x15, r24	; 21
   PORTD |= 0x02;
 5c8:	91 9a       	sbi	0x12, 1	; 18
   PORTE |= 0xFF;
 5ca:	83 b1       	in	r24, 0x03	; 3
 5cc:	93 b9       	out	0x03, r25	; 3
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
 5ce:	87 b3       	in	r24, 0x17	; 23
 5d0:	87 60       	ori	r24, 0x07	; 7
 5d2:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
 5d4:	8d b1       	in	r24, 0x0d	; 13
 5d6:	8c 65       	ori	r24, 0x5C	; 92
 5d8:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
 5da:	70 9a       	sbi	0x0e, 0	; 14
   PORTD |= 0x02;
   PORTE |= 0xFF;

   spi_init();				//Initalize SPI

   sei();				//Enable interrupts
 5dc:	78 94       	sei
   while(1){
      segsum(sum);			//Send sum to be formatted for the 7 seg display

      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
         if(j == 2 && hex){
	    PORTA = 0b00000011;		//Turns on L3 on the LED display
 5de:	d3 e0       	ldi	r29, 0x03	; 3
	    }
	    else {
               PORTA = segment_data[j];	//Writes the segment data to PORTA aka the segments
            }
         }
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
 5e0:	c0 e2       	ldi	r28, 0x20	; 32
   spi_init();				//Initalize SPI

   sei();				//Enable interrupts
   
   while(1){
      segsum(sum);			//Send sum to be formatted for the 7 seg display
 5e2:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <sum>
 5e6:	90 91 1c 01 	lds	r25, 0x011C	; 0x80011c <sum+0x1>
 5ea:	0e 94 94 00 	call	0x128	; 0x128 <segsum>
 5ee:	e6 e1       	ldi	r30, 0x16	; 22
 5f0:	f1 e0       	ldi	r31, 0x01	; 1
 5f2:	21 e0       	ldi	r18, 0x01	; 1
 5f4:	30 e0       	ldi	r19, 0x00	; 0
 5f6:	80 e0       	ldi	r24, 0x00	; 0
 5f8:	90 e0       	ldi	r25, 0x00	; 0
 5fa:	15 c0       	rjmp	.+42     	; 0x626 <main+0x82>
      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
         if(j == 2 && hex){
	    PORTA = 0b00000011;		//Turns on L3 on the LED display
	 }
	 else {
            if(hex){
 5fc:	40 91 1f 01 	lds	r20, 0x011F	; 0x80011f <hex>
	       PORTA = segment_data[j];
	    }
	    else {
               PORTA = segment_data[j];	//Writes the segment data to PORTA aka the segments
 600:	40 81       	ld	r20, Z
 602:	4b bb       	out	0x1b, r20	; 27
            }
         }
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
 604:	48 2f       	mov	r20, r24
 606:	42 95       	swap	r20
 608:	40 7f       	andi	r20, 0xF0	; 240
 60a:	48 bb       	out	0x18, r20	; 24
 60c:	af e1       	ldi	r26, 0x1F	; 31
 60e:	b3 e0       	ldi	r27, 0x03	; 3
 610:	11 97       	sbiw	r26, 0x01	; 1
 612:	f1 f7       	brne	.-4      	; 0x610 <main+0x6c>
 614:	00 c0       	rjmp	.+0      	; 0x616 <main+0x72>
 616:	00 00       	nop
   sei();				//Enable interrupts
   
   while(1){
      segsum(sum);			//Send sum to be formatted for the 7 seg display

      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
 618:	25 30       	cpi	r18, 0x05	; 5
 61a:	31 05       	cpc	r19, r1
 61c:	11 f3       	breq	.-60     	; 0x5e2 <main+0x3e>
 61e:	01 96       	adiw	r24, 0x01	; 1
 620:	2f 5f       	subi	r18, 0xFF	; 255
 622:	3f 4f       	sbci	r19, 0xFF	; 255
 624:	31 96       	adiw	r30, 0x01	; 1
         if(j == 2 && hex){
 626:	82 30       	cpi	r24, 0x02	; 2
 628:	91 05       	cpc	r25, r1
 62a:	41 f7       	brne	.-48     	; 0x5fc <main+0x58>
 62c:	40 91 1f 01 	lds	r20, 0x011F	; 0x80011f <hex>
 630:	44 23       	and	r20, r20
 632:	21 f3       	breq	.-56     	; 0x5fc <main+0x58>
	    PORTA = 0b00000011;		//Turns on L3 on the LED display
 634:	db bb       	out	0x1b, r29	; 27
	    }
	    else {
               PORTA = segment_data[j];	//Writes the segment data to PORTA aka the segments
            }
         }
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
 636:	c8 bb       	out	0x18, r28	; 24
 638:	af e1       	ldi	r26, 0x1F	; 31
 63a:	b3 e0       	ldi	r27, 0x03	; 3
 63c:	11 97       	sbiw	r26, 0x01	; 1
 63e:	f1 f7       	brne	.-4      	; 0x63c <main+0x98>
 640:	00 c0       	rjmp	.+0      	; 0x642 <main+0x9e>
 642:	00 00       	nop
 644:	ec cf       	rjmp	.-40     	; 0x61e <main+0x7a>

00000646 <__divmodhi4>:
 646:	97 fb       	bst	r25, 7
 648:	07 2e       	mov	r0, r23
 64a:	16 f4       	brtc	.+4      	; 0x650 <__divmodhi4+0xa>
 64c:	00 94       	com	r0
 64e:	07 d0       	rcall	.+14     	; 0x65e <__divmodhi4_neg1>
 650:	77 fd       	sbrc	r23, 7
 652:	09 d0       	rcall	.+18     	; 0x666 <__divmodhi4_neg2>
 654:	0e 94 46 03 	call	0x68c	; 0x68c <__udivmodhi4>
 658:	07 fc       	sbrc	r0, 7
 65a:	05 d0       	rcall	.+10     	; 0x666 <__divmodhi4_neg2>
 65c:	3e f4       	brtc	.+14     	; 0x66c <__divmodhi4_exit>

0000065e <__divmodhi4_neg1>:
 65e:	90 95       	com	r25
 660:	81 95       	neg	r24
 662:	9f 4f       	sbci	r25, 0xFF	; 255
 664:	08 95       	ret

00000666 <__divmodhi4_neg2>:
 666:	70 95       	com	r23
 668:	61 95       	neg	r22
 66a:	7f 4f       	sbci	r23, 0xFF	; 255

0000066c <__divmodhi4_exit>:
 66c:	08 95       	ret

0000066e <__umulhisi3>:
 66e:	a2 9f       	mul	r26, r18
 670:	b0 01       	movw	r22, r0
 672:	b3 9f       	mul	r27, r19
 674:	c0 01       	movw	r24, r0
 676:	a3 9f       	mul	r26, r19
 678:	70 0d       	add	r23, r0
 67a:	81 1d       	adc	r24, r1
 67c:	11 24       	eor	r1, r1
 67e:	91 1d       	adc	r25, r1
 680:	b2 9f       	mul	r27, r18
 682:	70 0d       	add	r23, r0
 684:	81 1d       	adc	r24, r1
 686:	11 24       	eor	r1, r1
 688:	91 1d       	adc	r25, r1
 68a:	08 95       	ret

0000068c <__udivmodhi4>:
 68c:	aa 1b       	sub	r26, r26
 68e:	bb 1b       	sub	r27, r27
 690:	51 e1       	ldi	r21, 0x11	; 17
 692:	07 c0       	rjmp	.+14     	; 0x6a2 <__udivmodhi4_ep>

00000694 <__udivmodhi4_loop>:
 694:	aa 1f       	adc	r26, r26
 696:	bb 1f       	adc	r27, r27
 698:	a6 17       	cp	r26, r22
 69a:	b7 07       	cpc	r27, r23
 69c:	10 f0       	brcs	.+4      	; 0x6a2 <__udivmodhi4_ep>
 69e:	a6 1b       	sub	r26, r22
 6a0:	b7 0b       	sbc	r27, r23

000006a2 <__udivmodhi4_ep>:
 6a2:	88 1f       	adc	r24, r24
 6a4:	99 1f       	adc	r25, r25
 6a6:	5a 95       	dec	r21
 6a8:	a9 f7       	brne	.-22     	; 0x694 <__udivmodhi4_loop>
 6aa:	80 95       	com	r24
 6ac:	90 95       	com	r25
 6ae:	bc 01       	movw	r22, r24
 6b0:	cd 01       	movw	r24, r26
 6b2:	08 95       	ret

000006b4 <_exit>:
 6b4:	f8 94       	cli

000006b6 <__stop_program>:
 6b6:	ff cf       	rjmp	.-2      	; 0x6b6 <__stop_program>
