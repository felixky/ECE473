
interrupts_SPI.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00800100  000006b4  00000748  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000006b4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000001c  00800116  00800116  0000075e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000075e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000790  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000028  00000000  00000000  000007cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000c40  00000000  00000000  000007f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000099c  00000000  00000000  00001434  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000445  00000000  00000000  00001dd0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000e4  00000000  00000000  00002218  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000042a  00000000  00000000  000022fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000566  00000000  00000000  00002726  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000060  00000000  00000000  00002c8c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  40:	0c 94 7b 02 	jmp	0x4f6	; 0x4f6 <__vector_16>
  44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e4 eb       	ldi	r30, 0xB4	; 180
  a0:	f6 e0       	ldi	r31, 0x06	; 6
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a6 31       	cpi	r26, 0x16	; 22
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	21 e0       	ldi	r18, 0x01	; 1
  b4:	a6 e1       	ldi	r26, 0x16	; 22
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	a2 33       	cpi	r26, 0x32	; 50
  be:	b2 07       	cpc	r27, r18
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	0e 94 d0 02 	call	0x5a0	; 0x5a0 <main>
  c6:	0c 94 58 03 	jmp	0x6b0	; 0x6b0 <_exit>

000000ca <__bad_interrupt>:
  ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <spi_init>:
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
  ce:	87 b3       	in	r24, 0x17	; 23
  d0:	87 60       	ori	r24, 0x07	; 7
  d2:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
  d4:	8d b1       	in	r24, 0x0d	; 13
  d6:	8c 65       	ori	r24, 0x5C	; 92
  d8:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
  da:	70 9a       	sbi	0x0e, 0	; 14
  dc:	08 95       	ret

000000de <spi_read>:
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
  de:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
  e0:	77 9b       	sbis	0x0e, 7	; 14
  e2:	fe cf       	rjmp	.-4      	; 0xe0 <spi_read+0x2>
   return SPDR;
  e4:	8f b1       	in	r24, 0x0f	; 15
}
  e6:	08 95       	ret

000000e8 <chk_buttons>:
	be implemented at the same time. Adapted to check all buttons from 
	Ganssel's "Guide to Debouncing" Expects active low pushbuttons on PINA 
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
  e8:	48 2f       	mov	r20, r24
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
  ea:	e8 2f       	mov	r30, r24
  ec:	f0 e0       	ldi	r31, 0x00	; 0
  ee:	99 b3       	in	r25, 0x19	; 25
  f0:	ee 0f       	add	r30, r30
  f2:	ff 1f       	adc	r31, r31
  f4:	e0 5e       	subi	r30, 0xE0	; 224
  f6:	fe 4f       	sbci	r31, 0xFE	; 254
  f8:	20 81       	ld	r18, Z
  fa:	31 81       	ldd	r19, Z+1	; 0x01
  fc:	22 0f       	add	r18, r18
  fe:	33 1f       	adc	r19, r19
 100:	30 6e       	ori	r19, 0xE0	; 224
 102:	89 2f       	mov	r24, r25
 104:	90 e0       	ldi	r25, 0x00	; 0
 106:	02 c0       	rjmp	.+4      	; 0x10c <chk_buttons+0x24>
 108:	95 95       	asr	r25
 10a:	87 95       	ror	r24
 10c:	4a 95       	dec	r20
 10e:	e2 f7       	brpl	.-8      	; 0x108 <chk_buttons+0x20>
 110:	81 70       	andi	r24, 0x01	; 1
 112:	99 27       	eor	r25, r25
 114:	28 2b       	or	r18, r24
 116:	39 2b       	or	r19, r25
 118:	31 83       	std	Z+1, r19	; 0x01
 11a:	20 83       	st	Z, r18
 11c:	81 e0       	ldi	r24, 0x01	; 1
 11e:	21 15       	cp	r18, r1
 120:	30 4f       	sbci	r19, 0xF0	; 240
 122:	09 f0       	breq	.+2      	; 0x126 <chk_buttons+0x3e>
 124:	80 e0       	ldi	r24, 0x00	; 0
  if (state[button] == 0xF000)
    return 1;
return 0;
}
 126:	08 95       	ret

00000128 <segsum>:
Description: takes a 16-bit binary input value and places the appropriate equivalent 
	4 digit BCD segment code in the array segment_data for display. array is 
	loaded at exit as:  |digit3|digit2|colon|digit1|digit0|
Parameters: A sum that willl be decoded
************************************************************************************/
void segsum(uint16_t sum) {
 128:	cf 93       	push	r28
 12a:	ac 01       	movw	r20, r24
  int d0,d1,d2,d3; //,colon, digits;
  //determine how many digits there are 
  //break up decimal sum into 4 digit-segments
  //This block of code takes in the sum and finds the 0-9 value for each of the four led digits  
  if(hex) {
 12c:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <hex>
 130:	88 23       	and	r24, r24
 132:	69 f1       	breq	.+90     	; 0x18e <segsum+0x66>
     d0 = ((sum%256)%16);//1s digit
     d1 = (sum %256)/16; //10s digit
     d2 = sum/256;	 //100s digit. Integer division
     d3 = 0;		 //1000s digit. 1023 will never need this digit

     segment_data[0] = dec_to_7seg[d0]; 
 134:	fa 01       	movw	r30, r20
 136:	ef 70       	andi	r30, 0x0F	; 15
 138:	ff 27       	eor	r31, r31
 13a:	e0 50       	subi	r30, 0x00	; 0
 13c:	ff 4f       	sbci	r31, 0xFF	; 255
 13e:	80 81       	ld	r24, Z
 140:	80 93 16 01 	sts	0x0116, r24	; 0x800116 <__data_end>
     segment_data[1] = dec_to_7seg[d1];
 144:	fa 01       	movw	r30, r20
 146:	ff 27       	eor	r31, r31
 148:	f2 95       	swap	r31
 14a:	e2 95       	swap	r30
 14c:	ef 70       	andi	r30, 0x0F	; 15
 14e:	ef 27       	eor	r30, r31
 150:	ff 70       	andi	r31, 0x0F	; 15
 152:	ef 27       	eor	r30, r31
 154:	e0 50       	subi	r30, 0x00	; 0
 156:	ff 4f       	sbci	r31, 0xFF	; 255
 158:	80 81       	ld	r24, Z
 15a:	80 93 17 01 	sts	0x0117, r24	; 0x800117 <__data_end+0x1>
     segment_data[2] = 0xFF;
 15e:	8f ef       	ldi	r24, 0xFF	; 255
 160:	80 93 18 01 	sts	0x0118, r24	; 0x800118 <__data_end+0x2>
     segment_data[3] = dec_to_7seg[d2];
 164:	e5 2f       	mov	r30, r21
 166:	ff 27       	eor	r31, r31
 168:	e0 50       	subi	r30, 0x00	; 0
 16a:	ff 4f       	sbci	r31, 0xFF	; 255
 16c:	90 81       	ld	r25, Z
 16e:	90 93 19 01 	sts	0x0119, r25	; 0x800119 <__data_end+0x3>
     segment_data[4] = 0xFF;
 172:	80 93 1a 01 	sts	0x011A, r24	; 0x80011a <__data_end+0x4>
     
     if(sum < 0x100)	//Compares the sum to 255
 176:	4f 3f       	cpi	r20, 0xFF	; 255
 178:	51 05       	cpc	r21, r1
 17a:	09 f0       	breq	.+2      	; 0x17e <segsum+0x56>
 17c:	30 f4       	brcc	.+12     	; 0x18a <segsum+0x62>
	segment_data[3] = 0xFF;
 17e:	80 93 19 01 	sts	0x0119, r24	; 0x800119 <__data_end+0x3>
     if(sum < 0x10)	//Compares the sum to 10
 182:	40 31       	cpi	r20, 0x10	; 16
 184:	51 05       	cpc	r21, r1
 186:	08 f4       	brcc	.+2      	; 0x18a <segsum+0x62>
 188:	75 c0       	rjmp	.+234    	; 0x274 <segsum+0x14c>
	segment_data[3] = 0xFF;
     if(sum < 0xA)	//Compares the sum to 10
	segment_data[1] = 0xFF;
  }
   return;
}//segment_sum
 18a:	cf 91       	pop	r28
 18c:	08 95       	ret
     d1 = (((sum % 100) / 10) % 10);	//10's digit
     d2 = (sum / 100) % 10;		//100's digit
     d3 = (sum / 1000) % 10;		//1000's digit

  //This block changes the decimal from just above into 8-bits that can be displayed on the segments 
     segment_data[0] = dec_to_7seg[d0]; 
 18e:	9a 01       	movw	r18, r20
 190:	ad ec       	ldi	r26, 0xCD	; 205
 192:	bc ec       	ldi	r27, 0xCC	; 204
 194:	0e 94 35 03 	call	0x66a	; 0x66a <__umulhisi3>
 198:	96 95       	lsr	r25
 19a:	87 95       	ror	r24
 19c:	96 95       	lsr	r25
 19e:	87 95       	ror	r24
 1a0:	96 95       	lsr	r25
 1a2:	87 95       	ror	r24
 1a4:	9c 01       	movw	r18, r24
 1a6:	22 0f       	add	r18, r18
 1a8:	33 1f       	adc	r19, r19
 1aa:	88 0f       	add	r24, r24
 1ac:	99 1f       	adc	r25, r25
 1ae:	88 0f       	add	r24, r24
 1b0:	99 1f       	adc	r25, r25
 1b2:	88 0f       	add	r24, r24
 1b4:	99 1f       	adc	r25, r25
 1b6:	82 0f       	add	r24, r18
 1b8:	93 1f       	adc	r25, r19
 1ba:	fa 01       	movw	r30, r20
 1bc:	e8 1b       	sub	r30, r24
 1be:	f9 0b       	sbc	r31, r25
 1c0:	e0 50       	subi	r30, 0x00	; 0
 1c2:	ff 4f       	sbci	r31, 0xFF	; 255
 1c4:	80 81       	ld	r24, Z
 1c6:	80 93 16 01 	sts	0x0116, r24	; 0x800116 <__data_end>
     segment_data[1] = dec_to_7seg[d1];
 1ca:	9a 01       	movw	r18, r20
 1cc:	36 95       	lsr	r19
 1ce:	27 95       	ror	r18
 1d0:	36 95       	lsr	r19
 1d2:	27 95       	ror	r18
 1d4:	ab e7       	ldi	r26, 0x7B	; 123
 1d6:	b4 e1       	ldi	r27, 0x14	; 20
 1d8:	0e 94 35 03 	call	0x66a	; 0x66a <__umulhisi3>
 1dc:	fc 01       	movw	r30, r24
 1de:	f6 95       	lsr	r31
 1e0:	e7 95       	ror	r30
 1e2:	24 e6       	ldi	r18, 0x64	; 100
 1e4:	2e 9f       	mul	r18, r30
 1e6:	c0 01       	movw	r24, r0
 1e8:	2f 9f       	mul	r18, r31
 1ea:	90 0d       	add	r25, r0
 1ec:	11 24       	eor	r1, r1
 1ee:	9a 01       	movw	r18, r20
 1f0:	28 1b       	sub	r18, r24
 1f2:	39 0b       	sbc	r19, r25
 1f4:	ad ec       	ldi	r26, 0xCD	; 205
 1f6:	bc ec       	ldi	r27, 0xCC	; 204
 1f8:	0e 94 35 03 	call	0x66a	; 0x66a <__umulhisi3>
 1fc:	96 95       	lsr	r25
 1fe:	87 95       	ror	r24
 200:	96 95       	lsr	r25
 202:	87 95       	ror	r24
 204:	96 95       	lsr	r25
 206:	87 95       	ror	r24
 208:	dc 01       	movw	r26, r24
 20a:	a0 50       	subi	r26, 0x00	; 0
 20c:	bf 4f       	sbci	r27, 0xFF	; 255
 20e:	8c 91       	ld	r24, X
 210:	80 93 17 01 	sts	0x0117, r24	; 0x800117 <__data_end+0x1>
     segment_data[2] = 0xFF;
 214:	cf ef       	ldi	r28, 0xFF	; 255
 216:	c0 93 18 01 	sts	0x0118, r28	; 0x800118 <__data_end+0x2>
     segment_data[3] = dec_to_7seg[d2];
 21a:	9f 01       	movw	r18, r30
 21c:	ad ec       	ldi	r26, 0xCD	; 205
 21e:	bc ec       	ldi	r27, 0xCC	; 204
 220:	0e 94 35 03 	call	0x66a	; 0x66a <__umulhisi3>
 224:	96 95       	lsr	r25
 226:	87 95       	ror	r24
 228:	96 95       	lsr	r25
 22a:	87 95       	ror	r24
 22c:	96 95       	lsr	r25
 22e:	87 95       	ror	r24
 230:	9c 01       	movw	r18, r24
 232:	22 0f       	add	r18, r18
 234:	33 1f       	adc	r19, r19
 236:	88 0f       	add	r24, r24
 238:	99 1f       	adc	r25, r25
 23a:	88 0f       	add	r24, r24
 23c:	99 1f       	adc	r25, r25
 23e:	88 0f       	add	r24, r24
 240:	99 1f       	adc	r25, r25
 242:	82 0f       	add	r24, r18
 244:	93 1f       	adc	r25, r19
 246:	e8 1b       	sub	r30, r24
 248:	f9 0b       	sbc	r31, r25
 24a:	e0 50       	subi	r30, 0x00	; 0
 24c:	ff 4f       	sbci	r31, 0xFF	; 255
 24e:	80 81       	ld	r24, Z
 250:	80 93 19 01 	sts	0x0119, r24	; 0x800119 <__data_end+0x3>
     segment_data[4] = dec_to_7seg[d3];

  //blank out leading zero digits and determine number of digits
     if(sum < 0x3E8)	//Compares the sum to 1000
 254:	48 3e       	cpi	r20, 0xE8	; 232
 256:	83 e0       	ldi	r24, 0x03	; 3
 258:	58 07       	cpc	r21, r24
 25a:	88 f4       	brcc	.+34     	; 0x27e <segsum+0x156>
	segment_data[4] = 0xFF;
 25c:	c0 93 1a 01 	sts	0x011A, r28	; 0x80011a <__data_end+0x4>
     if(sum < 0x64)	//Compares the sum to 100
 260:	44 36       	cpi	r20, 0x64	; 100
 262:	51 05       	cpc	r21, r1
 264:	08 f0       	brcs	.+2      	; 0x268 <segsum+0x140>
 266:	91 cf       	rjmp	.-222    	; 0x18a <segsum+0x62>
	segment_data[3] = 0xFF;
 268:	c0 93 19 01 	sts	0x0119, r28	; 0x800119 <__data_end+0x3>
     if(sum < 0xA)	//Compares the sum to 10
 26c:	4a 30       	cpi	r20, 0x0A	; 10
 26e:	51 05       	cpc	r21, r1
 270:	08 f0       	brcs	.+2      	; 0x274 <segsum+0x14c>
 272:	8b cf       	rjmp	.-234    	; 0x18a <segsum+0x62>
     segment_data[4] = 0xFF;
     
     if(sum < 0x100)	//Compares the sum to 255
	segment_data[3] = 0xFF;
     if(sum < 0x10)	//Compares the sum to 10
	segment_data[1] = 0xFF;
 274:	8f ef       	ldi	r24, 0xFF	; 255
 276:	80 93 17 01 	sts	0x0117, r24	; 0x800117 <__data_end+0x1>
	segment_data[3] = 0xFF;
     if(sum < 0xA)	//Compares the sum to 10
	segment_data[1] = 0xFF;
  }
   return;
}//segment_sum
 27a:	cf 91       	pop	r28
 27c:	08 95       	ret
  //This block changes the decimal from just above into 8-bits that can be displayed on the segments 
     segment_data[0] = dec_to_7seg[d0]; 
     segment_data[1] = dec_to_7seg[d1];
     segment_data[2] = 0xFF;
     segment_data[3] = dec_to_7seg[d2];
     segment_data[4] = dec_to_7seg[d3];
 27e:	9a 01       	movw	r18, r20
 280:	36 95       	lsr	r19
 282:	27 95       	ror	r18
 284:	36 95       	lsr	r19
 286:	27 95       	ror	r18
 288:	36 95       	lsr	r19
 28a:	27 95       	ror	r18
 28c:	a5 ec       	ldi	r26, 0xC5	; 197
 28e:	b0 e2       	ldi	r27, 0x20	; 32
 290:	0e 94 35 03 	call	0x66a	; 0x66a <__umulhisi3>
 294:	ac 01       	movw	r20, r24
 296:	52 95       	swap	r21
 298:	42 95       	swap	r20
 29a:	4f 70       	andi	r20, 0x0F	; 15
 29c:	45 27       	eor	r20, r21
 29e:	5f 70       	andi	r21, 0x0F	; 15
 2a0:	45 27       	eor	r20, r21
 2a2:	9a 01       	movw	r18, r20
 2a4:	ad ec       	ldi	r26, 0xCD	; 205
 2a6:	bc ec       	ldi	r27, 0xCC	; 204
 2a8:	0e 94 35 03 	call	0x66a	; 0x66a <__umulhisi3>
 2ac:	96 95       	lsr	r25
 2ae:	87 95       	ror	r24
 2b0:	96 95       	lsr	r25
 2b2:	87 95       	ror	r24
 2b4:	96 95       	lsr	r25
 2b6:	87 95       	ror	r24
 2b8:	9c 01       	movw	r18, r24
 2ba:	22 0f       	add	r18, r18
 2bc:	33 1f       	adc	r19, r19
 2be:	88 0f       	add	r24, r24
 2c0:	99 1f       	adc	r25, r25
 2c2:	88 0f       	add	r24, r24
 2c4:	99 1f       	adc	r25, r25
 2c6:	88 0f       	add	r24, r24
 2c8:	99 1f       	adc	r25, r25
 2ca:	82 0f       	add	r24, r18
 2cc:	93 1f       	adc	r25, r19
 2ce:	48 1b       	sub	r20, r24
 2d0:	59 0b       	sbc	r21, r25
 2d2:	fa 01       	movw	r30, r20
 2d4:	e0 50       	subi	r30, 0x00	; 0
 2d6:	ff 4f       	sbci	r31, 0xFF	; 255
 2d8:	80 81       	ld	r24, Z
 2da:	80 93 1a 01 	sts	0x011A, r24	; 0x80011a <__data_end+0x4>
	segment_data[3] = 0xFF;
     if(sum < 0xA)	//Compares the sum to 10
	segment_data[1] = 0xFF;
  }
   return;
}//segment_sum
 2de:	cf 91       	pop	r28
 2e0:	08 95       	ret

000002e2 <bars>:
Description:This function reads in the button board and updates the 
	LEDs on the bargraph through the serial port.
Parameters: NA
**********************************************************************/
void bars() {
   DDRA = 0x00;				//Set all as inputs
 2e2:	1a ba       	out	0x1a, r1	; 26
   PORTA = 0xFF;			//Pull up resistors
 2e4:	8f ef       	ldi	r24, 0xFF	; 255
 2e6:	8b bb       	out	0x1b, r24	; 27
   PORTB |= PINB | 0x70;		//Enable tristate buffer
 2e8:	86 b3       	in	r24, 0x16	; 22
 2ea:	98 b3       	in	r25, 0x18	; 24
 2ec:	80 67       	ori	r24, 0x70	; 112
 2ee:	89 2b       	or	r24, r25
 2f0:	88 bb       	out	0x18, r24	; 24
 2f2:	e0 e2       	ldi	r30, 0x20	; 32
 2f4:	f1 e0       	ldi	r31, 0x01	; 1

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
 2f6:	20 e0       	ldi	r18, 0x00	; 0
 2f8:	30 e0       	ldi	r19, 0x00	; 0
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
 2fa:	61 e0       	ldi	r22, 0x01	; 1
 2fc:	70 e0       	ldi	r23, 0x00	; 0
 2fe:	05 c0       	rjmp	.+10     	; 0x30a <bars+0x28>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
 300:	2f 5f       	subi	r18, 0xFF	; 255
 302:	3f 4f       	sbci	r19, 0xFF	; 255
 304:	28 30       	cpi	r18, 0x08	; 8
 306:	31 05       	cpc	r19, r1
 308:	39 f1       	breq	.+78     	; 0x358 <bars+0x76>
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
 30a:	99 b3       	in	r25, 0x19	; 25
 30c:	40 81       	ld	r20, Z
 30e:	51 81       	ldd	r21, Z+1	; 0x01
 310:	44 0f       	add	r20, r20
 312:	55 1f       	adc	r21, r21
 314:	89 2f       	mov	r24, r25
 316:	90 e0       	ldi	r25, 0x00	; 0
 318:	02 2e       	mov	r0, r18
 31a:	02 c0       	rjmp	.+4      	; 0x320 <bars+0x3e>
 31c:	95 95       	asr	r25
 31e:	87 95       	ror	r24
 320:	0a 94       	dec	r0
 322:	e2 f7       	brpl	.-8      	; 0x31c <bars+0x3a>
 324:	81 70       	andi	r24, 0x01	; 1
 326:	99 27       	eor	r25, r25
 328:	84 2b       	or	r24, r20
 32a:	95 2b       	or	r25, r21
 32c:	90 6e       	ori	r25, 0xE0	; 224
 32e:	81 93       	st	Z+, r24
 330:	91 93       	st	Z+, r25
  if (state[button] == 0xF000)
 332:	81 15       	cp	r24, r1
 334:	90 4f       	sbci	r25, 0xF0	; 240
 336:	21 f7       	brne	.-56     	; 0x300 <bars+0x1e>
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
 338:	cb 01       	movw	r24, r22
 33a:	02 2e       	mov	r0, r18
 33c:	02 c0       	rjmp	.+4      	; 0x342 <bars+0x60>
 33e:	88 0f       	add	r24, r24
 340:	99 1f       	adc	r25, r25
 342:	0a 94       	dec	r0
 344:	e2 f7       	brpl	.-8      	; 0x33e <bars+0x5c>
 346:	90 93 1e 01 	sts	0x011E, r25	; 0x80011e <mult+0x1>
 34a:	80 93 1d 01 	sts	0x011D, r24	; 0x80011d <mult>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
 34e:	2f 5f       	subi	r18, 0xFF	; 255
 350:	3f 4f       	sbci	r19, 0xFF	; 255
 352:	28 30       	cpi	r18, 0x08	; 8
 354:	31 05       	cpc	r19, r1
 356:	c9 f6       	brne	.-78     	; 0x30a <bars+0x28>
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   if(mult == 128){			//Button 8 toggles base 10 and 16
 358:	80 91 1d 01 	lds	r24, 0x011D	; 0x80011d <mult>
 35c:	90 91 1e 01 	lds	r25, 0x011E	; 0x80011e <mult+0x1>
 360:	80 38       	cpi	r24, 0x80	; 128
 362:	91 05       	cpc	r25, r1
 364:	09 f4       	brne	.+2      	; 0x368 <bars+0x86>
 366:	40 c0       	rjmp	.+128    	; 0x3e8 <bars+0x106>
      hex = !(hex);			//on the LED display
   }
   if(mult > 4) {			//I only want values from the
 368:	80 91 1d 01 	lds	r24, 0x011D	; 0x80011d <mult>
 36c:	90 91 1e 01 	lds	r25, 0x011E	; 0x80011e <mult+0x1>
 370:	05 97       	sbiw	r24, 0x05	; 5
 372:	20 f0       	brcs	.+8      	; 0x37c <bars+0x9a>
      mult = 0;				//first three buttons
 374:	10 92 1e 01 	sts	0x011E, r1	; 0x80011e <mult+0x1>
 378:	10 92 1d 01 	sts	0x011D, r1	; 0x80011d <mult>
   }
   //This switch statement is used to enable a 'toggle' functionality
   //so that modes can be selected an deselected
   switch(mult) {
 37c:	80 91 1d 01 	lds	r24, 0x011D	; 0x80011d <mult>
 380:	90 91 1e 01 	lds	r25, 0x011E	; 0x80011e <mult+0x1>
 384:	82 30       	cpi	r24, 0x02	; 2
 386:	91 05       	cpc	r25, r1
 388:	09 f4       	brne	.+2      	; 0x38c <bars+0xaa>
 38a:	4e c0       	rjmp	.+156    	; 0x428 <__LOCK_REGION_LENGTH__+0x28>
 38c:	84 30       	cpi	r24, 0x04	; 4
 38e:	91 05       	cpc	r25, r1
 390:	99 f1       	breq	.+102    	; 0x3f8 <bars+0x116>
 392:	81 30       	cpi	r24, 0x01	; 1
 394:	91 05       	cpc	r25, r1
 396:	c1 f0       	breq	.+48     	; 0x3c8 <bars+0xe6>
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
         break;
      default:
	 mode_sel = mode_sel;		//no/invalid button press
 398:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <mode_sel>
 39c:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <mode_sel+0x1>
 3a0:	90 93 15 01 	sts	0x0115, r25	; 0x800115 <mode_sel+0x1>
 3a4:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <mode_sel>
   }   
   mult = 0;				//clear mult for next pass
 3a8:	10 92 1e 01 	sts	0x011E, r1	; 0x80011e <mult+0x1>
 3ac:	10 92 1d 01 	sts	0x011D, r1	; 0x80011d <mult>

   DDRA = 0xFF;				//Set A to alloutputs
 3b0:	8f ef       	ldi	r24, 0xFF	; 255
 3b2:	8a bb       	out	0x1a, r24	; 26
   SPDR = mode_sel;			//Write mode to the Bargraph
 3b4:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <mode_sel>
 3b8:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <mode_sel+0x1>
 3bc:	8f b9       	out	0x0f, r24	; 15
   while(bit_is_clear(SPSR, SPIF)){}	
 3be:	77 9b       	sbis	0x0e, 7	; 14
 3c0:	fe cf       	rjmp	.-4      	; 0x3be <bars+0xdc>
   PORTB |= (1<<PB0);			//Rgclk high on bargraph
 3c2:	c0 9a       	sbi	0x18, 0	; 24
   PORTB &= 0xFE;			//Rgclk low on bargraph
 3c4:	c0 98       	cbi	0x18, 0	; 24
   
return ;
 3c6:	08 95       	ret
   }
   //This switch statement is used to enable a 'toggle' functionality
   //so that modes can be selected an deselected
   switch(mult) {
      case 1:
	 if((mode_sel ^ mult) == 0){	//XOR to see if they are the same
 3c8:	40 91 14 01 	lds	r20, 0x0114	; 0x800114 <mode_sel>
 3cc:	50 91 15 01 	lds	r21, 0x0115	; 0x800115 <mode_sel+0x1>
 3d0:	20 91 1d 01 	lds	r18, 0x011D	; 0x80011d <mult>
 3d4:	30 91 1e 01 	lds	r19, 0x011E	; 0x80011e <mult+0x1>
 3d8:	42 17       	cp	r20, r18
 3da:	53 07       	cpc	r21, r19
 3dc:	09 f7       	brne	.-62     	; 0x3a0 <bars+0xbe>
	 else
	    mode_sel = 2;		//If not, then change mode
         break;
      case 4:
	 if((mode_sel ^ mult) && (mode_sel != 1)){//if cur &prev are diff
	    mode_sel = 0;//and prev isn't = 1 then two modes are selected
 3de:	10 92 15 01 	sts	0x0115, r1	; 0x800115 <mode_sel+0x1>
 3e2:	10 92 14 01 	sts	0x0114, r1	; 0x800114 <mode_sel>
 3e6:	e0 cf       	rjmp	.-64     	; 0x3a8 <bars+0xc6>
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   if(mult == 128){			//Button 8 toggles base 10 and 16
      hex = !(hex);			//on the LED display
 3e8:	90 91 1f 01 	lds	r25, 0x011F	; 0x80011f <hex>
 3ec:	81 e0       	ldi	r24, 0x01	; 1
 3ee:	91 11       	cpse	r25, r1
 3f0:	33 c0       	rjmp	.+102    	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
 3f2:	80 93 1f 01 	sts	0x011F, r24	; 0x80011f <hex>
 3f6:	b8 cf       	rjmp	.-144    	; 0x368 <bars+0x86>
	 }
	 else
	    mode_sel = 2;		//If not, then change mode
         break;
      case 4:
	 if((mode_sel ^ mult) && (mode_sel != 1)){//if cur &prev are diff
 3f8:	20 91 14 01 	lds	r18, 0x0114	; 0x800114 <mode_sel>
 3fc:	30 91 15 01 	lds	r19, 0x0115	; 0x800115 <mode_sel+0x1>
 400:	80 91 1d 01 	lds	r24, 0x011D	; 0x80011d <mult>
 404:	90 91 1e 01 	lds	r25, 0x011E	; 0x80011e <mult+0x1>
 408:	28 17       	cp	r18, r24
 40a:	39 07       	cpc	r19, r25
 40c:	31 f0       	breq	.+12     	; 0x41a <__LOCK_REGION_LENGTH__+0x1a>
 40e:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <mode_sel>
 412:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <mode_sel+0x1>
 416:	01 97       	sbiw	r24, 0x01	; 1
 418:	11 f7       	brne	.-60     	; 0x3de <bars+0xfc>
	    mode_sel = 0;//and prev isn't = 1 then two modes are selected
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
 41a:	84 e0       	ldi	r24, 0x04	; 4
 41c:	90 e0       	ldi	r25, 0x00	; 0
 41e:	90 93 15 01 	sts	0x0115, r25	; 0x800115 <mode_sel+0x1>
 422:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <mode_sel>
 426:	c0 cf       	rjmp	.-128    	; 0x3a8 <bars+0xc6>
	 }
	 else
	    mode_sel = 1;		//If not, then change mode
         break;
      case 2:
	 if((mode_sel ^ mult) && (mode_sel != 1)){//if cur &prev are diff
 428:	20 91 14 01 	lds	r18, 0x0114	; 0x800114 <mode_sel>
 42c:	30 91 15 01 	lds	r19, 0x0115	; 0x800115 <mode_sel+0x1>
 430:	80 91 1d 01 	lds	r24, 0x011D	; 0x80011d <mult>
 434:	90 91 1e 01 	lds	r25, 0x011E	; 0x80011e <mult+0x1>
 438:	28 17       	cp	r18, r24
 43a:	39 07       	cpc	r19, r25
 43c:	31 f0       	breq	.+12     	; 0x44a <__LOCK_REGION_LENGTH__+0x4a>
 43e:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <mode_sel>
 442:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <mode_sel+0x1>
 446:	01 97       	sbiw	r24, 0x01	; 1
 448:	51 f6       	brne	.-108    	; 0x3de <bars+0xfc>
	    mode_sel = 0;//and prev isn't = 1 then two modes are selected
	 }
	 else
	    mode_sel = 2;		//If not, then change mode
 44a:	82 e0       	ldi	r24, 0x02	; 2
 44c:	90 e0       	ldi	r25, 0x00	; 0
 44e:	90 93 15 01 	sts	0x0115, r25	; 0x800115 <mode_sel+0x1>
 452:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <mode_sel>
 456:	a8 cf       	rjmp	.-176    	; 0x3a8 <bars+0xc6>
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   if(mult == 128){			//Button 8 toggles base 10 and 16
      hex = !(hex);			//on the LED display
 458:	80 e0       	ldi	r24, 0x00	; 0
 45a:	80 93 1f 01 	sts	0x011F, r24	; 0x80011f <hex>
 45e:	84 cf       	rjmp	.-248    	; 0x368 <bars+0x86>

00000460 <read_encoder>:
   int8_t value = 0x00;
   uint8_t ec_a;
   uint8_t ec_b;

   //Shift_LD_N low
   PORTE &= 0x00;	//Begining of SHIFT_LD_N pulse. It is low here
 460:	83 b1       	in	r24, 0x03	; 3
 462:	13 b8       	out	0x03, r1	; 3
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 464:	87 ec       	ldi	r24, 0xC7	; 199
 466:	90 e0       	ldi	r25, 0x00	; 0
 468:	01 97       	sbiw	r24, 0x01	; 1
 46a:	f1 f7       	brne	.-4      	; 0x468 <read_encoder+0x8>
 46c:	00 c0       	rjmp	.+0      	; 0x46e <read_encoder+0xe>
 46e:	00 00       	nop
   _delay_us(50);
   PORTE |= 0xFF;	//End of SHIFT_LD_N pulse. back to high
 470:	83 b1       	in	r24, 0x03	; 3
 472:	8f ef       	ldi	r24, 0xFF	; 255
 474:	83 b9       	out	0x03, r24	; 3
   PORTD &= 0x00;	//CLK_INH low
 476:	82 b3       	in	r24, 0x12	; 18
 478:	12 ba       	out	0x12, r1	; 18
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
 47a:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
 47c:	77 9b       	sbis	0x0e, 7	; 14
 47e:	fe cf       	rjmp	.-4      	; 0x47c <read_encoder+0x1c>
   return SPDR;
 480:	9f b1       	in	r25, 0x0f	; 15
   _delay_us(50);
   PORTE |= 0xFF;	//End of SHIFT_LD_N pulse. back to high
   PORTD &= 0x00;	//CLK_INH low

   encoder_value = spi_read();
   PORTD |= 0x02;	//CLK_INH high
 482:	91 9a       	sbi	0x12, 1	; 18
   value = mode_sel;
 484:	60 91 14 01 	lds	r22, 0x0114	; 0x800114 <mode_sel>
 488:	70 91 15 01 	lds	r23, 0x0115	; 0x800115 <mode_sel+0x1>
 48c:	86 2f       	mov	r24, r22
   ec_a = encoder_value & 0x03;  //Only grabs these bits 0000_0011
 48e:	49 2f       	mov	r20, r25
 490:	43 70       	andi	r20, 0x03	; 3
   ec_b = encoder_value & 0x0C;  //Only grabs these bits 0000_1100 
 492:	9c 70       	andi	r25, 0x0C	; 12
   ec_b = (ec_b >> 2);
 494:	96 95       	lsr	r25
 496:	96 95       	lsr	r25

   if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
 498:	20 91 31 01 	lds	r18, 0x0131	; 0x800131 <EC_a_prev>
 49c:	e4 2f       	mov	r30, r20
 49e:	f0 e0       	ldi	r31, 0x00	; 0
 4a0:	02 2e       	mov	r0, r18
 4a2:	00 0c       	add	r0, r0
 4a4:	33 0b       	sbc	r19, r19
 4a6:	e2 17       	cp	r30, r18
 4a8:	f3 07       	cpc	r31, r19
 4aa:	91 f0       	breq	.+36     	; 0x4d0 <read_encoder+0x70>
      if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
 4ac:	20 91 31 01 	lds	r18, 0x0131	; 0x800131 <EC_a_prev>
 4b0:	21 11       	cpse	r18, r1
 4b2:	02 c0       	rjmp	.+4      	; 0x4b8 <read_encoder+0x58>
 4b4:	41 30       	cpi	r20, 0x01	; 1
 4b6:	39 f0       	breq	.+14     	; 0x4c6 <read_encoder+0x66>
         value = value;
      }
      else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
 4b8:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <EC_a_prev>
 4bc:	81 11       	cpse	r24, r1
 4be:	02 c0       	rjmp	.+4      	; 0x4c4 <read_encoder+0x64>
 4c0:	42 30       	cpi	r20, 0x02	; 2
 4c2:	91 f0       	breq	.+36     	; 0x4e8 <read_encoder+0x88>
	 value = -(value); 
      }
      else	//If not one of the state changes above, do nothing
	 value = 0;
 4c4:	80 e0       	ldi	r24, 0x00	; 0
      }
      else
	 value = 0;
   }
//Saves previous values into volatile variables
EC_a_prev = ec_a;
 4c6:	40 93 31 01 	sts	0x0131, r20	; 0x800131 <EC_a_prev>
EC_b_prev = ec_b;
 4ca:	90 93 30 01 	sts	0x0130, r25	; 0x800130 <EC_b_prev>

return value;
}
 4ce:	08 95       	ret
      }
      else	//If not one of the state changes above, do nothing
	 value = 0;
   }
   else {	//This is for encoder B
      if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
 4d0:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <EC_b_prev>
 4d4:	21 11       	cpse	r18, r1
 4d6:	02 c0       	rjmp	.+4      	; 0x4dc <read_encoder+0x7c>
 4d8:	91 30       	cpi	r25, 0x01	; 1
 4da:	a9 f3       	breq	.-22     	; 0x4c6 <read_encoder+0x66>
         value = value; 
      }
      else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
 4dc:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <EC_b_prev>
 4e0:	81 11       	cpse	r24, r1
 4e2:	f0 cf       	rjmp	.-32     	; 0x4c4 <read_encoder+0x64>
 4e4:	92 30       	cpi	r25, 0x02	; 2
 4e6:	71 f7       	brne	.-36     	; 0x4c4 <read_encoder+0x64>
	 value = -(value);
 4e8:	86 2f       	mov	r24, r22
 4ea:	81 95       	neg	r24
      }
      else
	 value = 0;
   }
//Saves previous values into volatile variables
EC_a_prev = ec_a;
 4ec:	40 93 31 01 	sts	0x0131, r20	; 0x800131 <EC_a_prev>
EC_b_prev = ec_b;
 4f0:	90 93 30 01 	sts	0x0130, r25	; 0x800130 <EC_b_prev>

return value;
}
 4f4:	08 95       	ret

000004f6 <__vector_16>:
	update the mode and bargraph. Then I change the sum based on	
	the value returned from the encoder reading. Sum is then bounded
	from 0-1023. 1023+1=1 and 0-any number > 0 = 1023.
Parameters: NA
**********************************************************************/
ISR(TIMER0_OVF_vect) {
 4f6:	1f 92       	push	r1
 4f8:	0f 92       	push	r0
 4fa:	0f b6       	in	r0, 0x3f	; 63
 4fc:	0f 92       	push	r0
 4fe:	11 24       	eor	r1, r1
 500:	0b b6       	in	r0, 0x3b	; 59
 502:	0f 92       	push	r0
 504:	2f 93       	push	r18
 506:	3f 93       	push	r19
 508:	4f 93       	push	r20
 50a:	5f 93       	push	r21
 50c:	6f 93       	push	r22
 50e:	7f 93       	push	r23
 510:	8f 93       	push	r24
 512:	9f 93       	push	r25
 514:	af 93       	push	r26
 516:	bf 93       	push	r27
 518:	ef 93       	push	r30
 51a:	ff 93       	push	r31
      bars();      
 51c:	0e 94 71 01 	call	0x2e2	; 0x2e2 <bars>
      sum = sum + read_encoder();
 520:	0e 94 30 02 	call	0x460	; 0x460 <read_encoder>
 524:	20 91 1b 01 	lds	r18, 0x011B	; 0x80011b <sum>
 528:	30 91 1c 01 	lds	r19, 0x011C	; 0x80011c <sum+0x1>
 52c:	28 0f       	add	r18, r24
 52e:	31 1d       	adc	r19, r1
 530:	87 fd       	sbrc	r24, 7
 532:	3a 95       	dec	r19
 534:	30 93 1c 01 	sts	0x011C, r19	; 0x80011c <sum+0x1>
 538:	20 93 1b 01 	sts	0x011B, r18	; 0x80011b <sum>
      if(sum>1023)
 53c:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <sum>
 540:	90 91 1c 01 	lds	r25, 0x011C	; 0x80011c <sum+0x1>
 544:	81 15       	cp	r24, r1
 546:	94 40       	sbci	r25, 0x04	; 4
 548:	64 f0       	brlt	.+24     	; 0x562 <__vector_16+0x6c>
	sum = sum % 1023;
 54a:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <sum>
 54e:	90 91 1c 01 	lds	r25, 0x011C	; 0x80011c <sum+0x1>
 552:	6f ef       	ldi	r22, 0xFF	; 255
 554:	73 e0       	ldi	r23, 0x03	; 3
 556:	0e 94 21 03 	call	0x642	; 0x642 <__divmodhi4>
 55a:	90 93 1c 01 	sts	0x011C, r25	; 0x80011c <sum+0x1>
 55e:	80 93 1b 01 	sts	0x011B, r24	; 0x80011b <sum>
      if(sum<0)
 562:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <sum>
 566:	90 91 1c 01 	lds	r25, 0x011C	; 0x80011c <sum+0x1>
 56a:	97 ff       	sbrs	r25, 7
 56c:	06 c0       	rjmp	.+12     	; 0x57a <__vector_16+0x84>
	sum = 1023; //No overflow. If less than 0 always go to 1023.
 56e:	8f ef       	ldi	r24, 0xFF	; 255
 570:	93 e0       	ldi	r25, 0x03	; 3
 572:	90 93 1c 01 	sts	0x011C, r25	; 0x80011c <sum+0x1>
 576:	80 93 1b 01 	sts	0x011B, r24	; 0x80011b <sum>

}
 57a:	ff 91       	pop	r31
 57c:	ef 91       	pop	r30
 57e:	bf 91       	pop	r27
 580:	af 91       	pop	r26
 582:	9f 91       	pop	r25
 584:	8f 91       	pop	r24
 586:	7f 91       	pop	r23
 588:	6f 91       	pop	r22
 58a:	5f 91       	pop	r21
 58c:	4f 91       	pop	r20
 58e:	3f 91       	pop	r19
 590:	2f 91       	pop	r18
 592:	0f 90       	pop	r0
 594:	0b be       	out	0x3b, r0	; 59
 596:	0f 90       	pop	r0
 598:	0f be       	out	0x3f, r0	; 63
 59a:	0f 90       	pop	r0
 59c:	1f 90       	pop	r1
 59e:	18 95       	reti

000005a0 <main>:
	and while loop are defined. The LED display is updated continuously 
	in the loop.
Parameters: NA
**********************************************************************/
int main() {
   TIMSK |= (1<<TOIE0);			//enable interrupts
 5a0:	87 b7       	in	r24, 0x37	; 55
 5a2:	81 60       	ori	r24, 0x01	; 1
 5a4:	87 bf       	out	0x37, r24	; 55
   TCCR0 |= (1<<CS02) | (1<<CS00);	//normal mode, prescale by 128
 5a6:	83 b7       	in	r24, 0x33	; 51
 5a8:	85 60       	ori	r24, 0x05	; 5
 5aa:	83 bf       	out	0x33, r24	; 51
 
   DDRC |= 0xFF; 
 5ac:	84 b3       	in	r24, 0x14	; 20
 5ae:	9f ef       	ldi	r25, 0xFF	; 255
 5b0:	94 bb       	out	0x14, r25	; 20
   DDRB |= 0xF0;				//PB4-6 is SEL0-2, PB7 is PWM
 5b2:	87 b3       	in	r24, 0x17	; 23
 5b4:	80 6f       	ori	r24, 0xF0	; 240
 5b6:	87 bb       	out	0x17, r24	; 23
   DDRE |= 0x40;				//PE6 is SHIFT_LD_N
 5b8:	16 9a       	sbi	0x02, 6	; 2
   DDRD |= 0x0B;				//PE1 is CLK_INH and PE2 is SRCLK
 5ba:	81 b3       	in	r24, 0x11	; 17
 5bc:	8b 60       	ori	r24, 0x0B	; 11
 5be:	81 bb       	out	0x11, r24	; 17
   PORTC |= 0x00;
 5c0:	85 b3       	in	r24, 0x15	; 21
 5c2:	85 bb       	out	0x15, r24	; 21
   PORTD |= 0x02;
 5c4:	91 9a       	sbi	0x12, 1	; 18
   PORTE |= 0xFF;
 5c6:	83 b1       	in	r24, 0x03	; 3
 5c8:	93 b9       	out	0x03, r25	; 3
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
 5ca:	87 b3       	in	r24, 0x17	; 23
 5cc:	87 60       	ori	r24, 0x07	; 7
 5ce:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
 5d0:	8d b1       	in	r24, 0x0d	; 13
 5d2:	8c 65       	ori	r24, 0x5C	; 92
 5d4:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
 5d6:	70 9a       	sbi	0x0e, 0	; 14
   PORTD |= 0x02;
   PORTE |= 0xFF;

   spi_init();				//Initalize SPI

   sei();				//Enable interrupts
 5d8:	78 94       	sei
   while(1){
      segsum(sum);			//Send sum to be formatted for the 7 seg display

      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
         if(j == 2 && hex){
	    PORTA = 0b00000011;		//Turns on L3 on the LED display
 5da:	d3 e0       	ldi	r29, 0x03	; 3
	    }
	    else {
               PORTA = segment_data[j];	//Writes the segment data to PORTA aka the segments
            }
         }
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
 5dc:	c0 e2       	ldi	r28, 0x20	; 32
   spi_init();				//Initalize SPI

   sei();				//Enable interrupts
   
   while(1){
      segsum(sum);			//Send sum to be formatted for the 7 seg display
 5de:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <sum>
 5e2:	90 91 1c 01 	lds	r25, 0x011C	; 0x80011c <sum+0x1>
 5e6:	0e 94 94 00 	call	0x128	; 0x128 <segsum>
 5ea:	e6 e1       	ldi	r30, 0x16	; 22
 5ec:	f1 e0       	ldi	r31, 0x01	; 1
 5ee:	21 e0       	ldi	r18, 0x01	; 1
 5f0:	30 e0       	ldi	r19, 0x00	; 0
 5f2:	80 e0       	ldi	r24, 0x00	; 0
 5f4:	90 e0       	ldi	r25, 0x00	; 0
 5f6:	15 c0       	rjmp	.+42     	; 0x622 <main+0x82>
      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
         if(j == 2 && hex){
	    PORTA = 0b00000011;		//Turns on L3 on the LED display
	 }
	 else {
            if(hex){
 5f8:	40 91 1f 01 	lds	r20, 0x011F	; 0x80011f <hex>
	       PORTA = segment_data[j];
	    }
	    else {
               PORTA = segment_data[j];	//Writes the segment data to PORTA aka the segments
 5fc:	40 81       	ld	r20, Z
 5fe:	4b bb       	out	0x1b, r20	; 27
            }
         }
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
 600:	48 2f       	mov	r20, r24
 602:	42 95       	swap	r20
 604:	40 7f       	andi	r20, 0xF0	; 240
 606:	48 bb       	out	0x18, r20	; 24
 608:	af ea       	ldi	r26, 0xAF	; 175
 60a:	b4 e0       	ldi	r27, 0x04	; 4
 60c:	11 97       	sbiw	r26, 0x01	; 1
 60e:	f1 f7       	brne	.-4      	; 0x60c <main+0x6c>
 610:	00 c0       	rjmp	.+0      	; 0x612 <main+0x72>
 612:	00 00       	nop
   sei();				//Enable interrupts
   
   while(1){
      segsum(sum);			//Send sum to be formatted for the 7 seg display

      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
 614:	25 30       	cpi	r18, 0x05	; 5
 616:	31 05       	cpc	r19, r1
 618:	11 f3       	breq	.-60     	; 0x5de <main+0x3e>
 61a:	01 96       	adiw	r24, 0x01	; 1
 61c:	2f 5f       	subi	r18, 0xFF	; 255
 61e:	3f 4f       	sbci	r19, 0xFF	; 255
 620:	31 96       	adiw	r30, 0x01	; 1
         if(j == 2 && hex){
 622:	82 30       	cpi	r24, 0x02	; 2
 624:	91 05       	cpc	r25, r1
 626:	41 f7       	brne	.-48     	; 0x5f8 <main+0x58>
 628:	40 91 1f 01 	lds	r20, 0x011F	; 0x80011f <hex>
 62c:	44 23       	and	r20, r20
 62e:	21 f3       	breq	.-56     	; 0x5f8 <main+0x58>
	    PORTA = 0b00000011;		//Turns on L3 on the LED display
 630:	db bb       	out	0x1b, r29	; 27
	    }
	    else {
               PORTA = segment_data[j];	//Writes the segment data to PORTA aka the segments
            }
         }
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
 632:	c8 bb       	out	0x18, r28	; 24
 634:	af ea       	ldi	r26, 0xAF	; 175
 636:	b4 e0       	ldi	r27, 0x04	; 4
 638:	11 97       	sbiw	r26, 0x01	; 1
 63a:	f1 f7       	brne	.-4      	; 0x638 <main+0x98>
 63c:	00 c0       	rjmp	.+0      	; 0x63e <main+0x9e>
 63e:	00 00       	nop
 640:	ec cf       	rjmp	.-40     	; 0x61a <main+0x7a>

00000642 <__divmodhi4>:
 642:	97 fb       	bst	r25, 7
 644:	07 2e       	mov	r0, r23
 646:	16 f4       	brtc	.+4      	; 0x64c <__divmodhi4+0xa>
 648:	00 94       	com	r0
 64a:	07 d0       	rcall	.+14     	; 0x65a <__divmodhi4_neg1>
 64c:	77 fd       	sbrc	r23, 7
 64e:	09 d0       	rcall	.+18     	; 0x662 <__divmodhi4_neg2>
 650:	0e 94 44 03 	call	0x688	; 0x688 <__udivmodhi4>
 654:	07 fc       	sbrc	r0, 7
 656:	05 d0       	rcall	.+10     	; 0x662 <__divmodhi4_neg2>
 658:	3e f4       	brtc	.+14     	; 0x668 <__divmodhi4_exit>

0000065a <__divmodhi4_neg1>:
 65a:	90 95       	com	r25
 65c:	81 95       	neg	r24
 65e:	9f 4f       	sbci	r25, 0xFF	; 255
 660:	08 95       	ret

00000662 <__divmodhi4_neg2>:
 662:	70 95       	com	r23
 664:	61 95       	neg	r22
 666:	7f 4f       	sbci	r23, 0xFF	; 255

00000668 <__divmodhi4_exit>:
 668:	08 95       	ret

0000066a <__umulhisi3>:
 66a:	a2 9f       	mul	r26, r18
 66c:	b0 01       	movw	r22, r0
 66e:	b3 9f       	mul	r27, r19
 670:	c0 01       	movw	r24, r0
 672:	a3 9f       	mul	r26, r19
 674:	70 0d       	add	r23, r0
 676:	81 1d       	adc	r24, r1
 678:	11 24       	eor	r1, r1
 67a:	91 1d       	adc	r25, r1
 67c:	b2 9f       	mul	r27, r18
 67e:	70 0d       	add	r23, r0
 680:	81 1d       	adc	r24, r1
 682:	11 24       	eor	r1, r1
 684:	91 1d       	adc	r25, r1
 686:	08 95       	ret

00000688 <__udivmodhi4>:
 688:	aa 1b       	sub	r26, r26
 68a:	bb 1b       	sub	r27, r27
 68c:	51 e1       	ldi	r21, 0x11	; 17
 68e:	07 c0       	rjmp	.+14     	; 0x69e <__udivmodhi4_ep>

00000690 <__udivmodhi4_loop>:
 690:	aa 1f       	adc	r26, r26
 692:	bb 1f       	adc	r27, r27
 694:	a6 17       	cp	r26, r22
 696:	b7 07       	cpc	r27, r23
 698:	10 f0       	brcs	.+4      	; 0x69e <__udivmodhi4_ep>
 69a:	a6 1b       	sub	r26, r22
 69c:	b7 0b       	sbc	r27, r23

0000069e <__udivmodhi4_ep>:
 69e:	88 1f       	adc	r24, r24
 6a0:	99 1f       	adc	r25, r25
 6a2:	5a 95       	dec	r21
 6a4:	a9 f7       	brne	.-22     	; 0x690 <__udivmodhi4_loop>
 6a6:	80 95       	com	r24
 6a8:	90 95       	com	r25
 6aa:	bc 01       	movw	r22, r24
 6ac:	cd 01       	movw	r24, r26
 6ae:	08 95       	ret

000006b0 <_exit>:
 6b0:	f8 94       	cli

000006b2 <__stop_program>:
 6b2:	ff cf       	rjmp	.-2      	; 0x6b2 <__stop_program>
