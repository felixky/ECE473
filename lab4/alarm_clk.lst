
alarm_clk.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000018  00800100  00000ff4  00001088  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000ff4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000052  00800118  00800118  000010a0  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000010a0  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000010d0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000048  00000000  00000000  0000110c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001f1f  00000000  00000000  00001154  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c79  00000000  00000000  00003073  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000d56  00000000  00000000  00003cec  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000002ec  00000000  00000000  00004a44  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000005f8  00000000  00000000  00004d30  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000018cf  00000000  00000000  00005328  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000098  00000000  00000000  00006bf7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  40:	0c 94 d6 01 	jmp	0x3ac	; 0x3ac <__vector_16>
  44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e4 ef       	ldi	r30, 0xF4	; 244
  a0:	ff e0       	ldi	r31, 0x0F	; 15
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a8 31       	cpi	r26, 0x18	; 24
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	21 e0       	ldi	r18, 0x01	; 1
  b4:	a8 e1       	ldi	r26, 0x18	; 24
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	aa 36       	cpi	r26, 0x6A	; 106
  be:	b2 07       	cpc	r27, r18
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	0e 94 51 07 	call	0xea2	; 0xea2 <main>
  c6:	0c 94 f8 07 	jmp	0xff0	; 0xff0 <_exit>

000000ca <__bad_interrupt>:
  ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <spi_init>:
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
  ce:	87 b3       	in	r24, 0x17	; 23
  d0:	87 60       	ori	r24, 0x07	; 7
  d2:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
  d4:	8d b1       	in	r24, 0x0d	; 13
  d6:	8c 65       	ori	r24, 0x5C	; 92
  d8:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
  da:	70 9a       	sbi	0x0e, 0	; 14
  dc:	08 95       	ret

000000de <spi_read>:
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
  de:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
  e0:	77 9b       	sbis	0x0e, 7	; 14
  e2:	fe cf       	rjmp	.-4      	; 0xe0 <spi_read+0x2>
   return SPDR;
  e4:	8f b1       	in	r24, 0x0f	; 15
}
  e6:	08 95       	ret

000000e8 <chk_buttons>:
	be implemented at the same time. Adapted to check all buttons from 
	Ganssel's "Guide to Debouncing" Expects active low pushbuttons on PINA 
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
  e8:	48 2f       	mov	r20, r24
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
  ea:	e8 2f       	mov	r30, r24
  ec:	f0 e0       	ldi	r31, 0x00	; 0
  ee:	99 b3       	in	r25, 0x19	; 25
  f0:	ee 0f       	add	r30, r30
  f2:	ff 1f       	adc	r31, r31
  f4:	e9 5d       	subi	r30, 0xD9	; 217
  f6:	fe 4f       	sbci	r31, 0xFE	; 254
  f8:	20 81       	ld	r18, Z
  fa:	31 81       	ldd	r19, Z+1	; 0x01
  fc:	22 0f       	add	r18, r18
  fe:	33 1f       	adc	r19, r19
 100:	30 6e       	ori	r19, 0xE0	; 224
 102:	89 2f       	mov	r24, r25
 104:	90 e0       	ldi	r25, 0x00	; 0
 106:	02 c0       	rjmp	.+4      	; 0x10c <chk_buttons+0x24>
 108:	95 95       	asr	r25
 10a:	87 95       	ror	r24
 10c:	4a 95       	dec	r20
 10e:	e2 f7       	brpl	.-8      	; 0x108 <chk_buttons+0x20>
 110:	81 70       	andi	r24, 0x01	; 1
 112:	99 27       	eor	r25, r25
 114:	28 2b       	or	r18, r24
 116:	39 2b       	or	r19, r25
 118:	31 83       	std	Z+1, r19	; 0x01
 11a:	20 83       	st	Z, r18
 11c:	81 e0       	ldi	r24, 0x01	; 1
 11e:	21 15       	cp	r18, r1
 120:	30 4f       	sbci	r19, 0xF0	; 240
 122:	09 f0       	breq	.+2      	; 0x126 <chk_buttons+0x3e>
 124:	80 e0       	ldi	r24, 0x00	; 0
  if (state[button] == 0xF000)
    return 1;
return 0;
}
 126:	08 95       	ret

00000128 <bars>:
Description:This function reads in the button board and updates the 
	LEDs on the bargraph through the serial port.
Parameters: NA
**********************************************************************/
void bars() {
   DDRA = 0x00;				//Set all as inputs
 128:	1a ba       	out	0x1a, r1	; 26
   PORTA = 0xFF;			//Pull up resistors
 12a:	8f ef       	ldi	r24, 0xFF	; 255
 12c:	8b bb       	out	0x1b, r24	; 27
   PORTB |= PINB | 0x70;		//Enable tristate buffer
 12e:	86 b3       	in	r24, 0x16	; 22
 130:	98 b3       	in	r25, 0x18	; 24
 132:	80 67       	ori	r24, 0x70	; 112
 134:	89 2b       	or	r24, r25
 136:	88 bb       	out	0x18, r24	; 24
 138:	e7 e2       	ldi	r30, 0x27	; 39
 13a:	f1 e0       	ldi	r31, 0x01	; 1

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
 13c:	20 e0       	ldi	r18, 0x00	; 0
 13e:	30 e0       	ldi	r19, 0x00	; 0
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
 140:	61 e0       	ldi	r22, 0x01	; 1
 142:	70 e0       	ldi	r23, 0x00	; 0
 144:	05 c0       	rjmp	.+10     	; 0x150 <bars+0x28>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
 146:	2f 5f       	subi	r18, 0xFF	; 255
 148:	3f 4f       	sbci	r19, 0xFF	; 255
 14a:	28 30       	cpi	r18, 0x08	; 8
 14c:	31 05       	cpc	r19, r1
 14e:	39 f1       	breq	.+78     	; 0x19e <bars+0x76>
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
 150:	99 b3       	in	r25, 0x19	; 25
 152:	40 81       	ld	r20, Z
 154:	51 81       	ldd	r21, Z+1	; 0x01
 156:	44 0f       	add	r20, r20
 158:	55 1f       	adc	r21, r21
 15a:	89 2f       	mov	r24, r25
 15c:	90 e0       	ldi	r25, 0x00	; 0
 15e:	02 2e       	mov	r0, r18
 160:	02 c0       	rjmp	.+4      	; 0x166 <bars+0x3e>
 162:	95 95       	asr	r25
 164:	87 95       	ror	r24
 166:	0a 94       	dec	r0
 168:	e2 f7       	brpl	.-8      	; 0x162 <bars+0x3a>
 16a:	81 70       	andi	r24, 0x01	; 1
 16c:	99 27       	eor	r25, r25
 16e:	84 2b       	or	r24, r20
 170:	95 2b       	or	r25, r21
 172:	90 6e       	ori	r25, 0xE0	; 224
 174:	81 93       	st	Z+, r24
 176:	91 93       	st	Z+, r25
  if (state[button] == 0xF000)
 178:	81 15       	cp	r24, r1
 17a:	90 4f       	sbci	r25, 0xF0	; 240
 17c:	21 f7       	brne	.-56     	; 0x146 <bars+0x1e>
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
 17e:	cb 01       	movw	r24, r22
 180:	02 2e       	mov	r0, r18
 182:	02 c0       	rjmp	.+4      	; 0x188 <bars+0x60>
 184:	88 0f       	add	r24, r24
 186:	99 1f       	adc	r25, r25
 188:	0a 94       	dec	r0
 18a:	e2 f7       	brpl	.-8      	; 0x184 <bars+0x5c>
 18c:	90 93 20 01 	sts	0x0120, r25	; 0x800120 <mult+0x1>
 190:	80 93 1f 01 	sts	0x011F, r24	; 0x80011f <mult>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
 194:	2f 5f       	subi	r18, 0xFF	; 255
 196:	3f 4f       	sbci	r19, 0xFF	; 255
 198:	28 30       	cpi	r18, 0x08	; 8
 19a:	31 05       	cpc	r19, r1
 19c:	c9 f6       	brne	.-78     	; 0x150 <bars+0x28>
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
 19e:	88 b3       	in	r24, 0x18	; 24
 1a0:	18 ba       	out	0x18, r1	; 24
   if(mult == 128){			//Button 8 toggles base 10 and 16
 1a2:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <mult>
 1a6:	90 91 20 01 	lds	r25, 0x0120	; 0x800120 <mult+0x1>
 1aa:	80 38       	cpi	r24, 0x80	; 128
 1ac:	91 05       	cpc	r25, r1
 1ae:	e1 f1       	breq	.+120    	; 0x228 <bars+0x100>
      hex = !(hex);			//on the LED display
   }
   if(mult > 4) {			//I only want values from the
 1b0:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <mult>
 1b4:	90 91 20 01 	lds	r25, 0x0120	; 0x800120 <mult+0x1>
 1b8:	05 97       	sbiw	r24, 0x05	; 5
 1ba:	20 f0       	brcs	.+8      	; 0x1c4 <bars+0x9c>
      mult = 0;				//first three buttons
 1bc:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <mult+0x1>
 1c0:	10 92 1f 01 	sts	0x011F, r1	; 0x80011f <mult>
   }
   //This switch statement is used to enable a 'toggle' functionality
   //so that modes can be selected an deselected
   switch(mult) {
 1c4:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <mult>
 1c8:	90 91 20 01 	lds	r25, 0x0120	; 0x800120 <mult+0x1>
 1cc:	82 30       	cpi	r24, 0x02	; 2
 1ce:	91 05       	cpc	r25, r1
 1d0:	09 f4       	brne	.+2      	; 0x1d4 <bars+0xac>
 1d2:	4a c0       	rjmp	.+148    	; 0x268 <bars+0x140>
 1d4:	84 30       	cpi	r24, 0x04	; 4
 1d6:	91 05       	cpc	r25, r1
 1d8:	79 f1       	breq	.+94     	; 0x238 <bars+0x110>
 1da:	81 30       	cpi	r24, 0x01	; 1
 1dc:	91 05       	cpc	r25, r1
 1de:	c1 f0       	breq	.+48     	; 0x210 <bars+0xe8>
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
         break;
      default:
	 mode_sel = mode_sel;		//no/invalid button press
 1e0:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <mode_sel>
 1e4:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <mode_sel+0x1>
 1e8:	90 93 15 01 	sts	0x0115, r25	; 0x800115 <mode_sel+0x1>
 1ec:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <mode_sel>
   }   
   mult = 0;				//clear mult for next pass
 1f0:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <mult+0x1>
 1f4:	10 92 1f 01 	sts	0x011F, r1	; 0x80011f <mult>

   DDRA = 0xFF;				//Set A to alloutputs
 1f8:	8f ef       	ldi	r24, 0xFF	; 255
 1fa:	8a bb       	out	0x1a, r24	; 26
   SPDR = mode_sel;			//Write mode to the Bargraph
 1fc:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <mode_sel>
 200:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <mode_sel+0x1>
 204:	8f b9       	out	0x0f, r24	; 15
   while(bit_is_clear(SPSR, SPIF)){}	
 206:	77 9b       	sbis	0x0e, 7	; 14
 208:	fe cf       	rjmp	.-4      	; 0x206 <bars+0xde>
   PORTB |= (1<<PB0);			//Rgclk high on bargraph
 20a:	c0 9a       	sbi	0x18, 0	; 24
   PORTB &= 0xFE;			//Rgclk low on bargraph
 20c:	c0 98       	cbi	0x18, 0	; 24
   
return ;
 20e:	08 95       	ret
   }
   //This switch statement is used to enable a 'toggle' functionality
   //so that modes can be selected an deselected
   switch(mult) {
      case 1:
	 if((mode_sel ^ mult) == 0){	//XOR to see if they are the same
 210:	40 91 14 01 	lds	r20, 0x0114	; 0x800114 <mode_sel>
 214:	50 91 15 01 	lds	r21, 0x0115	; 0x800115 <mode_sel+0x1>
 218:	20 91 1f 01 	lds	r18, 0x011F	; 0x80011f <mult>
 21c:	30 91 20 01 	lds	r19, 0x0120	; 0x800120 <mult+0x1>
 220:	42 17       	cp	r20, r18
 222:	53 07       	cpc	r21, r19
 224:	09 f7       	brne	.-62     	; 0x1e8 <bars+0xc0>
 226:	31 c0       	rjmp	.+98     	; 0x28a <bars+0x162>
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      hex = !(hex);			//on the LED display
 228:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <hex>
 22c:	81 e0       	ldi	r24, 0x01	; 1
 22e:	91 11       	cpse	r25, r1
 230:	38 c0       	rjmp	.+112    	; 0x2a2 <bars+0x17a>
 232:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <hex>
 236:	bc cf       	rjmp	.-136    	; 0x1b0 <bars+0x88>
	 else
	    mode_sel = 2;		//If not, then change mode
         
         break;
      case 4:
	 if((mode_sel ^ mult) && ((mode_sel == 2))){//if cur &prev are diff
 238:	20 91 14 01 	lds	r18, 0x0114	; 0x800114 <mode_sel>
 23c:	30 91 15 01 	lds	r19, 0x0115	; 0x800115 <mode_sel+0x1>
 240:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <mult>
 244:	90 91 20 01 	lds	r25, 0x0120	; 0x800120 <mult+0x1>
 248:	28 17       	cp	r18, r24
 24a:	39 07       	cpc	r19, r25
 24c:	31 f0       	breq	.+12     	; 0x25a <bars+0x132>
 24e:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <mode_sel>
 252:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <mode_sel+0x1>
 256:	02 97       	sbiw	r24, 0x02	; 2
 258:	c1 f0       	breq	.+48     	; 0x28a <bars+0x162>
	    mode_sel = 0;//and prev isn't = 1 then two modes are selected
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
 25a:	84 e0       	ldi	r24, 0x04	; 4
 25c:	90 e0       	ldi	r25, 0x00	; 0
 25e:	90 93 15 01 	sts	0x0115, r25	; 0x800115 <mode_sel+0x1>
 262:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <mode_sel>
 266:	c4 cf       	rjmp	.-120    	; 0x1f0 <bars+0xc8>
	 }
	 else
	    mode_sel = 1;		//If not, then change mode
         break;
      case 2:
	 if((mode_sel ^ mult) && (mode_sel == 4)){//if cur &prev are diff
 268:	20 91 14 01 	lds	r18, 0x0114	; 0x800114 <mode_sel>
 26c:	30 91 15 01 	lds	r19, 0x0115	; 0x800115 <mode_sel+0x1>
 270:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <mult>
 274:	90 91 20 01 	lds	r25, 0x0120	; 0x800120 <mult+0x1>
 278:	28 17       	cp	r18, r24
 27a:	39 07       	cpc	r19, r25
 27c:	59 f0       	breq	.+22     	; 0x294 <bars+0x16c>
 27e:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <mode_sel>
 282:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <mode_sel+0x1>
 286:	04 97       	sbiw	r24, 0x04	; 4
 288:	29 f4       	brne	.+10     	; 0x294 <bars+0x16c>
	    mode_sel = 2;		//If not, then change mode
         
         break;
      case 4:
	 if((mode_sel ^ mult) && ((mode_sel == 2))){//if cur &prev are diff
	    mode_sel = 0;//and prev isn't = 1 then two modes are selected
 28a:	10 92 15 01 	sts	0x0115, r1	; 0x800115 <mode_sel+0x1>
 28e:	10 92 14 01 	sts	0x0114, r1	; 0x800114 <mode_sel>
 292:	ae cf       	rjmp	.-164    	; 0x1f0 <bars+0xc8>
      case 2:
	 if((mode_sel ^ mult) && (mode_sel == 4)){//if cur &prev are diff
	    mode_sel = 0;//and prev isn't = 1 then two modes are selected
	 }
	 else
	    mode_sel = 2;		//If not, then change mode
 294:	82 e0       	ldi	r24, 0x02	; 2
 296:	90 e0       	ldi	r25, 0x00	; 0
 298:	90 93 15 01 	sts	0x0115, r25	; 0x800115 <mode_sel+0x1>
 29c:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <mode_sel>
 2a0:	a7 cf       	rjmp	.-178    	; 0x1f0 <bars+0xc8>
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      hex = !(hex);			//on the LED display
 2a2:	80 e0       	ldi	r24, 0x00	; 0
 2a4:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <hex>
 2a8:	83 cf       	rjmp	.-250    	; 0x1b0 <bars+0x88>

000002aa <read_encoder>:
   int8_t value = 0x00;
   uint8_t ec_a;
   uint8_t ec_b;

   //Shift_LD_N low
   PORTE &= 0x00;	//Begining of SHIFT_LD_N pulse. It is low here
 2aa:	83 b1       	in	r24, 0x03	; 3
 2ac:	13 b8       	out	0x03, r1	; 3
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2ae:	87 ec       	ldi	r24, 0xC7	; 199
 2b0:	90 e0       	ldi	r25, 0x00	; 0
 2b2:	01 97       	sbiw	r24, 0x01	; 1
 2b4:	f1 f7       	brne	.-4      	; 0x2b2 <read_encoder+0x8>
 2b6:	00 c0       	rjmp	.+0      	; 0x2b8 <read_encoder+0xe>
 2b8:	00 00       	nop
   _delay_us(50);
   PORTE |= 0xFF;	//End of SHIFT_LD_N pulse. back to high
 2ba:	83 b1       	in	r24, 0x03	; 3
 2bc:	8f ef       	ldi	r24, 0xFF	; 255
 2be:	83 b9       	out	0x03, r24	; 3
   PORTD &= 0x00;	//CLK_INH low
 2c0:	82 b3       	in	r24, 0x12	; 18
 2c2:	12 ba       	out	0x12, r1	; 18
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
 2c4:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
 2c6:	77 9b       	sbis	0x0e, 7	; 14
 2c8:	fe cf       	rjmp	.-4      	; 0x2c6 <read_encoder+0x1c>
   return SPDR;
 2ca:	9f b1       	in	r25, 0x0f	; 15
   _delay_us(50);
   PORTE |= 0xFF;	//End of SHIFT_LD_N pulse. back to high
   PORTD &= 0x00;	//CLK_INH low

   encoder_value = spi_read();
   PORTD |= 0x02;	//CLK_INH high
 2cc:	91 9a       	sbi	0x12, 1	; 18
   value = mode_sel;
 2ce:	20 91 14 01 	lds	r18, 0x0114	; 0x800114 <mode_sel>
 2d2:	30 91 15 01 	lds	r19, 0x0115	; 0x800115 <mode_sel+0x1>
 2d6:	82 2f       	mov	r24, r18
   ec_a = encoder_value & 0x03;  //Only grabs these bits 0000_0011
 2d8:	69 2f       	mov	r22, r25
 2da:	63 70       	andi	r22, 0x03	; 3
   ec_b = encoder_value & 0x0C;  //Only grabs these bits 0000_1100 
 2dc:	9c 70       	andi	r25, 0x0C	; 12
   ec_b = (ec_b >> 2);
 2de:	96 95       	lsr	r25
 2e0:	96 95       	lsr	r25

   if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
 2e2:	20 91 39 01 	lds	r18, 0x0139	; 0x800139 <EC_a_prev>
 2e6:	46 2f       	mov	r20, r22
 2e8:	50 e0       	ldi	r21, 0x00	; 0
 2ea:	02 2e       	mov	r0, r18
 2ec:	00 0c       	add	r0, r0
 2ee:	33 0b       	sbc	r19, r19
 2f0:	42 17       	cp	r20, r18
 2f2:	53 07       	cpc	r21, r19
 2f4:	91 f0       	breq	.+36     	; 0x31a <read_encoder+0x70>
      if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
 2f6:	20 91 39 01 	lds	r18, 0x0139	; 0x800139 <EC_a_prev>
 2fa:	21 11       	cpse	r18, r1
 2fc:	02 c0       	rjmp	.+4      	; 0x302 <read_encoder+0x58>
 2fe:	61 30       	cpi	r22, 0x01	; 1
 300:	b9 f1       	breq	.+110    	; 0x370 <read_encoder+0xc6>
         hour_count = hour_count + 1;//value = value;
	 if(hour_count == 24)
	    hour_count = 0;
      }
      else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
 302:	20 91 39 01 	lds	r18, 0x0139	; 0x800139 <EC_a_prev>
 306:	21 11       	cpse	r18, r1
 308:	02 c0       	rjmp	.+4      	; 0x30e <read_encoder+0x64>
 30a:	62 30       	cpi	r22, 0x02	; 2
 30c:	21 f1       	breq	.+72     	; 0x356 <read_encoder+0xac>
	 hour_count = hour_count - 1;//value = -(value);
	 if(hour_count < 0)
	    hour_count = 23; 
      }
      else	//If not one of the state changes above, do nothing
	 value = 0;
 30e:	80 e0       	ldi	r24, 0x00	; 0
      }
      else
	 value = 0;
   }
//Saves previous values into volatile variables
EC_a_prev = ec_a;
 310:	60 93 39 01 	sts	0x0139, r22	; 0x800139 <EC_a_prev>
EC_b_prev = ec_b;
 314:	90 93 38 01 	sts	0x0138, r25	; 0x800138 <EC_b_prev>

return value;
}
 318:	08 95       	ret
      }
      else	//If not one of the state changes above, do nothing
	 value = 0;
   }
   else {	//This is for encoder B
      if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
 31a:	20 91 38 01 	lds	r18, 0x0138	; 0x800138 <EC_b_prev>
 31e:	21 11       	cpse	r18, r1
 320:	02 c0       	rjmp	.+4      	; 0x326 <read_encoder+0x7c>
 322:	91 30       	cpi	r25, 0x01	; 1
 324:	89 f1       	breq	.+98     	; 0x388 <read_encoder+0xde>
	 if(min_count == 60){
	    min_count = 0; 
	    hour_count++;
	 }
      }
      else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
 326:	20 91 38 01 	lds	r18, 0x0138	; 0x800138 <EC_b_prev>
 32a:	21 11       	cpse	r18, r1
 32c:	f0 cf       	rjmp	.-32     	; 0x30e <read_encoder+0x64>
 32e:	92 30       	cpi	r25, 0x02	; 2
 330:	71 f7       	brne	.-36     	; 0x30e <read_encoder+0x64>
	 min_count = min_count - 1; //value = -(value);
 332:	20 91 24 01 	lds	r18, 0x0124	; 0x800124 <min_count>
 336:	21 50       	subi	r18, 0x01	; 1
 338:	20 93 24 01 	sts	0x0124, r18	; 0x800124 <min_count>
	 if(min_count < 0){
 33c:	20 91 24 01 	lds	r18, 0x0124	; 0x800124 <min_count>
 340:	27 ff       	sbrs	r18, 7
 342:	e6 cf       	rjmp	.-52     	; 0x310 <read_encoder+0x66>
	    min_count = 59;
 344:	2b e3       	ldi	r18, 0x3B	; 59
 346:	20 93 24 01 	sts	0x0124, r18	; 0x800124 <min_count>
	    hour_count--;
 34a:	20 91 17 01 	lds	r18, 0x0117	; 0x800117 <hour_count>
 34e:	21 50       	subi	r18, 0x01	; 1
 350:	20 93 17 01 	sts	0x0117, r18	; 0x800117 <hour_count>
 354:	dd cf       	rjmp	.-70     	; 0x310 <read_encoder+0x66>
         hour_count = hour_count + 1;//value = value;
	 if(hour_count == 24)
	    hour_count = 0;
      }
      else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
	 hour_count = hour_count - 1;//value = -(value);
 356:	20 91 17 01 	lds	r18, 0x0117	; 0x800117 <hour_count>
 35a:	21 50       	subi	r18, 0x01	; 1
 35c:	20 93 17 01 	sts	0x0117, r18	; 0x800117 <hour_count>
	 if(hour_count < 0)
 360:	20 91 17 01 	lds	r18, 0x0117	; 0x800117 <hour_count>
 364:	27 ff       	sbrs	r18, 7
 366:	d4 cf       	rjmp	.-88     	; 0x310 <read_encoder+0x66>
	    hour_count = 23; 
 368:	27 e1       	ldi	r18, 0x17	; 23
 36a:	20 93 17 01 	sts	0x0117, r18	; 0x800117 <hour_count>
 36e:	d0 cf       	rjmp	.-96     	; 0x310 <read_encoder+0x66>
   ec_b = encoder_value & 0x0C;  //Only grabs these bits 0000_1100 
   ec_b = (ec_b >> 2);

   if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
      if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
         hour_count = hour_count + 1;//value = value;
 370:	20 91 17 01 	lds	r18, 0x0117	; 0x800117 <hour_count>
 374:	2f 5f       	subi	r18, 0xFF	; 255
 376:	20 93 17 01 	sts	0x0117, r18	; 0x800117 <hour_count>
	 if(hour_count == 24)
 37a:	20 91 17 01 	lds	r18, 0x0117	; 0x800117 <hour_count>
 37e:	28 31       	cpi	r18, 0x18	; 24
 380:	39 f6       	brne	.-114    	; 0x310 <read_encoder+0x66>
	    hour_count = 0;
 382:	10 92 17 01 	sts	0x0117, r1	; 0x800117 <hour_count>
 386:	c4 cf       	rjmp	.-120    	; 0x310 <read_encoder+0x66>
      else	//If not one of the state changes above, do nothing
	 value = 0;
   }
   else {	//This is for encoder B
      if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
         min_count = min_count + 1;//value = value;
 388:	20 91 24 01 	lds	r18, 0x0124	; 0x800124 <min_count>
 38c:	2f 5f       	subi	r18, 0xFF	; 255
 38e:	20 93 24 01 	sts	0x0124, r18	; 0x800124 <min_count>
	 if(min_count == 60){
 392:	20 91 24 01 	lds	r18, 0x0124	; 0x800124 <min_count>
 396:	2c 33       	cpi	r18, 0x3C	; 60
 398:	09 f0       	breq	.+2      	; 0x39c <read_encoder+0xf2>
 39a:	ba cf       	rjmp	.-140    	; 0x310 <read_encoder+0x66>
	    min_count = 0; 
 39c:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <min_count>
	    hour_count++;
 3a0:	20 91 17 01 	lds	r18, 0x0117	; 0x800117 <hour_count>
 3a4:	2f 5f       	subi	r18, 0xFF	; 255
 3a6:	20 93 17 01 	sts	0x0117, r18	; 0x800117 <hour_count>
 3aa:	b2 cf       	rjmp	.-156    	; 0x310 <read_encoder+0x66>

000003ac <__vector_16>:
	update the mode and bargraph. Then I change the sum based on	
	the value returned from the encoder reading. Sum is then bounded
	from 0-1023. 1023+1=1 and 0-any number > 0 = 1023.
Parameters: NA
**********************************************************************/
ISR(TIMER0_OVF_vect) {
 3ac:	1f 92       	push	r1
 3ae:	0f 92       	push	r0
 3b0:	0f b6       	in	r0, 0x3f	; 63
 3b2:	0f 92       	push	r0
 3b4:	11 24       	eor	r1, r1
 3b6:	0b b6       	in	r0, 0x3b	; 59
 3b8:	0f 92       	push	r0
 3ba:	2f 93       	push	r18
 3bc:	3f 93       	push	r19
 3be:	4f 93       	push	r20
 3c0:	5f 93       	push	r21
 3c2:	6f 93       	push	r22
 3c4:	7f 93       	push	r23
 3c6:	8f 93       	push	r24
 3c8:	9f 93       	push	r25
 3ca:	af 93       	push	r26
 3cc:	bf 93       	push	r27
 3ce:	ef 93       	push	r30
 3d0:	ff 93       	push	r31
   static uint8_t count_7_8125ms = 0;

   count_7_8125ms++;
 3d2:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <count_7_8125ms.1999>
 3d6:	8f 5f       	subi	r24, 0xFF	; 255
 3d8:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <count_7_8125ms.1999>
   if((count_7_8125ms % 128) == 0) { //interrupts every 1 second
 3dc:	8f 77       	andi	r24, 0x7F	; 127
 3de:	29 f4       	brne	.+10     	; 0x3ea <__vector_16+0x3e>
      sec_count++;
 3e0:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <sec_count>
 3e4:	8f 5f       	subi	r24, 0xFF	; 255
 3e6:	80 93 25 01 	sts	0x0125, r24	; 0x800125 <sec_count>
   }
   bars();  
 3ea:	0e 94 94 00 	call	0x128	; 0x128 <bars>
   read_encoder();      
 3ee:	0e 94 55 01 	call	0x2aa	; 0x2aa <read_encoder>
//      if(sum>1023)
//	sum = sum % 1023;
//      if(sum<0)
//	sum = 1023; //No overflow. If less than 0 always go to 1023.

}
 3f2:	ff 91       	pop	r31
 3f4:	ef 91       	pop	r30
 3f6:	bf 91       	pop	r27
 3f8:	af 91       	pop	r26
 3fa:	9f 91       	pop	r25
 3fc:	8f 91       	pop	r24
 3fe:	7f 91       	pop	r23
 400:	6f 91       	pop	r22
 402:	5f 91       	pop	r21
 404:	4f 91       	pop	r20
 406:	3f 91       	pop	r19
 408:	2f 91       	pop	r18
 40a:	0f 90       	pop	r0
 40c:	0b be       	out	0x3b, r0	; 59
 40e:	0f 90       	pop	r0
 410:	0f be       	out	0x3f, r0	; 63
 412:	0f 90       	pop	r0
 414:	1f 90       	pop	r1
 416:	18 95       	reti

00000418 <clock_time>:
Description:
Parameters:
**********************************************************************/
void clock_time(){ //by default we use military time
   
   if(sec_count > 59){
 418:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <sec_count>
 41c:	8c 33       	cpi	r24, 0x3C	; 60
 41e:	60 f0       	brcs	.+24     	; 0x438 <clock_time+0x20>
      min_count++;
 420:	80 91 24 01 	lds	r24, 0x0124	; 0x800124 <min_count>
 424:	8f 5f       	subi	r24, 0xFF	; 255
 426:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <min_count>
      sec_count = 0;
 42a:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <sec_count>
      if(min_count > 59){
 42e:	80 91 24 01 	lds	r24, 0x0124	; 0x800124 <min_count>
 432:	8c 33       	cpi	r24, 0x3C	; 60
 434:	0c f0       	brlt	.+2      	; 0x438 <clock_time+0x20>
 436:	6c c0       	rjmp	.+216    	; 0x510 <clock_time+0xf8>
	    hour_count = 0;
	 }//hours	
      }//mins
   }//secs
   
   if(!mil){
 438:	80 91 16 01 	lds	r24, 0x0116	; 0x800116 <mil>
 43c:	81 11       	cpse	r24, r1
 43e:	0e c0       	rjmp	.+28     	; 0x45c <clock_time+0x44>
      if(hour_count > 12){
 440:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <hour_count>
 444:	8d 30       	cpi	r24, 0x0D	; 13
 446:	2c f0       	brlt	.+10     	; 0x452 <clock_time+0x3a>
         hour_count = hour_count - 12;
 448:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <hour_count>
 44c:	8c 50       	subi	r24, 0x0C	; 12
 44e:	80 93 17 01 	sts	0x0117, r24	; 0x800117 <hour_count>
      }
      if(hour_count == 0){
 452:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <hour_count>
 456:	88 23       	and	r24, r24
 458:	09 f4       	brne	.+2      	; 0x45c <clock_time+0x44>
 45a:	56 c0       	rjmp	.+172    	; 0x508 <clock_time+0xf0>
         hour_count = 12;
      }
      
   }
      segment_data[4] = dec_to_7seg[hour_count/10];
 45c:	90 91 17 01 	lds	r25, 0x0117	; 0x800117 <hour_count>
 460:	87 e6       	ldi	r24, 0x67	; 103
 462:	98 02       	muls	r25, r24
 464:	e1 2d       	mov	r30, r1
 466:	11 24       	eor	r1, r1
 468:	e5 95       	asr	r30
 46a:	e5 95       	asr	r30
 46c:	97 fd       	sbrc	r25, 7
 46e:	e3 95       	inc	r30
 470:	0e 2e       	mov	r0, r30
 472:	00 0c       	add	r0, r0
 474:	ff 0b       	sbc	r31, r31
 476:	e0 50       	subi	r30, 0x00	; 0
 478:	ff 4f       	sbci	r31, 0xFF	; 255
 47a:	90 81       	ld	r25, Z
 47c:	90 93 1c 01 	sts	0x011C, r25	; 0x80011c <__data_end+0x4>
      segment_data[3] = dec_to_7seg[hour_count%10];
 480:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <hour_count>
 484:	e8 02       	muls	r30, r24
 486:	81 2d       	mov	r24, r1
 488:	11 24       	eor	r1, r1
 48a:	85 95       	asr	r24
 48c:	85 95       	asr	r24
 48e:	e7 fd       	sbrc	r30, 7
 490:	83 95       	inc	r24
 492:	9a e0       	ldi	r25, 0x0A	; 10
 494:	89 9f       	mul	r24, r25
 496:	e0 19       	sub	r30, r0
 498:	11 24       	eor	r1, r1
 49a:	0e 2e       	mov	r0, r30
 49c:	00 0c       	add	r0, r0
 49e:	ff 0b       	sbc	r31, r31
 4a0:	e0 50       	subi	r30, 0x00	; 0
 4a2:	ff 4f       	sbci	r31, 0xFF	; 255
 4a4:	80 81       	ld	r24, Z
 4a6:	80 93 1b 01 	sts	0x011B, r24	; 0x80011b <__data_end+0x3>
      if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
 4aa:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <sec_count>
 4ae:	80 fd       	sbrc	r24, 0
 4b0:	3e c0       	rjmp	.+124    	; 0x52e <clock_time+0x116>
      else {segment_data[2] = 0b111;}		//Turn colon off
 4b2:	87 e0       	ldi	r24, 0x07	; 7
 4b4:	80 93 1a 01 	sts	0x011A, r24	; 0x80011a <__data_end+0x2>
      segment_data[1] = dec_to_7seg[min_count/10];
 4b8:	90 91 24 01 	lds	r25, 0x0124	; 0x800124 <min_count>
 4bc:	87 e6       	ldi	r24, 0x67	; 103
 4be:	98 02       	muls	r25, r24
 4c0:	e1 2d       	mov	r30, r1
 4c2:	11 24       	eor	r1, r1
 4c4:	e5 95       	asr	r30
 4c6:	e5 95       	asr	r30
 4c8:	97 fd       	sbrc	r25, 7
 4ca:	e3 95       	inc	r30
 4cc:	0e 2e       	mov	r0, r30
 4ce:	00 0c       	add	r0, r0
 4d0:	ff 0b       	sbc	r31, r31
 4d2:	e0 50       	subi	r30, 0x00	; 0
 4d4:	ff 4f       	sbci	r31, 0xFF	; 255
 4d6:	90 81       	ld	r25, Z
 4d8:	90 93 19 01 	sts	0x0119, r25	; 0x800119 <__data_end+0x1>
      segment_data[0] = dec_to_7seg[min_count%10];
 4dc:	e0 91 24 01 	lds	r30, 0x0124	; 0x800124 <min_count>
 4e0:	e8 02       	muls	r30, r24
 4e2:	81 2d       	mov	r24, r1
 4e4:	11 24       	eor	r1, r1
 4e6:	85 95       	asr	r24
 4e8:	85 95       	asr	r24
 4ea:	e7 fd       	sbrc	r30, 7
 4ec:	83 95       	inc	r24
 4ee:	9a e0       	ldi	r25, 0x0A	; 10
 4f0:	89 9f       	mul	r24, r25
 4f2:	e0 19       	sub	r30, r0
 4f4:	11 24       	eor	r1, r1
 4f6:	0e 2e       	mov	r0, r30
 4f8:	00 0c       	add	r0, r0
 4fa:	ff 0b       	sbc	r31, r31
 4fc:	e0 50       	subi	r30, 0x00	; 0
 4fe:	ff 4f       	sbci	r31, 0xFF	; 255
 500:	80 81       	ld	r24, Z
 502:	80 93 18 01 	sts	0x0118, r24	; 0x800118 <__data_end>
 506:	08 95       	ret
   if(!mil){
      if(hour_count > 12){
         hour_count = hour_count - 12;
      }
      if(hour_count == 0){
         hour_count = 12;
 508:	8c e0       	ldi	r24, 0x0C	; 12
 50a:	80 93 17 01 	sts	0x0117, r24	; 0x800117 <hour_count>
 50e:	a6 cf       	rjmp	.-180    	; 0x45c <clock_time+0x44>
   
   if(sec_count > 59){
      min_count++;
      sec_count = 0;
      if(min_count > 59){
	 hour_count++;
 510:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <hour_count>
 514:	8f 5f       	subi	r24, 0xFF	; 255
 516:	80 93 17 01 	sts	0x0117, r24	; 0x800117 <hour_count>
	 min_count = 0;
 51a:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <min_count>
	 if(hour_count > 23){
 51e:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <hour_count>
 522:	88 31       	cpi	r24, 0x18	; 24
 524:	0c f4       	brge	.+2      	; 0x528 <clock_time+0x110>
 526:	88 cf       	rjmp	.-240    	; 0x438 <clock_time+0x20>
	    hour_count = 0;
 528:	10 92 17 01 	sts	0x0117, r1	; 0x800117 <hour_count>
 52c:	85 cf       	rjmp	.-246    	; 0x438 <clock_time+0x20>
      }
      
   }
      segment_data[4] = dec_to_7seg[hour_count/10];
      segment_data[3] = dec_to_7seg[hour_count%10];
      if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
 52e:	84 e0       	ldi	r24, 0x04	; 4
 530:	80 93 1a 01 	sts	0x011A, r24	; 0x80011a <__data_end+0x2>
 534:	c1 cf       	rjmp	.-126    	; 0x4b8 <clock_time+0xa0>

00000536 <send_lcd>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 536:	91 e0       	ldi	r25, 0x01	; 1
 538:	81 11       	cpse	r24, r1
 53a:	01 c0       	rjmp	.+2      	; 0x53e <send_lcd+0x8>
 53c:	90 e0       	ldi	r25, 0x00	; 0
 53e:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 540:	77 9b       	sbis	0x0e, 7	; 14
 542:	fe cf       	rjmp	.-4      	; 0x540 <send_lcd+0xa>
  SPDR = byte;                        //send payload
 544:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 546:	77 9b       	sbis	0x0e, 7	; 14
 548:	fe cf       	rjmp	.-4      	; 0x546 <send_lcd+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 54a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 54e:	88 60       	ori	r24, 0x08	; 8
 550:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 554:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 558:	87 7f       	andi	r24, 0xF7	; 247
 55a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 55e:	08 95       	ret

00000560 <refresh_lcd>:
//
void refresh_lcd(char lcd_string_array[]) {

  static uint8_t i=0;           // index into string array 

 send_lcd(CHAR_BYTE,lcd_string_array[i]);
 560:	20 91 37 01 	lds	r18, 0x0137	; 0x800137 <i.2095>
 564:	82 0f       	add	r24, r18
 566:	91 1d       	adc	r25, r1
 568:	fc 01       	movw	r30, r24
 56a:	80 81       	ld	r24, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 56c:	91 e0       	ldi	r25, 0x01	; 1
 56e:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 570:	77 9b       	sbis	0x0e, 7	; 14
 572:	fe cf       	rjmp	.-4      	; 0x570 <refresh_lcd+0x10>
  SPDR = byte;                        //send payload
 574:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 576:	77 9b       	sbis	0x0e, 7	; 14
 578:	fe cf       	rjmp	.-4      	; 0x576 <refresh_lcd+0x16>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 57a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 57e:	88 60       	ori	r24, 0x08	; 8
 580:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 584:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 588:	87 7f       	andi	r24, 0xF7	; 247
 58a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
void refresh_lcd(char lcd_string_array[]) {

  static uint8_t i=0;           // index into string array 

 send_lcd(CHAR_BYTE,lcd_string_array[i]);
 i++;   //increment to next character
 58e:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <i.2095>
 592:	8f 5f       	subi	r24, 0xFF	; 255
 594:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <i.2095>
 //delays are inserted to allow character to be written before moving
 //the cursor to the next line.
 if(i == 16){_delay_us(40); line2_col1();      } //goto line 2, 1st char 
 598:	80 31       	cpi	r24, 0x10	; 16
 59a:	f9 f0       	breq	.+62     	; 0x5da <refresh_lcd+0x7a>
 if(i == 32){_delay_us(40); line1_col1(); i=0; } //goto line 1, 1st char 
 59c:	80 32       	cpi	r24, 0x20	; 32
 59e:	09 f0       	breq	.+2      	; 0x5a2 <refresh_lcd+0x42>
 5a0:	08 95       	ret
 5a2:	e5 ed       	ldi	r30, 0xD5	; 213
 5a4:	ea 95       	dec	r30
 5a6:	f1 f7       	brne	.-4      	; 0x5a4 <refresh_lcd+0x44>
 5a8:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 5aa:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 5ac:	77 9b       	sbis	0x0e, 7	; 14
 5ae:	fe cf       	rjmp	.-4      	; 0x5ac <refresh_lcd+0x4c>
  SPDR = byte;                        //send payload
 5b0:	80 e8       	ldi	r24, 0x80	; 128
 5b2:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 5b4:	77 9b       	sbis	0x0e, 7	; 14
 5b6:	fe cf       	rjmp	.-4      	; 0x5b4 <refresh_lcd+0x54>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 5b8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 5bc:	88 60       	ori	r24, 0x08	; 8
 5be:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 5c2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 5c6:	87 7f       	andi	r24, 0xF7	; 247
 5c8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 5cc:	f5 ed       	ldi	r31, 0xD5	; 213
 5ce:	fa 95       	dec	r31
 5d0:	f1 f7       	brne	.-4      	; 0x5ce <refresh_lcd+0x6e>
 5d2:	00 00       	nop
 send_lcd(CHAR_BYTE,lcd_string_array[i]);
 i++;   //increment to next character
 //delays are inserted to allow character to be written before moving
 //the cursor to the next line.
 if(i == 16){_delay_us(40); line2_col1();      } //goto line 2, 1st char 
 if(i == 32){_delay_us(40); line1_col1(); i=0; } //goto line 1, 1st char 
 5d4:	10 92 37 01 	sts	0x0137, r1	; 0x800137 <i.2095>
 5d8:	08 95       	ret
 5da:	f5 ed       	ldi	r31, 0xD5	; 213
 5dc:	fa 95       	dec	r31
 5de:	f1 f7       	brne	.-4      	; 0x5dc <refresh_lcd+0x7c>
 5e0:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 5e2:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 5e4:	77 9b       	sbis	0x0e, 7	; 14
 5e6:	fe cf       	rjmp	.-4      	; 0x5e4 <refresh_lcd+0x84>
  SPDR = byte;                        //send payload
 5e8:	80 ec       	ldi	r24, 0xC0	; 192
 5ea:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 5ec:	77 9b       	sbis	0x0e, 7	; 14
 5ee:	fe cf       	rjmp	.-4      	; 0x5ec <refresh_lcd+0x8c>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 5f0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 5f4:	88 60       	ori	r24, 0x08	; 8
 5f6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 5fa:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 5fe:	87 7f       	andi	r24, 0xF7	; 247
 600:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 604:	85 ed       	ldi	r24, 0xD5	; 213
 606:	8a 95       	dec	r24
 608:	f1 f7       	brne	.-4      	; 0x606 <refresh_lcd+0xa6>
 60a:	00 00       	nop
 60c:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <i.2095>
 610:	c5 cf       	rjmp	.-118    	; 0x59c <refresh_lcd+0x3c>

00000612 <set_custom_character>:
//address, such as send_lcd(CHAR_BYTE, 0x01, 1) or it can be insteretd into a string 
//via a forward slash escape as in string2lcd("this is my music note \1")

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
 612:	66 0f       	add	r22, r22
 614:	66 0f       	add	r22, r22
 616:	66 0f       	add	r22, r22
 618:	60 5c       	subi	r22, 0xC0	; 192
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 61a:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 61c:	77 9b       	sbis	0x0e, 7	; 14
 61e:	fe cf       	rjmp	.-4      	; 0x61c <set_custom_character+0xa>
  SPDR = byte;                        //send payload
 620:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 622:	77 9b       	sbis	0x0e, 7	; 14
 624:	fe cf       	rjmp	.-4      	; 0x622 <set_custom_character+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 626:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 62a:	28 60       	ori	r18, 0x08	; 8
 62c:	20 93 62 00 	sts	0x0062, r18	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 630:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 634:	27 7f       	andi	r18, 0xF7	; 247
 636:	20 93 62 00 	sts	0x0062, r18	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 63a:	25 ed       	ldi	r18, 0xD5	; 213
 63c:	2a 95       	dec	r18
 63e:	f1 f7       	brne	.-4      	; 0x63c <set_custom_character+0x2a>
 640:	00 00       	nop
 642:	fc 01       	movw	r30, r24
 644:	9c 01       	movw	r18, r24
 646:	28 5f       	subi	r18, 0xF8	; 248
 648:	3f 4f       	sbci	r19, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 64a:	91 e0       	ldi	r25, 0x01	; 1

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
    for(i=0; i<8; i++){
      send_lcd(CHAR_BYTE, data[i]); _delay_us(40); //each char byte takes 37us to execute
 64c:	81 91       	ld	r24, Z+
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 64e:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 650:	77 9b       	sbis	0x0e, 7	; 14
 652:	fe cf       	rjmp	.-4      	; 0x650 <set_custom_character+0x3e>
  SPDR = byte;                        //send payload
 654:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 656:	77 9b       	sbis	0x0e, 7	; 14
 658:	fe cf       	rjmp	.-4      	; 0x656 <set_custom_character+0x44>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 65a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 65e:	88 60       	ori	r24, 0x08	; 8
 660:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 664:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 668:	87 7f       	andi	r24, 0xF7	; 247
 66a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 66e:	85 ed       	ldi	r24, 0xD5	; 213
 670:	8a 95       	dec	r24
 672:	f1 f7       	brne	.-4      	; 0x670 <set_custom_character+0x5e>
 674:	00 00       	nop
//via a forward slash escape as in string2lcd("this is my music note \1")

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
    for(i=0; i<8; i++){
 676:	e2 17       	cp	r30, r18
 678:	f3 07       	cpc	r31, r19
 67a:	41 f7       	brne	.-48     	; 0x64c <set_custom_character+0x3a>
      send_lcd(CHAR_BYTE, data[i]); _delay_us(40); //each char byte takes 37us to execute
    }
}
 67c:	08 95       	ret

0000067e <set_cursor>:
//                          set_cursor 
//
//Sets the cursor to an arbitrary potition on the screen, row is either 1 or 2
//col is a number form 0-15, counting from left to right
void set_cursor(uint8_t row, uint8_t col){
    send_lcd(CMD_BYTE, 0x80 + col + ((row-1)*0x40));
 67e:	90 e4       	ldi	r25, 0x40	; 64
 680:	89 9f       	mul	r24, r25
 682:	60 0d       	add	r22, r0
 684:	11 24       	eor	r1, r1
 686:	60 5c       	subi	r22, 0xC0	; 192
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 688:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 68a:	77 9b       	sbis	0x0e, 7	; 14
 68c:	fe cf       	rjmp	.-4      	; 0x68a <set_cursor+0xc>
  SPDR = byte;                        //send payload
 68e:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 690:	77 9b       	sbis	0x0e, 7	; 14
 692:	fe cf       	rjmp	.-4      	; 0x690 <set_cursor+0x12>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 694:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 698:	88 60       	ori	r24, 0x08	; 8
 69a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 69e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 6a2:	87 7f       	andi	r24, 0xF7	; 247
 6a4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 6a8:	08 95       	ret

000006aa <uint2lcd>:
//not displayed.  
//TODO: optimize by removing the mod operators
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
 6aa:	81 11       	cpse	r24, r1
 6ac:	13 c0       	rjmp	.+38     	; 0x6d4 <uint2lcd+0x2a>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 6ae:	81 e0       	ldi	r24, 0x01	; 1
 6b0:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 6b2:	77 9b       	sbis	0x0e, 7	; 14
 6b4:	fe cf       	rjmp	.-4      	; 0x6b2 <uint2lcd+0x8>
  SPDR = byte;                        //send payload
 6b6:	80 e3       	ldi	r24, 0x30	; 48
 6b8:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 6ba:	77 9b       	sbis	0x0e, 7	; 14
 6bc:	fe cf       	rjmp	.-4      	; 0x6ba <uint2lcd+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 6be:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 6c2:	88 60       	ori	r24, 0x08	; 8
 6c4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 6c8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 6cc:	87 7f       	andi	r24, 0xF7	; 247
 6ce:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 6d2:	08 95       	ret
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
 6d4:	84 36       	cpi	r24, 0x64	; 100
 6d6:	b0 f4       	brcc	.+44     	; 0x704 <uint2lcd+0x5a>
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
 6d8:	8a 30       	cpi	r24, 0x0A	; 10
 6da:	60 f5       	brcc	.+88     	; 0x734 <uint2lcd+0x8a>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 6dc:	91 e0       	ldi	r25, 0x01	; 1
 6de:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 6e0:	77 9b       	sbis	0x0e, 7	; 14
 6e2:	fe cf       	rjmp	.-4      	; 0x6e0 <uint2lcd+0x36>
void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
      if(number >= 1)  {send_lcd(CHAR_BYTE, 0x30+(number%10)    ); }
 6e4:	9d ec       	ldi	r25, 0xCD	; 205
 6e6:	89 9f       	mul	r24, r25
 6e8:	91 2d       	mov	r25, r1
 6ea:	11 24       	eor	r1, r1
 6ec:	96 95       	lsr	r25
 6ee:	96 95       	lsr	r25
 6f0:	96 95       	lsr	r25
 6f2:	2a e0       	ldi	r18, 0x0A	; 10
 6f4:	92 9f       	mul	r25, r18
 6f6:	80 19       	sub	r24, r0
 6f8:	11 24       	eor	r1, r1
 6fa:	80 5d       	subi	r24, 0xD0	; 208
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
  SPDR = byte;                        //send payload
 6fc:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 6fe:	77 9b       	sbis	0x0e, 7	; 14
 700:	fe cf       	rjmp	.-4      	; 0x6fe <uint2lcd+0x54>
 702:	dd cf       	rjmp	.-70     	; 0x6be <uint2lcd+0x14>
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
 704:	99 e2       	ldi	r25, 0x29	; 41
 706:	89 9f       	mul	r24, r25
 708:	91 2d       	mov	r25, r1
 70a:	11 24       	eor	r1, r1
 70c:	92 95       	swap	r25
 70e:	9f 70       	andi	r25, 0x0F	; 15
 710:	90 5d       	subi	r25, 0xD0	; 208
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 712:	21 e0       	ldi	r18, 0x01	; 1
 714:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 716:	77 9b       	sbis	0x0e, 7	; 14
 718:	fe cf       	rjmp	.-4      	; 0x716 <uint2lcd+0x6c>
  SPDR = byte;                        //send payload
 71a:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 71c:	77 9b       	sbis	0x0e, 7	; 14
 71e:	fe cf       	rjmp	.-4      	; 0x71c <uint2lcd+0x72>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 720:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 724:	98 60       	ori	r25, 0x08	; 8
 726:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 72a:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 72e:	97 7f       	andi	r25, 0xF7	; 247
 730:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
 734:	99 e2       	ldi	r25, 0x29	; 41
 736:	89 9f       	mul	r24, r25
 738:	91 2d       	mov	r25, r1
 73a:	11 24       	eor	r1, r1
 73c:	92 95       	swap	r25
 73e:	9f 70       	andi	r25, 0x0F	; 15
 740:	38 2f       	mov	r19, r24
 742:	24 e6       	ldi	r18, 0x64	; 100
 744:	92 9f       	mul	r25, r18
 746:	30 19       	sub	r19, r0
 748:	11 24       	eor	r1, r1
 74a:	2d ec       	ldi	r18, 0xCD	; 205
 74c:	32 9f       	mul	r19, r18
 74e:	91 2d       	mov	r25, r1
 750:	11 24       	eor	r1, r1
 752:	96 95       	lsr	r25
 754:	96 95       	lsr	r25
 756:	96 95       	lsr	r25
 758:	90 5d       	subi	r25, 0xD0	; 208
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 75a:	21 e0       	ldi	r18, 0x01	; 1
 75c:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 75e:	77 9b       	sbis	0x0e, 7	; 14
 760:	fe cf       	rjmp	.-4      	; 0x75e <uint2lcd+0xb4>
  SPDR = byte;                        //send payload
 762:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 764:	77 9b       	sbis	0x0e, 7	; 14
 766:	fe cf       	rjmp	.-4      	; 0x764 <uint2lcd+0xba>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 768:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 76c:	98 60       	ori	r25, 0x08	; 8
 76e:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 772:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 776:	97 7f       	andi	r25, 0xF7	; 247
 778:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 77c:	af cf       	rjmp	.-162    	; 0x6dc <uint2lcd+0x32>

0000077e <int2lcd>:
//Takes a 8bit signed and displays it in base ten on the LCD. Leading 0's are 
//not displayed.
//
void int2lcd(int8_t number){
    //if < 0, print minus sign, then take 2's complement of number and display
    if(number < 0){send_lcd(CHAR_BYTE, '-'); _delay_us(40); uint2lcd(~number+1);}  
 77e:	87 ff       	sbrs	r24, 7
    else          {uint2lcd(number);                                            }
 780:	0c 94 55 03 	jmp	0x6aa	; 0x6aa <uint2lcd>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 784:	91 e0       	ldi	r25, 0x01	; 1
 786:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 788:	77 9b       	sbis	0x0e, 7	; 14
 78a:	fe cf       	rjmp	.-4      	; 0x788 <int2lcd+0xa>
  SPDR = byte;                        //send payload
 78c:	9d e2       	ldi	r25, 0x2D	; 45
 78e:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 790:	77 9b       	sbis	0x0e, 7	; 14
 792:	fe cf       	rjmp	.-4      	; 0x790 <int2lcd+0x12>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 794:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 798:	98 60       	ori	r25, 0x08	; 8
 79a:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 79e:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 7a2:	97 7f       	andi	r25, 0xF7	; 247
 7a4:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 7a8:	95 ed       	ldi	r25, 0xD5	; 213
 7aa:	9a 95       	dec	r25
 7ac:	f1 f7       	brne	.-4      	; 0x7aa <int2lcd+0x2c>
 7ae:	00 00       	nop
//Takes a 8bit signed and displays it in base ten on the LCD. Leading 0's are 
//not displayed.
//
void int2lcd(int8_t number){
    //if < 0, print minus sign, then take 2's complement of number and display
    if(number < 0){send_lcd(CHAR_BYTE, '-'); _delay_us(40); uint2lcd(~number+1);}  
 7b0:	81 95       	neg	r24
 7b2:	0c 94 55 03 	jmp	0x6aa	; 0x6aa <uint2lcd>

000007b6 <cursor_on>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 7b6:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 7b8:	77 9b       	sbis	0x0e, 7	; 14
 7ba:	fe cf       	rjmp	.-4      	; 0x7b8 <cursor_on+0x2>
  SPDR = byte;                        //send payload
 7bc:	8e e0       	ldi	r24, 0x0E	; 14
 7be:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 7c0:	77 9b       	sbis	0x0e, 7	; 14
 7c2:	fe cf       	rjmp	.-4      	; 0x7c0 <cursor_on+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 7c4:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 7c8:	88 60       	ori	r24, 0x08	; 8
 7ca:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 7ce:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 7d2:	87 7f       	andi	r24, 0xF7	; 247
 7d4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 7d8:	08 95       	ret

000007da <cursor_off>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 7da:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 7dc:	77 9b       	sbis	0x0e, 7	; 14
 7de:	fe cf       	rjmp	.-4      	; 0x7dc <cursor_off+0x2>
  SPDR = byte;                        //send payload
 7e0:	8c e0       	ldi	r24, 0x0C	; 12
 7e2:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 7e4:	77 9b       	sbis	0x0e, 7	; 14
 7e6:	fe cf       	rjmp	.-4      	; 0x7e4 <cursor_off+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 7e8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 7ec:	88 60       	ori	r24, 0x08	; 8
 7ee:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 7f2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 7f6:	87 7f       	andi	r24, 0xF7	; 247
 7f8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 7fc:	08 95       	ret

000007fe <shift_right>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 7fe:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 800:	77 9b       	sbis	0x0e, 7	; 14
 802:	fe cf       	rjmp	.-4      	; 0x800 <shift_right+0x2>
  SPDR = byte;                        //send payload
 804:	8e e1       	ldi	r24, 0x1E	; 30
 806:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 808:	77 9b       	sbis	0x0e, 7	; 14
 80a:	fe cf       	rjmp	.-4      	; 0x808 <shift_right+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 80c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 810:	88 60       	ori	r24, 0x08	; 8
 812:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 816:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 81a:	87 7f       	andi	r24, 0xF7	; 247
 81c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 820:	08 95       	ret

00000822 <shift_left>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 822:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 824:	77 9b       	sbis	0x0e, 7	; 14
 826:	fe cf       	rjmp	.-4      	; 0x824 <shift_left+0x2>
  SPDR = byte;                        //send payload
 828:	88 e1       	ldi	r24, 0x18	; 24
 82a:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 82c:	77 9b       	sbis	0x0e, 7	; 14
 82e:	fe cf       	rjmp	.-4      	; 0x82c <shift_left+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 830:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 834:	88 60       	ori	r24, 0x08	; 8
 836:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 83a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 83e:	87 7f       	andi	r24, 0xF7	; 247
 840:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 844:	08 95       	ret

00000846 <strobe_lcd>:
 846:	e2 e6       	ldi	r30, 0x62	; 98
 848:	f0 e0       	ldi	r31, 0x00	; 0
 84a:	80 81       	ld	r24, Z
 84c:	88 60       	ori	r24, 0x08	; 8
 84e:	80 83       	st	Z, r24
 850:	80 81       	ld	r24, Z
 852:	87 7f       	andi	r24, 0xF7	; 247
 854:	80 83       	st	Z, r24
 856:	08 95       	ret

00000858 <clear_display>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 858:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 85a:	77 9b       	sbis	0x0e, 7	; 14
 85c:	fe cf       	rjmp	.-4      	; 0x85a <clear_display+0x2>
  SPDR = byte;                        //send payload
 85e:	81 e0       	ldi	r24, 0x01	; 1
 860:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 862:	77 9b       	sbis	0x0e, 7	; 14
 864:	fe cf       	rjmp	.-4      	; 0x862 <clear_display+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 866:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 86a:	88 60       	ori	r24, 0x08	; 8
 86c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 870:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 874:	87 7f       	andi	r24, 0xF7	; 247
 876:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 87a:	8f e1       	ldi	r24, 0x1F	; 31
 87c:	9c e1       	ldi	r25, 0x1C	; 28
 87e:	01 97       	sbiw	r24, 0x01	; 1
 880:	f1 f7       	brne	.-4      	; 0x87e <clear_display+0x26>
 882:	00 c0       	rjmp	.+0      	; 0x884 <clear_display+0x2c>
 884:	00 00       	nop
 886:	08 95       	ret

00000888 <cursor_home>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 888:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 88a:	77 9b       	sbis	0x0e, 7	; 14
 88c:	fe cf       	rjmp	.-4      	; 0x88a <cursor_home+0x2>
  SPDR = byte;                        //send payload
 88e:	82 e0       	ldi	r24, 0x02	; 2
 890:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 892:	77 9b       	sbis	0x0e, 7	; 14
 894:	fe cf       	rjmp	.-4      	; 0x892 <cursor_home+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 896:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 89a:	88 60       	ori	r24, 0x08	; 8
 89c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 8a0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 8a4:	87 7f       	andi	r24, 0xF7	; 247
 8a6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 8aa:	8f e6       	ldi	r24, 0x6F	; 111
 8ac:	97 e1       	ldi	r25, 0x17	; 23
 8ae:	01 97       	sbiw	r24, 0x01	; 1
 8b0:	f1 f7       	brne	.-4      	; 0x8ae <cursor_home+0x26>
 8b2:	00 c0       	rjmp	.+0      	; 0x8b4 <cursor_home+0x2c>
 8b4:	00 00       	nop
 8b6:	08 95       	ret

000008b8 <line2_col1>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 8b8:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 8ba:	77 9b       	sbis	0x0e, 7	; 14
 8bc:	fe cf       	rjmp	.-4      	; 0x8ba <line2_col1+0x2>
  SPDR = byte;                        //send payload
 8be:	80 ec       	ldi	r24, 0xC0	; 192
 8c0:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 8c2:	77 9b       	sbis	0x0e, 7	; 14
 8c4:	fe cf       	rjmp	.-4      	; 0x8c2 <line2_col1+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 8c6:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 8ca:	88 60       	ori	r24, 0x08	; 8
 8cc:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 8d0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 8d4:	87 7f       	andi	r24, 0xF7	; 247
 8d6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 8da:	85 ed       	ldi	r24, 0xD5	; 213
 8dc:	8a 95       	dec	r24
 8de:	f1 f7       	brne	.-4      	; 0x8dc <line2_col1+0x24>
 8e0:	00 00       	nop
 8e2:	08 95       	ret

000008e4 <line1_col1>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 8e4:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 8e6:	77 9b       	sbis	0x0e, 7	; 14
 8e8:	fe cf       	rjmp	.-4      	; 0x8e6 <line1_col1+0x2>
  SPDR = byte;                        //send payload
 8ea:	80 e8       	ldi	r24, 0x80	; 128
 8ec:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 8ee:	77 9b       	sbis	0x0e, 7	; 14
 8f0:	fe cf       	rjmp	.-4      	; 0x8ee <line1_col1+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 8f2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 8f6:	88 60       	ori	r24, 0x08	; 8
 8f8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 8fc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 900:	87 7f       	andi	r24, 0xF7	; 247
 902:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 906:	85 ed       	ldi	r24, 0xD5	; 213
 908:	8a 95       	dec	r24
 90a:	f1 f7       	brne	.-4      	; 0x908 <line1_col1+0x24>
 90c:	00 00       	nop
 90e:	08 95       	ret

00000910 <fill_spaces>:

//-----------------------------------------------------------------------------
//                          fill_spaces   
//
//Fill an entire line with spaces.
void fill_spaces(void){
 910:	90 e1       	ldi	r25, 0x10	; 16
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 912:	31 e0       	ldi	r19, 0x01	; 1
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
  SPDR = byte;                        //send payload
 914:	20 e2       	ldi	r18, 0x20	; 32
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 916:	3f b9       	out	0x0f, r19	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 918:	77 9b       	sbis	0x0e, 7	; 14
 91a:	fe cf       	rjmp	.-4      	; 0x918 <fill_spaces+0x8>
  SPDR = byte;                        //send payload
 91c:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 91e:	77 9b       	sbis	0x0e, 7	; 14
 920:	fe cf       	rjmp	.-4      	; 0x91e <fill_spaces+0xe>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 922:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 926:	88 60       	ori	r24, 0x08	; 8
 928:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 92c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 930:	87 7f       	andi	r24, 0xF7	; 247
 932:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 936:	85 ed       	ldi	r24, 0xD5	; 213
 938:	8a 95       	dec	r24
 93a:	f1 f7       	brne	.-4      	; 0x938 <fill_spaces+0x28>
 93c:	00 00       	nop
 93e:	91 50       	subi	r25, 0x01	; 1
//                          fill_spaces   
//
//Fill an entire line with spaces.
void fill_spaces(void){
	uint8_t i;
	for (i=0; i<=(NUM_LCD_CHARS-1); i++){
 940:	51 f7       	brne	.-44     	; 0x916 <fill_spaces+0x6>
		send_lcd(CHAR_BYTE, ' '); 
                _delay_us(40);  //40us wait between characters
	}
}  
 942:	08 95       	ret

00000944 <char2lcd>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 944:	91 e0       	ldi	r25, 0x01	; 1
 946:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 948:	77 9b       	sbis	0x0e, 7	; 14
 94a:	fe cf       	rjmp	.-4      	; 0x948 <char2lcd+0x4>
  SPDR = byte;                        //send payload
 94c:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 94e:	77 9b       	sbis	0x0e, 7	; 14
 950:	fe cf       	rjmp	.-4      	; 0x94e <char2lcd+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 952:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 956:	88 60       	ori	r24, 0x08	; 8
 958:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 95c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 960:	87 7f       	andi	r24, 0xF7	; 247
 962:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 966:	08 95       	ret

00000968 <string2lcd>:

//----------------------------------------------------------------------------
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
 968:	fc 01       	movw	r30, r24
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
 96a:	40 e0       	ldi	r20, 0x00	; 0
 96c:	50 e0       	ldi	r21, 0x00	; 0
 96e:	60 e0       	ldi	r22, 0x00	; 0
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 970:	71 e0       	ldi	r23, 0x01	; 1
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
 972:	df 01       	movw	r26, r30
 974:	a4 0f       	add	r26, r20
 976:	b5 1f       	adc	r27, r21
 978:	8c 91       	ld	r24, X
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 97a:	7f b9       	out	0x0f, r23	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 97c:	77 9b       	sbis	0x0e, 7	; 14
 97e:	fe cf       	rjmp	.-4      	; 0x97c <string2lcd+0x14>
  SPDR = byte;                        //send payload
 980:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 982:	77 9b       	sbis	0x0e, 7	; 14
 984:	fe cf       	rjmp	.-4      	; 0x982 <string2lcd+0x1a>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 986:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 98a:	98 60       	ori	r25, 0x08	; 8
 98c:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 990:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 994:	97 7f       	andi	r25, 0xF7	; 247
 996:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 99a:	85 ed       	ldi	r24, 0xD5	; 213
 99c:	8a 95       	dec	r24
 99e:	f1 f7       	brne	.-4      	; 0x99c <string2lcd+0x34>
 9a0:	00 00       	nop
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
 9a2:	6f 5f       	subi	r22, 0xFF	; 255
 9a4:	46 2f       	mov	r20, r22
 9a6:	50 e0       	ldi	r21, 0x00	; 0
 9a8:	df 01       	movw	r26, r30
 9aa:	0d 90       	ld	r0, X+
 9ac:	00 20       	and	r0, r0
 9ae:	e9 f7       	brne	.-6      	; 0x9aa <string2lcd+0x42>
 9b0:	9d 01       	movw	r18, r26
 9b2:	2e 1b       	sub	r18, r30
 9b4:	3f 0b       	sbc	r19, r31
 9b6:	22 50       	subi	r18, 0x02	; 2
 9b8:	31 09       	sbc	r19, r1
 9ba:	24 17       	cp	r18, r20
 9bc:	35 07       	cpc	r19, r21
 9be:	c8 f6       	brcc	.-78     	; 0x972 <string2lcd+0xa>
  _delay_us(40);  //execution takes 37us per character
  }                  
} 
 9c0:	08 95       	ret

000009c2 <lcd_init>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 9c2:	8f ef       	ldi	r24, 0xFF	; 255
 9c4:	99 ef       	ldi	r25, 0xF9	; 249
 9c6:	01 97       	sbiw	r24, 0x01	; 1
 9c8:	f1 f7       	brne	.-4      	; 0x9c6 <lcd_init+0x4>
 9ca:	00 c0       	rjmp	.+0      	; 0x9cc <lcd_init+0xa>
 9cc:	00 00       	nop
//
void lcd_init(void){
  _delay_ms(16);      //power up delay
#if SPI_MODE==1       //assumption is that the SPI port is intialized
  //TODO: kludge alert! setting of DDRF should not be here, but is probably harmless.
  DDRF=0x08;          //port F bit 3 is enable for LCD in SPI mode
 9ce:	88 e0       	ldi	r24, 0x08	; 8
 9d0:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 9d4:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 9d6:	77 9b       	sbis	0x0e, 7	; 14
 9d8:	fe cf       	rjmp	.-4      	; 0x9d6 <lcd_init+0x14>
  SPDR = byte;                        //send payload
 9da:	80 e3       	ldi	r24, 0x30	; 48
 9dc:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 9de:	77 9b       	sbis	0x0e, 7	; 14
 9e0:	fe cf       	rjmp	.-4      	; 0x9de <lcd_init+0x1c>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 9e2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 9e6:	88 60       	ori	r24, 0x08	; 8
 9e8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 9ec:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 9f0:	87 7f       	andi	r24, 0xF7	; 247
 9f2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 9f6:	8f e5       	ldi	r24, 0x5F	; 95
 9f8:	9d e6       	ldi	r25, 0x6D	; 109
 9fa:	01 97       	sbiw	r24, 0x01	; 1
 9fc:	f1 f7       	brne	.-4      	; 0x9fa <lcd_init+0x38>
 9fe:	00 c0       	rjmp	.+0      	; 0xa00 <lcd_init+0x3e>
 a00:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 a02:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 a04:	77 9b       	sbis	0x0e, 7	; 14
 a06:	fe cf       	rjmp	.-4      	; 0xa04 <lcd_init+0x42>
  SPDR = byte;                        //send payload
 a08:	80 e3       	ldi	r24, 0x30	; 48
 a0a:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 a0c:	77 9b       	sbis	0x0e, 7	; 14
 a0e:	fe cf       	rjmp	.-4      	; 0xa0c <lcd_init+0x4a>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 a10:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 a14:	88 60       	ori	r24, 0x08	; 8
 a16:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 a1a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 a1e:	87 7f       	andi	r24, 0xF7	; 247
 a20:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 a24:	8f e5       	ldi	r24, 0x5F	; 95
 a26:	9d e6       	ldi	r25, 0x6D	; 109
 a28:	01 97       	sbiw	r24, 0x01	; 1
 a2a:	f1 f7       	brne	.-4      	; 0xa28 <lcd_init+0x66>
 a2c:	00 c0       	rjmp	.+0      	; 0xa2e <lcd_init+0x6c>
 a2e:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 a30:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 a32:	77 9b       	sbis	0x0e, 7	; 14
 a34:	fe cf       	rjmp	.-4      	; 0xa32 <lcd_init+0x70>
  SPDR = byte;                        //send payload
 a36:	80 e3       	ldi	r24, 0x30	; 48
 a38:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 a3a:	77 9b       	sbis	0x0e, 7	; 14
 a3c:	fe cf       	rjmp	.-4      	; 0xa3a <lcd_init+0x78>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 a3e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 a42:	88 60       	ori	r24, 0x08	; 8
 a44:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 a48:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 a4c:	87 7f       	andi	r24, 0xF7	; 247
 a4e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 a52:	8f e5       	ldi	r24, 0x5F	; 95
 a54:	9d e6       	ldi	r25, 0x6D	; 109
 a56:	01 97       	sbiw	r24, 0x01	; 1
 a58:	f1 f7       	brne	.-4      	; 0xa56 <lcd_init+0x94>
 a5a:	00 c0       	rjmp	.+0      	; 0xa5c <lcd_init+0x9a>
 a5c:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 a5e:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 a60:	77 9b       	sbis	0x0e, 7	; 14
 a62:	fe cf       	rjmp	.-4      	; 0xa60 <lcd_init+0x9e>
  SPDR = byte;                        //send payload
 a64:	88 e3       	ldi	r24, 0x38	; 56
 a66:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 a68:	77 9b       	sbis	0x0e, 7	; 14
 a6a:	fe cf       	rjmp	.-4      	; 0xa68 <lcd_init+0xa6>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 a6c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 a70:	88 60       	ori	r24, 0x08	; 8
 a72:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 a76:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 a7a:	87 7f       	andi	r24, 0xF7	; 247
 a7c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 a80:	8f e1       	ldi	r24, 0x1F	; 31
 a82:	9e e4       	ldi	r25, 0x4E	; 78
 a84:	01 97       	sbiw	r24, 0x01	; 1
 a86:	f1 f7       	brne	.-4      	; 0xa84 <lcd_init+0xc2>
 a88:	00 c0       	rjmp	.+0      	; 0xa8a <lcd_init+0xc8>
 a8a:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 a8c:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 a8e:	77 9b       	sbis	0x0e, 7	; 14
 a90:	fe cf       	rjmp	.-4      	; 0xa8e <lcd_init+0xcc>
  SPDR = byte;                        //send payload
 a92:	88 e0       	ldi	r24, 0x08	; 8
 a94:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 a96:	77 9b       	sbis	0x0e, 7	; 14
 a98:	fe cf       	rjmp	.-4      	; 0xa96 <lcd_init+0xd4>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 a9a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 a9e:	88 60       	ori	r24, 0x08	; 8
 aa0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 aa4:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 aa8:	87 7f       	andi	r24, 0xF7	; 247
 aaa:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 aae:	8f e1       	ldi	r24, 0x1F	; 31
 ab0:	9e e4       	ldi	r25, 0x4E	; 78
 ab2:	01 97       	sbiw	r24, 0x01	; 1
 ab4:	f1 f7       	brne	.-4      	; 0xab2 <lcd_init+0xf0>
 ab6:	00 c0       	rjmp	.+0      	; 0xab8 <lcd_init+0xf6>
 ab8:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 aba:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 abc:	77 9b       	sbis	0x0e, 7	; 14
 abe:	fe cf       	rjmp	.-4      	; 0xabc <lcd_init+0xfa>
  SPDR = byte;                        //send payload
 ac0:	81 e0       	ldi	r24, 0x01	; 1
 ac2:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 ac4:	77 9b       	sbis	0x0e, 7	; 14
 ac6:	fe cf       	rjmp	.-4      	; 0xac4 <lcd_init+0x102>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 ac8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 acc:	88 60       	ori	r24, 0x08	; 8
 ace:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 ad2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 ad6:	87 7f       	andi	r24, 0xF7	; 247
 ad8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 adc:	8f e1       	ldi	r24, 0x1F	; 31
 ade:	9e e4       	ldi	r25, 0x4E	; 78
 ae0:	01 97       	sbiw	r24, 0x01	; 1
 ae2:	f1 f7       	brne	.-4      	; 0xae0 <lcd_init+0x11e>
 ae4:	00 c0       	rjmp	.+0      	; 0xae6 <lcd_init+0x124>
 ae6:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 ae8:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 aea:	77 9b       	sbis	0x0e, 7	; 14
 aec:	fe cf       	rjmp	.-4      	; 0xaea <lcd_init+0x128>
  SPDR = byte;                        //send payload
 aee:	86 e0       	ldi	r24, 0x06	; 6
 af0:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 af2:	77 9b       	sbis	0x0e, 7	; 14
 af4:	fe cf       	rjmp	.-4      	; 0xaf2 <lcd_init+0x130>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 af6:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 afa:	88 60       	ori	r24, 0x08	; 8
 afc:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 b00:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 b04:	87 7f       	andi	r24, 0xF7	; 247
 b06:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 b0a:	8f e1       	ldi	r24, 0x1F	; 31
 b0c:	9e e4       	ldi	r25, 0x4E	; 78
 b0e:	01 97       	sbiw	r24, 0x01	; 1
 b10:	f1 f7       	brne	.-4      	; 0xb0e <lcd_init+0x14c>
 b12:	00 c0       	rjmp	.+0      	; 0xb14 <lcd_init+0x152>
 b14:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 b16:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 b18:	77 9b       	sbis	0x0e, 7	; 14
 b1a:	fe cf       	rjmp	.-4      	; 0xb18 <lcd_init+0x156>
  SPDR = byte;                        //send payload
 b1c:	8c e0       	ldi	r24, 0x0C	; 12
 b1e:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 b20:	77 9b       	sbis	0x0e, 7	; 14
 b22:	fe cf       	rjmp	.-4      	; 0xb20 <lcd_init+0x15e>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 b24:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 b28:	88 60       	ori	r24, 0x08	; 8
 b2a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 b2e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 b32:	87 7f       	andi	r24, 0xF7	; 247
 b34:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 b38:	8f e1       	ldi	r24, 0x1F	; 31
 b3a:	9e e4       	ldi	r25, 0x4E	; 78
 b3c:	01 97       	sbiw	r24, 0x01	; 1
 b3e:	f1 f7       	brne	.-4      	; 0xb3c <lcd_init+0x17a>
 b40:	00 c0       	rjmp	.+0      	; 0xb42 <lcd_init+0x180>
 b42:	00 00       	nop
 b44:	08 95       	ret

00000b46 <lcd_int32>:
void  lcd_int32(int32_t l,          //number to display
                uint8_t fieldwidth, //width of the field for display
                uint8_t decpos,     //0 if no decimal point, otherwise
                uint8_t bSigned,    //non-zero if the number should be treated as signed 
                uint8_t bZeroFill)  //non-zero if a specified fieldwidth is to be zero filled
{
 b46:	4f 92       	push	r4
 b48:	5f 92       	push	r5
 b4a:	6f 92       	push	r6
 b4c:	7f 92       	push	r7
 b4e:	8f 92       	push	r8
 b50:	9f 92       	push	r9
 b52:	af 92       	push	r10
 b54:	bf 92       	push	r11
 b56:	cf 92       	push	r12
 b58:	df 92       	push	r13
 b5a:	ef 92       	push	r14
 b5c:	ff 92       	push	r15
 b5e:	0f 93       	push	r16
 b60:	1f 93       	push	r17
 b62:	cf 93       	push	r28
 b64:	df 93       	push	r29
 b66:	cd b7       	in	r28, 0x3d	; 61
 b68:	de b7       	in	r29, 0x3e	; 62
 b6a:	69 97       	sbiw	r28, 0x19	; 25
 b6c:	0f b6       	in	r0, 0x3f	; 63
 b6e:	f8 94       	cli
 b70:	de bf       	out	0x3e, r29	; 62
 b72:	0f be       	out	0x3f, r0	; 63
 b74:	cd bf       	out	0x3d, r28	; 61
 b76:	14 2f       	mov	r17, r20
 b78:	42 2e       	mov	r4, r18
 b7a:	5e 2c       	mov	r5, r14
      char    fillch;
      ldiv_t  qr;

      qr.quot = l; // initialize the quotient 

      if (bSigned){
 b7c:	00 23       	and	r16, r16
 b7e:	79 f0       	breq	.+30     	; 0xb9e <lcd_int32+0x58>
        bSigned = (qr.quot<0);
 b80:	6b 01       	movw	r12, r22
 b82:	7c 01       	movw	r14, r24
 b84:	cc 24       	eor	r12, r12
 b86:	f7 fc       	sbrc	r15, 7
 b88:	c3 94       	inc	r12
 b8a:	dd 24       	eor	r13, r13
 b8c:	ee 24       	eor	r14, r14
 b8e:	ff 24       	eor	r15, r15
 b90:	0c 2d       	mov	r16, r12
        qr.quot = labs(qr.quot);
 b92:	6b 01       	movw	r12, r22
 b94:	7c 01       	movw	r14, r24
 b96:	97 fd       	sbrc	r25, 7
 b98:	a3 c0       	rjmp	.+326    	; 0xce0 <lcd_int32+0x19a>
 b9a:	c7 01       	movw	r24, r14
 b9c:	b6 01       	movw	r22, r12
      }

      // convert the digits to the right of the decimal point 
      if (decpos){
 b9e:	44 20       	and	r4, r4
 ba0:	09 f4       	brne	.+2      	; 0xba4 <lcd_int32+0x5e>
 ba2:	96 c0       	rjmp	.+300    	; 0xcd0 <lcd_int32+0x18a>
 ba4:	9e 01       	movw	r18, r28
 ba6:	2f 5f       	subi	r18, 0xFF	; 255
 ba8:	3f 4f       	sbci	r19, 0xFF	; 255
 baa:	59 01       	movw	r10, r18
 bac:	49 01       	movw	r8, r18
 bae:	66 24       	eor	r6, r6
 bb0:	6a 94       	dec	r6
 bb2:	64 0c       	add	r6, r4
 bb4:	71 2c       	mov	r7, r1
 bb6:	3f ef       	ldi	r19, 0xFF	; 255
 bb8:	63 1a       	sub	r6, r19
 bba:	73 0a       	sbc	r7, r19
 bbc:	6a 0c       	add	r6, r10
 bbe:	7b 1c       	adc	r7, r11
        for (; decpos ; decpos--){
          qr = ldiv(qr.quot, 10);
 bc0:	2a e0       	ldi	r18, 0x0A	; 10
 bc2:	30 e0       	ldi	r19, 0x00	; 0
 bc4:	40 e0       	ldi	r20, 0x00	; 0
 bc6:	50 e0       	ldi	r21, 0x00	; 0
 bc8:	0e 94 a3 07 	call	0xf46	; 0xf46 <__divmodsi4>
 bcc:	e6 2f       	mov	r30, r22
 bce:	2a 8b       	std	Y+18, r18	; 0x12
 bd0:	3b 8b       	std	Y+19, r19	; 0x13
 bd2:	4c 8b       	std	Y+20, r20	; 0x14
 bd4:	5d 8b       	std	Y+21, r21	; 0x15
 bd6:	6a 89       	ldd	r22, Y+18	; 0x12
 bd8:	7b 89       	ldd	r23, Y+19	; 0x13
 bda:	8c 89       	ldd	r24, Y+20	; 0x14
 bdc:	9d 89       	ldd	r25, Y+21	; 0x15
          sline[i++] = qr.rem + '0';
 bde:	20 e3       	ldi	r18, 0x30	; 48
 be0:	2e 0f       	add	r18, r30
 be2:	f4 01       	movw	r30, r8
 be4:	21 93       	st	Z+, r18
 be6:	4f 01       	movw	r8, r30
        qr.quot = labs(qr.quot);
      }

      // convert the digits to the right of the decimal point 
      if (decpos){
        for (; decpos ; decpos--){
 be8:	6e 16       	cp	r6, r30
 bea:	7f 06       	cpc	r7, r31
 bec:	49 f7       	brne	.-46     	; 0xbc0 <lcd_int32+0x7a>
          qr = ldiv(qr.quot, 10);
          sline[i++] = qr.rem + '0';
        }
        sline[i++] = '.';
 bee:	99 24       	eor	r9, r9
 bf0:	93 94       	inc	r9
 bf2:	94 0c       	add	r9, r4
 bf4:	f5 01       	movw	r30, r10
 bf6:	e4 0d       	add	r30, r4
 bf8:	f1 1d       	adc	r31, r1
 bfa:	2e e2       	ldi	r18, 0x2E	; 46
 bfc:	20 83       	st	Z, r18
      }

      // convert the digits to the left of the decimal point 
      do{
          qr = ldiv(qr.quot, 10);
 bfe:	2a e0       	ldi	r18, 0x0A	; 10
 c00:	30 e0       	ldi	r19, 0x00	; 0
 c02:	40 e0       	ldi	r20, 0x00	; 0
 c04:	50 e0       	ldi	r21, 0x00	; 0
 c06:	0e 94 a3 07 	call	0xf46	; 0xf46 <__divmodsi4>
 c0a:	e6 2f       	mov	r30, r22
 c0c:	2a 8b       	std	Y+18, r18	; 0x12
 c0e:	3b 8b       	std	Y+19, r19	; 0x13
 c10:	4c 8b       	std	Y+20, r20	; 0x14
 c12:	5d 8b       	std	Y+21, r21	; 0x15
 c14:	6e 8b       	std	Y+22, r22	; 0x16
 c16:	7f 8b       	std	Y+23, r23	; 0x17
 c18:	88 8f       	std	Y+24, r24	; 0x18
 c1a:	99 8f       	std	Y+25, r25	; 0x19
 c1c:	6a 89       	ldd	r22, Y+18	; 0x12
 c1e:	7b 89       	ldd	r23, Y+19	; 0x13
 c20:	8c 89       	ldd	r24, Y+20	; 0x14
 c22:	9d 89       	ldd	r25, Y+21	; 0x15
          sline[i++] = qr.rem + '0';
 c24:	31 e0       	ldi	r19, 0x01	; 1
 c26:	39 0d       	add	r19, r9
 c28:	d5 01       	movw	r26, r10
 c2a:	a9 0d       	add	r26, r9
 c2c:	b1 1d       	adc	r27, r1
 c2e:	e0 5d       	subi	r30, 0xD0	; 208
 c30:	ec 93       	st	X, r30
 c32:	93 2e       	mov	r9, r19
        }while(qr.quot);
 c34:	61 15       	cp	r22, r1
 c36:	71 05       	cpc	r23, r1
 c38:	81 05       	cpc	r24, r1
 c3a:	91 05       	cpc	r25, r1
 c3c:	01 f7       	brne	.-64     	; 0xbfe <lcd_int32+0xb8>

      // fill the whole field if a width was specified
      if (fieldwidth){
 c3e:	11 23       	and	r17, r17
 c40:	61 f0       	breq	.+24     	; 0xc5a <lcd_int32+0x114>
        fillch = bZeroFill? '0': ' '; // determine the fill character
 c42:	51 10       	cpse	r5, r1
 c44:	4b c0       	rjmp	.+150    	; 0xcdc <lcd_int32+0x196>
 c46:	90 e2       	ldi	r25, 0x20	; 32
        for (; i<fieldwidth ; ){sline[i++] = fillch;}
 c48:	31 17       	cp	r19, r17
 c4a:	38 f4       	brcc	.+14     	; 0xc5a <lcd_int32+0x114>
 c4c:	f5 01       	movw	r30, r10
 c4e:	e3 0f       	add	r30, r19
 c50:	f1 1d       	adc	r31, r1
 c52:	90 83       	st	Z, r25
 c54:	3f 5f       	subi	r19, 0xFF	; 255
 c56:	13 13       	cpse	r17, r19
 c58:	f9 cf       	rjmp	.-14     	; 0xc4c <lcd_int32+0x106>
      }

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}
 c5a:	00 23       	and	r16, r16
 c5c:	31 f0       	breq	.+12     	; 0xc6a <lcd_int32+0x124>
 c5e:	f5 01       	movw	r30, r10
 c60:	e3 0f       	add	r30, r19
 c62:	f1 1d       	adc	r31, r1
 c64:	9d e2       	ldi	r25, 0x2D	; 45
 c66:	90 83       	st	Z, r25
 c68:	3f 5f       	subi	r19, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 c6a:	21 e0       	ldi	r18, 0x01	; 1

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}

      // now output the formatted number
      do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
 c6c:	31 50       	subi	r19, 0x01	; 1
 c6e:	f5 01       	movw	r30, r10
 c70:	e3 0f       	add	r30, r19
 c72:	f1 1d       	adc	r31, r1
 c74:	90 81       	ld	r25, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 c76:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 c78:	77 9b       	sbis	0x0e, 7	; 14
 c7a:	fe cf       	rjmp	.-4      	; 0xc78 <lcd_int32+0x132>
  SPDR = byte;                        //send payload
 c7c:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 c7e:	77 9b       	sbis	0x0e, 7	; 14
 c80:	fe cf       	rjmp	.-4      	; 0xc7e <lcd_int32+0x138>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 c82:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 c86:	98 60       	ori	r25, 0x08	; 8
 c88:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 c8c:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 c90:	97 7f       	andi	r25, 0xF7	; 247
 c92:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 c96:	85 ed       	ldi	r24, 0xD5	; 213
 c98:	8a 95       	dec	r24
 c9a:	f1 f7       	brne	.-4      	; 0xc98 <lcd_int32+0x152>
 c9c:	00 00       	nop

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}

      // now output the formatted number
      do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
 c9e:	31 11       	cpse	r19, r1
 ca0:	e5 cf       	rjmp	.-54     	; 0xc6c <lcd_int32+0x126>

}
 ca2:	69 96       	adiw	r28, 0x19	; 25
 ca4:	0f b6       	in	r0, 0x3f	; 63
 ca6:	f8 94       	cli
 ca8:	de bf       	out	0x3e, r29	; 62
 caa:	0f be       	out	0x3f, r0	; 63
 cac:	cd bf       	out	0x3d, r28	; 61
 cae:	df 91       	pop	r29
 cb0:	cf 91       	pop	r28
 cb2:	1f 91       	pop	r17
 cb4:	0f 91       	pop	r16
 cb6:	ff 90       	pop	r15
 cb8:	ef 90       	pop	r14
 cba:	df 90       	pop	r13
 cbc:	cf 90       	pop	r12
 cbe:	bf 90       	pop	r11
 cc0:	af 90       	pop	r10
 cc2:	9f 90       	pop	r9
 cc4:	8f 90       	pop	r8
 cc6:	7f 90       	pop	r7
 cc8:	6f 90       	pop	r6
 cca:	5f 90       	pop	r5
 ccc:	4f 90       	pop	r4
 cce:	08 95       	ret
                uint8_t decpos,     //0 if no decimal point, otherwise
                uint8_t bSigned,    //non-zero if the number should be treated as signed 
                uint8_t bZeroFill)  //non-zero if a specified fieldwidth is to be zero filled
{
      char    sline[NUM_LCD_CHARS+1];
      uint8_t i=0;
 cd0:	91 2c       	mov	r9, r1
 cd2:	9e 01       	movw	r18, r28
 cd4:	2f 5f       	subi	r18, 0xFF	; 255
 cd6:	3f 4f       	sbci	r19, 0xFF	; 255
 cd8:	59 01       	movw	r10, r18
 cda:	91 cf       	rjmp	.-222    	; 0xbfe <lcd_int32+0xb8>
          sline[i++] = qr.rem + '0';
        }while(qr.quot);

      // fill the whole field if a width was specified
      if (fieldwidth){
        fillch = bZeroFill? '0': ' '; // determine the fill character
 cdc:	90 e3       	ldi	r25, 0x30	; 48
 cde:	b4 cf       	rjmp	.-152    	; 0xc48 <lcd_int32+0x102>

      qr.quot = l; // initialize the quotient 

      if (bSigned){
        bSigned = (qr.quot<0);
        qr.quot = labs(qr.quot);
 ce0:	f0 94       	com	r15
 ce2:	e0 94       	com	r14
 ce4:	d0 94       	com	r13
 ce6:	c0 94       	com	r12
 ce8:	c1 1c       	adc	r12, r1
 cea:	d1 1c       	adc	r13, r1
 cec:	e1 1c       	adc	r14, r1
 cee:	f1 1c       	adc	r15, r1
 cf0:	54 cf       	rjmp	.-344    	; 0xb9a <lcd_int32+0x54>

00000cf2 <lcd_int16>:
void    lcd_int16(int16_t l, 
                  uint8_t fieldwidth, 
                  uint8_t decpos, 
                  uint8_t bSigned,
                  uint8_t bZeroFill)
{
 cf2:	5f 92       	push	r5
 cf4:	6f 92       	push	r6
 cf6:	7f 92       	push	r7
 cf8:	8f 92       	push	r8
 cfa:	9f 92       	push	r9
 cfc:	af 92       	push	r10
 cfe:	bf 92       	push	r11
 d00:	cf 92       	push	r12
 d02:	df 92       	push	r13
 d04:	ef 92       	push	r14
 d06:	ff 92       	push	r15
 d08:	0f 93       	push	r16
 d0a:	1f 93       	push	r17
 d0c:	cf 93       	push	r28
 d0e:	df 93       	push	r29
 d10:	cd b7       	in	r28, 0x3d	; 61
 d12:	de b7       	in	r29, 0x3e	; 62
 d14:	61 97       	sbiw	r28, 0x11	; 17
 d16:	0f b6       	in	r0, 0x3f	; 63
 d18:	f8 94       	cli
 d1a:	de bf       	out	0x3e, r29	; 62
 d1c:	0f be       	out	0x3f, r0	; 63
 d1e:	cd bf       	out	0x3d, r28	; 61
 d20:	5c 01       	movw	r10, r24
 d22:	16 2f       	mov	r17, r22
 d24:	74 2e       	mov	r7, r20
//        uint8_t bSigned;   Now an argument for signed or not

        // initialize the quotient 
        qr.quot = l;

        if ( (bSigned=(qr.quot<0)) )
 d26:	6b 2c       	mov	r6, r11
 d28:	66 1c       	adc	r6, r6
 d2a:	66 24       	eor	r6, r6
 d2c:	66 1c       	adc	r6, r6
 d2e:	56 2c       	mov	r5, r6
 d30:	9c 01       	movw	r18, r24
 d32:	97 fd       	sbrc	r25, 7
 d34:	9b c0       	rjmp	.+310    	; 0xe6c <lcd_int16+0x17a>
                qr.quot = -qr.quot;

        // convert the digits to the right of the decimal point 
        if (decpos){
 d36:	77 20       	and	r7, r7
 d38:	09 f4       	brne	.+2      	; 0xd3c <lcd_int16+0x4a>
 d3a:	8d c0       	rjmp	.+282    	; 0xe56 <lcd_int16+0x164>
 d3c:	ce 01       	movw	r24, r28
 d3e:	01 96       	adiw	r24, 0x01	; 1
 d40:	7c 01       	movw	r14, r24
 d42:	6c 01       	movw	r12, r24
 d44:	88 24       	eor	r8, r8
 d46:	8a 94       	dec	r8
 d48:	87 0c       	add	r8, r7
 d4a:	91 2c       	mov	r9, r1
 d4c:	9f ef       	ldi	r25, 0xFF	; 255
 d4e:	89 1a       	sub	r8, r25
 d50:	99 0a       	sbc	r9, r25
 d52:	8e 0c       	add	r8, r14
 d54:	9f 1c       	adc	r9, r15
          for (; decpos ; decpos--){
            qr = div(qr.quot, 10);
 d56:	6a e0       	ldi	r22, 0x0A	; 10
 d58:	70 e0       	ldi	r23, 0x00	; 0
 d5a:	c9 01       	movw	r24, r18
 d5c:	0e 94 8f 07 	call	0xf1e	; 0xf1e <__divmodhi4>
 d60:	46 2f       	mov	r20, r22
 d62:	24 2f       	mov	r18, r20
 d64:	37 2f       	mov	r19, r23
            sline[i++] = qr.rem + '0';
 d66:	80 5d       	subi	r24, 0xD0	; 208
 d68:	f6 01       	movw	r30, r12
 d6a:	81 93       	st	Z+, r24
 d6c:	6f 01       	movw	r12, r30
        if ( (bSigned=(qr.quot<0)) )
                qr.quot = -qr.quot;

        // convert the digits to the right of the decimal point 
        if (decpos){
          for (; decpos ; decpos--){
 d6e:	e8 15       	cp	r30, r8
 d70:	f9 05       	cpc	r31, r9
 d72:	89 f7       	brne	.-30     	; 0xd56 <lcd_int16+0x64>
            qr = div(qr.quot, 10);
            sline[i++] = qr.rem + '0';
          }
          sline[i++] = '.';
 d74:	dd 24       	eor	r13, r13
 d76:	d3 94       	inc	r13
 d78:	d7 0c       	add	r13, r7
 d7a:	f7 01       	movw	r30, r14
 d7c:	e7 0d       	add	r30, r7
 d7e:	f1 1d       	adc	r31, r1
 d80:	8e e2       	ldi	r24, 0x2E	; 46
 d82:	80 83       	st	Z, r24
 d84:	01 c0       	rjmp	.+2      	; 0xd88 <lcd_int16+0x96>

        // convert the digits to the left of the decimal point 
        do
        {
                qr = div(qr.quot, 10);
                sline[i++] = qr.rem + '0';
 d86:	d9 2e       	mov	r13, r25
        }

        // convert the digits to the left of the decimal point 
        do
        {
                qr = div(qr.quot, 10);
 d88:	6a e0       	ldi	r22, 0x0A	; 10
 d8a:	70 e0       	ldi	r23, 0x00	; 0
 d8c:	c9 01       	movw	r24, r18
 d8e:	0e 94 8f 07 	call	0xf1e	; 0xf1e <__divmodhi4>
 d92:	46 2f       	mov	r20, r22
 d94:	24 2f       	mov	r18, r20
 d96:	37 2f       	mov	r19, r23
                sline[i++] = qr.rem + '0';
 d98:	91 e0       	ldi	r25, 0x01	; 1
 d9a:	9d 0d       	add	r25, r13
 d9c:	f7 01       	movw	r30, r14
 d9e:	ed 0d       	add	r30, r13
 da0:	f1 1d       	adc	r31, r1
 da2:	80 5d       	subi	r24, 0xD0	; 208
 da4:	80 83       	st	Z, r24
        }
        while(qr.quot);
 da6:	21 15       	cp	r18, r1
 da8:	31 05       	cpc	r19, r1
 daa:	69 f7       	brne	.-38     	; 0xd86 <lcd_int16+0x94>

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
 dac:	01 11       	cpse	r16, r1
 dae:	58 c0       	rjmp	.+176    	; 0xe60 <lcd_int16+0x16e>
 db0:	b7 fc       	sbrc	r11, 7
 db2:	61 c0       	rjmp	.+194    	; 0xe76 <lcd_int16+0x184>
                sline[i++] = '-';
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
 db4:	11 23       	and	r17, r17
 db6:	a9 f0       	breq	.+42     	; 0xde2 <lcd_int16+0xf0>
 db8:	71 2c       	mov	r7, r1
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
 dba:	80 e2       	ldi	r24, 0x20	; 32
          for (; i<(fieldwidth-bSigned) ; ){ sline[i++] = fillch;}
 dbc:	29 2f       	mov	r18, r25
 dbe:	30 e0       	ldi	r19, 0x00	; 0
 dc0:	41 2f       	mov	r20, r17
 dc2:	50 e0       	ldi	r21, 0x00	; 0
 dc4:	46 19       	sub	r20, r6
 dc6:	57 09       	sbc	r21, r7
 dc8:	24 17       	cp	r18, r20
 dca:	35 07       	cpc	r19, r21
 dcc:	54 f4       	brge	.+20     	; 0xde2 <lcd_int16+0xf0>
 dce:	9f 5f       	subi	r25, 0xFF	; 255
 dd0:	f7 01       	movw	r30, r14
 dd2:	e2 0f       	add	r30, r18
 dd4:	f3 1f       	adc	r31, r19
 dd6:	80 83       	st	Z, r24
 dd8:	29 2f       	mov	r18, r25
 dda:	30 e0       	ldi	r19, 0x00	; 0
 ddc:	24 17       	cp	r18, r20
 dde:	35 07       	cpc	r19, r21
 de0:	b4 f3       	brlt	.-20     	; 0xdce <lcd_int16+0xdc>
        }

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}
 de2:	55 20       	and	r5, r5
 de4:	31 f0       	breq	.+12     	; 0xdf2 <lcd_int16+0x100>
 de6:	f7 01       	movw	r30, r14
 de8:	e9 0f       	add	r30, r25
 dea:	f1 1d       	adc	r31, r1
 dec:	8d e2       	ldi	r24, 0x2D	; 45
 dee:	80 83       	st	Z, r24
 df0:	9f 5f       	subi	r25, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 df2:	21 e0       	ldi	r18, 0x01	; 1

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}

        // now output the formatted number 
            do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
 df4:	91 50       	subi	r25, 0x01	; 1
 df6:	f7 01       	movw	r30, r14
 df8:	e9 0f       	add	r30, r25
 dfa:	f1 1d       	adc	r31, r1
 dfc:	80 81       	ld	r24, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
 dfe:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 e00:	77 9b       	sbis	0x0e, 7	; 14
 e02:	fe cf       	rjmp	.-4      	; 0xe00 <lcd_int16+0x10e>
  SPDR = byte;                        //send payload
 e04:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
 e06:	77 9b       	sbis	0x0e, 7	; 14
 e08:	fe cf       	rjmp	.-4      	; 0xe06 <lcd_int16+0x114>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
 e0a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 e0e:	88 60       	ori	r24, 0x08	; 8
 e10:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 e14:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 e18:	87 7f       	andi	r24, 0xF7	; 247
 e1a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
 e1e:	e5 ed       	ldi	r30, 0xD5	; 213
 e20:	ea 95       	dec	r30
 e22:	f1 f7       	brne	.-4      	; 0xe20 <lcd_int16+0x12e>
 e24:	00 00       	nop

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}

        // now output the formatted number 
            do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
 e26:	91 11       	cpse	r25, r1
 e28:	e5 cf       	rjmp	.-54     	; 0xdf4 <lcd_int16+0x102>
}
 e2a:	61 96       	adiw	r28, 0x11	; 17
 e2c:	0f b6       	in	r0, 0x3f	; 63
 e2e:	f8 94       	cli
 e30:	de bf       	out	0x3e, r29	; 62
 e32:	0f be       	out	0x3f, r0	; 63
 e34:	cd bf       	out	0x3d, r28	; 61
 e36:	df 91       	pop	r29
 e38:	cf 91       	pop	r28
 e3a:	1f 91       	pop	r17
 e3c:	0f 91       	pop	r16
 e3e:	ff 90       	pop	r15
 e40:	ef 90       	pop	r14
 e42:	df 90       	pop	r13
 e44:	cf 90       	pop	r12
 e46:	bf 90       	pop	r11
 e48:	af 90       	pop	r10
 e4a:	9f 90       	pop	r9
 e4c:	8f 90       	pop	r8
 e4e:	7f 90       	pop	r7
 e50:	6f 90       	pop	r6
 e52:	5f 90       	pop	r5
 e54:	08 95       	ret
                  uint8_t decpos, 
                  uint8_t bSigned,
                  uint8_t bZeroFill)
{
        char    sline[NUM_LCD_CHARS+1];
        uint8_t i=0;
 e56:	d1 2c       	mov	r13, r1
 e58:	ce 01       	movw	r24, r28
 e5a:	01 96       	adiw	r24, 0x01	; 1
 e5c:	7c 01       	movw	r14, r24
 e5e:	94 cf       	rjmp	.-216    	; 0xd88 <lcd_int16+0x96>
                sline[i++] = '-';
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
 e60:	11 23       	and	r17, r17
 e62:	09 f4       	brne	.+2      	; 0xe66 <lcd_int16+0x174>
 e64:	be cf       	rjmp	.-132    	; 0xde2 <lcd_int16+0xf0>
 e66:	71 2c       	mov	r7, r1
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
 e68:	80 e3       	ldi	r24, 0x30	; 48
 e6a:	a8 cf       	rjmp	.-176    	; 0xdbc <lcd_int16+0xca>
 e6c:	22 27       	eor	r18, r18
 e6e:	33 27       	eor	r19, r19
 e70:	28 1b       	sub	r18, r24
 e72:	39 0b       	sbc	r19, r25
 e74:	60 cf       	rjmp	.-320    	; 0xd36 <lcd_int16+0x44>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
 e76:	d3 94       	inc	r13
 e78:	d3 94       	inc	r13
 e7a:	f7 01       	movw	r30, r14
 e7c:	e9 0f       	add	r30, r25
 e7e:	f1 1d       	adc	r31, r1
 e80:	8d e2       	ldi	r24, 0x2D	; 45
 e82:	80 83       	st	Z, r24
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
 e84:	11 23       	and	r17, r17
 e86:	59 f0       	breq	.+22     	; 0xe9e <lcd_int16+0x1ac>
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
          for (; i<(fieldwidth-bSigned) ; ){ sline[i++] = fillch;}
 e88:	2d 2d       	mov	r18, r13
 e8a:	30 e0       	ldi	r19, 0x00	; 0
 e8c:	41 2f       	mov	r20, r17
 e8e:	50 e0       	ldi	r21, 0x00	; 0
 e90:	24 17       	cp	r18, r20
 e92:	35 07       	cpc	r19, r21
 e94:	24 f4       	brge	.+8      	; 0xe9e <lcd_int16+0x1ac>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
 e96:	9d 2d       	mov	r25, r13
                bSigned = 0;
 e98:	51 2c       	mov	r5, r1
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
 e9a:	80 e2       	ldi	r24, 0x20	; 32
 e9c:	98 cf       	rjmp	.-208    	; 0xdce <lcd_int16+0xdc>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
 e9e:	9d 2d       	mov	r25, r13
 ea0:	a8 cf       	rjmp	.-176    	; 0xdf2 <lcd_int16+0x100>

00000ea2 <main>:
	and while loop are defined. The LED display is updated continuously 
	in the loop.
Parameters: NA
**********************************************************************/
int main() {
   ASSR |= (1<<AS0);
 ea2:	80 b7       	in	r24, 0x30	; 48
 ea4:	88 60       	ori	r24, 0x08	; 8
 ea6:	80 bf       	out	0x30, r24	; 48
   TIMSK |= (1<<TOIE0);			//enable interrupts
 ea8:	87 b7       	in	r24, 0x37	; 55
 eaa:	81 60       	ori	r24, 0x01	; 1
 eac:	87 bf       	out	0x37, r24	; 55
   TCCR0 |= (1<<CS00);			//normal mode, no prescale
 eae:	83 b7       	in	r24, 0x33	; 51
 eb0:	81 60       	ori	r24, 0x01	; 1
 eb2:	83 bf       	out	0x33, r24	; 51
//   TIMSK
//   ETMISK
//   TIFR
//   TCNT1 = 0x00; 		//Initialize TNCT1 to 0

   DDRC |= 0xFF; 
 eb4:	84 b3       	in	r24, 0x14	; 20
 eb6:	9f ef       	ldi	r25, 0xFF	; 255
 eb8:	94 bb       	out	0x14, r25	; 20
   DDRB |= 0xF0;				//PB4-6 is SEL0-2, PB7 is PWM
 eba:	87 b3       	in	r24, 0x17	; 23
 ebc:	80 6f       	ori	r24, 0xF0	; 240
 ebe:	87 bb       	out	0x17, r24	; 23
   DDRE |= 0x40;				//PE6 is SHIFT_LD_N
 ec0:	16 9a       	sbi	0x02, 6	; 2
   DDRD |= 0x0B;				//PE1 is CLK_INH and PE2 is SRCLK
 ec2:	81 b3       	in	r24, 0x11	; 17
 ec4:	8b 60       	ori	r24, 0x0B	; 11
 ec6:	81 bb       	out	0x11, r24	; 17
   PORTC |= 0x00;
 ec8:	85 b3       	in	r24, 0x15	; 21
 eca:	85 bb       	out	0x15, r24	; 21
   PORTD |= 0x02;
 ecc:	91 9a       	sbi	0x12, 1	; 18
   PORTE |= 0xFF;
 ece:	83 b1       	in	r24, 0x03	; 3
 ed0:	93 b9       	out	0x03, r25	; 3
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
 ed2:	87 b3       	in	r24, 0x17	; 23
 ed4:	87 60       	ori	r24, 0x07	; 7
 ed6:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
 ed8:	8d b1       	in	r24, 0x0d	; 13
 eda:	8c 65       	ori	r24, 0x5C	; 92
 edc:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
 ede:	70 9a       	sbi	0x0e, 0	; 14
   PORTD |= 0x02;
   PORTE |= 0xFF;

   spi_init();				//Initalize SPI

   sei();				//Enable interrupts
 ee0:	78 94       	sei
   
   while(1){
      clock_time();
 ee2:	0e 94 0c 02 	call	0x418	; 0x418 <clock_time>
 ee6:	e8 e1       	ldi	r30, 0x18	; 24
 ee8:	f1 e0       	ldi	r31, 0x01	; 1
 eea:	80 e0       	ldi	r24, 0x00	; 0

      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
         if(alarm){
 eec:	90 91 22 01 	lds	r25, 0x0122	; 0x800122 <alarm>
 ef0:	99 23       	and	r25, r25
 ef2:	29 f0       	breq	.+10     	; 0xefe <main+0x5c>
	    segment_data[2] &= 0b011;
 ef4:	90 91 1a 01 	lds	r25, 0x011A	; 0x80011a <__data_end+0x2>
 ef8:	93 70       	andi	r25, 0x03	; 3
 efa:	90 93 1a 01 	sts	0x011A, r25	; 0x80011a <__data_end+0x2>
	 }
	 PORTA = segment_data[j];	//Writes the segment data to PORTA aka the segments
 efe:	91 91       	ld	r25, Z+
 f00:	9b bb       	out	0x1b, r25	; 27
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
 f02:	98 2f       	mov	r25, r24
 f04:	92 95       	swap	r25
 f06:	90 7f       	andi	r25, 0xF0	; 240
 f08:	98 bb       	out	0x18, r25	; 24
 f0a:	af e1       	ldi	r26, 0x1F	; 31
 f0c:	b3 e0       	ldi	r27, 0x03	; 3
 f0e:	11 97       	sbiw	r26, 0x01	; 1
 f10:	f1 f7       	brne	.-4      	; 0xf0e <main+0x6c>
 f12:	00 c0       	rjmp	.+0      	; 0xf14 <main+0x72>
 f14:	00 00       	nop
 f16:	8f 5f       	subi	r24, 0xFF	; 255
   sei();				//Enable interrupts
   
   while(1){
      clock_time();

      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
 f18:	85 30       	cpi	r24, 0x05	; 5
 f1a:	41 f7       	brne	.-48     	; 0xeec <main+0x4a>
 f1c:	e2 cf       	rjmp	.-60     	; 0xee2 <main+0x40>

00000f1e <__divmodhi4>:
 f1e:	97 fb       	bst	r25, 7
 f20:	07 2e       	mov	r0, r23
 f22:	16 f4       	brtc	.+4      	; 0xf28 <__divmodhi4+0xa>
 f24:	00 94       	com	r0
 f26:	07 d0       	rcall	.+14     	; 0xf36 <__divmodhi4_neg1>
 f28:	77 fd       	sbrc	r23, 7
 f2a:	09 d0       	rcall	.+18     	; 0xf3e <__divmodhi4_neg2>
 f2c:	0e 94 c2 07 	call	0xf84	; 0xf84 <__udivmodhi4>
 f30:	07 fc       	sbrc	r0, 7
 f32:	05 d0       	rcall	.+10     	; 0xf3e <__divmodhi4_neg2>
 f34:	3e f4       	brtc	.+14     	; 0xf44 <__divmodhi4_exit>

00000f36 <__divmodhi4_neg1>:
 f36:	90 95       	com	r25
 f38:	81 95       	neg	r24
 f3a:	9f 4f       	sbci	r25, 0xFF	; 255
 f3c:	08 95       	ret

00000f3e <__divmodhi4_neg2>:
 f3e:	70 95       	com	r23
 f40:	61 95       	neg	r22
 f42:	7f 4f       	sbci	r23, 0xFF	; 255

00000f44 <__divmodhi4_exit>:
 f44:	08 95       	ret

00000f46 <__divmodsi4>:
 f46:	05 2e       	mov	r0, r21
 f48:	97 fb       	bst	r25, 7
 f4a:	1e f4       	brtc	.+6      	; 0xf52 <__divmodsi4+0xc>
 f4c:	00 94       	com	r0
 f4e:	0e 94 ba 07 	call	0xf74	; 0xf74 <__negsi2>
 f52:	57 fd       	sbrc	r21, 7
 f54:	07 d0       	rcall	.+14     	; 0xf64 <__divmodsi4_neg2>
 f56:	0e 94 d6 07 	call	0xfac	; 0xfac <__udivmodsi4>
 f5a:	07 fc       	sbrc	r0, 7
 f5c:	03 d0       	rcall	.+6      	; 0xf64 <__divmodsi4_neg2>
 f5e:	4e f4       	brtc	.+18     	; 0xf72 <__divmodsi4_exit>
 f60:	0c 94 ba 07 	jmp	0xf74	; 0xf74 <__negsi2>

00000f64 <__divmodsi4_neg2>:
 f64:	50 95       	com	r21
 f66:	40 95       	com	r20
 f68:	30 95       	com	r19
 f6a:	21 95       	neg	r18
 f6c:	3f 4f       	sbci	r19, 0xFF	; 255
 f6e:	4f 4f       	sbci	r20, 0xFF	; 255
 f70:	5f 4f       	sbci	r21, 0xFF	; 255

00000f72 <__divmodsi4_exit>:
 f72:	08 95       	ret

00000f74 <__negsi2>:
 f74:	90 95       	com	r25
 f76:	80 95       	com	r24
 f78:	70 95       	com	r23
 f7a:	61 95       	neg	r22
 f7c:	7f 4f       	sbci	r23, 0xFF	; 255
 f7e:	8f 4f       	sbci	r24, 0xFF	; 255
 f80:	9f 4f       	sbci	r25, 0xFF	; 255
 f82:	08 95       	ret

00000f84 <__udivmodhi4>:
 f84:	aa 1b       	sub	r26, r26
 f86:	bb 1b       	sub	r27, r27
 f88:	51 e1       	ldi	r21, 0x11	; 17
 f8a:	07 c0       	rjmp	.+14     	; 0xf9a <__udivmodhi4_ep>

00000f8c <__udivmodhi4_loop>:
 f8c:	aa 1f       	adc	r26, r26
 f8e:	bb 1f       	adc	r27, r27
 f90:	a6 17       	cp	r26, r22
 f92:	b7 07       	cpc	r27, r23
 f94:	10 f0       	brcs	.+4      	; 0xf9a <__udivmodhi4_ep>
 f96:	a6 1b       	sub	r26, r22
 f98:	b7 0b       	sbc	r27, r23

00000f9a <__udivmodhi4_ep>:
 f9a:	88 1f       	adc	r24, r24
 f9c:	99 1f       	adc	r25, r25
 f9e:	5a 95       	dec	r21
 fa0:	a9 f7       	brne	.-22     	; 0xf8c <__udivmodhi4_loop>
 fa2:	80 95       	com	r24
 fa4:	90 95       	com	r25
 fa6:	bc 01       	movw	r22, r24
 fa8:	cd 01       	movw	r24, r26
 faa:	08 95       	ret

00000fac <__udivmodsi4>:
 fac:	a1 e2       	ldi	r26, 0x21	; 33
 fae:	1a 2e       	mov	r1, r26
 fb0:	aa 1b       	sub	r26, r26
 fb2:	bb 1b       	sub	r27, r27
 fb4:	fd 01       	movw	r30, r26
 fb6:	0d c0       	rjmp	.+26     	; 0xfd2 <__udivmodsi4_ep>

00000fb8 <__udivmodsi4_loop>:
 fb8:	aa 1f       	adc	r26, r26
 fba:	bb 1f       	adc	r27, r27
 fbc:	ee 1f       	adc	r30, r30
 fbe:	ff 1f       	adc	r31, r31
 fc0:	a2 17       	cp	r26, r18
 fc2:	b3 07       	cpc	r27, r19
 fc4:	e4 07       	cpc	r30, r20
 fc6:	f5 07       	cpc	r31, r21
 fc8:	20 f0       	brcs	.+8      	; 0xfd2 <__udivmodsi4_ep>
 fca:	a2 1b       	sub	r26, r18
 fcc:	b3 0b       	sbc	r27, r19
 fce:	e4 0b       	sbc	r30, r20
 fd0:	f5 0b       	sbc	r31, r21

00000fd2 <__udivmodsi4_ep>:
 fd2:	66 1f       	adc	r22, r22
 fd4:	77 1f       	adc	r23, r23
 fd6:	88 1f       	adc	r24, r24
 fd8:	99 1f       	adc	r25, r25
 fda:	1a 94       	dec	r1
 fdc:	69 f7       	brne	.-38     	; 0xfb8 <__udivmodsi4_loop>
 fde:	60 95       	com	r22
 fe0:	70 95       	com	r23
 fe2:	80 95       	com	r24
 fe4:	90 95       	com	r25
 fe6:	9b 01       	movw	r18, r22
 fe8:	ac 01       	movw	r20, r24
 fea:	bd 01       	movw	r22, r26
 fec:	cf 01       	movw	r24, r30
 fee:	08 95       	ret

00000ff0 <_exit>:
 ff0:	f8 94       	cli

00000ff2 <__stop_program>:
 ff2:	ff cf       	rjmp	.-2      	; 0xff2 <__stop_program>
