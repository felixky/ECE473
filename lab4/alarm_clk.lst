
alarm_clk.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00800100  0000100e  000010a2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000100e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000054  00800116  00800116  000010b8  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000010b8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000010e8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000048  00000000  00000000  00001124  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001f1d  00000000  00000000  0000116c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c79  00000000  00000000  00003089  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000d6e  00000000  00000000  00003d02  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000002ec  00000000  00000000  00004a70  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000005f8  00000000  00000000  00004d5c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000018bc  00000000  00000000  00005354  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000098  00000000  00000000  00006c10  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      40:	0c 94 e3 01 	jmp	0x3c6	; 0x3c6 <__vector_16>
      44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	11 e0       	ldi	r17, 0x01	; 1
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	ee e0       	ldi	r30, 0x0E	; 14
      a0:	f0 e1       	ldi	r31, 0x10	; 16
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	a6 31       	cpi	r26, 0x16	; 22
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	21 e0       	ldi	r18, 0x01	; 1
      b4:	a6 e1       	ldi	r26, 0x16	; 22
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	aa 36       	cpi	r26, 0x6A	; 106
      be:	b2 07       	cpc	r27, r18
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	0e 94 5e 07 	call	0xebc	; 0xebc <main>
      c6:	0c 94 05 08 	jmp	0x100a	; 0x100a <_exit>

000000ca <__bad_interrupt>:
      ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <spi_init>:
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
      ce:	87 b3       	in	r24, 0x17	; 23
      d0:	87 60       	ori	r24, 0x07	; 7
      d2:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
      d4:	8d b1       	in	r24, 0x0d	; 13
      d6:	8c 65       	ori	r24, 0x5C	; 92
      d8:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
      da:	70 9a       	sbi	0x0e, 0	; 14
      dc:	08 95       	ret

000000de <spi_read>:
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
      de:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
      e0:	77 9b       	sbis	0x0e, 7	; 14
      e2:	fe cf       	rjmp	.-4      	; 0xe0 <spi_read+0x2>
   return SPDR;
      e4:	8f b1       	in	r24, 0x0f	; 15
}
      e6:	08 95       	ret

000000e8 <chk_buttons>:
	be implemented at the same time. Adapted to check all buttons from 
	Ganssel's "Guide to Debouncing" Expects active low pushbuttons on PINA 
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
      e8:	48 2f       	mov	r20, r24
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
      ea:	e8 2f       	mov	r30, r24
      ec:	f0 e0       	ldi	r31, 0x00	; 0
      ee:	99 b3       	in	r25, 0x19	; 25
      f0:	ee 0f       	add	r30, r30
      f2:	ff 1f       	adc	r31, r31
      f4:	e9 5d       	subi	r30, 0xD9	; 217
      f6:	fe 4f       	sbci	r31, 0xFE	; 254
      f8:	20 81       	ld	r18, Z
      fa:	31 81       	ldd	r19, Z+1	; 0x01
      fc:	22 0f       	add	r18, r18
      fe:	33 1f       	adc	r19, r19
     100:	30 6e       	ori	r19, 0xE0	; 224
     102:	89 2f       	mov	r24, r25
     104:	90 e0       	ldi	r25, 0x00	; 0
     106:	02 c0       	rjmp	.+4      	; 0x10c <chk_buttons+0x24>
     108:	95 95       	asr	r25
     10a:	87 95       	ror	r24
     10c:	4a 95       	dec	r20
     10e:	e2 f7       	brpl	.-8      	; 0x108 <chk_buttons+0x20>
     110:	81 70       	andi	r24, 0x01	; 1
     112:	99 27       	eor	r25, r25
     114:	28 2b       	or	r18, r24
     116:	39 2b       	or	r19, r25
     118:	31 83       	std	Z+1, r19	; 0x01
     11a:	20 83       	st	Z, r18
     11c:	81 e0       	ldi	r24, 0x01	; 1
     11e:	21 15       	cp	r18, r1
     120:	30 4f       	sbci	r19, 0xF0	; 240
     122:	09 f0       	breq	.+2      	; 0x126 <chk_buttons+0x3e>
     124:	80 e0       	ldi	r24, 0x00	; 0
  if (state[button] == 0xF000)
    return 1;
return 0;
}
     126:	08 95       	ret

00000128 <bars>:
Description:This function reads in the button board and updates the 
	LEDs on the bargraph through the serial port.
Parameters: NA
**********************************************************************/
void bars() {
   DDRA = 0x00;				//Set all as inputs
     128:	1a ba       	out	0x1a, r1	; 26
   PORTA = 0xFF;			//Pull up resistors
     12a:	8f ef       	ldi	r24, 0xFF	; 255
     12c:	8b bb       	out	0x1b, r24	; 27
   PORTB |= PINB | 0x70;		//Enable tristate buffer
     12e:	86 b3       	in	r24, 0x16	; 22
     130:	98 b3       	in	r25, 0x18	; 24
     132:	80 67       	ori	r24, 0x70	; 112
     134:	89 2b       	or	r24, r25
     136:	88 bb       	out	0x18, r24	; 24
     138:	e7 e2       	ldi	r30, 0x27	; 39
     13a:	f1 e0       	ldi	r31, 0x01	; 1

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     13c:	20 e0       	ldi	r18, 0x00	; 0
     13e:	30 e0       	ldi	r19, 0x00	; 0
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
     140:	61 e0       	ldi	r22, 0x01	; 1
     142:	70 e0       	ldi	r23, 0x00	; 0
     144:	05 c0       	rjmp	.+10     	; 0x150 <bars+0x28>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     146:	2f 5f       	subi	r18, 0xFF	; 255
     148:	3f 4f       	sbci	r19, 0xFF	; 255
     14a:	28 30       	cpi	r18, 0x08	; 8
     14c:	31 05       	cpc	r19, r1
     14e:	39 f1       	breq	.+78     	; 0x19e <bars+0x76>
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
     150:	99 b3       	in	r25, 0x19	; 25
     152:	40 81       	ld	r20, Z
     154:	51 81       	ldd	r21, Z+1	; 0x01
     156:	44 0f       	add	r20, r20
     158:	55 1f       	adc	r21, r21
     15a:	89 2f       	mov	r24, r25
     15c:	90 e0       	ldi	r25, 0x00	; 0
     15e:	02 2e       	mov	r0, r18
     160:	02 c0       	rjmp	.+4      	; 0x166 <bars+0x3e>
     162:	95 95       	asr	r25
     164:	87 95       	ror	r24
     166:	0a 94       	dec	r0
     168:	e2 f7       	brpl	.-8      	; 0x162 <bars+0x3a>
     16a:	81 70       	andi	r24, 0x01	; 1
     16c:	99 27       	eor	r25, r25
     16e:	84 2b       	or	r24, r20
     170:	95 2b       	or	r25, r21
     172:	90 6e       	ori	r25, 0xE0	; 224
     174:	81 93       	st	Z+, r24
     176:	91 93       	st	Z+, r25
  if (state[button] == 0xF000)
     178:	81 15       	cp	r24, r1
     17a:	90 4f       	sbci	r25, 0xF0	; 240
     17c:	21 f7       	brne	.-56     	; 0x146 <bars+0x1e>
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
     17e:	cb 01       	movw	r24, r22
     180:	02 2e       	mov	r0, r18
     182:	02 c0       	rjmp	.+4      	; 0x188 <bars+0x60>
     184:	88 0f       	add	r24, r24
     186:	99 1f       	adc	r25, r25
     188:	0a 94       	dec	r0
     18a:	e2 f7       	brpl	.-8      	; 0x184 <bars+0x5c>
     18c:	90 93 20 01 	sts	0x0120, r25	; 0x800120 <mult+0x1>
     190:	80 93 1f 01 	sts	0x011F, r24	; 0x80011f <mult>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     194:	2f 5f       	subi	r18, 0xFF	; 255
     196:	3f 4f       	sbci	r19, 0xFF	; 255
     198:	28 30       	cpi	r18, 0x08	; 8
     19a:	31 05       	cpc	r19, r1
     19c:	c9 f6       	brne	.-78     	; 0x150 <bars+0x28>
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
     19e:	88 b3       	in	r24, 0x18	; 24
     1a0:	18 ba       	out	0x18, r1	; 24
   if(mult == 128){			//Button 8 toggles base 10 and 16
     1a2:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <mult>
     1a6:	90 91 20 01 	lds	r25, 0x0120	; 0x800120 <mult+0x1>
     1aa:	80 38       	cpi	r24, 0x80	; 128
     1ac:	91 05       	cpc	r25, r1
     1ae:	e1 f1       	breq	.+120    	; 0x228 <bars+0x100>
      alarm = !(alarm);			//on the LED display
   }
   if(mult > 4) {			//I only want values from the
     1b0:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <mult>
     1b4:	90 91 20 01 	lds	r25, 0x0120	; 0x800120 <mult+0x1>
     1b8:	05 97       	sbiw	r24, 0x05	; 5
     1ba:	20 f0       	brcs	.+8      	; 0x1c4 <bars+0x9c>
      mult = 0;				//first three buttons
     1bc:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <mult+0x1>
     1c0:	10 92 1f 01 	sts	0x011F, r1	; 0x80011f <mult>
   }
   //This switch statement is used to enable a 'toggle' functionality
   //so that modes can be selected an deselected
   switch(mult) {
     1c4:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <mult>
     1c8:	90 91 20 01 	lds	r25, 0x0120	; 0x800120 <mult+0x1>
     1cc:	82 30       	cpi	r24, 0x02	; 2
     1ce:	91 05       	cpc	r25, r1
     1d0:	09 f4       	brne	.+2      	; 0x1d4 <bars+0xac>
     1d2:	4a c0       	rjmp	.+148    	; 0x268 <bars+0x140>
     1d4:	84 30       	cpi	r24, 0x04	; 4
     1d6:	91 05       	cpc	r25, r1
     1d8:	79 f1       	breq	.+94     	; 0x238 <bars+0x110>
     1da:	81 30       	cpi	r24, 0x01	; 1
     1dc:	91 05       	cpc	r25, r1
     1de:	c1 f0       	breq	.+48     	; 0x210 <bars+0xe8>
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
         break;
      default:
	 mode_sel = mode_sel;		//no/invalid button press
     1e0:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <mode_sel>
     1e4:	90 91 1c 01 	lds	r25, 0x011C	; 0x80011c <mode_sel+0x1>
     1e8:	90 93 1c 01 	sts	0x011C, r25	; 0x80011c <mode_sel+0x1>
     1ec:	80 93 1b 01 	sts	0x011B, r24	; 0x80011b <mode_sel>
   }   
   mult = 0;				//clear mult for next pass
     1f0:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <mult+0x1>
     1f4:	10 92 1f 01 	sts	0x011F, r1	; 0x80011f <mult>

   DDRA = 0xFF;				//Set A to alloutputs
     1f8:	8f ef       	ldi	r24, 0xFF	; 255
     1fa:	8a bb       	out	0x1a, r24	; 26
   SPDR = mode_sel;			//Write mode to the Bargraph
     1fc:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <mode_sel>
     200:	90 91 1c 01 	lds	r25, 0x011C	; 0x80011c <mode_sel+0x1>
     204:	8f b9       	out	0x0f, r24	; 15
   while(bit_is_clear(SPSR, SPIF)){}	
     206:	77 9b       	sbis	0x0e, 7	; 14
     208:	fe cf       	rjmp	.-4      	; 0x206 <bars+0xde>
   PORTB |= (1<<PB0);			//Rgclk high on bargraph
     20a:	c0 9a       	sbi	0x18, 0	; 24
   PORTB &= 0xFE;			//Rgclk low on bargraph
     20c:	c0 98       	cbi	0x18, 0	; 24
   
return ;
     20e:	08 95       	ret
   }
   //This switch statement is used to enable a 'toggle' functionality
   //so that modes can be selected an deselected
   switch(mult) {
      case 1:
	 if((mode_sel ^ mult) == 0){	//XOR to see if they are the same
     210:	40 91 1b 01 	lds	r20, 0x011B	; 0x80011b <mode_sel>
     214:	50 91 1c 01 	lds	r21, 0x011C	; 0x80011c <mode_sel+0x1>
     218:	20 91 1f 01 	lds	r18, 0x011F	; 0x80011f <mult>
     21c:	30 91 20 01 	lds	r19, 0x0120	; 0x800120 <mult+0x1>
     220:	42 17       	cp	r20, r18
     222:	53 07       	cpc	r21, r19
     224:	09 f7       	brne	.-62     	; 0x1e8 <bars+0xc0>
     226:	31 c0       	rjmp	.+98     	; 0x28a <bars+0x162>
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
     228:	90 91 22 01 	lds	r25, 0x0122	; 0x800122 <alarm>
     22c:	81 e0       	ldi	r24, 0x01	; 1
     22e:	91 11       	cpse	r25, r1
     230:	38 c0       	rjmp	.+112    	; 0x2a2 <bars+0x17a>
     232:	80 93 22 01 	sts	0x0122, r24	; 0x800122 <alarm>
     236:	bc cf       	rjmp	.-136    	; 0x1b0 <bars+0x88>
	 else
	    mode_sel = 2;		//If not, then change mode
         
         break;
      case 4:
	 if((mode_sel ^ mult) && (mode_sel == 2)){//if cur &prev are diff
     238:	20 91 1b 01 	lds	r18, 0x011B	; 0x80011b <mode_sel>
     23c:	30 91 1c 01 	lds	r19, 0x011C	; 0x80011c <mode_sel+0x1>
     240:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <mult>
     244:	90 91 20 01 	lds	r25, 0x0120	; 0x800120 <mult+0x1>
     248:	28 17       	cp	r18, r24
     24a:	39 07       	cpc	r19, r25
     24c:	31 f0       	breq	.+12     	; 0x25a <bars+0x132>
     24e:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <mode_sel>
     252:	90 91 1c 01 	lds	r25, 0x011C	; 0x80011c <mode_sel+0x1>
     256:	02 97       	sbiw	r24, 0x02	; 2
     258:	c1 f0       	breq	.+48     	; 0x28a <bars+0x162>
	    mode_sel = 0;//and prev isn't = 1 then two modes are selected
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
     25a:	84 e0       	ldi	r24, 0x04	; 4
     25c:	90 e0       	ldi	r25, 0x00	; 0
     25e:	90 93 1c 01 	sts	0x011C, r25	; 0x80011c <mode_sel+0x1>
     262:	80 93 1b 01 	sts	0x011B, r24	; 0x80011b <mode_sel>
     266:	c4 cf       	rjmp	.-120    	; 0x1f0 <bars+0xc8>
	 }
	 else
	    mode_sel = 1;		//If not, then change mode
         break;
      case 2:
	 if((mode_sel ^ mult) && (mode_sel == 4)){//if cur &prev are diff
     268:	20 91 1b 01 	lds	r18, 0x011B	; 0x80011b <mode_sel>
     26c:	30 91 1c 01 	lds	r19, 0x011C	; 0x80011c <mode_sel+0x1>
     270:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <mult>
     274:	90 91 20 01 	lds	r25, 0x0120	; 0x800120 <mult+0x1>
     278:	28 17       	cp	r18, r24
     27a:	39 07       	cpc	r19, r25
     27c:	59 f0       	breq	.+22     	; 0x294 <bars+0x16c>
     27e:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <mode_sel>
     282:	90 91 1c 01 	lds	r25, 0x011C	; 0x80011c <mode_sel+0x1>
     286:	04 97       	sbiw	r24, 0x04	; 4
     288:	29 f4       	brne	.+10     	; 0x294 <bars+0x16c>
	    mode_sel = 2;		//If not, then change mode
         
         break;
      case 4:
	 if((mode_sel ^ mult) && (mode_sel == 2)){//if cur &prev are diff
	    mode_sel = 0;//and prev isn't = 1 then two modes are selected
     28a:	10 92 1c 01 	sts	0x011C, r1	; 0x80011c <mode_sel+0x1>
     28e:	10 92 1b 01 	sts	0x011B, r1	; 0x80011b <mode_sel>
     292:	ae cf       	rjmp	.-164    	; 0x1f0 <bars+0xc8>
      case 2:
	 if((mode_sel ^ mult) && (mode_sel == 4)){//if cur &prev are diff
	    mode_sel = 0;//and prev isn't = 1 then two modes are selected
	 }
	 else
	    mode_sel = 2;		//If not, then change mode
     294:	82 e0       	ldi	r24, 0x02	; 2
     296:	90 e0       	ldi	r25, 0x00	; 0
     298:	90 93 1c 01 	sts	0x011C, r25	; 0x80011c <mode_sel+0x1>
     29c:	80 93 1b 01 	sts	0x011B, r24	; 0x80011b <mode_sel>
     2a0:	a7 cf       	rjmp	.-178    	; 0x1f0 <bars+0xc8>
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
     2a2:	80 e0       	ldi	r24, 0x00	; 0
     2a4:	80 93 22 01 	sts	0x0122, r24	; 0x800122 <alarm>
     2a8:	83 cf       	rjmp	.-250    	; 0x1b0 <bars+0x88>

000002aa <read_encoder>:
   int8_t value = 0x00;
   uint8_t ec_a;
   uint8_t ec_b;

   //Shift_LD_N low
   PORTE &= 0x00;	//Begining of SHIFT_LD_N pulse. It is low here
     2aa:	83 b1       	in	r24, 0x03	; 3
     2ac:	13 b8       	out	0x03, r1	; 3
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     2ae:	87 ec       	ldi	r24, 0xC7	; 199
     2b0:	90 e0       	ldi	r25, 0x00	; 0
     2b2:	01 97       	sbiw	r24, 0x01	; 1
     2b4:	f1 f7       	brne	.-4      	; 0x2b2 <read_encoder+0x8>
     2b6:	00 c0       	rjmp	.+0      	; 0x2b8 <read_encoder+0xe>
     2b8:	00 00       	nop
   _delay_us(50);
   PORTE |= 0xFF;	//End of SHIFT_LD_N pulse. back to high
     2ba:	83 b1       	in	r24, 0x03	; 3
     2bc:	8f ef       	ldi	r24, 0xFF	; 255
     2be:	83 b9       	out	0x03, r24	; 3
   PORTD &= 0x00;	//CLK_INH low
     2c0:	82 b3       	in	r24, 0x12	; 18
     2c2:	12 ba       	out	0x12, r1	; 18
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
     2c4:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
     2c6:	77 9b       	sbis	0x0e, 7	; 14
     2c8:	fe cf       	rjmp	.-4      	; 0x2c6 <read_encoder+0x1c>
   return SPDR;
     2ca:	9f b1       	in	r25, 0x0f	; 15
   _delay_us(50);
   PORTE |= 0xFF;	//End of SHIFT_LD_N pulse. back to high
   PORTD &= 0x00;	//CLK_INH low

   encoder_value = spi_read();
   PORTD |= 0x02;	//CLK_INH high
     2cc:	91 9a       	sbi	0x12, 1	; 18
   value = mode_sel;
     2ce:	20 91 1b 01 	lds	r18, 0x011B	; 0x80011b <mode_sel>
     2d2:	30 91 1c 01 	lds	r19, 0x011C	; 0x80011c <mode_sel+0x1>
     2d6:	82 2f       	mov	r24, r18
   ec_a = encoder_value & 0x03;  //Only grabs these bits 0000_0011
     2d8:	49 2f       	mov	r20, r25
     2da:	43 70       	andi	r20, 0x03	; 3
   ec_b = encoder_value & 0x0C;  //Only grabs these bits 0000_1100 
     2dc:	9c 70       	andi	r25, 0x0C	; 12
   ec_b = (ec_b >> 2);
     2de:	96 95       	lsr	r25
     2e0:	96 95       	lsr	r25
if(mode_sel == 1){
     2e2:	20 91 1b 01 	lds	r18, 0x011B	; 0x80011b <mode_sel>
     2e6:	30 91 1c 01 	lds	r19, 0x011C	; 0x80011c <mode_sel+0x1>
     2ea:	21 30       	cpi	r18, 0x01	; 1
     2ec:	31 05       	cpc	r19, r1
     2ee:	29 f0       	breq	.+10     	; 0x2fa <read_encoder+0x50>
      else
	 value = 0;
   }
}
//Saves previous values into volatile variables
EC_a_prev = ec_a;
     2f0:	40 93 39 01 	sts	0x0139, r20	; 0x800139 <EC_a_prev>
EC_b_prev = ec_b;
     2f4:	90 93 38 01 	sts	0x0138, r25	; 0x800138 <EC_b_prev>

return value;
}
     2f8:	08 95       	ret
   value = mode_sel;
   ec_a = encoder_value & 0x03;  //Only grabs these bits 0000_0011
   ec_b = encoder_value & 0x0C;  //Only grabs these bits 0000_1100 
   ec_b = (ec_b >> 2);
if(mode_sel == 1){
   if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     2fa:	20 91 39 01 	lds	r18, 0x0139	; 0x800139 <EC_a_prev>
     2fe:	64 2f       	mov	r22, r20
     300:	70 e0       	ldi	r23, 0x00	; 0
     302:	02 2e       	mov	r0, r18
     304:	00 0c       	add	r0, r0
     306:	33 0b       	sbc	r19, r19
     308:	62 17       	cp	r22, r18
     30a:	73 07       	cpc	r23, r19
     30c:	c9 f0       	breq	.+50     	; 0x340 <read_encoder+0x96>
      if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     30e:	20 91 39 01 	lds	r18, 0x0139	; 0x800139 <EC_a_prev>
     312:	21 11       	cpse	r18, r1
     314:	02 c0       	rjmp	.+4      	; 0x31a <read_encoder+0x70>
     316:	41 30       	cpi	r20, 0x01	; 1
     318:	29 f1       	breq	.+74     	; 0x364 <read_encoder+0xba>
         hour_count = hour_count + 1;//value = value;
	 if(hour_count == 24)
	    hour_count = 0;
      }
      else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     31a:	20 91 39 01 	lds	r18, 0x0139	; 0x800139 <EC_a_prev>
     31e:	21 11       	cpse	r18, r1
     320:	1b c0       	rjmp	.+54     	; 0x358 <read_encoder+0xae>
     322:	42 30       	cpi	r20, 0x02	; 2
     324:	c9 f4       	brne	.+50     	; 0x358 <read_encoder+0xae>
	 hour_count = hour_count - 1;//value = -(value);
     326:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <hour_count>
     32a:	21 50       	subi	r18, 0x01	; 1
     32c:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <hour_count>
	 if(hour_count < 0)
     330:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <hour_count>
     334:	27 ff       	sbrs	r18, 7
     336:	dc cf       	rjmp	.-72     	; 0x2f0 <read_encoder+0x46>
	    hour_count = 23; 
     338:	27 e1       	ldi	r18, 0x17	; 23
     33a:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <hour_count>
     33e:	d8 cf       	rjmp	.-80     	; 0x2f0 <read_encoder+0x46>
      }
      else	//If not one of the state changes above, do nothing
	 value = 0;
   }
   else {	//This is for encoder B
      if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
     340:	20 91 38 01 	lds	r18, 0x0138	; 0x800138 <EC_b_prev>
     344:	21 11       	cpse	r18, r1
     346:	02 c0       	rjmp	.+4      	; 0x34c <read_encoder+0xa2>
     348:	91 30       	cpi	r25, 0x01	; 1
     34a:	59 f1       	breq	.+86     	; 0x3a2 <read_encoder+0xf8>
	 if(min_count == 60){
	    min_count = 0; 
	    hour_count++;
	 }
      }
      else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
     34c:	20 91 38 01 	lds	r18, 0x0138	; 0x800138 <EC_b_prev>
     350:	21 11       	cpse	r18, r1
     352:	02 c0       	rjmp	.+4      	; 0x358 <read_encoder+0xae>
     354:	92 30       	cpi	r25, 0x02	; 2
     356:	99 f0       	breq	.+38     	; 0x37e <read_encoder+0xd4>
	 hour_count = hour_count - 1;//value = -(value);
	 if(hour_count < 0)
	    hour_count = 23; 
      }
      else	//If not one of the state changes above, do nothing
	 value = 0;
     358:	80 e0       	ldi	r24, 0x00	; 0
      else
	 value = 0;
   }
}
//Saves previous values into volatile variables
EC_a_prev = ec_a;
     35a:	40 93 39 01 	sts	0x0139, r20	; 0x800139 <EC_a_prev>
EC_b_prev = ec_b;
     35e:	90 93 38 01 	sts	0x0138, r25	; 0x800138 <EC_b_prev>

return value;
}
     362:	08 95       	ret
   ec_b = encoder_value & 0x0C;  //Only grabs these bits 0000_1100 
   ec_b = (ec_b >> 2);
if(mode_sel == 1){
   if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
      if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
         hour_count = hour_count + 1;//value = value;
     364:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <hour_count>
     368:	2f 5f       	subi	r18, 0xFF	; 255
     36a:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <hour_count>
	 if(hour_count == 24)
     36e:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <hour_count>
     372:	28 31       	cpi	r18, 0x18	; 24
     374:	09 f0       	breq	.+2      	; 0x378 <read_encoder+0xce>
     376:	bc cf       	rjmp	.-136    	; 0x2f0 <read_encoder+0x46>
	    hour_count = 0;
     378:	10 92 15 01 	sts	0x0115, r1	; 0x800115 <hour_count>
     37c:	b9 cf       	rjmp	.-142    	; 0x2f0 <read_encoder+0x46>
	    min_count = 0; 
	    hour_count++;
	 }
      }
      else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
	 min_count = min_count - 1; //value = -(value);
     37e:	20 91 24 01 	lds	r18, 0x0124	; 0x800124 <min_count>
     382:	21 50       	subi	r18, 0x01	; 1
     384:	20 93 24 01 	sts	0x0124, r18	; 0x800124 <min_count>
	 if(min_count < 0){
     388:	20 91 24 01 	lds	r18, 0x0124	; 0x800124 <min_count>
     38c:	27 ff       	sbrs	r18, 7
     38e:	b0 cf       	rjmp	.-160    	; 0x2f0 <read_encoder+0x46>
	    min_count = 59;
     390:	2b e3       	ldi	r18, 0x3B	; 59
     392:	20 93 24 01 	sts	0x0124, r18	; 0x800124 <min_count>
	    hour_count--;
     396:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <hour_count>
     39a:	21 50       	subi	r18, 0x01	; 1
     39c:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <hour_count>
     3a0:	a7 cf       	rjmp	.-178    	; 0x2f0 <read_encoder+0x46>
      else	//If not one of the state changes above, do nothing
	 value = 0;
   }
   else {	//This is for encoder B
      if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
         min_count = min_count + 1;//value = value;
     3a2:	20 91 24 01 	lds	r18, 0x0124	; 0x800124 <min_count>
     3a6:	2f 5f       	subi	r18, 0xFF	; 255
     3a8:	20 93 24 01 	sts	0x0124, r18	; 0x800124 <min_count>
	 if(min_count == 60){
     3ac:	20 91 24 01 	lds	r18, 0x0124	; 0x800124 <min_count>
     3b0:	2c 33       	cpi	r18, 0x3C	; 60
     3b2:	09 f0       	breq	.+2      	; 0x3b6 <read_encoder+0x10c>
     3b4:	9d cf       	rjmp	.-198    	; 0x2f0 <read_encoder+0x46>
	    min_count = 0; 
     3b6:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <min_count>
	    hour_count++;
     3ba:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <hour_count>
     3be:	2f 5f       	subi	r18, 0xFF	; 255
     3c0:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <hour_count>
     3c4:	95 cf       	rjmp	.-214    	; 0x2f0 <read_encoder+0x46>

000003c6 <__vector_16>:
	update the mode and bargraph. Then I change the sum based on	
	the value returned from the encoder reading. Sum is then bounded
	from 0-1023. 1023+1=1 and 0-any number > 0 = 1023.
Parameters: NA
**********************************************************************/
ISR(TIMER0_OVF_vect) {
     3c6:	1f 92       	push	r1
     3c8:	0f 92       	push	r0
     3ca:	0f b6       	in	r0, 0x3f	; 63
     3cc:	0f 92       	push	r0
     3ce:	11 24       	eor	r1, r1
     3d0:	0b b6       	in	r0, 0x3b	; 59
     3d2:	0f 92       	push	r0
     3d4:	2f 93       	push	r18
     3d6:	3f 93       	push	r19
     3d8:	4f 93       	push	r20
     3da:	5f 93       	push	r21
     3dc:	6f 93       	push	r22
     3de:	7f 93       	push	r23
     3e0:	8f 93       	push	r24
     3e2:	9f 93       	push	r25
     3e4:	af 93       	push	r26
     3e6:	bf 93       	push	r27
     3e8:	ef 93       	push	r30
     3ea:	ff 93       	push	r31
   static uint8_t count_7_8125ms = 0;

   count_7_8125ms++;
     3ec:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <count_7_8125ms.1999>
     3f0:	8f 5f       	subi	r24, 0xFF	; 255
     3f2:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <count_7_8125ms.1999>
   if((count_7_8125ms % 128) == 0) { //interrupts every 1 second
     3f6:	8f 77       	andi	r24, 0x7F	; 127
     3f8:	29 f4       	brne	.+10     	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
      sec_count++;
     3fa:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <sec_count>
     3fe:	8f 5f       	subi	r24, 0xFF	; 255
     400:	80 93 25 01 	sts	0x0125, r24	; 0x800125 <sec_count>
   }
   bars();  
     404:	0e 94 94 00 	call	0x128	; 0x128 <bars>
   read_encoder();      
     408:	0e 94 55 01 	call	0x2aa	; 0x2aa <read_encoder>
//      if(sum>1023)
//	sum = sum % 1023;
//      if(sum<0)
//	sum = 1023; //No overflow. If less than 0 always go to 1023.

}
     40c:	ff 91       	pop	r31
     40e:	ef 91       	pop	r30
     410:	bf 91       	pop	r27
     412:	af 91       	pop	r26
     414:	9f 91       	pop	r25
     416:	8f 91       	pop	r24
     418:	7f 91       	pop	r23
     41a:	6f 91       	pop	r22
     41c:	5f 91       	pop	r21
     41e:	4f 91       	pop	r20
     420:	3f 91       	pop	r19
     422:	2f 91       	pop	r18
     424:	0f 90       	pop	r0
     426:	0b be       	out	0x3b, r0	; 59
     428:	0f 90       	pop	r0
     42a:	0f be       	out	0x3f, r0	; 63
     42c:	0f 90       	pop	r0
     42e:	1f 90       	pop	r1
     430:	18 95       	reti

00000432 <clock_time>:
Description:
Parameters:
**********************************************************************/
void clock_time(){ //by default we use military time
   
   if(sec_count > 59){
     432:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <sec_count>
     436:	8c 33       	cpi	r24, 0x3C	; 60
     438:	60 f0       	brcs	.+24     	; 0x452 <clock_time+0x20>
      min_count++;
     43a:	80 91 24 01 	lds	r24, 0x0124	; 0x800124 <min_count>
     43e:	8f 5f       	subi	r24, 0xFF	; 255
     440:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <min_count>
      sec_count = 0;
     444:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <sec_count>
      if(min_count > 59){
     448:	80 91 24 01 	lds	r24, 0x0124	; 0x800124 <min_count>
     44c:	8c 33       	cpi	r24, 0x3C	; 60
     44e:	0c f0       	brlt	.+2      	; 0x452 <clock_time+0x20>
     450:	6c c0       	rjmp	.+216    	; 0x52a <clock_time+0xf8>
	    hour_count = 0;
	 }//hours	
      }//mins
   }//secs
   
   if(!mil){
     452:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <mil>
     456:	81 11       	cpse	r24, r1
     458:	0e c0       	rjmp	.+28     	; 0x476 <clock_time+0x44>
      if(hour_count > 12){
     45a:	80 91 15 01 	lds	r24, 0x0115	; 0x800115 <hour_count>
     45e:	8d 30       	cpi	r24, 0x0D	; 13
     460:	2c f0       	brlt	.+10     	; 0x46c <clock_time+0x3a>
         hour_count = hour_count - 12;
     462:	80 91 15 01 	lds	r24, 0x0115	; 0x800115 <hour_count>
     466:	8c 50       	subi	r24, 0x0C	; 12
     468:	80 93 15 01 	sts	0x0115, r24	; 0x800115 <hour_count>
      }
      if(hour_count == 0){
     46c:	80 91 15 01 	lds	r24, 0x0115	; 0x800115 <hour_count>
     470:	88 23       	and	r24, r24
     472:	09 f4       	brne	.+2      	; 0x476 <clock_time+0x44>
     474:	56 c0       	rjmp	.+172    	; 0x522 <clock_time+0xf0>
         hour_count = 12;
      }
      
   }
      segment_data[4] = dec_to_7seg[hour_count/10];
     476:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <hour_count>
     47a:	87 e6       	ldi	r24, 0x67	; 103
     47c:	98 02       	muls	r25, r24
     47e:	e1 2d       	mov	r30, r1
     480:	11 24       	eor	r1, r1
     482:	e5 95       	asr	r30
     484:	e5 95       	asr	r30
     486:	97 fd       	sbrc	r25, 7
     488:	e3 95       	inc	r30
     48a:	0e 2e       	mov	r0, r30
     48c:	00 0c       	add	r0, r0
     48e:	ff 0b       	sbc	r31, r31
     490:	e0 50       	subi	r30, 0x00	; 0
     492:	ff 4f       	sbci	r31, 0xFF	; 255
     494:	90 81       	ld	r25, Z
     496:	90 93 1a 01 	sts	0x011A, r25	; 0x80011a <__data_end+0x4>
      segment_data[3] = dec_to_7seg[hour_count%10];
     49a:	e0 91 15 01 	lds	r30, 0x0115	; 0x800115 <hour_count>
     49e:	e8 02       	muls	r30, r24
     4a0:	81 2d       	mov	r24, r1
     4a2:	11 24       	eor	r1, r1
     4a4:	85 95       	asr	r24
     4a6:	85 95       	asr	r24
     4a8:	e7 fd       	sbrc	r30, 7
     4aa:	83 95       	inc	r24
     4ac:	9a e0       	ldi	r25, 0x0A	; 10
     4ae:	89 9f       	mul	r24, r25
     4b0:	e0 19       	sub	r30, r0
     4b2:	11 24       	eor	r1, r1
     4b4:	0e 2e       	mov	r0, r30
     4b6:	00 0c       	add	r0, r0
     4b8:	ff 0b       	sbc	r31, r31
     4ba:	e0 50       	subi	r30, 0x00	; 0
     4bc:	ff 4f       	sbci	r31, 0xFF	; 255
     4be:	80 81       	ld	r24, Z
     4c0:	80 93 19 01 	sts	0x0119, r24	; 0x800119 <__data_end+0x3>
      if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     4c4:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <sec_count>
     4c8:	80 fd       	sbrc	r24, 0
     4ca:	3e c0       	rjmp	.+124    	; 0x548 <clock_time+0x116>
      else {segment_data[2] = 0b111;}		//Turn colon off
     4cc:	87 e0       	ldi	r24, 0x07	; 7
     4ce:	80 93 18 01 	sts	0x0118, r24	; 0x800118 <__data_end+0x2>
      segment_data[1] = dec_to_7seg[min_count/10];
     4d2:	90 91 24 01 	lds	r25, 0x0124	; 0x800124 <min_count>
     4d6:	87 e6       	ldi	r24, 0x67	; 103
     4d8:	98 02       	muls	r25, r24
     4da:	e1 2d       	mov	r30, r1
     4dc:	11 24       	eor	r1, r1
     4de:	e5 95       	asr	r30
     4e0:	e5 95       	asr	r30
     4e2:	97 fd       	sbrc	r25, 7
     4e4:	e3 95       	inc	r30
     4e6:	0e 2e       	mov	r0, r30
     4e8:	00 0c       	add	r0, r0
     4ea:	ff 0b       	sbc	r31, r31
     4ec:	e0 50       	subi	r30, 0x00	; 0
     4ee:	ff 4f       	sbci	r31, 0xFF	; 255
     4f0:	90 81       	ld	r25, Z
     4f2:	90 93 17 01 	sts	0x0117, r25	; 0x800117 <__data_end+0x1>
      segment_data[0] = dec_to_7seg[min_count%10];
     4f6:	e0 91 24 01 	lds	r30, 0x0124	; 0x800124 <min_count>
     4fa:	e8 02       	muls	r30, r24
     4fc:	81 2d       	mov	r24, r1
     4fe:	11 24       	eor	r1, r1
     500:	85 95       	asr	r24
     502:	85 95       	asr	r24
     504:	e7 fd       	sbrc	r30, 7
     506:	83 95       	inc	r24
     508:	9a e0       	ldi	r25, 0x0A	; 10
     50a:	89 9f       	mul	r24, r25
     50c:	e0 19       	sub	r30, r0
     50e:	11 24       	eor	r1, r1
     510:	0e 2e       	mov	r0, r30
     512:	00 0c       	add	r0, r0
     514:	ff 0b       	sbc	r31, r31
     516:	e0 50       	subi	r30, 0x00	; 0
     518:	ff 4f       	sbci	r31, 0xFF	; 255
     51a:	80 81       	ld	r24, Z
     51c:	80 93 16 01 	sts	0x0116, r24	; 0x800116 <__data_end>
     520:	08 95       	ret
   if(!mil){
      if(hour_count > 12){
         hour_count = hour_count - 12;
      }
      if(hour_count == 0){
         hour_count = 12;
     522:	8c e0       	ldi	r24, 0x0C	; 12
     524:	80 93 15 01 	sts	0x0115, r24	; 0x800115 <hour_count>
     528:	a6 cf       	rjmp	.-180    	; 0x476 <clock_time+0x44>
   
   if(sec_count > 59){
      min_count++;
      sec_count = 0;
      if(min_count > 59){
	 hour_count++;
     52a:	80 91 15 01 	lds	r24, 0x0115	; 0x800115 <hour_count>
     52e:	8f 5f       	subi	r24, 0xFF	; 255
     530:	80 93 15 01 	sts	0x0115, r24	; 0x800115 <hour_count>
	 min_count = 0;
     534:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <min_count>
	 if(hour_count > 23){
     538:	80 91 15 01 	lds	r24, 0x0115	; 0x800115 <hour_count>
     53c:	88 31       	cpi	r24, 0x18	; 24
     53e:	0c f4       	brge	.+2      	; 0x542 <clock_time+0x110>
     540:	88 cf       	rjmp	.-240    	; 0x452 <clock_time+0x20>
	    hour_count = 0;
     542:	10 92 15 01 	sts	0x0115, r1	; 0x800115 <hour_count>
     546:	85 cf       	rjmp	.-246    	; 0x452 <clock_time+0x20>
      }
      
   }
      segment_data[4] = dec_to_7seg[hour_count/10];
      segment_data[3] = dec_to_7seg[hour_count%10];
      if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     548:	84 e0       	ldi	r24, 0x04	; 4
     54a:	80 93 18 01 	sts	0x0118, r24	; 0x800118 <__data_end+0x2>
     54e:	c1 cf       	rjmp	.-126    	; 0x4d2 <clock_time+0xa0>

00000550 <send_lcd>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     550:	91 e0       	ldi	r25, 0x01	; 1
     552:	81 11       	cpse	r24, r1
     554:	01 c0       	rjmp	.+2      	; 0x558 <send_lcd+0x8>
     556:	90 e0       	ldi	r25, 0x00	; 0
     558:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     55a:	77 9b       	sbis	0x0e, 7	; 14
     55c:	fe cf       	rjmp	.-4      	; 0x55a <send_lcd+0xa>
  SPDR = byte;                        //send payload
     55e:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     560:	77 9b       	sbis	0x0e, 7	; 14
     562:	fe cf       	rjmp	.-4      	; 0x560 <send_lcd+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     564:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     568:	88 60       	ori	r24, 0x08	; 8
     56a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     56e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     572:	87 7f       	andi	r24, 0xF7	; 247
     574:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     578:	08 95       	ret

0000057a <refresh_lcd>:
//
void refresh_lcd(char lcd_string_array[]) {

  static uint8_t i=0;           // index into string array 

 send_lcd(CHAR_BYTE,lcd_string_array[i]);
     57a:	20 91 37 01 	lds	r18, 0x0137	; 0x800137 <i.2095>
     57e:	82 0f       	add	r24, r18
     580:	91 1d       	adc	r25, r1
     582:	fc 01       	movw	r30, r24
     584:	80 81       	ld	r24, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     586:	91 e0       	ldi	r25, 0x01	; 1
     588:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     58a:	77 9b       	sbis	0x0e, 7	; 14
     58c:	fe cf       	rjmp	.-4      	; 0x58a <refresh_lcd+0x10>
  SPDR = byte;                        //send payload
     58e:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     590:	77 9b       	sbis	0x0e, 7	; 14
     592:	fe cf       	rjmp	.-4      	; 0x590 <refresh_lcd+0x16>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     594:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     598:	88 60       	ori	r24, 0x08	; 8
     59a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     59e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     5a2:	87 7f       	andi	r24, 0xF7	; 247
     5a4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
void refresh_lcd(char lcd_string_array[]) {

  static uint8_t i=0;           // index into string array 

 send_lcd(CHAR_BYTE,lcd_string_array[i]);
 i++;   //increment to next character
     5a8:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <i.2095>
     5ac:	8f 5f       	subi	r24, 0xFF	; 255
     5ae:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <i.2095>
 //delays are inserted to allow character to be written before moving
 //the cursor to the next line.
 if(i == 16){_delay_us(40); line2_col1();      } //goto line 2, 1st char 
     5b2:	80 31       	cpi	r24, 0x10	; 16
     5b4:	f9 f0       	breq	.+62     	; 0x5f4 <refresh_lcd+0x7a>
 if(i == 32){_delay_us(40); line1_col1(); i=0; } //goto line 1, 1st char 
     5b6:	80 32       	cpi	r24, 0x20	; 32
     5b8:	09 f0       	breq	.+2      	; 0x5bc <refresh_lcd+0x42>
     5ba:	08 95       	ret
     5bc:	e5 ed       	ldi	r30, 0xD5	; 213
     5be:	ea 95       	dec	r30
     5c0:	f1 f7       	brne	.-4      	; 0x5be <refresh_lcd+0x44>
     5c2:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     5c4:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     5c6:	77 9b       	sbis	0x0e, 7	; 14
     5c8:	fe cf       	rjmp	.-4      	; 0x5c6 <refresh_lcd+0x4c>
  SPDR = byte;                        //send payload
     5ca:	80 e8       	ldi	r24, 0x80	; 128
     5cc:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     5ce:	77 9b       	sbis	0x0e, 7	; 14
     5d0:	fe cf       	rjmp	.-4      	; 0x5ce <refresh_lcd+0x54>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     5d2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     5d6:	88 60       	ori	r24, 0x08	; 8
     5d8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     5dc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     5e0:	87 7f       	andi	r24, 0xF7	; 247
     5e2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     5e6:	f5 ed       	ldi	r31, 0xD5	; 213
     5e8:	fa 95       	dec	r31
     5ea:	f1 f7       	brne	.-4      	; 0x5e8 <refresh_lcd+0x6e>
     5ec:	00 00       	nop
 send_lcd(CHAR_BYTE,lcd_string_array[i]);
 i++;   //increment to next character
 //delays are inserted to allow character to be written before moving
 //the cursor to the next line.
 if(i == 16){_delay_us(40); line2_col1();      } //goto line 2, 1st char 
 if(i == 32){_delay_us(40); line1_col1(); i=0; } //goto line 1, 1st char 
     5ee:	10 92 37 01 	sts	0x0137, r1	; 0x800137 <i.2095>
     5f2:	08 95       	ret
     5f4:	f5 ed       	ldi	r31, 0xD5	; 213
     5f6:	fa 95       	dec	r31
     5f8:	f1 f7       	brne	.-4      	; 0x5f6 <refresh_lcd+0x7c>
     5fa:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     5fc:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     5fe:	77 9b       	sbis	0x0e, 7	; 14
     600:	fe cf       	rjmp	.-4      	; 0x5fe <refresh_lcd+0x84>
  SPDR = byte;                        //send payload
     602:	80 ec       	ldi	r24, 0xC0	; 192
     604:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     606:	77 9b       	sbis	0x0e, 7	; 14
     608:	fe cf       	rjmp	.-4      	; 0x606 <refresh_lcd+0x8c>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     60a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     60e:	88 60       	ori	r24, 0x08	; 8
     610:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     614:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     618:	87 7f       	andi	r24, 0xF7	; 247
     61a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     61e:	85 ed       	ldi	r24, 0xD5	; 213
     620:	8a 95       	dec	r24
     622:	f1 f7       	brne	.-4      	; 0x620 <refresh_lcd+0xa6>
     624:	00 00       	nop
     626:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <i.2095>
     62a:	c5 cf       	rjmp	.-118    	; 0x5b6 <refresh_lcd+0x3c>

0000062c <set_custom_character>:
//address, such as send_lcd(CHAR_BYTE, 0x01, 1) or it can be insteretd into a string 
//via a forward slash escape as in string2lcd("this is my music note \1")

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
     62c:	66 0f       	add	r22, r22
     62e:	66 0f       	add	r22, r22
     630:	66 0f       	add	r22, r22
     632:	60 5c       	subi	r22, 0xC0	; 192
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     634:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     636:	77 9b       	sbis	0x0e, 7	; 14
     638:	fe cf       	rjmp	.-4      	; 0x636 <set_custom_character+0xa>
  SPDR = byte;                        //send payload
     63a:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     63c:	77 9b       	sbis	0x0e, 7	; 14
     63e:	fe cf       	rjmp	.-4      	; 0x63c <set_custom_character+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     640:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     644:	28 60       	ori	r18, 0x08	; 8
     646:	20 93 62 00 	sts	0x0062, r18	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     64a:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     64e:	27 7f       	andi	r18, 0xF7	; 247
     650:	20 93 62 00 	sts	0x0062, r18	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     654:	25 ed       	ldi	r18, 0xD5	; 213
     656:	2a 95       	dec	r18
     658:	f1 f7       	brne	.-4      	; 0x656 <set_custom_character+0x2a>
     65a:	00 00       	nop
     65c:	fc 01       	movw	r30, r24
     65e:	9c 01       	movw	r18, r24
     660:	28 5f       	subi	r18, 0xF8	; 248
     662:	3f 4f       	sbci	r19, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     664:	91 e0       	ldi	r25, 0x01	; 1

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
    for(i=0; i<8; i++){
      send_lcd(CHAR_BYTE, data[i]); _delay_us(40); //each char byte takes 37us to execute
     666:	81 91       	ld	r24, Z+
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     668:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     66a:	77 9b       	sbis	0x0e, 7	; 14
     66c:	fe cf       	rjmp	.-4      	; 0x66a <set_custom_character+0x3e>
  SPDR = byte;                        //send payload
     66e:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     670:	77 9b       	sbis	0x0e, 7	; 14
     672:	fe cf       	rjmp	.-4      	; 0x670 <set_custom_character+0x44>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     674:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     678:	88 60       	ori	r24, 0x08	; 8
     67a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     67e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     682:	87 7f       	andi	r24, 0xF7	; 247
     684:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     688:	85 ed       	ldi	r24, 0xD5	; 213
     68a:	8a 95       	dec	r24
     68c:	f1 f7       	brne	.-4      	; 0x68a <set_custom_character+0x5e>
     68e:	00 00       	nop
//via a forward slash escape as in string2lcd("this is my music note \1")

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
    for(i=0; i<8; i++){
     690:	e2 17       	cp	r30, r18
     692:	f3 07       	cpc	r31, r19
     694:	41 f7       	brne	.-48     	; 0x666 <set_custom_character+0x3a>
      send_lcd(CHAR_BYTE, data[i]); _delay_us(40); //each char byte takes 37us to execute
    }
}
     696:	08 95       	ret

00000698 <set_cursor>:
//                          set_cursor 
//
//Sets the cursor to an arbitrary potition on the screen, row is either 1 or 2
//col is a number form 0-15, counting from left to right
void set_cursor(uint8_t row, uint8_t col){
    send_lcd(CMD_BYTE, 0x80 + col + ((row-1)*0x40));
     698:	90 e4       	ldi	r25, 0x40	; 64
     69a:	89 9f       	mul	r24, r25
     69c:	60 0d       	add	r22, r0
     69e:	11 24       	eor	r1, r1
     6a0:	60 5c       	subi	r22, 0xC0	; 192
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     6a2:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     6a4:	77 9b       	sbis	0x0e, 7	; 14
     6a6:	fe cf       	rjmp	.-4      	; 0x6a4 <set_cursor+0xc>
  SPDR = byte;                        //send payload
     6a8:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     6aa:	77 9b       	sbis	0x0e, 7	; 14
     6ac:	fe cf       	rjmp	.-4      	; 0x6aa <set_cursor+0x12>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     6ae:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     6b2:	88 60       	ori	r24, 0x08	; 8
     6b4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     6b8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     6bc:	87 7f       	andi	r24, 0xF7	; 247
     6be:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     6c2:	08 95       	ret

000006c4 <uint2lcd>:
//not displayed.  
//TODO: optimize by removing the mod operators
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
     6c4:	81 11       	cpse	r24, r1
     6c6:	13 c0       	rjmp	.+38     	; 0x6ee <uint2lcd+0x2a>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     6c8:	81 e0       	ldi	r24, 0x01	; 1
     6ca:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     6cc:	77 9b       	sbis	0x0e, 7	; 14
     6ce:	fe cf       	rjmp	.-4      	; 0x6cc <uint2lcd+0x8>
  SPDR = byte;                        //send payload
     6d0:	80 e3       	ldi	r24, 0x30	; 48
     6d2:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     6d4:	77 9b       	sbis	0x0e, 7	; 14
     6d6:	fe cf       	rjmp	.-4      	; 0x6d4 <uint2lcd+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     6d8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     6dc:	88 60       	ori	r24, 0x08	; 8
     6de:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     6e2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     6e6:	87 7f       	andi	r24, 0xF7	; 247
     6e8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     6ec:	08 95       	ret
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
     6ee:	84 36       	cpi	r24, 0x64	; 100
     6f0:	b0 f4       	brcc	.+44     	; 0x71e <uint2lcd+0x5a>
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
     6f2:	8a 30       	cpi	r24, 0x0A	; 10
     6f4:	60 f5       	brcc	.+88     	; 0x74e <uint2lcd+0x8a>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     6f6:	91 e0       	ldi	r25, 0x01	; 1
     6f8:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     6fa:	77 9b       	sbis	0x0e, 7	; 14
     6fc:	fe cf       	rjmp	.-4      	; 0x6fa <uint2lcd+0x36>
void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
      if(number >= 1)  {send_lcd(CHAR_BYTE, 0x30+(number%10)    ); }
     6fe:	9d ec       	ldi	r25, 0xCD	; 205
     700:	89 9f       	mul	r24, r25
     702:	91 2d       	mov	r25, r1
     704:	11 24       	eor	r1, r1
     706:	96 95       	lsr	r25
     708:	96 95       	lsr	r25
     70a:	96 95       	lsr	r25
     70c:	2a e0       	ldi	r18, 0x0A	; 10
     70e:	92 9f       	mul	r25, r18
     710:	80 19       	sub	r24, r0
     712:	11 24       	eor	r1, r1
     714:	80 5d       	subi	r24, 0xD0	; 208
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
  SPDR = byte;                        //send payload
     716:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     718:	77 9b       	sbis	0x0e, 7	; 14
     71a:	fe cf       	rjmp	.-4      	; 0x718 <uint2lcd+0x54>
     71c:	dd cf       	rjmp	.-70     	; 0x6d8 <uint2lcd+0x14>
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
     71e:	99 e2       	ldi	r25, 0x29	; 41
     720:	89 9f       	mul	r24, r25
     722:	91 2d       	mov	r25, r1
     724:	11 24       	eor	r1, r1
     726:	92 95       	swap	r25
     728:	9f 70       	andi	r25, 0x0F	; 15
     72a:	90 5d       	subi	r25, 0xD0	; 208
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     72c:	21 e0       	ldi	r18, 0x01	; 1
     72e:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     730:	77 9b       	sbis	0x0e, 7	; 14
     732:	fe cf       	rjmp	.-4      	; 0x730 <uint2lcd+0x6c>
  SPDR = byte;                        //send payload
     734:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     736:	77 9b       	sbis	0x0e, 7	; 14
     738:	fe cf       	rjmp	.-4      	; 0x736 <uint2lcd+0x72>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     73a:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     73e:	98 60       	ori	r25, 0x08	; 8
     740:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     744:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     748:	97 7f       	andi	r25, 0xF7	; 247
     74a:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
     74e:	99 e2       	ldi	r25, 0x29	; 41
     750:	89 9f       	mul	r24, r25
     752:	91 2d       	mov	r25, r1
     754:	11 24       	eor	r1, r1
     756:	92 95       	swap	r25
     758:	9f 70       	andi	r25, 0x0F	; 15
     75a:	38 2f       	mov	r19, r24
     75c:	24 e6       	ldi	r18, 0x64	; 100
     75e:	92 9f       	mul	r25, r18
     760:	30 19       	sub	r19, r0
     762:	11 24       	eor	r1, r1
     764:	2d ec       	ldi	r18, 0xCD	; 205
     766:	32 9f       	mul	r19, r18
     768:	91 2d       	mov	r25, r1
     76a:	11 24       	eor	r1, r1
     76c:	96 95       	lsr	r25
     76e:	96 95       	lsr	r25
     770:	96 95       	lsr	r25
     772:	90 5d       	subi	r25, 0xD0	; 208
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     774:	21 e0       	ldi	r18, 0x01	; 1
     776:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     778:	77 9b       	sbis	0x0e, 7	; 14
     77a:	fe cf       	rjmp	.-4      	; 0x778 <uint2lcd+0xb4>
  SPDR = byte;                        //send payload
     77c:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     77e:	77 9b       	sbis	0x0e, 7	; 14
     780:	fe cf       	rjmp	.-4      	; 0x77e <uint2lcd+0xba>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     782:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     786:	98 60       	ori	r25, 0x08	; 8
     788:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     78c:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     790:	97 7f       	andi	r25, 0xF7	; 247
     792:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     796:	af cf       	rjmp	.-162    	; 0x6f6 <uint2lcd+0x32>

00000798 <int2lcd>:
//Takes a 8bit signed and displays it in base ten on the LCD. Leading 0's are 
//not displayed.
//
void int2lcd(int8_t number){
    //if < 0, print minus sign, then take 2's complement of number and display
    if(number < 0){send_lcd(CHAR_BYTE, '-'); _delay_us(40); uint2lcd(~number+1);}  
     798:	87 ff       	sbrs	r24, 7
    else          {uint2lcd(number);                                            }
     79a:	0c 94 62 03 	jmp	0x6c4	; 0x6c4 <uint2lcd>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     79e:	91 e0       	ldi	r25, 0x01	; 1
     7a0:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     7a2:	77 9b       	sbis	0x0e, 7	; 14
     7a4:	fe cf       	rjmp	.-4      	; 0x7a2 <int2lcd+0xa>
  SPDR = byte;                        //send payload
     7a6:	9d e2       	ldi	r25, 0x2D	; 45
     7a8:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     7aa:	77 9b       	sbis	0x0e, 7	; 14
     7ac:	fe cf       	rjmp	.-4      	; 0x7aa <int2lcd+0x12>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     7ae:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     7b2:	98 60       	ori	r25, 0x08	; 8
     7b4:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     7b8:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     7bc:	97 7f       	andi	r25, 0xF7	; 247
     7be:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     7c2:	95 ed       	ldi	r25, 0xD5	; 213
     7c4:	9a 95       	dec	r25
     7c6:	f1 f7       	brne	.-4      	; 0x7c4 <int2lcd+0x2c>
     7c8:	00 00       	nop
//Takes a 8bit signed and displays it in base ten on the LCD. Leading 0's are 
//not displayed.
//
void int2lcd(int8_t number){
    //if < 0, print minus sign, then take 2's complement of number and display
    if(number < 0){send_lcd(CHAR_BYTE, '-'); _delay_us(40); uint2lcd(~number+1);}  
     7ca:	81 95       	neg	r24
     7cc:	0c 94 62 03 	jmp	0x6c4	; 0x6c4 <uint2lcd>

000007d0 <cursor_on>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     7d0:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     7d2:	77 9b       	sbis	0x0e, 7	; 14
     7d4:	fe cf       	rjmp	.-4      	; 0x7d2 <cursor_on+0x2>
  SPDR = byte;                        //send payload
     7d6:	8e e0       	ldi	r24, 0x0E	; 14
     7d8:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     7da:	77 9b       	sbis	0x0e, 7	; 14
     7dc:	fe cf       	rjmp	.-4      	; 0x7da <cursor_on+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     7de:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     7e2:	88 60       	ori	r24, 0x08	; 8
     7e4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     7e8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     7ec:	87 7f       	andi	r24, 0xF7	; 247
     7ee:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     7f2:	08 95       	ret

000007f4 <cursor_off>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     7f4:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     7f6:	77 9b       	sbis	0x0e, 7	; 14
     7f8:	fe cf       	rjmp	.-4      	; 0x7f6 <cursor_off+0x2>
  SPDR = byte;                        //send payload
     7fa:	8c e0       	ldi	r24, 0x0C	; 12
     7fc:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     7fe:	77 9b       	sbis	0x0e, 7	; 14
     800:	fe cf       	rjmp	.-4      	; 0x7fe <cursor_off+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     802:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     806:	88 60       	ori	r24, 0x08	; 8
     808:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     80c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     810:	87 7f       	andi	r24, 0xF7	; 247
     812:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     816:	08 95       	ret

00000818 <shift_right>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     818:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     81a:	77 9b       	sbis	0x0e, 7	; 14
     81c:	fe cf       	rjmp	.-4      	; 0x81a <shift_right+0x2>
  SPDR = byte;                        //send payload
     81e:	8e e1       	ldi	r24, 0x1E	; 30
     820:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     822:	77 9b       	sbis	0x0e, 7	; 14
     824:	fe cf       	rjmp	.-4      	; 0x822 <shift_right+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     826:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     82a:	88 60       	ori	r24, 0x08	; 8
     82c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     830:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     834:	87 7f       	andi	r24, 0xF7	; 247
     836:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     83a:	08 95       	ret

0000083c <shift_left>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     83c:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     83e:	77 9b       	sbis	0x0e, 7	; 14
     840:	fe cf       	rjmp	.-4      	; 0x83e <shift_left+0x2>
  SPDR = byte;                        //send payload
     842:	88 e1       	ldi	r24, 0x18	; 24
     844:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     846:	77 9b       	sbis	0x0e, 7	; 14
     848:	fe cf       	rjmp	.-4      	; 0x846 <shift_left+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     84a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     84e:	88 60       	ori	r24, 0x08	; 8
     850:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     854:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     858:	87 7f       	andi	r24, 0xF7	; 247
     85a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     85e:	08 95       	ret

00000860 <strobe_lcd>:
     860:	e2 e6       	ldi	r30, 0x62	; 98
     862:	f0 e0       	ldi	r31, 0x00	; 0
     864:	80 81       	ld	r24, Z
     866:	88 60       	ori	r24, 0x08	; 8
     868:	80 83       	st	Z, r24
     86a:	80 81       	ld	r24, Z
     86c:	87 7f       	andi	r24, 0xF7	; 247
     86e:	80 83       	st	Z, r24
     870:	08 95       	ret

00000872 <clear_display>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     872:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     874:	77 9b       	sbis	0x0e, 7	; 14
     876:	fe cf       	rjmp	.-4      	; 0x874 <clear_display+0x2>
  SPDR = byte;                        //send payload
     878:	81 e0       	ldi	r24, 0x01	; 1
     87a:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     87c:	77 9b       	sbis	0x0e, 7	; 14
     87e:	fe cf       	rjmp	.-4      	; 0x87c <clear_display+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     880:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     884:	88 60       	ori	r24, 0x08	; 8
     886:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     88a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     88e:	87 7f       	andi	r24, 0xF7	; 247
     890:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     894:	8f e1       	ldi	r24, 0x1F	; 31
     896:	9c e1       	ldi	r25, 0x1C	; 28
     898:	01 97       	sbiw	r24, 0x01	; 1
     89a:	f1 f7       	brne	.-4      	; 0x898 <clear_display+0x26>
     89c:	00 c0       	rjmp	.+0      	; 0x89e <clear_display+0x2c>
     89e:	00 00       	nop
     8a0:	08 95       	ret

000008a2 <cursor_home>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     8a2:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     8a4:	77 9b       	sbis	0x0e, 7	; 14
     8a6:	fe cf       	rjmp	.-4      	; 0x8a4 <cursor_home+0x2>
  SPDR = byte;                        //send payload
     8a8:	82 e0       	ldi	r24, 0x02	; 2
     8aa:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     8ac:	77 9b       	sbis	0x0e, 7	; 14
     8ae:	fe cf       	rjmp	.-4      	; 0x8ac <cursor_home+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     8b0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8b4:	88 60       	ori	r24, 0x08	; 8
     8b6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8ba:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8be:	87 7f       	andi	r24, 0xF7	; 247
     8c0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8c4:	8f e6       	ldi	r24, 0x6F	; 111
     8c6:	97 e1       	ldi	r25, 0x17	; 23
     8c8:	01 97       	sbiw	r24, 0x01	; 1
     8ca:	f1 f7       	brne	.-4      	; 0x8c8 <cursor_home+0x26>
     8cc:	00 c0       	rjmp	.+0      	; 0x8ce <cursor_home+0x2c>
     8ce:	00 00       	nop
     8d0:	08 95       	ret

000008d2 <line2_col1>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     8d2:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     8d4:	77 9b       	sbis	0x0e, 7	; 14
     8d6:	fe cf       	rjmp	.-4      	; 0x8d4 <line2_col1+0x2>
  SPDR = byte;                        //send payload
     8d8:	80 ec       	ldi	r24, 0xC0	; 192
     8da:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     8dc:	77 9b       	sbis	0x0e, 7	; 14
     8de:	fe cf       	rjmp	.-4      	; 0x8dc <line2_col1+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     8e0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8e4:	88 60       	ori	r24, 0x08	; 8
     8e6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8ea:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8ee:	87 7f       	andi	r24, 0xF7	; 247
     8f0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8f4:	85 ed       	ldi	r24, 0xD5	; 213
     8f6:	8a 95       	dec	r24
     8f8:	f1 f7       	brne	.-4      	; 0x8f6 <line2_col1+0x24>
     8fa:	00 00       	nop
     8fc:	08 95       	ret

000008fe <line1_col1>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     8fe:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     900:	77 9b       	sbis	0x0e, 7	; 14
     902:	fe cf       	rjmp	.-4      	; 0x900 <line1_col1+0x2>
  SPDR = byte;                        //send payload
     904:	80 e8       	ldi	r24, 0x80	; 128
     906:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     908:	77 9b       	sbis	0x0e, 7	; 14
     90a:	fe cf       	rjmp	.-4      	; 0x908 <line1_col1+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     90c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     910:	88 60       	ori	r24, 0x08	; 8
     912:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     916:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     91a:	87 7f       	andi	r24, 0xF7	; 247
     91c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     920:	85 ed       	ldi	r24, 0xD5	; 213
     922:	8a 95       	dec	r24
     924:	f1 f7       	brne	.-4      	; 0x922 <line1_col1+0x24>
     926:	00 00       	nop
     928:	08 95       	ret

0000092a <fill_spaces>:

//-----------------------------------------------------------------------------
//                          fill_spaces   
//
//Fill an entire line with spaces.
void fill_spaces(void){
     92a:	90 e1       	ldi	r25, 0x10	; 16
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     92c:	31 e0       	ldi	r19, 0x01	; 1
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
  SPDR = byte;                        //send payload
     92e:	20 e2       	ldi	r18, 0x20	; 32
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     930:	3f b9       	out	0x0f, r19	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     932:	77 9b       	sbis	0x0e, 7	; 14
     934:	fe cf       	rjmp	.-4      	; 0x932 <fill_spaces+0x8>
  SPDR = byte;                        //send payload
     936:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     938:	77 9b       	sbis	0x0e, 7	; 14
     93a:	fe cf       	rjmp	.-4      	; 0x938 <fill_spaces+0xe>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     93c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     940:	88 60       	ori	r24, 0x08	; 8
     942:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     946:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     94a:	87 7f       	andi	r24, 0xF7	; 247
     94c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     950:	85 ed       	ldi	r24, 0xD5	; 213
     952:	8a 95       	dec	r24
     954:	f1 f7       	brne	.-4      	; 0x952 <fill_spaces+0x28>
     956:	00 00       	nop
     958:	91 50       	subi	r25, 0x01	; 1
//                          fill_spaces   
//
//Fill an entire line with spaces.
void fill_spaces(void){
	uint8_t i;
	for (i=0; i<=(NUM_LCD_CHARS-1); i++){
     95a:	51 f7       	brne	.-44     	; 0x930 <fill_spaces+0x6>
		send_lcd(CHAR_BYTE, ' '); 
                _delay_us(40);  //40us wait between characters
	}
}  
     95c:	08 95       	ret

0000095e <char2lcd>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     95e:	91 e0       	ldi	r25, 0x01	; 1
     960:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     962:	77 9b       	sbis	0x0e, 7	; 14
     964:	fe cf       	rjmp	.-4      	; 0x962 <char2lcd+0x4>
  SPDR = byte;                        //send payload
     966:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     968:	77 9b       	sbis	0x0e, 7	; 14
     96a:	fe cf       	rjmp	.-4      	; 0x968 <char2lcd+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     96c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     970:	88 60       	ori	r24, 0x08	; 8
     972:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     976:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     97a:	87 7f       	andi	r24, 0xF7	; 247
     97c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     980:	08 95       	ret

00000982 <string2lcd>:

//----------------------------------------------------------------------------
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
     982:	fc 01       	movw	r30, r24
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     984:	40 e0       	ldi	r20, 0x00	; 0
     986:	50 e0       	ldi	r21, 0x00	; 0
     988:	60 e0       	ldi	r22, 0x00	; 0
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     98a:	71 e0       	ldi	r23, 0x01	; 1
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     98c:	df 01       	movw	r26, r30
     98e:	a4 0f       	add	r26, r20
     990:	b5 1f       	adc	r27, r21
     992:	8c 91       	ld	r24, X
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     994:	7f b9       	out	0x0f, r23	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     996:	77 9b       	sbis	0x0e, 7	; 14
     998:	fe cf       	rjmp	.-4      	; 0x996 <string2lcd+0x14>
  SPDR = byte;                        //send payload
     99a:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     99c:	77 9b       	sbis	0x0e, 7	; 14
     99e:	fe cf       	rjmp	.-4      	; 0x99c <string2lcd+0x1a>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     9a0:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9a4:	98 60       	ori	r25, 0x08	; 8
     9a6:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9aa:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9ae:	97 7f       	andi	r25, 0xF7	; 247
     9b0:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9b4:	85 ed       	ldi	r24, 0xD5	; 213
     9b6:	8a 95       	dec	r24
     9b8:	f1 f7       	brne	.-4      	; 0x9b6 <string2lcd+0x34>
     9ba:	00 00       	nop
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     9bc:	6f 5f       	subi	r22, 0xFF	; 255
     9be:	46 2f       	mov	r20, r22
     9c0:	50 e0       	ldi	r21, 0x00	; 0
     9c2:	df 01       	movw	r26, r30
     9c4:	0d 90       	ld	r0, X+
     9c6:	00 20       	and	r0, r0
     9c8:	e9 f7       	brne	.-6      	; 0x9c4 <string2lcd+0x42>
     9ca:	9d 01       	movw	r18, r26
     9cc:	2e 1b       	sub	r18, r30
     9ce:	3f 0b       	sbc	r19, r31
     9d0:	22 50       	subi	r18, 0x02	; 2
     9d2:	31 09       	sbc	r19, r1
     9d4:	24 17       	cp	r18, r20
     9d6:	35 07       	cpc	r19, r21
     9d8:	c8 f6       	brcc	.-78     	; 0x98c <string2lcd+0xa>
  _delay_us(40);  //execution takes 37us per character
  }                  
} 
     9da:	08 95       	ret

000009dc <lcd_init>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     9dc:	8f ef       	ldi	r24, 0xFF	; 255
     9de:	99 ef       	ldi	r25, 0xF9	; 249
     9e0:	01 97       	sbiw	r24, 0x01	; 1
     9e2:	f1 f7       	brne	.-4      	; 0x9e0 <lcd_init+0x4>
     9e4:	00 c0       	rjmp	.+0      	; 0x9e6 <lcd_init+0xa>
     9e6:	00 00       	nop
//
void lcd_init(void){
  _delay_ms(16);      //power up delay
#if SPI_MODE==1       //assumption is that the SPI port is intialized
  //TODO: kludge alert! setting of DDRF should not be here, but is probably harmless.
  DDRF=0x08;          //port F bit 3 is enable for LCD in SPI mode
     9e8:	88 e0       	ldi	r24, 0x08	; 8
     9ea:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     9ee:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     9f0:	77 9b       	sbis	0x0e, 7	; 14
     9f2:	fe cf       	rjmp	.-4      	; 0x9f0 <lcd_init+0x14>
  SPDR = byte;                        //send payload
     9f4:	80 e3       	ldi	r24, 0x30	; 48
     9f6:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     9f8:	77 9b       	sbis	0x0e, 7	; 14
     9fa:	fe cf       	rjmp	.-4      	; 0x9f8 <lcd_init+0x1c>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     9fc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a00:	88 60       	ori	r24, 0x08	; 8
     a02:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a06:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a0a:	87 7f       	andi	r24, 0xF7	; 247
     a0c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a10:	8f e5       	ldi	r24, 0x5F	; 95
     a12:	9d e6       	ldi	r25, 0x6D	; 109
     a14:	01 97       	sbiw	r24, 0x01	; 1
     a16:	f1 f7       	brne	.-4      	; 0xa14 <lcd_init+0x38>
     a18:	00 c0       	rjmp	.+0      	; 0xa1a <lcd_init+0x3e>
     a1a:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     a1c:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a1e:	77 9b       	sbis	0x0e, 7	; 14
     a20:	fe cf       	rjmp	.-4      	; 0xa1e <lcd_init+0x42>
  SPDR = byte;                        //send payload
     a22:	80 e3       	ldi	r24, 0x30	; 48
     a24:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a26:	77 9b       	sbis	0x0e, 7	; 14
     a28:	fe cf       	rjmp	.-4      	; 0xa26 <lcd_init+0x4a>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     a2a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a2e:	88 60       	ori	r24, 0x08	; 8
     a30:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a34:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a38:	87 7f       	andi	r24, 0xF7	; 247
     a3a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a3e:	8f e5       	ldi	r24, 0x5F	; 95
     a40:	9d e6       	ldi	r25, 0x6D	; 109
     a42:	01 97       	sbiw	r24, 0x01	; 1
     a44:	f1 f7       	brne	.-4      	; 0xa42 <lcd_init+0x66>
     a46:	00 c0       	rjmp	.+0      	; 0xa48 <lcd_init+0x6c>
     a48:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     a4a:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a4c:	77 9b       	sbis	0x0e, 7	; 14
     a4e:	fe cf       	rjmp	.-4      	; 0xa4c <lcd_init+0x70>
  SPDR = byte;                        //send payload
     a50:	80 e3       	ldi	r24, 0x30	; 48
     a52:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a54:	77 9b       	sbis	0x0e, 7	; 14
     a56:	fe cf       	rjmp	.-4      	; 0xa54 <lcd_init+0x78>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     a58:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a5c:	88 60       	ori	r24, 0x08	; 8
     a5e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a62:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a66:	87 7f       	andi	r24, 0xF7	; 247
     a68:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a6c:	8f e5       	ldi	r24, 0x5F	; 95
     a6e:	9d e6       	ldi	r25, 0x6D	; 109
     a70:	01 97       	sbiw	r24, 0x01	; 1
     a72:	f1 f7       	brne	.-4      	; 0xa70 <lcd_init+0x94>
     a74:	00 c0       	rjmp	.+0      	; 0xa76 <lcd_init+0x9a>
     a76:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     a78:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a7a:	77 9b       	sbis	0x0e, 7	; 14
     a7c:	fe cf       	rjmp	.-4      	; 0xa7a <lcd_init+0x9e>
  SPDR = byte;                        //send payload
     a7e:	88 e3       	ldi	r24, 0x38	; 56
     a80:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a82:	77 9b       	sbis	0x0e, 7	; 14
     a84:	fe cf       	rjmp	.-4      	; 0xa82 <lcd_init+0xa6>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     a86:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a8a:	88 60       	ori	r24, 0x08	; 8
     a8c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a90:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a94:	87 7f       	andi	r24, 0xF7	; 247
     a96:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a9a:	8f e1       	ldi	r24, 0x1F	; 31
     a9c:	9e e4       	ldi	r25, 0x4E	; 78
     a9e:	01 97       	sbiw	r24, 0x01	; 1
     aa0:	f1 f7       	brne	.-4      	; 0xa9e <lcd_init+0xc2>
     aa2:	00 c0       	rjmp	.+0      	; 0xaa4 <lcd_init+0xc8>
     aa4:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     aa6:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     aa8:	77 9b       	sbis	0x0e, 7	; 14
     aaa:	fe cf       	rjmp	.-4      	; 0xaa8 <lcd_init+0xcc>
  SPDR = byte;                        //send payload
     aac:	88 e0       	ldi	r24, 0x08	; 8
     aae:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ab0:	77 9b       	sbis	0x0e, 7	; 14
     ab2:	fe cf       	rjmp	.-4      	; 0xab0 <lcd_init+0xd4>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     ab4:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ab8:	88 60       	ori	r24, 0x08	; 8
     aba:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     abe:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ac2:	87 7f       	andi	r24, 0xF7	; 247
     ac4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ac8:	8f e1       	ldi	r24, 0x1F	; 31
     aca:	9e e4       	ldi	r25, 0x4E	; 78
     acc:	01 97       	sbiw	r24, 0x01	; 1
     ace:	f1 f7       	brne	.-4      	; 0xacc <lcd_init+0xf0>
     ad0:	00 c0       	rjmp	.+0      	; 0xad2 <lcd_init+0xf6>
     ad2:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ad4:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ad6:	77 9b       	sbis	0x0e, 7	; 14
     ad8:	fe cf       	rjmp	.-4      	; 0xad6 <lcd_init+0xfa>
  SPDR = byte;                        //send payload
     ada:	81 e0       	ldi	r24, 0x01	; 1
     adc:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ade:	77 9b       	sbis	0x0e, 7	; 14
     ae0:	fe cf       	rjmp	.-4      	; 0xade <lcd_init+0x102>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     ae2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ae6:	88 60       	ori	r24, 0x08	; 8
     ae8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     aec:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     af0:	87 7f       	andi	r24, 0xF7	; 247
     af2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     af6:	8f e1       	ldi	r24, 0x1F	; 31
     af8:	9e e4       	ldi	r25, 0x4E	; 78
     afa:	01 97       	sbiw	r24, 0x01	; 1
     afc:	f1 f7       	brne	.-4      	; 0xafa <lcd_init+0x11e>
     afe:	00 c0       	rjmp	.+0      	; 0xb00 <lcd_init+0x124>
     b00:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b02:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b04:	77 9b       	sbis	0x0e, 7	; 14
     b06:	fe cf       	rjmp	.-4      	; 0xb04 <lcd_init+0x128>
  SPDR = byte;                        //send payload
     b08:	86 e0       	ldi	r24, 0x06	; 6
     b0a:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b0c:	77 9b       	sbis	0x0e, 7	; 14
     b0e:	fe cf       	rjmp	.-4      	; 0xb0c <lcd_init+0x130>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b10:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b14:	88 60       	ori	r24, 0x08	; 8
     b16:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b1a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b1e:	87 7f       	andi	r24, 0xF7	; 247
     b20:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b24:	8f e1       	ldi	r24, 0x1F	; 31
     b26:	9e e4       	ldi	r25, 0x4E	; 78
     b28:	01 97       	sbiw	r24, 0x01	; 1
     b2a:	f1 f7       	brne	.-4      	; 0xb28 <lcd_init+0x14c>
     b2c:	00 c0       	rjmp	.+0      	; 0xb2e <lcd_init+0x152>
     b2e:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b30:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b32:	77 9b       	sbis	0x0e, 7	; 14
     b34:	fe cf       	rjmp	.-4      	; 0xb32 <lcd_init+0x156>
  SPDR = byte;                        //send payload
     b36:	8c e0       	ldi	r24, 0x0C	; 12
     b38:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b3a:	77 9b       	sbis	0x0e, 7	; 14
     b3c:	fe cf       	rjmp	.-4      	; 0xb3a <lcd_init+0x15e>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b3e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b42:	88 60       	ori	r24, 0x08	; 8
     b44:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b48:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b4c:	87 7f       	andi	r24, 0xF7	; 247
     b4e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b52:	8f e1       	ldi	r24, 0x1F	; 31
     b54:	9e e4       	ldi	r25, 0x4E	; 78
     b56:	01 97       	sbiw	r24, 0x01	; 1
     b58:	f1 f7       	brne	.-4      	; 0xb56 <lcd_init+0x17a>
     b5a:	00 c0       	rjmp	.+0      	; 0xb5c <lcd_init+0x180>
     b5c:	00 00       	nop
     b5e:	08 95       	ret

00000b60 <lcd_int32>:
void  lcd_int32(int32_t l,          //number to display
                uint8_t fieldwidth, //width of the field for display
                uint8_t decpos,     //0 if no decimal point, otherwise
                uint8_t bSigned,    //non-zero if the number should be treated as signed 
                uint8_t bZeroFill)  //non-zero if a specified fieldwidth is to be zero filled
{
     b60:	4f 92       	push	r4
     b62:	5f 92       	push	r5
     b64:	6f 92       	push	r6
     b66:	7f 92       	push	r7
     b68:	8f 92       	push	r8
     b6a:	9f 92       	push	r9
     b6c:	af 92       	push	r10
     b6e:	bf 92       	push	r11
     b70:	cf 92       	push	r12
     b72:	df 92       	push	r13
     b74:	ef 92       	push	r14
     b76:	ff 92       	push	r15
     b78:	0f 93       	push	r16
     b7a:	1f 93       	push	r17
     b7c:	cf 93       	push	r28
     b7e:	df 93       	push	r29
     b80:	cd b7       	in	r28, 0x3d	; 61
     b82:	de b7       	in	r29, 0x3e	; 62
     b84:	69 97       	sbiw	r28, 0x19	; 25
     b86:	0f b6       	in	r0, 0x3f	; 63
     b88:	f8 94       	cli
     b8a:	de bf       	out	0x3e, r29	; 62
     b8c:	0f be       	out	0x3f, r0	; 63
     b8e:	cd bf       	out	0x3d, r28	; 61
     b90:	14 2f       	mov	r17, r20
     b92:	42 2e       	mov	r4, r18
     b94:	5e 2c       	mov	r5, r14
      char    fillch;
      ldiv_t  qr;

      qr.quot = l; // initialize the quotient 

      if (bSigned){
     b96:	00 23       	and	r16, r16
     b98:	79 f0       	breq	.+30     	; 0xbb8 <lcd_int32+0x58>
        bSigned = (qr.quot<0);
     b9a:	6b 01       	movw	r12, r22
     b9c:	7c 01       	movw	r14, r24
     b9e:	cc 24       	eor	r12, r12
     ba0:	f7 fc       	sbrc	r15, 7
     ba2:	c3 94       	inc	r12
     ba4:	dd 24       	eor	r13, r13
     ba6:	ee 24       	eor	r14, r14
     ba8:	ff 24       	eor	r15, r15
     baa:	0c 2d       	mov	r16, r12
        qr.quot = labs(qr.quot);
     bac:	6b 01       	movw	r12, r22
     bae:	7c 01       	movw	r14, r24
     bb0:	97 fd       	sbrc	r25, 7
     bb2:	a3 c0       	rjmp	.+326    	; 0xcfa <lcd_int32+0x19a>
     bb4:	c7 01       	movw	r24, r14
     bb6:	b6 01       	movw	r22, r12
      }

      // convert the digits to the right of the decimal point 
      if (decpos){
     bb8:	44 20       	and	r4, r4
     bba:	09 f4       	brne	.+2      	; 0xbbe <lcd_int32+0x5e>
     bbc:	96 c0       	rjmp	.+300    	; 0xcea <lcd_int32+0x18a>
     bbe:	9e 01       	movw	r18, r28
     bc0:	2f 5f       	subi	r18, 0xFF	; 255
     bc2:	3f 4f       	sbci	r19, 0xFF	; 255
     bc4:	59 01       	movw	r10, r18
     bc6:	49 01       	movw	r8, r18
     bc8:	66 24       	eor	r6, r6
     bca:	6a 94       	dec	r6
     bcc:	64 0c       	add	r6, r4
     bce:	71 2c       	mov	r7, r1
     bd0:	3f ef       	ldi	r19, 0xFF	; 255
     bd2:	63 1a       	sub	r6, r19
     bd4:	73 0a       	sbc	r7, r19
     bd6:	6a 0c       	add	r6, r10
     bd8:	7b 1c       	adc	r7, r11
        for (; decpos ; decpos--){
          qr = ldiv(qr.quot, 10);
     bda:	2a e0       	ldi	r18, 0x0A	; 10
     bdc:	30 e0       	ldi	r19, 0x00	; 0
     bde:	40 e0       	ldi	r20, 0x00	; 0
     be0:	50 e0       	ldi	r21, 0x00	; 0
     be2:	0e 94 b0 07 	call	0xf60	; 0xf60 <__divmodsi4>
     be6:	e6 2f       	mov	r30, r22
     be8:	2a 8b       	std	Y+18, r18	; 0x12
     bea:	3b 8b       	std	Y+19, r19	; 0x13
     bec:	4c 8b       	std	Y+20, r20	; 0x14
     bee:	5d 8b       	std	Y+21, r21	; 0x15
     bf0:	6a 89       	ldd	r22, Y+18	; 0x12
     bf2:	7b 89       	ldd	r23, Y+19	; 0x13
     bf4:	8c 89       	ldd	r24, Y+20	; 0x14
     bf6:	9d 89       	ldd	r25, Y+21	; 0x15
          sline[i++] = qr.rem + '0';
     bf8:	20 e3       	ldi	r18, 0x30	; 48
     bfa:	2e 0f       	add	r18, r30
     bfc:	f4 01       	movw	r30, r8
     bfe:	21 93       	st	Z+, r18
     c00:	4f 01       	movw	r8, r30
        qr.quot = labs(qr.quot);
      }

      // convert the digits to the right of the decimal point 
      if (decpos){
        for (; decpos ; decpos--){
     c02:	6e 16       	cp	r6, r30
     c04:	7f 06       	cpc	r7, r31
     c06:	49 f7       	brne	.-46     	; 0xbda <lcd_int32+0x7a>
          qr = ldiv(qr.quot, 10);
          sline[i++] = qr.rem + '0';
        }
        sline[i++] = '.';
     c08:	99 24       	eor	r9, r9
     c0a:	93 94       	inc	r9
     c0c:	94 0c       	add	r9, r4
     c0e:	f5 01       	movw	r30, r10
     c10:	e4 0d       	add	r30, r4
     c12:	f1 1d       	adc	r31, r1
     c14:	2e e2       	ldi	r18, 0x2E	; 46
     c16:	20 83       	st	Z, r18
      }

      // convert the digits to the left of the decimal point 
      do{
          qr = ldiv(qr.quot, 10);
     c18:	2a e0       	ldi	r18, 0x0A	; 10
     c1a:	30 e0       	ldi	r19, 0x00	; 0
     c1c:	40 e0       	ldi	r20, 0x00	; 0
     c1e:	50 e0       	ldi	r21, 0x00	; 0
     c20:	0e 94 b0 07 	call	0xf60	; 0xf60 <__divmodsi4>
     c24:	e6 2f       	mov	r30, r22
     c26:	2a 8b       	std	Y+18, r18	; 0x12
     c28:	3b 8b       	std	Y+19, r19	; 0x13
     c2a:	4c 8b       	std	Y+20, r20	; 0x14
     c2c:	5d 8b       	std	Y+21, r21	; 0x15
     c2e:	6e 8b       	std	Y+22, r22	; 0x16
     c30:	7f 8b       	std	Y+23, r23	; 0x17
     c32:	88 8f       	std	Y+24, r24	; 0x18
     c34:	99 8f       	std	Y+25, r25	; 0x19
     c36:	6a 89       	ldd	r22, Y+18	; 0x12
     c38:	7b 89       	ldd	r23, Y+19	; 0x13
     c3a:	8c 89       	ldd	r24, Y+20	; 0x14
     c3c:	9d 89       	ldd	r25, Y+21	; 0x15
          sline[i++] = qr.rem + '0';
     c3e:	31 e0       	ldi	r19, 0x01	; 1
     c40:	39 0d       	add	r19, r9
     c42:	d5 01       	movw	r26, r10
     c44:	a9 0d       	add	r26, r9
     c46:	b1 1d       	adc	r27, r1
     c48:	e0 5d       	subi	r30, 0xD0	; 208
     c4a:	ec 93       	st	X, r30
     c4c:	93 2e       	mov	r9, r19
        }while(qr.quot);
     c4e:	61 15       	cp	r22, r1
     c50:	71 05       	cpc	r23, r1
     c52:	81 05       	cpc	r24, r1
     c54:	91 05       	cpc	r25, r1
     c56:	01 f7       	brne	.-64     	; 0xc18 <lcd_int32+0xb8>

      // fill the whole field if a width was specified
      if (fieldwidth){
     c58:	11 23       	and	r17, r17
     c5a:	61 f0       	breq	.+24     	; 0xc74 <lcd_int32+0x114>
        fillch = bZeroFill? '0': ' '; // determine the fill character
     c5c:	51 10       	cpse	r5, r1
     c5e:	4b c0       	rjmp	.+150    	; 0xcf6 <lcd_int32+0x196>
     c60:	90 e2       	ldi	r25, 0x20	; 32
        for (; i<fieldwidth ; ){sline[i++] = fillch;}
     c62:	31 17       	cp	r19, r17
     c64:	38 f4       	brcc	.+14     	; 0xc74 <lcd_int32+0x114>
     c66:	f5 01       	movw	r30, r10
     c68:	e3 0f       	add	r30, r19
     c6a:	f1 1d       	adc	r31, r1
     c6c:	90 83       	st	Z, r25
     c6e:	3f 5f       	subi	r19, 0xFF	; 255
     c70:	13 13       	cpse	r17, r19
     c72:	f9 cf       	rjmp	.-14     	; 0xc66 <lcd_int32+0x106>
      }

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}
     c74:	00 23       	and	r16, r16
     c76:	31 f0       	breq	.+12     	; 0xc84 <lcd_int32+0x124>
     c78:	f5 01       	movw	r30, r10
     c7a:	e3 0f       	add	r30, r19
     c7c:	f1 1d       	adc	r31, r1
     c7e:	9d e2       	ldi	r25, 0x2D	; 45
     c80:	90 83       	st	Z, r25
     c82:	3f 5f       	subi	r19, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c84:	21 e0       	ldi	r18, 0x01	; 1

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}

      // now output the formatted number
      do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
     c86:	31 50       	subi	r19, 0x01	; 1
     c88:	f5 01       	movw	r30, r10
     c8a:	e3 0f       	add	r30, r19
     c8c:	f1 1d       	adc	r31, r1
     c8e:	90 81       	ld	r25, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c90:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c92:	77 9b       	sbis	0x0e, 7	; 14
     c94:	fe cf       	rjmp	.-4      	; 0xc92 <lcd_int32+0x132>
  SPDR = byte;                        //send payload
     c96:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c98:	77 9b       	sbis	0x0e, 7	; 14
     c9a:	fe cf       	rjmp	.-4      	; 0xc98 <lcd_int32+0x138>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     c9c:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ca0:	98 60       	ori	r25, 0x08	; 8
     ca2:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ca6:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     caa:	97 7f       	andi	r25, 0xF7	; 247
     cac:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     cb0:	85 ed       	ldi	r24, 0xD5	; 213
     cb2:	8a 95       	dec	r24
     cb4:	f1 f7       	brne	.-4      	; 0xcb2 <lcd_int32+0x152>
     cb6:	00 00       	nop

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}

      // now output the formatted number
      do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
     cb8:	31 11       	cpse	r19, r1
     cba:	e5 cf       	rjmp	.-54     	; 0xc86 <lcd_int32+0x126>

}
     cbc:	69 96       	adiw	r28, 0x19	; 25
     cbe:	0f b6       	in	r0, 0x3f	; 63
     cc0:	f8 94       	cli
     cc2:	de bf       	out	0x3e, r29	; 62
     cc4:	0f be       	out	0x3f, r0	; 63
     cc6:	cd bf       	out	0x3d, r28	; 61
     cc8:	df 91       	pop	r29
     cca:	cf 91       	pop	r28
     ccc:	1f 91       	pop	r17
     cce:	0f 91       	pop	r16
     cd0:	ff 90       	pop	r15
     cd2:	ef 90       	pop	r14
     cd4:	df 90       	pop	r13
     cd6:	cf 90       	pop	r12
     cd8:	bf 90       	pop	r11
     cda:	af 90       	pop	r10
     cdc:	9f 90       	pop	r9
     cde:	8f 90       	pop	r8
     ce0:	7f 90       	pop	r7
     ce2:	6f 90       	pop	r6
     ce4:	5f 90       	pop	r5
     ce6:	4f 90       	pop	r4
     ce8:	08 95       	ret
                uint8_t decpos,     //0 if no decimal point, otherwise
                uint8_t bSigned,    //non-zero if the number should be treated as signed 
                uint8_t bZeroFill)  //non-zero if a specified fieldwidth is to be zero filled
{
      char    sline[NUM_LCD_CHARS+1];
      uint8_t i=0;
     cea:	91 2c       	mov	r9, r1
     cec:	9e 01       	movw	r18, r28
     cee:	2f 5f       	subi	r18, 0xFF	; 255
     cf0:	3f 4f       	sbci	r19, 0xFF	; 255
     cf2:	59 01       	movw	r10, r18
     cf4:	91 cf       	rjmp	.-222    	; 0xc18 <lcd_int32+0xb8>
          sline[i++] = qr.rem + '0';
        }while(qr.quot);

      // fill the whole field if a width was specified
      if (fieldwidth){
        fillch = bZeroFill? '0': ' '; // determine the fill character
     cf6:	90 e3       	ldi	r25, 0x30	; 48
     cf8:	b4 cf       	rjmp	.-152    	; 0xc62 <lcd_int32+0x102>

      qr.quot = l; // initialize the quotient 

      if (bSigned){
        bSigned = (qr.quot<0);
        qr.quot = labs(qr.quot);
     cfa:	f0 94       	com	r15
     cfc:	e0 94       	com	r14
     cfe:	d0 94       	com	r13
     d00:	c0 94       	com	r12
     d02:	c1 1c       	adc	r12, r1
     d04:	d1 1c       	adc	r13, r1
     d06:	e1 1c       	adc	r14, r1
     d08:	f1 1c       	adc	r15, r1
     d0a:	54 cf       	rjmp	.-344    	; 0xbb4 <lcd_int32+0x54>

00000d0c <lcd_int16>:
void    lcd_int16(int16_t l, 
                  uint8_t fieldwidth, 
                  uint8_t decpos, 
                  uint8_t bSigned,
                  uint8_t bZeroFill)
{
     d0c:	5f 92       	push	r5
     d0e:	6f 92       	push	r6
     d10:	7f 92       	push	r7
     d12:	8f 92       	push	r8
     d14:	9f 92       	push	r9
     d16:	af 92       	push	r10
     d18:	bf 92       	push	r11
     d1a:	cf 92       	push	r12
     d1c:	df 92       	push	r13
     d1e:	ef 92       	push	r14
     d20:	ff 92       	push	r15
     d22:	0f 93       	push	r16
     d24:	1f 93       	push	r17
     d26:	cf 93       	push	r28
     d28:	df 93       	push	r29
     d2a:	cd b7       	in	r28, 0x3d	; 61
     d2c:	de b7       	in	r29, 0x3e	; 62
     d2e:	61 97       	sbiw	r28, 0x11	; 17
     d30:	0f b6       	in	r0, 0x3f	; 63
     d32:	f8 94       	cli
     d34:	de bf       	out	0x3e, r29	; 62
     d36:	0f be       	out	0x3f, r0	; 63
     d38:	cd bf       	out	0x3d, r28	; 61
     d3a:	5c 01       	movw	r10, r24
     d3c:	16 2f       	mov	r17, r22
     d3e:	74 2e       	mov	r7, r20
//        uint8_t bSigned;   Now an argument for signed or not

        // initialize the quotient 
        qr.quot = l;

        if ( (bSigned=(qr.quot<0)) )
     d40:	6b 2c       	mov	r6, r11
     d42:	66 1c       	adc	r6, r6
     d44:	66 24       	eor	r6, r6
     d46:	66 1c       	adc	r6, r6
     d48:	56 2c       	mov	r5, r6
     d4a:	9c 01       	movw	r18, r24
     d4c:	97 fd       	sbrc	r25, 7
     d4e:	9b c0       	rjmp	.+310    	; 0xe86 <lcd_int16+0x17a>
                qr.quot = -qr.quot;

        // convert the digits to the right of the decimal point 
        if (decpos){
     d50:	77 20       	and	r7, r7
     d52:	09 f4       	brne	.+2      	; 0xd56 <lcd_int16+0x4a>
     d54:	8d c0       	rjmp	.+282    	; 0xe70 <lcd_int16+0x164>
     d56:	ce 01       	movw	r24, r28
     d58:	01 96       	adiw	r24, 0x01	; 1
     d5a:	7c 01       	movw	r14, r24
     d5c:	6c 01       	movw	r12, r24
     d5e:	88 24       	eor	r8, r8
     d60:	8a 94       	dec	r8
     d62:	87 0c       	add	r8, r7
     d64:	91 2c       	mov	r9, r1
     d66:	9f ef       	ldi	r25, 0xFF	; 255
     d68:	89 1a       	sub	r8, r25
     d6a:	99 0a       	sbc	r9, r25
     d6c:	8e 0c       	add	r8, r14
     d6e:	9f 1c       	adc	r9, r15
          for (; decpos ; decpos--){
            qr = div(qr.quot, 10);
     d70:	6a e0       	ldi	r22, 0x0A	; 10
     d72:	70 e0       	ldi	r23, 0x00	; 0
     d74:	c9 01       	movw	r24, r18
     d76:	0e 94 9c 07 	call	0xf38	; 0xf38 <__divmodhi4>
     d7a:	46 2f       	mov	r20, r22
     d7c:	24 2f       	mov	r18, r20
     d7e:	37 2f       	mov	r19, r23
            sline[i++] = qr.rem + '0';
     d80:	80 5d       	subi	r24, 0xD0	; 208
     d82:	f6 01       	movw	r30, r12
     d84:	81 93       	st	Z+, r24
     d86:	6f 01       	movw	r12, r30
        if ( (bSigned=(qr.quot<0)) )
                qr.quot = -qr.quot;

        // convert the digits to the right of the decimal point 
        if (decpos){
          for (; decpos ; decpos--){
     d88:	e8 15       	cp	r30, r8
     d8a:	f9 05       	cpc	r31, r9
     d8c:	89 f7       	brne	.-30     	; 0xd70 <lcd_int16+0x64>
            qr = div(qr.quot, 10);
            sline[i++] = qr.rem + '0';
          }
          sline[i++] = '.';
     d8e:	dd 24       	eor	r13, r13
     d90:	d3 94       	inc	r13
     d92:	d7 0c       	add	r13, r7
     d94:	f7 01       	movw	r30, r14
     d96:	e7 0d       	add	r30, r7
     d98:	f1 1d       	adc	r31, r1
     d9a:	8e e2       	ldi	r24, 0x2E	; 46
     d9c:	80 83       	st	Z, r24
     d9e:	01 c0       	rjmp	.+2      	; 0xda2 <lcd_int16+0x96>

        // convert the digits to the left of the decimal point 
        do
        {
                qr = div(qr.quot, 10);
                sline[i++] = qr.rem + '0';
     da0:	d9 2e       	mov	r13, r25
        }

        // convert the digits to the left of the decimal point 
        do
        {
                qr = div(qr.quot, 10);
     da2:	6a e0       	ldi	r22, 0x0A	; 10
     da4:	70 e0       	ldi	r23, 0x00	; 0
     da6:	c9 01       	movw	r24, r18
     da8:	0e 94 9c 07 	call	0xf38	; 0xf38 <__divmodhi4>
     dac:	46 2f       	mov	r20, r22
     dae:	24 2f       	mov	r18, r20
     db0:	37 2f       	mov	r19, r23
                sline[i++] = qr.rem + '0';
     db2:	91 e0       	ldi	r25, 0x01	; 1
     db4:	9d 0d       	add	r25, r13
     db6:	f7 01       	movw	r30, r14
     db8:	ed 0d       	add	r30, r13
     dba:	f1 1d       	adc	r31, r1
     dbc:	80 5d       	subi	r24, 0xD0	; 208
     dbe:	80 83       	st	Z, r24
        }
        while(qr.quot);
     dc0:	21 15       	cp	r18, r1
     dc2:	31 05       	cpc	r19, r1
     dc4:	69 f7       	brne	.-38     	; 0xda0 <lcd_int16+0x94>

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
     dc6:	01 11       	cpse	r16, r1
     dc8:	58 c0       	rjmp	.+176    	; 0xe7a <lcd_int16+0x16e>
     dca:	b7 fc       	sbrc	r11, 7
     dcc:	61 c0       	rjmp	.+194    	; 0xe90 <lcd_int16+0x184>
                sline[i++] = '-';
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
     dce:	11 23       	and	r17, r17
     dd0:	a9 f0       	breq	.+42     	; 0xdfc <lcd_int16+0xf0>
     dd2:	71 2c       	mov	r7, r1
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
     dd4:	80 e2       	ldi	r24, 0x20	; 32
          for (; i<(fieldwidth-bSigned) ; ){ sline[i++] = fillch;}
     dd6:	29 2f       	mov	r18, r25
     dd8:	30 e0       	ldi	r19, 0x00	; 0
     dda:	41 2f       	mov	r20, r17
     ddc:	50 e0       	ldi	r21, 0x00	; 0
     dde:	46 19       	sub	r20, r6
     de0:	57 09       	sbc	r21, r7
     de2:	24 17       	cp	r18, r20
     de4:	35 07       	cpc	r19, r21
     de6:	54 f4       	brge	.+20     	; 0xdfc <lcd_int16+0xf0>
     de8:	9f 5f       	subi	r25, 0xFF	; 255
     dea:	f7 01       	movw	r30, r14
     dec:	e2 0f       	add	r30, r18
     dee:	f3 1f       	adc	r31, r19
     df0:	80 83       	st	Z, r24
     df2:	29 2f       	mov	r18, r25
     df4:	30 e0       	ldi	r19, 0x00	; 0
     df6:	24 17       	cp	r18, r20
     df8:	35 07       	cpc	r19, r21
     dfa:	b4 f3       	brlt	.-20     	; 0xde8 <lcd_int16+0xdc>
        }

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}
     dfc:	55 20       	and	r5, r5
     dfe:	31 f0       	breq	.+12     	; 0xe0c <lcd_int16+0x100>
     e00:	f7 01       	movw	r30, r14
     e02:	e9 0f       	add	r30, r25
     e04:	f1 1d       	adc	r31, r1
     e06:	8d e2       	ldi	r24, 0x2D	; 45
     e08:	80 83       	st	Z, r24
     e0a:	9f 5f       	subi	r25, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e0c:	21 e0       	ldi	r18, 0x01	; 1

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}

        // now output the formatted number 
            do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
     e0e:	91 50       	subi	r25, 0x01	; 1
     e10:	f7 01       	movw	r30, r14
     e12:	e9 0f       	add	r30, r25
     e14:	f1 1d       	adc	r31, r1
     e16:	80 81       	ld	r24, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e18:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e1a:	77 9b       	sbis	0x0e, 7	; 14
     e1c:	fe cf       	rjmp	.-4      	; 0xe1a <lcd_int16+0x10e>
  SPDR = byte;                        //send payload
     e1e:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e20:	77 9b       	sbis	0x0e, 7	; 14
     e22:	fe cf       	rjmp	.-4      	; 0xe20 <lcd_int16+0x114>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     e24:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e28:	88 60       	ori	r24, 0x08	; 8
     e2a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e2e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e32:	87 7f       	andi	r24, 0xF7	; 247
     e34:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e38:	e5 ed       	ldi	r30, 0xD5	; 213
     e3a:	ea 95       	dec	r30
     e3c:	f1 f7       	brne	.-4      	; 0xe3a <lcd_int16+0x12e>
     e3e:	00 00       	nop

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}

        // now output the formatted number 
            do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
     e40:	91 11       	cpse	r25, r1
     e42:	e5 cf       	rjmp	.-54     	; 0xe0e <lcd_int16+0x102>
}
     e44:	61 96       	adiw	r28, 0x11	; 17
     e46:	0f b6       	in	r0, 0x3f	; 63
     e48:	f8 94       	cli
     e4a:	de bf       	out	0x3e, r29	; 62
     e4c:	0f be       	out	0x3f, r0	; 63
     e4e:	cd bf       	out	0x3d, r28	; 61
     e50:	df 91       	pop	r29
     e52:	cf 91       	pop	r28
     e54:	1f 91       	pop	r17
     e56:	0f 91       	pop	r16
     e58:	ff 90       	pop	r15
     e5a:	ef 90       	pop	r14
     e5c:	df 90       	pop	r13
     e5e:	cf 90       	pop	r12
     e60:	bf 90       	pop	r11
     e62:	af 90       	pop	r10
     e64:	9f 90       	pop	r9
     e66:	8f 90       	pop	r8
     e68:	7f 90       	pop	r7
     e6a:	6f 90       	pop	r6
     e6c:	5f 90       	pop	r5
     e6e:	08 95       	ret
                  uint8_t decpos, 
                  uint8_t bSigned,
                  uint8_t bZeroFill)
{
        char    sline[NUM_LCD_CHARS+1];
        uint8_t i=0;
     e70:	d1 2c       	mov	r13, r1
     e72:	ce 01       	movw	r24, r28
     e74:	01 96       	adiw	r24, 0x01	; 1
     e76:	7c 01       	movw	r14, r24
     e78:	94 cf       	rjmp	.-216    	; 0xda2 <lcd_int16+0x96>
                sline[i++] = '-';
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
     e7a:	11 23       	and	r17, r17
     e7c:	09 f4       	brne	.+2      	; 0xe80 <lcd_int16+0x174>
     e7e:	be cf       	rjmp	.-132    	; 0xdfc <lcd_int16+0xf0>
     e80:	71 2c       	mov	r7, r1
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
     e82:	80 e3       	ldi	r24, 0x30	; 48
     e84:	a8 cf       	rjmp	.-176    	; 0xdd6 <lcd_int16+0xca>
     e86:	22 27       	eor	r18, r18
     e88:	33 27       	eor	r19, r19
     e8a:	28 1b       	sub	r18, r24
     e8c:	39 0b       	sbc	r19, r25
     e8e:	60 cf       	rjmp	.-320    	; 0xd50 <lcd_int16+0x44>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
     e90:	d3 94       	inc	r13
     e92:	d3 94       	inc	r13
     e94:	f7 01       	movw	r30, r14
     e96:	e9 0f       	add	r30, r25
     e98:	f1 1d       	adc	r31, r1
     e9a:	8d e2       	ldi	r24, 0x2D	; 45
     e9c:	80 83       	st	Z, r24
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
     e9e:	11 23       	and	r17, r17
     ea0:	59 f0       	breq	.+22     	; 0xeb8 <lcd_int16+0x1ac>
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
          for (; i<(fieldwidth-bSigned) ; ){ sline[i++] = fillch;}
     ea2:	2d 2d       	mov	r18, r13
     ea4:	30 e0       	ldi	r19, 0x00	; 0
     ea6:	41 2f       	mov	r20, r17
     ea8:	50 e0       	ldi	r21, 0x00	; 0
     eaa:	24 17       	cp	r18, r20
     eac:	35 07       	cpc	r19, r21
     eae:	24 f4       	brge	.+8      	; 0xeb8 <lcd_int16+0x1ac>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
     eb0:	9d 2d       	mov	r25, r13
                bSigned = 0;
     eb2:	51 2c       	mov	r5, r1
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
     eb4:	80 e2       	ldi	r24, 0x20	; 32
     eb6:	98 cf       	rjmp	.-208    	; 0xde8 <lcd_int16+0xdc>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
     eb8:	9d 2d       	mov	r25, r13
     eba:	a8 cf       	rjmp	.-176    	; 0xe0c <lcd_int16+0x100>

00000ebc <main>:
	and while loop are defined. The LED display is updated continuously 
	in the loop.
Parameters: NA
**********************************************************************/
int main() {
   ASSR |= (1<<AS0);
     ebc:	80 b7       	in	r24, 0x30	; 48
     ebe:	88 60       	ori	r24, 0x08	; 8
     ec0:	80 bf       	out	0x30, r24	; 48
   TIMSK |= (1<<TOIE0);			//enable interrupts
     ec2:	87 b7       	in	r24, 0x37	; 55
     ec4:	81 60       	ori	r24, 0x01	; 1
     ec6:	87 bf       	out	0x37, r24	; 55
   TCCR0 |= (1<<CS00);			//normal mode, no prescale
     ec8:	83 b7       	in	r24, 0x33	; 51
     eca:	81 60       	ori	r24, 0x01	; 1
     ecc:	83 bf       	out	0x33, r24	; 51
//   TIMSK
//   ETMISK
//   TIFR
//   TCNT1 = 0x00; 		//Initialize TNCT1 to 0

   DDRC |= 0xFF; 
     ece:	84 b3       	in	r24, 0x14	; 20
     ed0:	9f ef       	ldi	r25, 0xFF	; 255
     ed2:	94 bb       	out	0x14, r25	; 20
   DDRB |= 0xF0;				//PB4-6 is SEL0-2, PB7 is PWM
     ed4:	87 b3       	in	r24, 0x17	; 23
     ed6:	80 6f       	ori	r24, 0xF0	; 240
     ed8:	87 bb       	out	0x17, r24	; 23
   DDRE |= 0x40;				//PE6 is SHIFT_LD_N
     eda:	16 9a       	sbi	0x02, 6	; 2
   DDRD |= 0x0B;				//PE1 is CLK_INH and PE2 is SRCLK
     edc:	81 b3       	in	r24, 0x11	; 17
     ede:	8b 60       	ori	r24, 0x0B	; 11
     ee0:	81 bb       	out	0x11, r24	; 17
   PORTC |= 0x00;
     ee2:	85 b3       	in	r24, 0x15	; 21
     ee4:	85 bb       	out	0x15, r24	; 21
   PORTD |= 0x02;
     ee6:	91 9a       	sbi	0x12, 1	; 18
   PORTE |= 0xFF;
     ee8:	83 b1       	in	r24, 0x03	; 3
     eea:	93 b9       	out	0x03, r25	; 3
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
     eec:	87 b3       	in	r24, 0x17	; 23
     eee:	87 60       	ori	r24, 0x07	; 7
     ef0:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
     ef2:	8d b1       	in	r24, 0x0d	; 13
     ef4:	8c 65       	ori	r24, 0x5C	; 92
     ef6:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
     ef8:	70 9a       	sbi	0x0e, 0	; 14
   PORTD |= 0x02;
   PORTE |= 0xFF;

   spi_init();				//Initalize SPI

   sei();				//Enable interrupts
     efa:	78 94       	sei
   
   while(1){
      clock_time();
     efc:	0e 94 19 02 	call	0x432	; 0x432 <clock_time>
     f00:	e6 e1       	ldi	r30, 0x16	; 22
     f02:	f1 e0       	ldi	r31, 0x01	; 1
     f04:	80 e0       	ldi	r24, 0x00	; 0

      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
         if(alarm){
     f06:	90 91 22 01 	lds	r25, 0x0122	; 0x800122 <alarm>
     f0a:	99 23       	and	r25, r25
     f0c:	29 f0       	breq	.+10     	; 0xf18 <main+0x5c>
	    segment_data[2] &= 0b011;
     f0e:	90 91 18 01 	lds	r25, 0x0118	; 0x800118 <__data_end+0x2>
     f12:	93 70       	andi	r25, 0x03	; 3
     f14:	90 93 18 01 	sts	0x0118, r25	; 0x800118 <__data_end+0x2>
	 }
	 PORTA = segment_data[j];	//Writes the segment data to PORTA aka the segments
     f18:	91 91       	ld	r25, Z+
     f1a:	9b bb       	out	0x1b, r25	; 27
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
     f1c:	98 2f       	mov	r25, r24
     f1e:	92 95       	swap	r25
     f20:	90 7f       	andi	r25, 0xF0	; 240
     f22:	98 bb       	out	0x18, r25	; 24
     f24:	af e1       	ldi	r26, 0x1F	; 31
     f26:	b3 e0       	ldi	r27, 0x03	; 3
     f28:	11 97       	sbiw	r26, 0x01	; 1
     f2a:	f1 f7       	brne	.-4      	; 0xf28 <main+0x6c>
     f2c:	00 c0       	rjmp	.+0      	; 0xf2e <main+0x72>
     f2e:	00 00       	nop
     f30:	8f 5f       	subi	r24, 0xFF	; 255
   sei();				//Enable interrupts
   
   while(1){
      clock_time();

      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
     f32:	85 30       	cpi	r24, 0x05	; 5
     f34:	41 f7       	brne	.-48     	; 0xf06 <main+0x4a>
     f36:	e2 cf       	rjmp	.-60     	; 0xefc <main+0x40>

00000f38 <__divmodhi4>:
     f38:	97 fb       	bst	r25, 7
     f3a:	07 2e       	mov	r0, r23
     f3c:	16 f4       	brtc	.+4      	; 0xf42 <__divmodhi4+0xa>
     f3e:	00 94       	com	r0
     f40:	07 d0       	rcall	.+14     	; 0xf50 <__divmodhi4_neg1>
     f42:	77 fd       	sbrc	r23, 7
     f44:	09 d0       	rcall	.+18     	; 0xf58 <__divmodhi4_neg2>
     f46:	0e 94 cf 07 	call	0xf9e	; 0xf9e <__udivmodhi4>
     f4a:	07 fc       	sbrc	r0, 7
     f4c:	05 d0       	rcall	.+10     	; 0xf58 <__divmodhi4_neg2>
     f4e:	3e f4       	brtc	.+14     	; 0xf5e <__divmodhi4_exit>

00000f50 <__divmodhi4_neg1>:
     f50:	90 95       	com	r25
     f52:	81 95       	neg	r24
     f54:	9f 4f       	sbci	r25, 0xFF	; 255
     f56:	08 95       	ret

00000f58 <__divmodhi4_neg2>:
     f58:	70 95       	com	r23
     f5a:	61 95       	neg	r22
     f5c:	7f 4f       	sbci	r23, 0xFF	; 255

00000f5e <__divmodhi4_exit>:
     f5e:	08 95       	ret

00000f60 <__divmodsi4>:
     f60:	05 2e       	mov	r0, r21
     f62:	97 fb       	bst	r25, 7
     f64:	1e f4       	brtc	.+6      	; 0xf6c <__divmodsi4+0xc>
     f66:	00 94       	com	r0
     f68:	0e 94 c7 07 	call	0xf8e	; 0xf8e <__negsi2>
     f6c:	57 fd       	sbrc	r21, 7
     f6e:	07 d0       	rcall	.+14     	; 0xf7e <__divmodsi4_neg2>
     f70:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <__udivmodsi4>
     f74:	07 fc       	sbrc	r0, 7
     f76:	03 d0       	rcall	.+6      	; 0xf7e <__divmodsi4_neg2>
     f78:	4e f4       	brtc	.+18     	; 0xf8c <__divmodsi4_exit>
     f7a:	0c 94 c7 07 	jmp	0xf8e	; 0xf8e <__negsi2>

00000f7e <__divmodsi4_neg2>:
     f7e:	50 95       	com	r21
     f80:	40 95       	com	r20
     f82:	30 95       	com	r19
     f84:	21 95       	neg	r18
     f86:	3f 4f       	sbci	r19, 0xFF	; 255
     f88:	4f 4f       	sbci	r20, 0xFF	; 255
     f8a:	5f 4f       	sbci	r21, 0xFF	; 255

00000f8c <__divmodsi4_exit>:
     f8c:	08 95       	ret

00000f8e <__negsi2>:
     f8e:	90 95       	com	r25
     f90:	80 95       	com	r24
     f92:	70 95       	com	r23
     f94:	61 95       	neg	r22
     f96:	7f 4f       	sbci	r23, 0xFF	; 255
     f98:	8f 4f       	sbci	r24, 0xFF	; 255
     f9a:	9f 4f       	sbci	r25, 0xFF	; 255
     f9c:	08 95       	ret

00000f9e <__udivmodhi4>:
     f9e:	aa 1b       	sub	r26, r26
     fa0:	bb 1b       	sub	r27, r27
     fa2:	51 e1       	ldi	r21, 0x11	; 17
     fa4:	07 c0       	rjmp	.+14     	; 0xfb4 <__udivmodhi4_ep>

00000fa6 <__udivmodhi4_loop>:
     fa6:	aa 1f       	adc	r26, r26
     fa8:	bb 1f       	adc	r27, r27
     faa:	a6 17       	cp	r26, r22
     fac:	b7 07       	cpc	r27, r23
     fae:	10 f0       	brcs	.+4      	; 0xfb4 <__udivmodhi4_ep>
     fb0:	a6 1b       	sub	r26, r22
     fb2:	b7 0b       	sbc	r27, r23

00000fb4 <__udivmodhi4_ep>:
     fb4:	88 1f       	adc	r24, r24
     fb6:	99 1f       	adc	r25, r25
     fb8:	5a 95       	dec	r21
     fba:	a9 f7       	brne	.-22     	; 0xfa6 <__udivmodhi4_loop>
     fbc:	80 95       	com	r24
     fbe:	90 95       	com	r25
     fc0:	bc 01       	movw	r22, r24
     fc2:	cd 01       	movw	r24, r26
     fc4:	08 95       	ret

00000fc6 <__udivmodsi4>:
     fc6:	a1 e2       	ldi	r26, 0x21	; 33
     fc8:	1a 2e       	mov	r1, r26
     fca:	aa 1b       	sub	r26, r26
     fcc:	bb 1b       	sub	r27, r27
     fce:	fd 01       	movw	r30, r26
     fd0:	0d c0       	rjmp	.+26     	; 0xfec <__udivmodsi4_ep>

00000fd2 <__udivmodsi4_loop>:
     fd2:	aa 1f       	adc	r26, r26
     fd4:	bb 1f       	adc	r27, r27
     fd6:	ee 1f       	adc	r30, r30
     fd8:	ff 1f       	adc	r31, r31
     fda:	a2 17       	cp	r26, r18
     fdc:	b3 07       	cpc	r27, r19
     fde:	e4 07       	cpc	r30, r20
     fe0:	f5 07       	cpc	r31, r21
     fe2:	20 f0       	brcs	.+8      	; 0xfec <__udivmodsi4_ep>
     fe4:	a2 1b       	sub	r26, r18
     fe6:	b3 0b       	sbc	r27, r19
     fe8:	e4 0b       	sbc	r30, r20
     fea:	f5 0b       	sbc	r31, r21

00000fec <__udivmodsi4_ep>:
     fec:	66 1f       	adc	r22, r22
     fee:	77 1f       	adc	r23, r23
     ff0:	88 1f       	adc	r24, r24
     ff2:	99 1f       	adc	r25, r25
     ff4:	1a 94       	dec	r1
     ff6:	69 f7       	brne	.-38     	; 0xfd2 <__udivmodsi4_loop>
     ff8:	60 95       	com	r22
     ffa:	70 95       	com	r23
     ffc:	80 95       	com	r24
     ffe:	90 95       	com	r25
    1000:	9b 01       	movw	r18, r22
    1002:	ac 01       	movw	r20, r24
    1004:	bd 01       	movw	r22, r26
    1006:	cf 01       	movw	r24, r30
    1008:	08 95       	ret

0000100a <_exit>:
    100a:	f8 94       	cli

0000100c <__stop_program>:
    100c:	ff cf       	rjmp	.-2      	; 0x100c <__stop_program>
