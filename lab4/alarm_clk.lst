
alarm_clk.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000002e  00800100  000014d6  0000156a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000014d6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000005a  0080012e  0080012e  00001598  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001598  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000015c8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000048  00000000  00000000  00001604  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000022e7  00000000  00000000  0000164c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000d10  00000000  00000000  00003933  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001121  00000000  00000000  00004643  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000003b8  00000000  00000000  00005764  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000691  00000000  00000000  00005b1c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000019cc  00000000  00000000  000061ad  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000e0  00000000  00000000  00007b79  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      30:	0c 94 a0 04 	jmp	0x940	; 0x940 <__vector_12>
      34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      40:	0c 94 f7 02 	jmp	0x5ee	; 0x5ee <__vector_16>
      44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	11 e0       	ldi	r17, 0x01	; 1
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e6 ed       	ldi	r30, 0xD6	; 214
      a0:	f4 e1       	ldi	r31, 0x14	; 20
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	ae 32       	cpi	r26, 0x2E	; 46
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	21 e0       	ldi	r18, 0x01	; 1
      b4:	ae e2       	ldi	r26, 0x2E	; 46
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	a8 38       	cpi	r26, 0x88	; 136
      be:	b2 07       	cpc	r27, r18
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	0e 94 83 09 	call	0x1306	; 0x1306 <main>
      c6:	0c 94 69 0a 	jmp	0x14d2	; 0x14d2 <_exit>

000000ca <__bad_interrupt>:
      ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <snoozin.part.1>:
	seconds equals the normal seconds. 
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
      if(a_sec_count == sec_count)
      ce:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <a_sec_count>
      d2:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <sec_count>
      d6:	98 17       	cp	r25, r24
      d8:	21 f0       	breq	.+8      	; 0xe2 <snoozin.part.1+0x14>
         snooze = 0;
      else 
         snooze = 1;
      da:	81 e0       	ldi	r24, 0x01	; 1
      dc:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <snooze>
      e0:	08 95       	ret
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
      if(a_sec_count == sec_count)
         snooze = 0;
      e2:	10 92 3a 01 	sts	0x013A, r1	; 0x80013a <snooze>
      e6:	08 95       	ret

000000e8 <spi_init>:
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
      e8:	87 b3       	in	r24, 0x17	; 23
      ea:	87 60       	ori	r24, 0x07	; 7
      ec:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
      ee:	8d b1       	in	r24, 0x0d	; 13
      f0:	8c 65       	ori	r24, 0x5C	; 92
      f2:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
      f4:	70 9a       	sbi	0x0e, 0	; 14
      f6:	08 95       	ret

000000f8 <tcnt0_init>:
Description: Timer counter 0 is initialized in normal mode with no prescale
	and will be used as a seconds counter for the clock
Parameters: NA
**********************************************************************/
void tcnt0_init(){
   ASSR |= (1<<AS0);
      f8:	80 b7       	in	r24, 0x30	; 48
      fa:	88 60       	ori	r24, 0x08	; 8
      fc:	80 bf       	out	0x30, r24	; 48
   TIMSK |= (1<<TOIE0);			//enable interrupts
      fe:	87 b7       	in	r24, 0x37	; 55
     100:	81 60       	ori	r24, 0x01	; 1
     102:	87 bf       	out	0x37, r24	; 55
   TCCR0 |= (1<<CS00);			//normal mode, no prescale
     104:	83 b7       	in	r24, 0x33	; 51
     106:	81 60       	ori	r24, 0x01	; 1
     108:	83 bf       	out	0x33, r24	; 51
     10a:	08 95       	ret

0000010c <tcnt1_init>:
Description: Timer counter 1 is initialized in CTC mode, 64 bit prescaler
	so that it can be used to generate an alarm frequency
Parameters: NA
**********************************************************************/
void tcnt1_init(){
   TCCR1B |= (1<<CS11) | (1<<CS10) | (1<<WGM12);		//CTC mode, 64bit prescaler
     10c:	8e b5       	in	r24, 0x2e	; 46
     10e:	8b 60       	ori	r24, 0x0B	; 11
     110:	8e bd       	out	0x2e, r24	; 46
   TCCR1C = 0x00;
     112:	10 92 7a 00 	sts	0x007A, r1	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
   TIMSK  |= (1<<OCIE1A);	//enable flag for interrupt 
     116:	87 b7       	in	r24, 0x37	; 55
     118:	80 61       	ori	r24, 0x10	; 16
     11a:	87 bf       	out	0x37, r24	; 55
   OCR1A = 0x0040;		//compare match at 64
     11c:	80 e4       	ldi	r24, 0x40	; 64
     11e:	90 e0       	ldi	r25, 0x00	; 0
     120:	9b bd       	out	0x2b, r25	; 43
     122:	8a bd       	out	0x2a, r24	; 42
     124:	08 95       	ret

00000126 <tcnt2_init>:
	normal mode with a 64 bit prescaler. OCRA2 is adjusted to change
	the pwn produced.
Parameters: NA
**********************************************************************/
void tcnt2_init(){
   TCCR2 |= (1<<WGM21) | (1<<WGM20)| (1<<CS20) | (1<<COM21);			
     126:	85 b5       	in	r24, 0x25	; 37
     128:	89 66       	ori	r24, 0x69	; 105
     12a:	85 bd       	out	0x25, r24	; 37
     12c:	08 95       	ret

0000012e <tcnt3_init>:
Description: This timer is used as a volume control for the audio amp.
	I adjust the value of OCR3A to change the pwm.
Parameters: NA
**********************************************************************/
void tcnt3_init(){
   TCCR3A |= (1<<COM3A1) | (1<<WGM31);	 //Clear on OCR3A match
     12e:	eb e8       	ldi	r30, 0x8B	; 139
     130:	f0 e0       	ldi	r31, 0x00	; 0
     132:	80 81       	ld	r24, Z
     134:	82 68       	ori	r24, 0x82	; 130
     136:	80 83       	st	Z, r24
   TCCR3B |= (1<<CS30) | (1<<WGM32) | (1<<WGM33);		//Fast PWM mode, no prescaler
     138:	ea e8       	ldi	r30, 0x8A	; 138
     13a:	f0 e0       	ldi	r31, 0x00	; 0
     13c:	80 81       	ld	r24, Z
     13e:	89 61       	ori	r24, 0x19	; 25
     140:	80 83       	st	Z, r24
   TCCR3C = 0x00;
     142:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x7e008c>
   ICR3 = 0x9F;				//Setting the TOP value
     146:	8f e9       	ldi	r24, 0x9F	; 159
     148:	90 e0       	ldi	r25, 0x00	; 0
     14a:	90 93 81 00 	sts	0x0081, r25	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
     14e:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
   TCNT3 = 0x0000; 			//Initialize TNCT1 to 0
     152:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     156:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
   OCR3A = 0x9F;			//Volume Control 0x9F=Max 0x00=Min
     15a:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     15e:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
     162:	08 95       	ret

00000164 <spi_read>:
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
     164:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
     166:	77 9b       	sbis	0x0e, 7	; 14
     168:	fe cf       	rjmp	.-4      	; 0x166 <spi_read+0x2>
   return SPDR;
     16a:	8f b1       	in	r24, 0x0f	; 15
}
     16c:	08 95       	ret

0000016e <chk_buttons>:
	be implemented at the same time. Adapted to check all buttons from 
	Ganssel's "Guide to Debouncing" Expects active low pushbuttons on PINA 
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
     16e:	48 2f       	mov	r20, r24
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
     170:	e8 2f       	mov	r30, r24
     172:	f0 e0       	ldi	r31, 0x00	; 0
     174:	99 b3       	in	r25, 0x19	; 25
     176:	ee 0f       	add	r30, r30
     178:	ff 1f       	adc	r31, r31
     17a:	eb 5b       	subi	r30, 0xBB	; 187
     17c:	fe 4f       	sbci	r31, 0xFE	; 254
     17e:	20 81       	ld	r18, Z
     180:	31 81       	ldd	r19, Z+1	; 0x01
     182:	22 0f       	add	r18, r18
     184:	33 1f       	adc	r19, r19
     186:	30 6e       	ori	r19, 0xE0	; 224
     188:	89 2f       	mov	r24, r25
     18a:	90 e0       	ldi	r25, 0x00	; 0
     18c:	02 c0       	rjmp	.+4      	; 0x192 <chk_buttons+0x24>
     18e:	95 95       	asr	r25
     190:	87 95       	ror	r24
     192:	4a 95       	dec	r20
     194:	e2 f7       	brpl	.-8      	; 0x18e <chk_buttons+0x20>
     196:	81 70       	andi	r24, 0x01	; 1
     198:	99 27       	eor	r25, r25
     19a:	28 2b       	or	r18, r24
     19c:	39 2b       	or	r19, r25
     19e:	31 83       	std	Z+1, r19	; 0x01
     1a0:	20 83       	st	Z, r18
     1a2:	81 e0       	ldi	r24, 0x01	; 1
     1a4:	21 15       	cp	r18, r1
     1a6:	30 4f       	sbci	r19, 0xF0	; 240
     1a8:	09 f0       	breq	.+2      	; 0x1ac <chk_buttons+0x3e>
     1aa:	80 e0       	ldi	r24, 0x00	; 0
  if (state[button] == 0xF000)
    return 1;
return 0;
}
     1ac:	08 95       	ret

000001ae <bars>:
Description:This function reads in the button board and updates the 
	LEDs on the bargraph through the serial port.
Parameters: NA
**********************************************************************/
void bars() {
   DDRA = 0x00;				//Set all as inputs
     1ae:	1a ba       	out	0x1a, r1	; 26
   PORTA = 0xFF;			//Pull up resistors
     1b0:	8f ef       	ldi	r24, 0xFF	; 255
     1b2:	8b bb       	out	0x1b, r24	; 27
   PORTB |= PINB | 0x70;		//Enable tristate buffer
     1b4:	86 b3       	in	r24, 0x16	; 22
     1b6:	98 b3       	in	r25, 0x18	; 24
     1b8:	80 67       	ori	r24, 0x70	; 112
     1ba:	89 2b       	or	r24, r25
     1bc:	88 bb       	out	0x18, r24	; 24
     1be:	e5 e4       	ldi	r30, 0x45	; 69
     1c0:	f1 e0       	ldi	r31, 0x01	; 1

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     1c2:	20 e0       	ldi	r18, 0x00	; 0
     1c4:	30 e0       	ldi	r19, 0x00	; 0
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
     1c6:	61 e0       	ldi	r22, 0x01	; 1
     1c8:	70 e0       	ldi	r23, 0x00	; 0
     1ca:	05 c0       	rjmp	.+10     	; 0x1d6 <bars+0x28>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     1cc:	2f 5f       	subi	r18, 0xFF	; 255
     1ce:	3f 4f       	sbci	r19, 0xFF	; 255
     1d0:	28 30       	cpi	r18, 0x08	; 8
     1d2:	31 05       	cpc	r19, r1
     1d4:	39 f1       	breq	.+78     	; 0x224 <bars+0x76>
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
     1d6:	99 b3       	in	r25, 0x19	; 25
     1d8:	40 81       	ld	r20, Z
     1da:	51 81       	ldd	r21, Z+1	; 0x01
     1dc:	44 0f       	add	r20, r20
     1de:	55 1f       	adc	r21, r21
     1e0:	89 2f       	mov	r24, r25
     1e2:	90 e0       	ldi	r25, 0x00	; 0
     1e4:	02 2e       	mov	r0, r18
     1e6:	02 c0       	rjmp	.+4      	; 0x1ec <bars+0x3e>
     1e8:	95 95       	asr	r25
     1ea:	87 95       	ror	r24
     1ec:	0a 94       	dec	r0
     1ee:	e2 f7       	brpl	.-8      	; 0x1e8 <bars+0x3a>
     1f0:	81 70       	andi	r24, 0x01	; 1
     1f2:	99 27       	eor	r25, r25
     1f4:	84 2b       	or	r24, r20
     1f6:	95 2b       	or	r25, r21
     1f8:	90 6e       	ori	r25, 0xE0	; 224
     1fa:	81 93       	st	Z+, r24
     1fc:	91 93       	st	Z+, r25
  if (state[button] == 0xF000)
     1fe:	81 15       	cp	r24, r1
     200:	90 4f       	sbci	r25, 0xF0	; 240
     202:	21 f7       	brne	.-56     	; 0x1cc <bars+0x1e>
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
     204:	cb 01       	movw	r24, r22
     206:	02 2e       	mov	r0, r18
     208:	02 c0       	rjmp	.+4      	; 0x20e <bars+0x60>
     20a:	88 0f       	add	r24, r24
     20c:	99 1f       	adc	r25, r25
     20e:	0a 94       	dec	r0
     210:	e2 f7       	brpl	.-8      	; 0x20a <bars+0x5c>
     212:	90 93 38 01 	sts	0x0138, r25	; 0x800138 <mult+0x1>
     216:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <mult>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     21a:	2f 5f       	subi	r18, 0xFF	; 255
     21c:	3f 4f       	sbci	r19, 0xFF	; 255
     21e:	28 30       	cpi	r18, 0x08	; 8
     220:	31 05       	cpc	r19, r1
     222:	c9 f6       	brne	.-78     	; 0x1d6 <bars+0x28>
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
     224:	88 b3       	in	r24, 0x18	; 24
     226:	18 ba       	out	0x18, r1	; 24
   if(mult == 128){			//Button 8 toggles base 10 and 16
     228:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <mult>
     22c:	90 91 38 01 	lds	r25, 0x0138	; 0x800138 <mult+0x1>
     230:	80 38       	cpi	r24, 0x80	; 128
     232:	91 05       	cpc	r25, r1
     234:	09 f4       	brne	.+2      	; 0x238 <bars+0x8a>
     236:	79 c0       	rjmp	.+242    	; 0x32a <bars+0x17c>
      alarm = !(alarm);			//on the LED display
   }
   if(mult == 64){		//Button 7 toggles snooze
     238:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <mult>
     23c:	90 91 38 01 	lds	r25, 0x0138	; 0x800138 <mult+0x1>
     240:	80 34       	cpi	r24, 0x40	; 64
     242:	91 05       	cpc	r25, r1
     244:	c9 f1       	breq	.+114    	; 0x2b8 <bars+0x10a>
	       a_hour_count = 0;
	    }
	 }  
      }
   }
   if(mult > 4) {			//I only want values from the
     246:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <mult>
     24a:	90 91 38 01 	lds	r25, 0x0138	; 0x800138 <mult+0x1>
     24e:	05 97       	sbiw	r24, 0x05	; 5
     250:	20 f0       	brcs	.+8      	; 0x25a <bars+0xac>
      mult = 0;				//first three buttons
     252:	10 92 38 01 	sts	0x0138, r1	; 0x800138 <mult+0x1>
     256:	10 92 37 01 	sts	0x0137, r1	; 0x800137 <mult>
   }
   //This switch statement is used to enable a 'toggle' functionality
   //so that modes can be selected an deselected
   switch(mult) {
     25a:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <mult>
     25e:	90 91 38 01 	lds	r25, 0x0138	; 0x800138 <mult+0x1>
     262:	81 30       	cpi	r24, 0x01	; 1
     264:	91 05       	cpc	r25, r1
     266:	19 f0       	breq	.+6      	; 0x26e <bars+0xc0>
     268:	82 30       	cpi	r24, 0x02	; 2
     26a:	91 05       	cpc	r25, r1
     26c:	01 f5       	brne	.+64     	; 0x2ae <bars+0x100>
	 }
	 else
	    mode_sel = 1;		//If not, then change mode
         break;
      case 2:
	 if((mode_sel ^ mult) == 0 ){//if((mode_sel ^ mult) && (mode_sel == 4)){//if cur &prev are diff
     26e:	40 91 33 01 	lds	r20, 0x0133	; 0x800133 <mode_sel>
     272:	50 91 34 01 	lds	r21, 0x0134	; 0x800134 <mode_sel+0x1>
     276:	20 91 37 01 	lds	r18, 0x0137	; 0x800137 <mult>
     27a:	30 91 38 01 	lds	r19, 0x0138	; 0x800138 <mult+0x1>
     27e:	42 17       	cp	r20, r18
     280:	53 07       	cpc	r21, r19
     282:	09 f4       	brne	.+2      	; 0x286 <bars+0xd8>
     284:	5a c0       	rjmp	.+180    	; 0x33a <bars+0x18c>
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
         break;*/
      default:
	 mode_sel = mode_sel;		//no/invalid button press
     286:	90 93 34 01 	sts	0x0134, r25	; 0x800134 <mode_sel+0x1>
     28a:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <mode_sel>
   }   
   mult = 0;				//clear mult for next pass
     28e:	10 92 38 01 	sts	0x0138, r1	; 0x800138 <mult+0x1>
     292:	10 92 37 01 	sts	0x0137, r1	; 0x800137 <mult>

   DDRA = 0xFF;				//Set A to alloutputs
     296:	8f ef       	ldi	r24, 0xFF	; 255
     298:	8a bb       	out	0x1a, r24	; 26
   SPDR = mode_sel;			//Write mode to the Bargraph
     29a:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <mode_sel>
     29e:	90 91 34 01 	lds	r25, 0x0134	; 0x800134 <mode_sel+0x1>
     2a2:	8f b9       	out	0x0f, r24	; 15
   while(bit_is_clear(SPSR, SPIF)){}	
     2a4:	77 9b       	sbis	0x0e, 7	; 14
     2a6:	fe cf       	rjmp	.-4      	; 0x2a4 <bars+0xf6>
   PORTB |= (1<<PB0);			//Rgclk high on bargraph
     2a8:	c0 9a       	sbi	0x18, 0	; 24
   PORTB &= 0xFE;			//Rgclk low on bargraph
     2aa:	c0 98       	cbi	0x18, 0	; 24
   
return ;
     2ac:	08 95       	ret
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
         break;*/
      default:
	 mode_sel = mode_sel;		//no/invalid button press
     2ae:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <mode_sel>
     2b2:	90 91 34 01 	lds	r25, 0x0134	; 0x800134 <mode_sel+0x1>
     2b6:	e7 cf       	rjmp	.-50     	; 0x286 <bars+0xd8>
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
   }
   if(mult == 64){		//Button 7 toggles snooze
      snooze = !(snooze);		//10 second snooze functionality
     2b8:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <snooze>
     2bc:	81 e0       	ldi	r24, 0x01	; 1
     2be:	91 11       	cpse	r25, r1
     2c0:	45 c0       	rjmp	.+138    	; 0x34c <bars+0x19e>
     2c2:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <snooze>
      a_sec_count = sec_count + 10;
     2c6:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <sec_count>
     2ca:	86 5f       	subi	r24, 0xF6	; 246
     2cc:	80 93 3f 01 	sts	0x013F, r24	; 0x80013f <a_sec_count>
      if(a_sec_count > 60){
     2d0:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <a_sec_count>
     2d4:	8d 33       	cpi	r24, 0x3D	; 61
     2d6:	08 f4       	brcc	.+2      	; 0x2da <bars+0x12c>
     2d8:	b6 cf       	rjmp	.-148    	; 0x246 <bars+0x98>
         a_sec_count = a_sec_count % 60;
     2da:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <a_sec_count>
     2de:	89 e8       	ldi	r24, 0x89	; 137
     2e0:	98 9f       	mul	r25, r24
     2e2:	81 2d       	mov	r24, r1
     2e4:	11 24       	eor	r1, r1
     2e6:	82 95       	swap	r24
     2e8:	86 95       	lsr	r24
     2ea:	87 70       	andi	r24, 0x07	; 7
     2ec:	2c e3       	ldi	r18, 0x3C	; 60
     2ee:	82 9f       	mul	r24, r18
     2f0:	90 19       	sub	r25, r0
     2f2:	11 24       	eor	r1, r1
     2f4:	90 93 3f 01 	sts	0x013F, r25	; 0x80013f <a_sec_count>
	 a_min_count++;
     2f8:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <a_min_count>
     2fc:	8f 5f       	subi	r24, 0xFF	; 255
     2fe:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <a_min_count>
	 if(a_min_count == 60){
     302:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <a_min_count>
     306:	8c 33       	cpi	r24, 0x3C	; 60
     308:	09 f0       	breq	.+2      	; 0x30c <bars+0x15e>
     30a:	9d cf       	rjmp	.-198    	; 0x246 <bars+0x98>
	    a_hour_count++;
     30c:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <a_hour_count>
     310:	8f 5f       	subi	r24, 0xFF	; 255
     312:	80 93 3d 01 	sts	0x013D, r24	; 0x80013d <a_hour_count>
	    a_min_count = 0;
     316:	10 92 3e 01 	sts	0x013E, r1	; 0x80013e <a_min_count>
	    if(a_hour_count == 24){
     31a:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <a_hour_count>
     31e:	88 31       	cpi	r24, 0x18	; 24
     320:	09 f0       	breq	.+2      	; 0x324 <bars+0x176>
     322:	91 cf       	rjmp	.-222    	; 0x246 <bars+0x98>
	       a_hour_count = 0;
     324:	10 92 3d 01 	sts	0x013D, r1	; 0x80013d <a_hour_count>
     328:	8e cf       	rjmp	.-228    	; 0x246 <bars+0x98>
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
     32a:	90 91 3b 01 	lds	r25, 0x013B	; 0x80013b <alarm>
     32e:	81 e0       	ldi	r24, 0x01	; 1
     330:	91 11       	cpse	r25, r1
     332:	08 c0       	rjmp	.+16     	; 0x344 <bars+0x196>
     334:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <alarm>
     338:	7f cf       	rjmp	.-258    	; 0x238 <bars+0x8a>
	 else
	    mode_sel = 1;		//If not, then change mode
         break;
      case 2:
	 if((mode_sel ^ mult) == 0 ){//if((mode_sel ^ mult) && (mode_sel == 4)){//if cur &prev are diff
	    mode_sel = 0;//and prev isn't = 1 then two modes are selected
     33a:	10 92 34 01 	sts	0x0134, r1	; 0x800134 <mode_sel+0x1>
     33e:	10 92 33 01 	sts	0x0133, r1	; 0x800133 <mode_sel>
     342:	a5 cf       	rjmp	.-182    	; 0x28e <bars+0xe0>
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
     344:	80 e0       	ldi	r24, 0x00	; 0
     346:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <alarm>
     34a:	76 cf       	rjmp	.-276    	; 0x238 <bars+0x8a>
   }
   if(mult == 64){		//Button 7 toggles snooze
      snooze = !(snooze);		//10 second snooze functionality
     34c:	80 e0       	ldi	r24, 0x00	; 0
     34e:	b9 cf       	rjmp	.-142    	; 0x2c2 <bars+0x114>

00000350 <read_encoder>:
   int8_t value = 0x00;
   uint8_t ec_a;
   uint8_t ec_b;

   //Shift_LD_N low
   PORTE &= 0x00;	//Begining of SHIFT_LD_N pulse. It is low here
     350:	83 b1       	in	r24, 0x03	; 3
     352:	13 b8       	out	0x03, r1	; 3
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     354:	87 ec       	ldi	r24, 0xC7	; 199
     356:	90 e0       	ldi	r25, 0x00	; 0
     358:	01 97       	sbiw	r24, 0x01	; 1
     35a:	f1 f7       	brne	.-4      	; 0x358 <read_encoder+0x8>
     35c:	00 c0       	rjmp	.+0      	; 0x35e <read_encoder+0xe>
     35e:	00 00       	nop
   _delay_us(50);
   PORTE |= 0xFF;	//End of SHIFT_LD_N pulse. back to high
     360:	83 b1       	in	r24, 0x03	; 3
     362:	8f ef       	ldi	r24, 0xFF	; 255
     364:	83 b9       	out	0x03, r24	; 3
   PORTD &= 0x00;	//CLK_INH low
     366:	82 b3       	in	r24, 0x12	; 18
     368:	12 ba       	out	0x12, r1	; 18
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
     36a:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
     36c:	77 9b       	sbis	0x0e, 7	; 14
     36e:	fe cf       	rjmp	.-4      	; 0x36c <read_encoder+0x1c>
   return SPDR;
     370:	9f b1       	in	r25, 0x0f	; 15
   _delay_us(50);
   PORTE |= 0xFF;	//End of SHIFT_LD_N pulse. back to high
   PORTD &= 0x00;	//CLK_INH low

   encoder_value = spi_read();
   PORTD |= 0x02;	//CLK_INH high
     372:	91 9a       	sbi	0x12, 1	; 18
   value = mode_sel;
     374:	20 91 33 01 	lds	r18, 0x0133	; 0x800133 <mode_sel>
     378:	30 91 34 01 	lds	r19, 0x0134	; 0x800134 <mode_sel+0x1>
     37c:	82 2f       	mov	r24, r18
   ec_a = encoder_value & 0x03;  //Only grabs these bits 0000_0011
     37e:	69 2f       	mov	r22, r25
     380:	63 70       	andi	r22, 0x03	; 3
   ec_b = encoder_value & 0x0C;  //Only grabs these bits 0000_1100 
     382:	9c 70       	andi	r25, 0x0C	; 12
   ec_b = (ec_b >> 2);
     384:	96 95       	lsr	r25
     386:	96 95       	lsr	r25

//mode_sel == 0 means that no mode has been selected and the speaker volume can be adjusted
   if(mode_sel == 0){
     388:	20 91 33 01 	lds	r18, 0x0133	; 0x800133 <mode_sel>
     38c:	30 91 34 01 	lds	r19, 0x0134	; 0x800134 <mode_sel+0x1>
     390:	23 2b       	or	r18, r19
     392:	09 f5       	brne	.+66     	; 0x3d6 <read_encoder+0x86>
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     394:	20 91 57 01 	lds	r18, 0x0157	; 0x800157 <EC_a_prev>
     398:	46 2f       	mov	r20, r22
     39a:	50 e0       	ldi	r21, 0x00	; 0
     39c:	02 2e       	mov	r0, r18
     39e:	00 0c       	add	r0, r0
     3a0:	33 0b       	sbc	r19, r19
     3a2:	42 17       	cp	r20, r18
     3a4:	53 07       	cpc	r21, r19
     3a6:	b9 f0       	breq	.+46     	; 0x3d6 <read_encoder+0x86>
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     3a8:	20 91 57 01 	lds	r18, 0x0157	; 0x800157 <EC_a_prev>
     3ac:	21 11       	cpse	r18, r1
     3ae:	26 c0       	rjmp	.+76     	; 0x3fc <read_encoder+0xac>
     3b0:	61 30       	cpi	r22, 0x01	; 1
     3b2:	21 f5       	brne	.+72     	; 0x3fc <read_encoder+0xac>
            volume += 10;	//increment volume
     3b4:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     3b8:	26 5f       	subi	r18, 0xF6	; 246
     3ba:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <volume>
	    if(volume <= 0x9F){
     3be:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     3c2:	20 3a       	cpi	r18, 0xA0	; 160
     3c4:	08 f0       	brcs	.+2      	; 0x3c8 <read_encoder+0x78>
     3c6:	e5 c0       	rjmp	.+458    	; 0x592 <__LOCK_REGION_LENGTH__+0x192>
	    }
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
	    volume -= 10;	//decrement volume 
	    if(volume >= 0x00){
		OCR3A = volume;	//minimum volume
     3c8:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     3cc:	30 e0       	ldi	r19, 0x00	; 0
     3ce:	30 93 87 00 	sts	0x0087, r19	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     3d2:	20 93 86 00 	sts	0x0086, r18	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
	    value = 0;
      }*/
   }

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
     3d6:	20 91 33 01 	lds	r18, 0x0133	; 0x800133 <mode_sel>
     3da:	30 91 34 01 	lds	r19, 0x0134	; 0x800134 <mode_sel+0x1>
     3de:	21 30       	cpi	r18, 0x01	; 1
     3e0:	31 05       	cpc	r19, r1
     3e2:	f1 f0       	breq	.+60     	; 0x420 <__LOCK_REGION_LENGTH__+0x20>
         else
	    value = 0;
      }
   }
//mode_sel == 2 means that the user has selected the "alarm time change" mode
   if(mode_sel == 2){
     3e4:	20 91 33 01 	lds	r18, 0x0133	; 0x800133 <mode_sel>
     3e8:	30 91 34 01 	lds	r19, 0x0134	; 0x800134 <mode_sel+0x1>
     3ec:	22 30       	cpi	r18, 0x02	; 2
     3ee:	31 05       	cpc	r19, r1
     3f0:	b1 f1       	breq	.+108    	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
         else
	    value = 0;
      }
   }
//Saves previous values into volatile variables
EC_a_prev = ec_a;
     3f2:	60 93 57 01 	sts	0x0157, r22	; 0x800157 <EC_a_prev>
EC_b_prev = ec_b;
     3f6:	90 93 56 01 	sts	0x0156, r25	; 0x800156 <EC_b_prev>

return value;
}
     3fa:	08 95       	ret
	    else {
		volume = 0x9F;
		OCR3A = 0x9F;
	    }
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     3fc:	20 91 57 01 	lds	r18, 0x0157	; 0x800157 <EC_a_prev>
     400:	21 11       	cpse	r18, r1
     402:	03 c0       	rjmp	.+6      	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
     404:	62 30       	cpi	r22, 0x02	; 2
     406:	09 f4       	brne	.+2      	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
     408:	af c0       	rjmp	.+350    	; 0x568 <__LOCK_REGION_LENGTH__+0x168>
		volume = 0x00;
		OCR3A = 0x00;
	    }
         }
         else	//If not one of the state changes above, do nothing
	 volume = volume;
     40a:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     40e:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <volume>
	    value = 0;
      }*/
   }

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
     412:	20 91 33 01 	lds	r18, 0x0133	; 0x800133 <mode_sel>
     416:	30 91 34 01 	lds	r19, 0x0134	; 0x800134 <mode_sel+0x1>
     41a:	21 30       	cpi	r18, 0x01	; 1
     41c:	31 05       	cpc	r19, r1
     41e:	11 f7       	brne	.-60     	; 0x3e4 <read_encoder+0x94>
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     420:	20 91 57 01 	lds	r18, 0x0157	; 0x800157 <EC_a_prev>
     424:	46 2f       	mov	r20, r22
     426:	50 e0       	ldi	r21, 0x00	; 0
     428:	02 2e       	mov	r0, r18
     42a:	00 0c       	add	r0, r0
     42c:	33 0b       	sbc	r19, r19
     42e:	42 17       	cp	r20, r18
     430:	53 07       	cpc	r21, r19
     432:	09 f4       	brne	.+2      	; 0x436 <__LOCK_REGION_LENGTH__+0x36>
     434:	5a c0       	rjmp	.+180    	; 0x4ea <__LOCK_REGION_LENGTH__+0xea>
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     436:	20 91 57 01 	lds	r18, 0x0157	; 0x800157 <EC_a_prev>
     43a:	22 23       	and	r18, r18
     43c:	09 f4       	brne	.+2      	; 0x440 <__LOCK_REGION_LENGTH__+0x40>
     43e:	47 c0       	rjmp	.+142    	; 0x4ce <__LOCK_REGION_LENGTH__+0xce>
            hour_count = hour_count + 1;//value = value;
	    if(hour_count == 24)
	       hour_count = 0;
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     440:	20 91 57 01 	lds	r18, 0x0157	; 0x800157 <EC_a_prev>
     444:	21 11       	cpse	r18, r1
     446:	03 c0       	rjmp	.+6      	; 0x44e <__LOCK_REGION_LENGTH__+0x4e>
     448:	62 30       	cpi	r22, 0x02	; 2
     44a:	09 f4       	brne	.+2      	; 0x44e <__LOCK_REGION_LENGTH__+0x4e>
     44c:	80 c0       	rjmp	.+256    	; 0x54e <__LOCK_REGION_LENGTH__+0x14e>
	    hour_count = hour_count - 1;//value = -(value);
	    if(hour_count < 0)
	       hour_count = 23; 
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
     44e:	80 e0       	ldi	r24, 0x00	; 0
         else
	    value = 0;
      }
   }
//mode_sel == 2 means that the user has selected the "alarm time change" mode
   if(mode_sel == 2){
     450:	20 91 33 01 	lds	r18, 0x0133	; 0x800133 <mode_sel>
     454:	30 91 34 01 	lds	r19, 0x0134	; 0x800134 <mode_sel+0x1>
     458:	22 30       	cpi	r18, 0x02	; 2
     45a:	31 05       	cpc	r19, r1
     45c:	51 f6       	brne	.-108    	; 0x3f2 <read_encoder+0xa2>
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     45e:	20 91 57 01 	lds	r18, 0x0157	; 0x800157 <EC_a_prev>
     462:	46 2f       	mov	r20, r22
     464:	50 e0       	ldi	r21, 0x00	; 0
     466:	02 2e       	mov	r0, r18
     468:	00 0c       	add	r0, r0
     46a:	33 0b       	sbc	r19, r19
     46c:	42 17       	cp	r20, r18
     46e:	53 07       	cpc	r21, r19
     470:	d1 f0       	breq	.+52     	; 0x4a6 <__LOCK_REGION_LENGTH__+0xa6>
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     472:	20 91 57 01 	lds	r18, 0x0157	; 0x800157 <EC_a_prev>
     476:	21 11       	cpse	r18, r1
     478:	03 c0       	rjmp	.+6      	; 0x480 <__LOCK_REGION_LENGTH__+0x80>
     47a:	61 30       	cpi	r22, 0x01	; 1
     47c:	09 f4       	brne	.+2      	; 0x480 <__LOCK_REGION_LENGTH__+0x80>
     47e:	7c c0       	rjmp	.+248    	; 0x578 <__LOCK_REGION_LENGTH__+0x178>
            a_hour_count = a_hour_count + 1;//value = value;
	    if(a_hour_count == 24)
	       a_hour_count = 0;
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     480:	20 91 57 01 	lds	r18, 0x0157	; 0x800157 <EC_a_prev>
     484:	21 11       	cpse	r18, r1
     486:	1d c0       	rjmp	.+58     	; 0x4c2 <__LOCK_REGION_LENGTH__+0xc2>
     488:	62 30       	cpi	r22, 0x02	; 2
     48a:	d9 f4       	brne	.+54     	; 0x4c2 <__LOCK_REGION_LENGTH__+0xc2>
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
	    a_min_count = a_min_count - 1; //value = -(value);
	    if(a_min_count < 0){
	       a_min_count = 59;
	       a_hour_count--;
     48c:	20 91 3d 01 	lds	r18, 0x013D	; 0x80013d <a_hour_count>
     490:	21 50       	subi	r18, 0x01	; 1
     492:	20 93 3d 01 	sts	0x013D, r18	; 0x80013d <a_hour_count>
	       if(a_hour_count < 0){
     496:	20 91 3d 01 	lds	r18, 0x013D	; 0x80013d <a_hour_count>
     49a:	27 ff       	sbrs	r18, 7
     49c:	aa cf       	rjmp	.-172    	; 0x3f2 <read_encoder+0xa2>
	          a_hour_count = 23;
     49e:	27 e1       	ldi	r18, 0x17	; 23
     4a0:	20 93 3d 01 	sts	0x013D, r18	; 0x80013d <a_hour_count>
     4a4:	a6 cf       	rjmp	.-180    	; 0x3f2 <read_encoder+0xa2>
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
     4a6:	20 91 56 01 	lds	r18, 0x0156	; 0x800156 <EC_b_prev>
     4aa:	21 11       	cpse	r18, r1
     4ac:	03 c0       	rjmp	.+6      	; 0x4b4 <__LOCK_REGION_LENGTH__+0xb4>
     4ae:	91 30       	cpi	r25, 0x01	; 1
     4b0:	09 f4       	brne	.+2      	; 0x4b4 <__LOCK_REGION_LENGTH__+0xb4>
     4b2:	86 c0       	rjmp	.+268    	; 0x5c0 <__LOCK_REGION_LENGTH__+0x1c0>
	       a_hour_count++;
	       if(a_hour_count > 23)
	          a_hour_count = 0;
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
     4b4:	20 91 56 01 	lds	r18, 0x0156	; 0x800156 <EC_b_prev>
     4b8:	21 11       	cpse	r18, r1
     4ba:	03 c0       	rjmp	.+6      	; 0x4c2 <__LOCK_REGION_LENGTH__+0xc2>
     4bc:	92 30       	cpi	r25, 0x02	; 2
     4be:	09 f4       	brne	.+2      	; 0x4c2 <__LOCK_REGION_LENGTH__+0xc2>
     4c0:	72 c0       	rjmp	.+228    	; 0x5a6 <__LOCK_REGION_LENGTH__+0x1a6>
	    a_hour_count = a_hour_count - 1;//value = -(value);
	    if(a_hour_count < 0)
	       a_hour_count = 23; 
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
     4c2:	80 e0       	ldi	r24, 0x00	; 0
         else
	    value = 0;
      }
   }
//Saves previous values into volatile variables
EC_a_prev = ec_a;
     4c4:	60 93 57 01 	sts	0x0157, r22	; 0x800157 <EC_a_prev>
EC_b_prev = ec_b;
     4c8:	90 93 56 01 	sts	0x0156, r25	; 0x800156 <EC_b_prev>

return value;
}
     4cc:	08 95       	ret
   }

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     4ce:	61 30       	cpi	r22, 0x01	; 1
     4d0:	09 f0       	breq	.+2      	; 0x4d4 <__LOCK_REGION_LENGTH__+0xd4>
     4d2:	b6 cf       	rjmp	.-148    	; 0x440 <__LOCK_REGION_LENGTH__+0x40>
            hour_count = hour_count + 1;//value = value;
     4d4:	20 91 40 01 	lds	r18, 0x0140	; 0x800140 <hour_count>
     4d8:	2f 5f       	subi	r18, 0xFF	; 255
     4da:	20 93 40 01 	sts	0x0140, r18	; 0x800140 <hour_count>
	    if(hour_count == 24)
     4de:	20 91 40 01 	lds	r18, 0x0140	; 0x800140 <hour_count>
     4e2:	28 31       	cpi	r18, 0x18	; 24
     4e4:	09 f0       	breq	.+2      	; 0x4e8 <__LOCK_REGION_LENGTH__+0xe8>
     4e6:	7e cf       	rjmp	.-260    	; 0x3e4 <read_encoder+0x94>
     4e8:	1c c0       	rjmp	.+56     	; 0x522 <__LOCK_REGION_LENGTH__+0x122>
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
     4ea:	20 91 56 01 	lds	r18, 0x0156	; 0x800156 <EC_b_prev>
     4ee:	21 11       	cpse	r18, r1
     4f0:	1b c0       	rjmp	.+54     	; 0x528 <__LOCK_REGION_LENGTH__+0x128>
     4f2:	91 30       	cpi	r25, 0x01	; 1
     4f4:	c9 f4       	brne	.+50     	; 0x528 <__LOCK_REGION_LENGTH__+0x128>
            min_count = min_count + 1;//value = value;
     4f6:	20 91 41 01 	lds	r18, 0x0141	; 0x800141 <min_count>
     4fa:	2f 5f       	subi	r18, 0xFF	; 255
     4fc:	20 93 41 01 	sts	0x0141, r18	; 0x800141 <min_count>
	    if(min_count == 60){
     500:	20 91 41 01 	lds	r18, 0x0141	; 0x800141 <min_count>
     504:	2c 33       	cpi	r18, 0x3C	; 60
     506:	09 f0       	breq	.+2      	; 0x50a <__LOCK_REGION_LENGTH__+0x10a>
     508:	6d cf       	rjmp	.-294    	; 0x3e4 <read_encoder+0x94>
	       min_count = 0; 
     50a:	10 92 41 01 	sts	0x0141, r1	; 0x800141 <min_count>
	       hour_count++;
     50e:	20 91 40 01 	lds	r18, 0x0140	; 0x800140 <hour_count>
     512:	2f 5f       	subi	r18, 0xFF	; 255
     514:	20 93 40 01 	sts	0x0140, r18	; 0x800140 <hour_count>
	       if(hour_count > 23)
     518:	20 91 40 01 	lds	r18, 0x0140	; 0x800140 <hour_count>
     51c:	28 31       	cpi	r18, 0x18	; 24
     51e:	0c f4       	brge	.+2      	; 0x522 <__LOCK_REGION_LENGTH__+0x122>
     520:	61 cf       	rjmp	.-318    	; 0x3e4 <read_encoder+0x94>
	          hour_count = 0;
     522:	10 92 40 01 	sts	0x0140, r1	; 0x800140 <hour_count>
     526:	5e cf       	rjmp	.-324    	; 0x3e4 <read_encoder+0x94>
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
     528:	20 91 56 01 	lds	r18, 0x0156	; 0x800156 <EC_b_prev>
     52c:	21 11       	cpse	r18, r1
     52e:	8f cf       	rjmp	.-226    	; 0x44e <__LOCK_REGION_LENGTH__+0x4e>
     530:	92 30       	cpi	r25, 0x02	; 2
     532:	09 f0       	breq	.+2      	; 0x536 <__LOCK_REGION_LENGTH__+0x136>
     534:	8c cf       	rjmp	.-232    	; 0x44e <__LOCK_REGION_LENGTH__+0x4e>
	    min_count = min_count - 1; //value = -(value);
     536:	20 91 41 01 	lds	r18, 0x0141	; 0x800141 <min_count>
     53a:	21 50       	subi	r18, 0x01	; 1
     53c:	20 93 41 01 	sts	0x0141, r18	; 0x800141 <min_count>
	    if(min_count < 0){
     540:	20 91 41 01 	lds	r18, 0x0141	; 0x800141 <min_count>
     544:	27 ff       	sbrs	r18, 7
     546:	4e cf       	rjmp	.-356    	; 0x3e4 <read_encoder+0x94>
	       min_count = 59;
     548:	2b e3       	ldi	r18, 0x3B	; 59
     54a:	20 93 41 01 	sts	0x0141, r18	; 0x800141 <min_count>
	       hour_count--;
     54e:	20 91 40 01 	lds	r18, 0x0140	; 0x800140 <hour_count>
     552:	21 50       	subi	r18, 0x01	; 1
     554:	20 93 40 01 	sts	0x0140, r18	; 0x800140 <hour_count>
	       if(hour_count < 0){
     558:	20 91 40 01 	lds	r18, 0x0140	; 0x800140 <hour_count>
     55c:	27 ff       	sbrs	r18, 7
     55e:	42 cf       	rjmp	.-380    	; 0x3e4 <read_encoder+0x94>
	          hour_count = 23;
     560:	27 e1       	ldi	r18, 0x17	; 23
     562:	20 93 40 01 	sts	0x0140, r18	; 0x800140 <hour_count>
     566:	3e cf       	rjmp	.-388    	; 0x3e4 <read_encoder+0x94>
		volume = 0x9F;
		OCR3A = 0x9F;
	    }
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
	    volume -= 10;	//decrement volume 
     568:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     56c:	2a 50       	subi	r18, 0x0A	; 10
     56e:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <volume>
	    if(volume >= 0x00){
     572:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     576:	28 cf       	rjmp	.-432    	; 0x3c8 <read_encoder+0x78>
   }
//mode_sel == 2 means that the user has selected the "alarm time change" mode
   if(mode_sel == 2){
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
            a_hour_count = a_hour_count + 1;//value = value;
     578:	20 91 3d 01 	lds	r18, 0x013D	; 0x80013d <a_hour_count>
     57c:	2f 5f       	subi	r18, 0xFF	; 255
     57e:	20 93 3d 01 	sts	0x013D, r18	; 0x80013d <a_hour_count>
	    if(a_hour_count == 24)
     582:	20 91 3d 01 	lds	r18, 0x013D	; 0x80013d <a_hour_count>
     586:	28 31       	cpi	r18, 0x18	; 24
     588:	09 f0       	breq	.+2      	; 0x58c <__LOCK_REGION_LENGTH__+0x18c>
     58a:	33 cf       	rjmp	.-410    	; 0x3f2 <read_encoder+0xa2>
            a_min_count = a_min_count + 1;//value = value;
	    if(a_min_count == 60){
	       a_min_count = 0; 
	       a_hour_count++;
	       if(a_hour_count > 23)
	          a_hour_count = 0;
     58c:	10 92 3d 01 	sts	0x013D, r1	; 0x80013d <a_hour_count>
     590:	30 cf       	rjmp	.-416    	; 0x3f2 <read_encoder+0xa2>
            volume += 10;	//increment volume
	    if(volume <= 0x9F){
		OCR3A = volume;	//maximum volume
	    }
	    else {
		volume = 0x9F;
     592:	2f e9       	ldi	r18, 0x9F	; 159
     594:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <volume>
		OCR3A = 0x9F;
     598:	2f e9       	ldi	r18, 0x9F	; 159
     59a:	30 e0       	ldi	r19, 0x00	; 0
     59c:	30 93 87 00 	sts	0x0087, r19	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     5a0:	20 93 86 00 	sts	0x0086, r18	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
     5a4:	18 cf       	rjmp	.-464    	; 0x3d6 <read_encoder+0x86>
	       if(a_hour_count > 23)
	          a_hour_count = 0;
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
	    a_min_count = a_min_count - 1; //value = -(value);
     5a6:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <a_min_count>
     5aa:	21 50       	subi	r18, 0x01	; 1
     5ac:	20 93 3e 01 	sts	0x013E, r18	; 0x80013e <a_min_count>
	    if(a_min_count < 0){
     5b0:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <a_min_count>
     5b4:	27 ff       	sbrs	r18, 7
     5b6:	1d cf       	rjmp	.-454    	; 0x3f2 <read_encoder+0xa2>
	       a_min_count = 59;
     5b8:	2b e3       	ldi	r18, 0x3B	; 59
     5ba:	20 93 3e 01 	sts	0x013E, r18	; 0x80013e <a_min_count>
     5be:	66 cf       	rjmp	.-308    	; 0x48c <__LOCK_REGION_LENGTH__+0x8c>
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
            a_min_count = a_min_count + 1;//value = value;
     5c0:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <a_min_count>
     5c4:	2f 5f       	subi	r18, 0xFF	; 255
     5c6:	20 93 3e 01 	sts	0x013E, r18	; 0x80013e <a_min_count>
	    if(a_min_count == 60){
     5ca:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <a_min_count>
     5ce:	2c 33       	cpi	r18, 0x3C	; 60
     5d0:	09 f0       	breq	.+2      	; 0x5d4 <__LOCK_REGION_LENGTH__+0x1d4>
     5d2:	0f cf       	rjmp	.-482    	; 0x3f2 <read_encoder+0xa2>
	       a_min_count = 0; 
     5d4:	10 92 3e 01 	sts	0x013E, r1	; 0x80013e <a_min_count>
	       a_hour_count++;
     5d8:	20 91 3d 01 	lds	r18, 0x013D	; 0x80013d <a_hour_count>
     5dc:	2f 5f       	subi	r18, 0xFF	; 255
     5de:	20 93 3d 01 	sts	0x013D, r18	; 0x80013d <a_hour_count>
	       if(a_hour_count > 23)
     5e2:	20 91 3d 01 	lds	r18, 0x013D	; 0x80013d <a_hour_count>
     5e6:	28 31       	cpi	r18, 0x18	; 24
     5e8:	0c f4       	brge	.+2      	; 0x5ec <__LOCK_REGION_LENGTH__+0x1ec>
     5ea:	03 cf       	rjmp	.-506    	; 0x3f2 <read_encoder+0xa2>
     5ec:	cf cf       	rjmp	.-98     	; 0x58c <__LOCK_REGION_LENGTH__+0x18c>

000005ee <__vector_16>:
	update the mode and bargraph. Then I change the sum based on	
	the value returned from the encoder reading. Sum is then bounded
	from 0-1023. 1023+1=1 and 0-any number > 0 = 1023.
Parameters: NA
**********************************************************************/
ISR(TIMER0_OVF_vect) { 
     5ee:	1f 92       	push	r1
     5f0:	0f 92       	push	r0
     5f2:	0f b6       	in	r0, 0x3f	; 63
     5f4:	0f 92       	push	r0
     5f6:	11 24       	eor	r1, r1
     5f8:	0b b6       	in	r0, 0x3b	; 59
     5fa:	0f 92       	push	r0
     5fc:	2f 93       	push	r18
     5fe:	3f 93       	push	r19
     600:	4f 93       	push	r20
     602:	5f 93       	push	r21
     604:	6f 93       	push	r22
     606:	7f 93       	push	r23
     608:	8f 93       	push	r24
     60a:	9f 93       	push	r25
     60c:	af 93       	push	r26
     60e:	bf 93       	push	r27
     610:	ef 93       	push	r30
     612:	ff 93       	push	r31
   static uint8_t count_7_8125ms = 0;

   count_7_8125ms++;
     614:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <count_7_8125ms.2011>
     618:	8f 5f       	subi	r24, 0xFF	; 255
     61a:	80 93 44 01 	sts	0x0144, r24	; 0x800144 <count_7_8125ms.2011>
   if((count_7_8125ms % 128) == 0) { //interrupts every 1 second
     61e:	8f 77       	andi	r24, 0x7F	; 127
     620:	29 f4       	brne	.+10     	; 0x62c <__vector_16+0x3e>
      sec_count++;
     622:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <sec_count>
     626:	8f 5f       	subi	r24, 0xFF	; 255
     628:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <sec_count>
   }
   bars();  
     62c:	0e 94 d7 00 	call	0x1ae	; 0x1ae <bars>
   read_encoder();      
     630:	0e 94 a8 01 	call	0x350	; 0x350 <read_encoder>

}
     634:	ff 91       	pop	r31
     636:	ef 91       	pop	r30
     638:	bf 91       	pop	r27
     63a:	af 91       	pop	r26
     63c:	9f 91       	pop	r25
     63e:	8f 91       	pop	r24
     640:	7f 91       	pop	r23
     642:	6f 91       	pop	r22
     644:	5f 91       	pop	r21
     646:	4f 91       	pop	r20
     648:	3f 91       	pop	r19
     64a:	2f 91       	pop	r18
     64c:	0f 90       	pop	r0
     64e:	0b be       	out	0x3b, r0	; 59
     650:	0f 90       	pop	r0
     652:	0f be       	out	0x3f, r0	; 63
     654:	0f 90       	pop	r0
     656:	1f 90       	pop	r1
     658:	18 95       	reti

0000065a <clock_time>:
	selected alarm time or normal time is displayed.
Parameters: NA
**********************************************************************/
void clock_time(){ //by default we use military time
//This block is used to increment the time based on an increasing seconds count   
   if(sec_count == 60){
     65a:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <sec_count>
     65e:	8c 33       	cpi	r24, 0x3C	; 60
     660:	09 f4       	brne	.+2      	; 0x664 <clock_time+0xa>
     662:	a4 c0       	rjmp	.+328    	; 0x7ac <clock_time+0x152>
	 }//hours	
      }//mins
   }//secs

//This is where the digits are written to the data array
      if(mode_sel == 2){	//display alarm time
     664:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <mode_sel>
     668:	90 91 34 01 	lds	r25, 0x0134	; 0x800134 <mode_sel+0x1>
     66c:	02 97       	sbiw	r24, 0x02	; 2
     66e:	09 f4       	brne	.+2      	; 0x672 <clock_time+0x18>
     670:	5a c0       	rjmp	.+180    	; 0x726 <clock_time+0xcc>
         else {segment_data[2] = 0b111;}		//Turn colon off
         segment_data[1] = dec_to_7seg[a_min_count/10];
         segment_data[0] = dec_to_7seg[a_min_count%10];
      }
      else{			//display military time
         segment_data[4] = dec_to_7seg[hour_count/10];
     672:	90 91 40 01 	lds	r25, 0x0140	; 0x800140 <hour_count>
     676:	87 e6       	ldi	r24, 0x67	; 103
     678:	98 02       	muls	r25, r24
     67a:	e1 2d       	mov	r30, r1
     67c:	11 24       	eor	r1, r1
     67e:	e5 95       	asr	r30
     680:	e5 95       	asr	r30
     682:	97 fd       	sbrc	r25, 7
     684:	e3 95       	inc	r30
     686:	0e 2e       	mov	r0, r30
     688:	00 0c       	add	r0, r0
     68a:	ff 0b       	sbc	r31, r31
     68c:	e0 50       	subi	r30, 0x00	; 0
     68e:	ff 4f       	sbci	r31, 0xFF	; 255
     690:	90 81       	ld	r25, Z
     692:	90 93 32 01 	sts	0x0132, r25	; 0x800132 <__data_end+0x4>
         segment_data[3] = dec_to_7seg[hour_count%10];
     696:	e0 91 40 01 	lds	r30, 0x0140	; 0x800140 <hour_count>
     69a:	e8 02       	muls	r30, r24
     69c:	81 2d       	mov	r24, r1
     69e:	11 24       	eor	r1, r1
     6a0:	85 95       	asr	r24
     6a2:	85 95       	asr	r24
     6a4:	e7 fd       	sbrc	r30, 7
     6a6:	83 95       	inc	r24
     6a8:	9a e0       	ldi	r25, 0x0A	; 10
     6aa:	89 9f       	mul	r24, r25
     6ac:	e0 19       	sub	r30, r0
     6ae:	11 24       	eor	r1, r1
     6b0:	0e 2e       	mov	r0, r30
     6b2:	00 0c       	add	r0, r0
     6b4:	ff 0b       	sbc	r31, r31
     6b6:	e0 50       	subi	r30, 0x00	; 0
     6b8:	ff 4f       	sbci	r31, 0xFF	; 255
     6ba:	80 81       	ld	r24, Z
     6bc:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__data_end+0x3>
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     6c0:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <sec_count>
     6c4:	80 fd       	sbrc	r24, 0
     6c6:	2b c0       	rjmp	.+86     	; 0x71e <clock_time+0xc4>
         else {segment_data[2] = 0b111;}		//Turn colon off
     6c8:	87 e0       	ldi	r24, 0x07	; 7
     6ca:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__data_end+0x2>
         segment_data[1] = dec_to_7seg[min_count/10];
     6ce:	90 91 41 01 	lds	r25, 0x0141	; 0x800141 <min_count>
     6d2:	87 e6       	ldi	r24, 0x67	; 103
     6d4:	98 02       	muls	r25, r24
     6d6:	e1 2d       	mov	r30, r1
     6d8:	11 24       	eor	r1, r1
     6da:	e5 95       	asr	r30
     6dc:	e5 95       	asr	r30
     6de:	97 fd       	sbrc	r25, 7
     6e0:	e3 95       	inc	r30
     6e2:	0e 2e       	mov	r0, r30
     6e4:	00 0c       	add	r0, r0
     6e6:	ff 0b       	sbc	r31, r31
     6e8:	e0 50       	subi	r30, 0x00	; 0
     6ea:	ff 4f       	sbci	r31, 0xFF	; 255
     6ec:	90 81       	ld	r25, Z
     6ee:	90 93 2f 01 	sts	0x012F, r25	; 0x80012f <__data_end+0x1>
         segment_data[0] = dec_to_7seg[min_count%10];
     6f2:	e0 91 41 01 	lds	r30, 0x0141	; 0x800141 <min_count>
     6f6:	e8 02       	muls	r30, r24
     6f8:	81 2d       	mov	r24, r1
     6fa:	11 24       	eor	r1, r1
     6fc:	85 95       	asr	r24
     6fe:	85 95       	asr	r24
     700:	e7 fd       	sbrc	r30, 7
     702:	83 95       	inc	r24
     704:	9a e0       	ldi	r25, 0x0A	; 10
     706:	89 9f       	mul	r24, r25
     708:	e0 19       	sub	r30, r0
     70a:	11 24       	eor	r1, r1
     70c:	0e 2e       	mov	r0, r30
     70e:	00 0c       	add	r0, r0
     710:	ff 0b       	sbc	r31, r31
     712:	e0 50       	subi	r30, 0x00	; 0
     714:	ff 4f       	sbci	r31, 0xFF	; 255
     716:	80 81       	ld	r24, Z
     718:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <__data_end>
     71c:	08 95       	ret
         segment_data[0] = dec_to_7seg[a_min_count%10];
      }
      else{			//display military time
         segment_data[4] = dec_to_7seg[hour_count/10];
         segment_data[3] = dec_to_7seg[hour_count%10];
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     71e:	84 e0       	ldi	r24, 0x04	; 4
     720:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__data_end+0x2>
     724:	d4 cf       	rjmp	.-88     	; 0x6ce <clock_time+0x74>
      }//mins
   }//secs

//This is where the digits are written to the data array
      if(mode_sel == 2){	//display alarm time
         segment_data[4] = dec_to_7seg[a_hour_count/10];
     726:	90 91 3d 01 	lds	r25, 0x013D	; 0x80013d <a_hour_count>
     72a:	87 e6       	ldi	r24, 0x67	; 103
     72c:	98 02       	muls	r25, r24
     72e:	e1 2d       	mov	r30, r1
     730:	11 24       	eor	r1, r1
     732:	e5 95       	asr	r30
     734:	e5 95       	asr	r30
     736:	97 fd       	sbrc	r25, 7
     738:	e3 95       	inc	r30
     73a:	0e 2e       	mov	r0, r30
     73c:	00 0c       	add	r0, r0
     73e:	ff 0b       	sbc	r31, r31
     740:	e0 50       	subi	r30, 0x00	; 0
     742:	ff 4f       	sbci	r31, 0xFF	; 255
     744:	90 81       	ld	r25, Z
     746:	90 93 32 01 	sts	0x0132, r25	; 0x800132 <__data_end+0x4>
         segment_data[3] = dec_to_7seg[a_hour_count%10];
     74a:	e0 91 3d 01 	lds	r30, 0x013D	; 0x80013d <a_hour_count>
     74e:	e8 02       	muls	r30, r24
     750:	81 2d       	mov	r24, r1
     752:	11 24       	eor	r1, r1
     754:	85 95       	asr	r24
     756:	85 95       	asr	r24
     758:	e7 fd       	sbrc	r30, 7
     75a:	83 95       	inc	r24
     75c:	9a e0       	ldi	r25, 0x0A	; 10
     75e:	89 9f       	mul	r24, r25
     760:	e0 19       	sub	r30, r0
     762:	11 24       	eor	r1, r1
     764:	0e 2e       	mov	r0, r30
     766:	00 0c       	add	r0, r0
     768:	ff 0b       	sbc	r31, r31
     76a:	e0 50       	subi	r30, 0x00	; 0
     76c:	ff 4f       	sbci	r31, 0xFF	; 255
     76e:	80 81       	ld	r24, Z
     770:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__data_end+0x3>
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     774:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <sec_count>
     778:	80 fd       	sbrc	r24, 0
     77a:	33 c0       	rjmp	.+102    	; 0x7e2 <clock_time+0x188>
         else {segment_data[2] = 0b111;}		//Turn colon off
     77c:	87 e0       	ldi	r24, 0x07	; 7
     77e:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__data_end+0x2>
         segment_data[1] = dec_to_7seg[a_min_count/10];
     782:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <a_min_count>
     786:	87 e6       	ldi	r24, 0x67	; 103
     788:	98 02       	muls	r25, r24
     78a:	e1 2d       	mov	r30, r1
     78c:	11 24       	eor	r1, r1
     78e:	e5 95       	asr	r30
     790:	e5 95       	asr	r30
     792:	97 fd       	sbrc	r25, 7
     794:	e3 95       	inc	r30
     796:	0e 2e       	mov	r0, r30
     798:	00 0c       	add	r0, r0
     79a:	ff 0b       	sbc	r31, r31
     79c:	e0 50       	subi	r30, 0x00	; 0
     79e:	ff 4f       	sbci	r31, 0xFF	; 255
     7a0:	90 81       	ld	r25, Z
     7a2:	90 93 2f 01 	sts	0x012F, r25	; 0x80012f <__data_end+0x1>
         segment_data[0] = dec_to_7seg[a_min_count%10];
     7a6:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <a_min_count>
     7aa:	a5 cf       	rjmp	.-182    	; 0x6f6 <clock_time+0x9c>
Parameters: NA
**********************************************************************/
void clock_time(){ //by default we use military time
//This block is used to increment the time based on an increasing seconds count   
   if(sec_count == 60){
      min_count++;
     7ac:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <min_count>
     7b0:	8f 5f       	subi	r24, 0xFF	; 255
     7b2:	80 93 41 01 	sts	0x0141, r24	; 0x800141 <min_count>
      sec_count = 0;
     7b6:	10 92 42 01 	sts	0x0142, r1	; 0x800142 <sec_count>
      if(min_count == 60){
     7ba:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <min_count>
     7be:	8c 33       	cpi	r24, 0x3C	; 60
     7c0:	09 f0       	breq	.+2      	; 0x7c4 <clock_time+0x16a>
     7c2:	50 cf       	rjmp	.-352    	; 0x664 <clock_time+0xa>
	 hour_count++;
     7c4:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <hour_count>
     7c8:	8f 5f       	subi	r24, 0xFF	; 255
     7ca:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <hour_count>
	 min_count = 0;
     7ce:	10 92 41 01 	sts	0x0141, r1	; 0x800141 <min_count>
	 if(hour_count == 24){
     7d2:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <hour_count>
     7d6:	88 31       	cpi	r24, 0x18	; 24
     7d8:	09 f0       	breq	.+2      	; 0x7dc <clock_time+0x182>
     7da:	44 cf       	rjmp	.-376    	; 0x664 <clock_time+0xa>
	    hour_count = 0;
     7dc:	10 92 40 01 	sts	0x0140, r1	; 0x800140 <hour_count>
     7e0:	41 cf       	rjmp	.-382    	; 0x664 <clock_time+0xa>

//This is where the digits are written to the data array
      if(mode_sel == 2){	//display alarm time
         segment_data[4] = dec_to_7seg[a_hour_count/10];
         segment_data[3] = dec_to_7seg[a_hour_count%10];
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     7e2:	84 e0       	ldi	r24, 0x04	; 4
     7e4:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__data_end+0x2>
     7e8:	cc cf       	rjmp	.-104    	; 0x782 <clock_time+0x128>

000007ea <port_init>:
Function: port_init
Description: General port initialization and setting pull up resistors
Parameters: NA
**********************************************************************/
void port_init(){
   DDRC |= 0xFF; 
     7ea:	84 b3       	in	r24, 0x14	; 20
     7ec:	9f ef       	ldi	r25, 0xFF	; 255
     7ee:	94 bb       	out	0x14, r25	; 20
   DDRB |= 0xF0;				//PB4-6 is SEL0-2, PB7 is PWM
     7f0:	87 b3       	in	r24, 0x17	; 23
     7f2:	80 6f       	ori	r24, 0xF0	; 240
     7f4:	87 bb       	out	0x17, r24	; 23
   DDRE |= 0x4F;				//PE6 is SHIFT_LD_N
     7f6:	82 b1       	in	r24, 0x02	; 2
     7f8:	8f 64       	ori	r24, 0x4F	; 79
     7fa:	82 b9       	out	0x02, r24	; 2
   DDRD |= 0x0F;				//PE1 is CLK_INH and PE2 is SRCLK
     7fc:	81 b3       	in	r24, 0x11	; 17
     7fe:	8f 60       	ori	r24, 0x0F	; 15
     800:	81 bb       	out	0x11, r24	; 17
   PORTC |= 0x01;
     802:	a8 9a       	sbi	0x15, 0	; 21
   PORTD |= 0x0F;
     804:	82 b3       	in	r24, 0x12	; 18
     806:	8f 60       	ori	r24, 0x0F	; 15
     808:	82 bb       	out	0x12, r24	; 18
   PORTE |= 0xFF;
     80a:	83 b1       	in	r24, 0x03	; 3
     80c:	93 b9       	out	0x03, r25	; 3
     80e:	08 95       	ret

00000810 <change_alarm_state>:
Function: change_alarm_state
Description: This function is used to display when the alarm is armed
	and what time it is set for on the LCD.
Parameters: NA
**********************************************************************/
void change_alarm_state(){
     810:	0f 93       	push	r16
   static uint8_t curr = 0;
   if(alarm && (curr == 0)){	//First time through function with alarm on
     812:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <alarm>
     816:	88 23       	and	r24, r24
     818:	c1 f1       	breq	.+112    	; 0x88a <change_alarm_state+0x7a>
     81a:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <curr.2018>
     81e:	81 11       	cpse	r24, r1
     820:	34 c0       	rjmp	.+104    	; 0x88a <change_alarm_state+0x7a>
      if((a_hour_count > 9) && (a_min_count > 9)){	//hours and min counts > 9
     822:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <a_hour_count>
     826:	8a 30       	cpi	r24, 0x0A	; 10
     828:	2c f0       	brlt	.+10     	; 0x834 <change_alarm_state+0x24>
     82a:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <a_min_count>
     82e:	8a 30       	cpi	r24, 0x0A	; 10
     830:	0c f0       	brlt	.+2      	; 0x834 <change_alarm_state+0x24>
     832:	5d c0       	rjmp	.+186    	; 0x8ee <change_alarm_state+0xde>
         string2lcd("ALARM at ");
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         lcd_int16(a_min_count, 2, 0, 0, 0);
      }
      else if(a_hour_count > 9){ //hour>9 and min<10
     834:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <a_hour_count>
     838:	8a 30       	cpi	r24, 0x0A	; 10
     83a:	a4 f5       	brge	.+104    	; 0x8a4 <change_alarm_state+0x94>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         string2lcd("0");
         lcd_int16(a_min_count, 1, 0, 0, 0);
      }
      else if(a_min_count > 9){ //min>9 and hour<10
     83c:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <a_min_count>
     840:	8a 30       	cpi	r24, 0x0A	; 10
     842:	0c f4       	brge	.+2      	; 0x846 <change_alarm_state+0x36>
     844:	51 c0       	rjmp	.+162    	; 0x8e8 <change_alarm_state+0xd8>
         string2lcd("ALARM at");
     846:	84 e2       	ldi	r24, 0x24	; 36
     848:	91 e0       	ldi	r25, 0x01	; 1
     84a:	0e 94 e6 06 	call	0xdcc	; 0xdcc <string2lcd>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
     84e:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <a_hour_count>
     852:	00 e0       	ldi	r16, 0x00	; 0
     854:	20 e0       	ldi	r18, 0x00	; 0
     856:	40 e0       	ldi	r20, 0x00	; 0
     858:	62 e0       	ldi	r22, 0x02	; 2
     85a:	08 2e       	mov	r0, r24
     85c:	00 0c       	add	r0, r0
     85e:	99 0b       	sbc	r25, r25
     860:	0e 94 ab 08 	call	0x1156	; 0x1156 <lcd_int16>
         string2lcd(":");
     864:	80 e2       	ldi	r24, 0x20	; 32
     866:	91 e0       	ldi	r25, 0x01	; 1
     868:	0e 94 e6 06 	call	0xdcc	; 0xdcc <string2lcd>
         lcd_int16(a_min_count, 2, 0, 0, 0);
     86c:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <a_min_count>
     870:	20 e0       	ldi	r18, 0x00	; 0
     872:	40 e0       	ldi	r20, 0x00	; 0
     874:	62 e0       	ldi	r22, 0x02	; 2
     876:	08 2e       	mov	r0, r24
     878:	00 0c       	add	r0, r0
     87a:	99 0b       	sbc	r25, r25
     87c:	0e 94 ab 08 	call	0x1156	; 0x1156 <lcd_int16>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         string2lcd("0");
         lcd_int16(a_min_count, 1, 0, 0, 0);
      }
      curr = 1;	//indicated that alarm has been written to the display next time
     880:	81 e0       	ldi	r24, 0x01	; 1
     882:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <curr.2018>
   else if((!alarm) && (curr == 1)){
      curr = 0;
      clear_display();
   }
   else{}
}
     886:	0f 91       	pop	r16
     888:	08 95       	ret
      }
      curr = 1;	//indicated that alarm has been written to the display next time
	//through the function
   }
	//clears display when the alarm is turned off
   else if((!alarm) && (curr == 1)){
     88a:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <alarm>
     88e:	81 11       	cpse	r24, r1
     890:	fa cf       	rjmp	.-12     	; 0x886 <change_alarm_state+0x76>
     892:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <curr.2018>
     896:	81 30       	cpi	r24, 0x01	; 1
     898:	b1 f7       	brne	.-20     	; 0x886 <change_alarm_state+0x76>
      curr = 0;
     89a:	10 92 43 01 	sts	0x0143, r1	; 0x800143 <curr.2018>
      clear_display();
   }
   else{}
}
     89e:	0f 91       	pop	r16
	//through the function
   }
	//clears display when the alarm is turned off
   else if((!alarm) && (curr == 1)){
      curr = 0;
      clear_display();
     8a0:	0c 94 5e 06 	jmp	0xcbc	; 0xcbc <clear_display>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         lcd_int16(a_min_count, 2, 0, 0, 0);
      }
      else if(a_hour_count > 9){ //hour>9 and min<10
         string2lcd("ALARM at ");
     8a4:	86 e1       	ldi	r24, 0x16	; 22
     8a6:	91 e0       	ldi	r25, 0x01	; 1
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         lcd_int16(a_min_count, 2, 0, 0, 0);
      }
      else { //hour and min < 10
         string2lcd("ALARM at");
     8a8:	0e 94 e6 06 	call	0xdcc	; 0xdcc <string2lcd>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
     8ac:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <a_hour_count>
     8b0:	00 e0       	ldi	r16, 0x00	; 0
     8b2:	20 e0       	ldi	r18, 0x00	; 0
     8b4:	40 e0       	ldi	r20, 0x00	; 0
     8b6:	62 e0       	ldi	r22, 0x02	; 2
     8b8:	08 2e       	mov	r0, r24
     8ba:	00 0c       	add	r0, r0
     8bc:	99 0b       	sbc	r25, r25
     8be:	0e 94 ab 08 	call	0x1156	; 0x1156 <lcd_int16>
         string2lcd(":");
     8c2:	80 e2       	ldi	r24, 0x20	; 32
     8c4:	91 e0       	ldi	r25, 0x01	; 1
     8c6:	0e 94 e6 06 	call	0xdcc	; 0xdcc <string2lcd>
         string2lcd("0");
     8ca:	82 e2       	ldi	r24, 0x22	; 34
     8cc:	91 e0       	ldi	r25, 0x01	; 1
     8ce:	0e 94 e6 06 	call	0xdcc	; 0xdcc <string2lcd>
         lcd_int16(a_min_count, 1, 0, 0, 0);
     8d2:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <a_min_count>
     8d6:	20 e0       	ldi	r18, 0x00	; 0
     8d8:	40 e0       	ldi	r20, 0x00	; 0
     8da:	61 e0       	ldi	r22, 0x01	; 1
     8dc:	08 2e       	mov	r0, r24
     8de:	00 0c       	add	r0, r0
     8e0:	99 0b       	sbc	r25, r25
     8e2:	0e 94 ab 08 	call	0x1156	; 0x1156 <lcd_int16>
     8e6:	cc cf       	rjmp	.-104    	; 0x880 <change_alarm_state+0x70>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         lcd_int16(a_min_count, 2, 0, 0, 0);
      }
      else { //hour and min < 10
         string2lcd("ALARM at");
     8e8:	84 e2       	ldi	r24, 0x24	; 36
     8ea:	91 e0       	ldi	r25, 0x01	; 1
     8ec:	dd cf       	rjmp	.-70     	; 0x8a8 <change_alarm_state+0x98>
**********************************************************************/
void change_alarm_state(){
   static uint8_t curr = 0;
   if(alarm && (curr == 0)){	//First time through function with alarm on
      if((a_hour_count > 9) && (a_min_count > 9)){	//hours and min counts > 9
         string2lcd("ALARM at ");
     8ee:	86 e1       	ldi	r24, 0x16	; 22
     8f0:	91 e0       	ldi	r25, 0x01	; 1
     8f2:	ab cf       	rjmp	.-170    	; 0x84a <change_alarm_state+0x3a>

000008f4 <adc_init>:
Description: Basic adc initialization used for single shot adc readings
Parameters: NA
**********************************************************************/
void adc_init(){
//Initalize ADC and its ports
   DDRF  &= ~(_BV(DDF7)); //make port F bit 7 is ADC input  
     8f4:	e1 e6       	ldi	r30, 0x61	; 97
     8f6:	f0 e0       	ldi	r31, 0x00	; 0
     8f8:	80 81       	ld	r24, Z
     8fa:	8f 77       	andi	r24, 0x7F	; 127
     8fc:	80 83       	st	Z, r24
   PORTF &= ~(_BV(PF7));  //port F bit 7 pullups must be off
     8fe:	e2 e6       	ldi	r30, 0x62	; 98
     900:	f0 e0       	ldi	r31, 0x00	; 0
     902:	80 81       	ld	r24, Z
     904:	8f 77       	andi	r24, 0x7F	; 127
     906:	80 83       	st	Z, r24
   ADMUX |= (1<<REFS0) | (1<<MUX2)| (1<<MUX1)| (1<<MUX0); //single-ended, input PORTF bit 7, right adjusted, 10 bits
     908:	87 b1       	in	r24, 0x07	; 7
     90a:	87 64       	ori	r24, 0x47	; 71
     90c:	87 b9       	out	0x07, r24	; 7

   ADCSRA |= (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);//ADC enabled, don't start yet, single shot mode 
     90e:	86 b1       	in	r24, 0x06	; 6
     910:	87 68       	ori	r24, 0x87	; 135
     912:	86 b9       	out	0x06, r24	; 6
     914:	08 95       	ret

00000916 <fetch_adc>:
void fetch_adc(){
   uint16_t adc_result;
   uint16_t step;   
   uint16_t step2;   

   ADCSRA |= (1<<ADSC); //poke ADSC and start conversion
     916:	36 9a       	sbi	0x06, 6	; 6
   while(bit_is_clear(ADCSRA, ADIF)){} //spin while interrupt flag not set
     918:	34 9b       	sbis	0x06, 4	; 6
     91a:	fe cf       	rjmp	.-4      	; 0x918 <fetch_adc+0x2>
   ACSR |= (1<<ACI); //its done, clear flag by writing a one 
     91c:	44 9a       	sbi	0x08, 4	; 8
   adc_result = ADC;                      //read the ADC output as 16 bits
     91e:	24 b1       	in	r18, 0x04	; 4
     920:	35 b1       	in	r19, 0x05	; 5

   step = adc_result/4;//scales the adc result from 0-255
   step2 =  255 - step;//I need the complement to the adc result
     922:	36 95       	lsr	r19
     924:	27 95       	ror	r18
     926:	36 95       	lsr	r19
     928:	27 95       	ror	r18
   if(step2 > 235){	//this is a minimum brightness level
      step2 = 235;
   }

   OCR2 = step2;	//Write brightness level to tnct2 compare match register
     92a:	8f ef       	ldi	r24, 0xFF	; 255
     92c:	90 e0       	ldi	r25, 0x00	; 0
     92e:	82 1b       	sub	r24, r18
     930:	93 0b       	sbc	r25, r19
     932:	8c 3e       	cpi	r24, 0xEC	; 236
     934:	91 05       	cpc	r25, r1
     936:	10 f0       	brcs	.+4      	; 0x93c <fetch_adc+0x26>
     938:	8b ee       	ldi	r24, 0xEB	; 235
     93a:	90 e0       	ldi	r25, 0x00	; 0
     93c:	83 bd       	out	0x23, r24	; 35
     93e:	08 95       	ret

00000940 <__vector_12>:
Function: TIMER!_COMPA_vect
Description: This ISR creates the alarm frequency on PORTD but 3 the is used
	for the alarm tone.
Parameters: NA
**********************************************************************/
ISR(TIMER1_COMPA_vect){
     940:	1f 92       	push	r1
     942:	0f 92       	push	r0
     944:	0f b6       	in	r0, 0x3f	; 63
     946:	0f 92       	push	r0
     948:	11 24       	eor	r1, r1
     94a:	8f 93       	push	r24
     94c:	9f 93       	push	r25
   //static uint8_t seconds = 0;
   //bars();  //displays the mode on the bargraph
   //read_encoder();     //reads the encoder values
if(!snooze){ //alarm has not been snoozed
     94e:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <snooze>
     952:	81 11       	cpse	r24, r1
     954:	0a c0       	rjmp	.+20     	; 0x96a <__vector_12+0x2a>
//checks to see alarm is on and the alarm time matches clock time
   if(alarm && ((hour_count == a_hour_count) && (min_count == a_min_count))){
     956:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <alarm>
     95a:	88 23       	and	r24, r24
     95c:	31 f0       	breq	.+12     	; 0x96a <__vector_12+0x2a>
     95e:	90 91 40 01 	lds	r25, 0x0140	; 0x800140 <hour_count>
     962:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <a_hour_count>
     966:	98 17       	cp	r25, r24
     968:	39 f0       	breq	.+14     	; 0x978 <__vector_12+0x38>
      PORTD = PIND ^ 0b00000100;//toggles PD3 to create frequency
   }
}
}
     96a:	9f 91       	pop	r25
     96c:	8f 91       	pop	r24
     96e:	0f 90       	pop	r0
     970:	0f be       	out	0x3f, r0	; 63
     972:	0f 90       	pop	r0
     974:	1f 90       	pop	r1
     976:	18 95       	reti
   //static uint8_t seconds = 0;
   //bars();  //displays the mode on the bargraph
   //read_encoder();     //reads the encoder values
if(!snooze){ //alarm has not been snoozed
//checks to see alarm is on and the alarm time matches clock time
   if(alarm && ((hour_count == a_hour_count) && (min_count == a_min_count))){
     978:	90 91 41 01 	lds	r25, 0x0141	; 0x800141 <min_count>
     97c:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <a_min_count>
     980:	98 13       	cpse	r25, r24
     982:	f3 cf       	rjmp	.-26     	; 0x96a <__vector_12+0x2a>
      PORTD = PIND ^ 0b00000100;//toggles PD3 to create frequency
     984:	90 b3       	in	r25, 0x10	; 16
     986:	84 e0       	ldi	r24, 0x04	; 4
     988:	89 27       	eor	r24, r25
     98a:	82 bb       	out	0x12, r24	; 18
   }
}
}
     98c:	ee cf       	rjmp	.-36     	; 0x96a <__vector_12+0x2a>

0000098e <snoozin>:
Description: This function disables the snooze variable once the alarm
	seconds equals the normal seconds. 
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
     98e:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <snooze>
     992:	81 11       	cpse	r24, r1
     994:	0c 94 67 00 	jmp	0xce	; 0xce <snoozin.part.1>
     998:	08 95       	ret

0000099a <send_lcd>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     99a:	91 e0       	ldi	r25, 0x01	; 1
     99c:	81 11       	cpse	r24, r1
     99e:	01 c0       	rjmp	.+2      	; 0x9a2 <send_lcd+0x8>
     9a0:	90 e0       	ldi	r25, 0x00	; 0
     9a2:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     9a4:	77 9b       	sbis	0x0e, 7	; 14
     9a6:	fe cf       	rjmp	.-4      	; 0x9a4 <send_lcd+0xa>
  SPDR = byte;                        //send payload
     9a8:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     9aa:	77 9b       	sbis	0x0e, 7	; 14
     9ac:	fe cf       	rjmp	.-4      	; 0x9aa <send_lcd+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     9ae:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9b2:	88 60       	ori	r24, 0x08	; 8
     9b4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9b8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9bc:	87 7f       	andi	r24, 0xF7	; 247
     9be:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9c2:	08 95       	ret

000009c4 <refresh_lcd>:
//
void refresh_lcd(char lcd_string_array[]) {

  static uint8_t i=0;           // index into string array 

 send_lcd(CHAR_BYTE,lcd_string_array[i]);
     9c4:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <i.2095>
     9c8:	82 0f       	add	r24, r18
     9ca:	91 1d       	adc	r25, r1
     9cc:	fc 01       	movw	r30, r24
     9ce:	80 81       	ld	r24, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     9d0:	91 e0       	ldi	r25, 0x01	; 1
     9d2:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     9d4:	77 9b       	sbis	0x0e, 7	; 14
     9d6:	fe cf       	rjmp	.-4      	; 0x9d4 <refresh_lcd+0x10>
  SPDR = byte;                        //send payload
     9d8:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     9da:	77 9b       	sbis	0x0e, 7	; 14
     9dc:	fe cf       	rjmp	.-4      	; 0x9da <refresh_lcd+0x16>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     9de:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9e2:	88 60       	ori	r24, 0x08	; 8
     9e4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9e8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9ec:	87 7f       	andi	r24, 0xF7	; 247
     9ee:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
void refresh_lcd(char lcd_string_array[]) {

  static uint8_t i=0;           // index into string array 

 send_lcd(CHAR_BYTE,lcd_string_array[i]);
 i++;   //increment to next character
     9f2:	80 91 55 01 	lds	r24, 0x0155	; 0x800155 <i.2095>
     9f6:	8f 5f       	subi	r24, 0xFF	; 255
     9f8:	80 93 55 01 	sts	0x0155, r24	; 0x800155 <i.2095>
 //delays are inserted to allow character to be written before moving
 //the cursor to the next line.
 if(i == 16){_delay_us(40); line2_col1();      } //goto line 2, 1st char 
     9fc:	80 31       	cpi	r24, 0x10	; 16
     9fe:	f9 f0       	breq	.+62     	; 0xa3e <refresh_lcd+0x7a>
 if(i == 32){_delay_us(40); line1_col1(); i=0; } //goto line 1, 1st char 
     a00:	80 32       	cpi	r24, 0x20	; 32
     a02:	09 f0       	breq	.+2      	; 0xa06 <refresh_lcd+0x42>
     a04:	08 95       	ret
     a06:	e5 ed       	ldi	r30, 0xD5	; 213
     a08:	ea 95       	dec	r30
     a0a:	f1 f7       	brne	.-4      	; 0xa08 <refresh_lcd+0x44>
     a0c:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     a0e:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a10:	77 9b       	sbis	0x0e, 7	; 14
     a12:	fe cf       	rjmp	.-4      	; 0xa10 <refresh_lcd+0x4c>
  SPDR = byte;                        //send payload
     a14:	80 e8       	ldi	r24, 0x80	; 128
     a16:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a18:	77 9b       	sbis	0x0e, 7	; 14
     a1a:	fe cf       	rjmp	.-4      	; 0xa18 <refresh_lcd+0x54>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     a1c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a20:	88 60       	ori	r24, 0x08	; 8
     a22:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a26:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a2a:	87 7f       	andi	r24, 0xF7	; 247
     a2c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a30:	f5 ed       	ldi	r31, 0xD5	; 213
     a32:	fa 95       	dec	r31
     a34:	f1 f7       	brne	.-4      	; 0xa32 <refresh_lcd+0x6e>
     a36:	00 00       	nop
 send_lcd(CHAR_BYTE,lcd_string_array[i]);
 i++;   //increment to next character
 //delays are inserted to allow character to be written before moving
 //the cursor to the next line.
 if(i == 16){_delay_us(40); line2_col1();      } //goto line 2, 1st char 
 if(i == 32){_delay_us(40); line1_col1(); i=0; } //goto line 1, 1st char 
     a38:	10 92 55 01 	sts	0x0155, r1	; 0x800155 <i.2095>
     a3c:	08 95       	ret
     a3e:	f5 ed       	ldi	r31, 0xD5	; 213
     a40:	fa 95       	dec	r31
     a42:	f1 f7       	brne	.-4      	; 0xa40 <refresh_lcd+0x7c>
     a44:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     a46:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a48:	77 9b       	sbis	0x0e, 7	; 14
     a4a:	fe cf       	rjmp	.-4      	; 0xa48 <refresh_lcd+0x84>
  SPDR = byte;                        //send payload
     a4c:	80 ec       	ldi	r24, 0xC0	; 192
     a4e:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a50:	77 9b       	sbis	0x0e, 7	; 14
     a52:	fe cf       	rjmp	.-4      	; 0xa50 <refresh_lcd+0x8c>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     a54:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a58:	88 60       	ori	r24, 0x08	; 8
     a5a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a5e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a62:	87 7f       	andi	r24, 0xF7	; 247
     a64:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a68:	85 ed       	ldi	r24, 0xD5	; 213
     a6a:	8a 95       	dec	r24
     a6c:	f1 f7       	brne	.-4      	; 0xa6a <refresh_lcd+0xa6>
     a6e:	00 00       	nop
     a70:	80 91 55 01 	lds	r24, 0x0155	; 0x800155 <i.2095>
     a74:	c5 cf       	rjmp	.-118    	; 0xa00 <refresh_lcd+0x3c>

00000a76 <set_custom_character>:
//address, such as send_lcd(CHAR_BYTE, 0x01, 1) or it can be insteretd into a string 
//via a forward slash escape as in string2lcd("this is my music note \1")

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
     a76:	66 0f       	add	r22, r22
     a78:	66 0f       	add	r22, r22
     a7a:	66 0f       	add	r22, r22
     a7c:	60 5c       	subi	r22, 0xC0	; 192
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     a7e:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a80:	77 9b       	sbis	0x0e, 7	; 14
     a82:	fe cf       	rjmp	.-4      	; 0xa80 <set_custom_character+0xa>
  SPDR = byte;                        //send payload
     a84:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a86:	77 9b       	sbis	0x0e, 7	; 14
     a88:	fe cf       	rjmp	.-4      	; 0xa86 <set_custom_character+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     a8a:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a8e:	28 60       	ori	r18, 0x08	; 8
     a90:	20 93 62 00 	sts	0x0062, r18	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a94:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a98:	27 7f       	andi	r18, 0xF7	; 247
     a9a:	20 93 62 00 	sts	0x0062, r18	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a9e:	25 ed       	ldi	r18, 0xD5	; 213
     aa0:	2a 95       	dec	r18
     aa2:	f1 f7       	brne	.-4      	; 0xaa0 <set_custom_character+0x2a>
     aa4:	00 00       	nop
     aa6:	fc 01       	movw	r30, r24
     aa8:	9c 01       	movw	r18, r24
     aaa:	28 5f       	subi	r18, 0xF8	; 248
     aac:	3f 4f       	sbci	r19, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     aae:	91 e0       	ldi	r25, 0x01	; 1

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
    for(i=0; i<8; i++){
      send_lcd(CHAR_BYTE, data[i]); _delay_us(40); //each char byte takes 37us to execute
     ab0:	81 91       	ld	r24, Z+
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ab2:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ab4:	77 9b       	sbis	0x0e, 7	; 14
     ab6:	fe cf       	rjmp	.-4      	; 0xab4 <set_custom_character+0x3e>
  SPDR = byte;                        //send payload
     ab8:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     aba:	77 9b       	sbis	0x0e, 7	; 14
     abc:	fe cf       	rjmp	.-4      	; 0xaba <set_custom_character+0x44>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     abe:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ac2:	88 60       	ori	r24, 0x08	; 8
     ac4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ac8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     acc:	87 7f       	andi	r24, 0xF7	; 247
     ace:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ad2:	85 ed       	ldi	r24, 0xD5	; 213
     ad4:	8a 95       	dec	r24
     ad6:	f1 f7       	brne	.-4      	; 0xad4 <set_custom_character+0x5e>
     ad8:	00 00       	nop
//via a forward slash escape as in string2lcd("this is my music note \1")

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
    for(i=0; i<8; i++){
     ada:	e2 17       	cp	r30, r18
     adc:	f3 07       	cpc	r31, r19
     ade:	41 f7       	brne	.-48     	; 0xab0 <set_custom_character+0x3a>
      send_lcd(CHAR_BYTE, data[i]); _delay_us(40); //each char byte takes 37us to execute
    }
}
     ae0:	08 95       	ret

00000ae2 <set_cursor>:
//                          set_cursor 
//
//Sets the cursor to an arbitrary potition on the screen, row is either 1 or 2
//col is a number form 0-15, counting from left to right
void set_cursor(uint8_t row, uint8_t col){
    send_lcd(CMD_BYTE, 0x80 + col + ((row-1)*0x40));
     ae2:	90 e4       	ldi	r25, 0x40	; 64
     ae4:	89 9f       	mul	r24, r25
     ae6:	60 0d       	add	r22, r0
     ae8:	11 24       	eor	r1, r1
     aea:	60 5c       	subi	r22, 0xC0	; 192
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     aec:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     aee:	77 9b       	sbis	0x0e, 7	; 14
     af0:	fe cf       	rjmp	.-4      	; 0xaee <set_cursor+0xc>
  SPDR = byte;                        //send payload
     af2:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     af4:	77 9b       	sbis	0x0e, 7	; 14
     af6:	fe cf       	rjmp	.-4      	; 0xaf4 <set_cursor+0x12>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     af8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     afc:	88 60       	ori	r24, 0x08	; 8
     afe:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b02:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b06:	87 7f       	andi	r24, 0xF7	; 247
     b08:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b0c:	08 95       	ret

00000b0e <uint2lcd>:
//not displayed.  
//TODO: optimize by removing the mod operators
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
     b0e:	81 11       	cpse	r24, r1
     b10:	13 c0       	rjmp	.+38     	; 0xb38 <uint2lcd+0x2a>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b12:	81 e0       	ldi	r24, 0x01	; 1
     b14:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b16:	77 9b       	sbis	0x0e, 7	; 14
     b18:	fe cf       	rjmp	.-4      	; 0xb16 <uint2lcd+0x8>
  SPDR = byte;                        //send payload
     b1a:	80 e3       	ldi	r24, 0x30	; 48
     b1c:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b1e:	77 9b       	sbis	0x0e, 7	; 14
     b20:	fe cf       	rjmp	.-4      	; 0xb1e <uint2lcd+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b22:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b26:	88 60       	ori	r24, 0x08	; 8
     b28:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b2c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b30:	87 7f       	andi	r24, 0xF7	; 247
     b32:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b36:	08 95       	ret
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
     b38:	84 36       	cpi	r24, 0x64	; 100
     b3a:	b0 f4       	brcc	.+44     	; 0xb68 <uint2lcd+0x5a>
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
     b3c:	8a 30       	cpi	r24, 0x0A	; 10
     b3e:	60 f5       	brcc	.+88     	; 0xb98 <uint2lcd+0x8a>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b40:	91 e0       	ldi	r25, 0x01	; 1
     b42:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b44:	77 9b       	sbis	0x0e, 7	; 14
     b46:	fe cf       	rjmp	.-4      	; 0xb44 <uint2lcd+0x36>
void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
      if(number >= 1)  {send_lcd(CHAR_BYTE, 0x30+(number%10)    ); }
     b48:	9d ec       	ldi	r25, 0xCD	; 205
     b4a:	89 9f       	mul	r24, r25
     b4c:	91 2d       	mov	r25, r1
     b4e:	11 24       	eor	r1, r1
     b50:	96 95       	lsr	r25
     b52:	96 95       	lsr	r25
     b54:	96 95       	lsr	r25
     b56:	2a e0       	ldi	r18, 0x0A	; 10
     b58:	92 9f       	mul	r25, r18
     b5a:	80 19       	sub	r24, r0
     b5c:	11 24       	eor	r1, r1
     b5e:	80 5d       	subi	r24, 0xD0	; 208
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
  SPDR = byte;                        //send payload
     b60:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b62:	77 9b       	sbis	0x0e, 7	; 14
     b64:	fe cf       	rjmp	.-4      	; 0xb62 <uint2lcd+0x54>
     b66:	dd cf       	rjmp	.-70     	; 0xb22 <uint2lcd+0x14>
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
     b68:	99 e2       	ldi	r25, 0x29	; 41
     b6a:	89 9f       	mul	r24, r25
     b6c:	91 2d       	mov	r25, r1
     b6e:	11 24       	eor	r1, r1
     b70:	92 95       	swap	r25
     b72:	9f 70       	andi	r25, 0x0F	; 15
     b74:	90 5d       	subi	r25, 0xD0	; 208
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b76:	21 e0       	ldi	r18, 0x01	; 1
     b78:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b7a:	77 9b       	sbis	0x0e, 7	; 14
     b7c:	fe cf       	rjmp	.-4      	; 0xb7a <uint2lcd+0x6c>
  SPDR = byte;                        //send payload
     b7e:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b80:	77 9b       	sbis	0x0e, 7	; 14
     b82:	fe cf       	rjmp	.-4      	; 0xb80 <uint2lcd+0x72>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b84:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b88:	98 60       	ori	r25, 0x08	; 8
     b8a:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b8e:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b92:	97 7f       	andi	r25, 0xF7	; 247
     b94:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
     b98:	99 e2       	ldi	r25, 0x29	; 41
     b9a:	89 9f       	mul	r24, r25
     b9c:	91 2d       	mov	r25, r1
     b9e:	11 24       	eor	r1, r1
     ba0:	92 95       	swap	r25
     ba2:	9f 70       	andi	r25, 0x0F	; 15
     ba4:	38 2f       	mov	r19, r24
     ba6:	24 e6       	ldi	r18, 0x64	; 100
     ba8:	92 9f       	mul	r25, r18
     baa:	30 19       	sub	r19, r0
     bac:	11 24       	eor	r1, r1
     bae:	2d ec       	ldi	r18, 0xCD	; 205
     bb0:	32 9f       	mul	r19, r18
     bb2:	91 2d       	mov	r25, r1
     bb4:	11 24       	eor	r1, r1
     bb6:	96 95       	lsr	r25
     bb8:	96 95       	lsr	r25
     bba:	96 95       	lsr	r25
     bbc:	90 5d       	subi	r25, 0xD0	; 208
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     bbe:	21 e0       	ldi	r18, 0x01	; 1
     bc0:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     bc2:	77 9b       	sbis	0x0e, 7	; 14
     bc4:	fe cf       	rjmp	.-4      	; 0xbc2 <uint2lcd+0xb4>
  SPDR = byte;                        //send payload
     bc6:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     bc8:	77 9b       	sbis	0x0e, 7	; 14
     bca:	fe cf       	rjmp	.-4      	; 0xbc8 <uint2lcd+0xba>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     bcc:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bd0:	98 60       	ori	r25, 0x08	; 8
     bd2:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bd6:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bda:	97 7f       	andi	r25, 0xF7	; 247
     bdc:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     be0:	af cf       	rjmp	.-162    	; 0xb40 <uint2lcd+0x32>

00000be2 <int2lcd>:
//Takes a 8bit signed and displays it in base ten on the LCD. Leading 0's are 
//not displayed.
//
void int2lcd(int8_t number){
    //if < 0, print minus sign, then take 2's complement of number and display
    if(number < 0){send_lcd(CHAR_BYTE, '-'); _delay_us(40); uint2lcd(~number+1);}  
     be2:	87 ff       	sbrs	r24, 7
    else          {uint2lcd(number);                                            }
     be4:	0c 94 87 05 	jmp	0xb0e	; 0xb0e <uint2lcd>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     be8:	91 e0       	ldi	r25, 0x01	; 1
     bea:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     bec:	77 9b       	sbis	0x0e, 7	; 14
     bee:	fe cf       	rjmp	.-4      	; 0xbec <int2lcd+0xa>
  SPDR = byte;                        //send payload
     bf0:	9d e2       	ldi	r25, 0x2D	; 45
     bf2:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     bf4:	77 9b       	sbis	0x0e, 7	; 14
     bf6:	fe cf       	rjmp	.-4      	; 0xbf4 <int2lcd+0x12>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     bf8:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bfc:	98 60       	ori	r25, 0x08	; 8
     bfe:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c02:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c06:	97 7f       	andi	r25, 0xF7	; 247
     c08:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c0c:	95 ed       	ldi	r25, 0xD5	; 213
     c0e:	9a 95       	dec	r25
     c10:	f1 f7       	brne	.-4      	; 0xc0e <int2lcd+0x2c>
     c12:	00 00       	nop
//Takes a 8bit signed and displays it in base ten on the LCD. Leading 0's are 
//not displayed.
//
void int2lcd(int8_t number){
    //if < 0, print minus sign, then take 2's complement of number and display
    if(number < 0){send_lcd(CHAR_BYTE, '-'); _delay_us(40); uint2lcd(~number+1);}  
     c14:	81 95       	neg	r24
     c16:	0c 94 87 05 	jmp	0xb0e	; 0xb0e <uint2lcd>

00000c1a <cursor_on>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c1a:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c1c:	77 9b       	sbis	0x0e, 7	; 14
     c1e:	fe cf       	rjmp	.-4      	; 0xc1c <cursor_on+0x2>
  SPDR = byte;                        //send payload
     c20:	8e e0       	ldi	r24, 0x0E	; 14
     c22:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c24:	77 9b       	sbis	0x0e, 7	; 14
     c26:	fe cf       	rjmp	.-4      	; 0xc24 <cursor_on+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     c28:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c2c:	88 60       	ori	r24, 0x08	; 8
     c2e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c32:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c36:	87 7f       	andi	r24, 0xF7	; 247
     c38:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c3c:	08 95       	ret

00000c3e <cursor_off>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c3e:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c40:	77 9b       	sbis	0x0e, 7	; 14
     c42:	fe cf       	rjmp	.-4      	; 0xc40 <cursor_off+0x2>
  SPDR = byte;                        //send payload
     c44:	8c e0       	ldi	r24, 0x0C	; 12
     c46:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c48:	77 9b       	sbis	0x0e, 7	; 14
     c4a:	fe cf       	rjmp	.-4      	; 0xc48 <cursor_off+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     c4c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c50:	88 60       	ori	r24, 0x08	; 8
     c52:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c56:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c5a:	87 7f       	andi	r24, 0xF7	; 247
     c5c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c60:	08 95       	ret

00000c62 <shift_right>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c62:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c64:	77 9b       	sbis	0x0e, 7	; 14
     c66:	fe cf       	rjmp	.-4      	; 0xc64 <shift_right+0x2>
  SPDR = byte;                        //send payload
     c68:	8e e1       	ldi	r24, 0x1E	; 30
     c6a:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c6c:	77 9b       	sbis	0x0e, 7	; 14
     c6e:	fe cf       	rjmp	.-4      	; 0xc6c <shift_right+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     c70:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c74:	88 60       	ori	r24, 0x08	; 8
     c76:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c7a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c7e:	87 7f       	andi	r24, 0xF7	; 247
     c80:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c84:	08 95       	ret

00000c86 <shift_left>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c86:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c88:	77 9b       	sbis	0x0e, 7	; 14
     c8a:	fe cf       	rjmp	.-4      	; 0xc88 <shift_left+0x2>
  SPDR = byte;                        //send payload
     c8c:	88 e1       	ldi	r24, 0x18	; 24
     c8e:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c90:	77 9b       	sbis	0x0e, 7	; 14
     c92:	fe cf       	rjmp	.-4      	; 0xc90 <shift_left+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     c94:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c98:	88 60       	ori	r24, 0x08	; 8
     c9a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c9e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ca2:	87 7f       	andi	r24, 0xF7	; 247
     ca4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ca8:	08 95       	ret

00000caa <strobe_lcd>:
     caa:	e2 e6       	ldi	r30, 0x62	; 98
     cac:	f0 e0       	ldi	r31, 0x00	; 0
     cae:	80 81       	ld	r24, Z
     cb0:	88 60       	ori	r24, 0x08	; 8
     cb2:	80 83       	st	Z, r24
     cb4:	80 81       	ld	r24, Z
     cb6:	87 7f       	andi	r24, 0xF7	; 247
     cb8:	80 83       	st	Z, r24
     cba:	08 95       	ret

00000cbc <clear_display>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     cbc:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     cbe:	77 9b       	sbis	0x0e, 7	; 14
     cc0:	fe cf       	rjmp	.-4      	; 0xcbe <clear_display+0x2>
  SPDR = byte;                        //send payload
     cc2:	81 e0       	ldi	r24, 0x01	; 1
     cc4:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     cc6:	77 9b       	sbis	0x0e, 7	; 14
     cc8:	fe cf       	rjmp	.-4      	; 0xcc6 <clear_display+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     cca:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cce:	88 60       	ori	r24, 0x08	; 8
     cd0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cd4:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cd8:	87 7f       	andi	r24, 0xF7	; 247
     cda:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cde:	8f e1       	ldi	r24, 0x1F	; 31
     ce0:	9c e1       	ldi	r25, 0x1C	; 28
     ce2:	01 97       	sbiw	r24, 0x01	; 1
     ce4:	f1 f7       	brne	.-4      	; 0xce2 <clear_display+0x26>
     ce6:	00 c0       	rjmp	.+0      	; 0xce8 <clear_display+0x2c>
     ce8:	00 00       	nop
     cea:	08 95       	ret

00000cec <cursor_home>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     cec:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     cee:	77 9b       	sbis	0x0e, 7	; 14
     cf0:	fe cf       	rjmp	.-4      	; 0xcee <cursor_home+0x2>
  SPDR = byte;                        //send payload
     cf2:	82 e0       	ldi	r24, 0x02	; 2
     cf4:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     cf6:	77 9b       	sbis	0x0e, 7	; 14
     cf8:	fe cf       	rjmp	.-4      	; 0xcf6 <cursor_home+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     cfa:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cfe:	88 60       	ori	r24, 0x08	; 8
     d00:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d04:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d08:	87 7f       	andi	r24, 0xF7	; 247
     d0a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d0e:	8f e6       	ldi	r24, 0x6F	; 111
     d10:	97 e1       	ldi	r25, 0x17	; 23
     d12:	01 97       	sbiw	r24, 0x01	; 1
     d14:	f1 f7       	brne	.-4      	; 0xd12 <cursor_home+0x26>
     d16:	00 c0       	rjmp	.+0      	; 0xd18 <cursor_home+0x2c>
     d18:	00 00       	nop
     d1a:	08 95       	ret

00000d1c <line2_col1>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d1c:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d1e:	77 9b       	sbis	0x0e, 7	; 14
     d20:	fe cf       	rjmp	.-4      	; 0xd1e <line2_col1+0x2>
  SPDR = byte;                        //send payload
     d22:	80 ec       	ldi	r24, 0xC0	; 192
     d24:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d26:	77 9b       	sbis	0x0e, 7	; 14
     d28:	fe cf       	rjmp	.-4      	; 0xd26 <line2_col1+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d2a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d2e:	88 60       	ori	r24, 0x08	; 8
     d30:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d34:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d38:	87 7f       	andi	r24, 0xF7	; 247
     d3a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d3e:	85 ed       	ldi	r24, 0xD5	; 213
     d40:	8a 95       	dec	r24
     d42:	f1 f7       	brne	.-4      	; 0xd40 <line2_col1+0x24>
     d44:	00 00       	nop
     d46:	08 95       	ret

00000d48 <line1_col1>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d48:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d4a:	77 9b       	sbis	0x0e, 7	; 14
     d4c:	fe cf       	rjmp	.-4      	; 0xd4a <line1_col1+0x2>
  SPDR = byte;                        //send payload
     d4e:	80 e8       	ldi	r24, 0x80	; 128
     d50:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d52:	77 9b       	sbis	0x0e, 7	; 14
     d54:	fe cf       	rjmp	.-4      	; 0xd52 <line1_col1+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d56:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d5a:	88 60       	ori	r24, 0x08	; 8
     d5c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d60:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d64:	87 7f       	andi	r24, 0xF7	; 247
     d66:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d6a:	85 ed       	ldi	r24, 0xD5	; 213
     d6c:	8a 95       	dec	r24
     d6e:	f1 f7       	brne	.-4      	; 0xd6c <line1_col1+0x24>
     d70:	00 00       	nop
     d72:	08 95       	ret

00000d74 <fill_spaces>:

//-----------------------------------------------------------------------------
//                          fill_spaces   
//
//Fill an entire line with spaces.
void fill_spaces(void){
     d74:	90 e1       	ldi	r25, 0x10	; 16
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d76:	31 e0       	ldi	r19, 0x01	; 1
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
  SPDR = byte;                        //send payload
     d78:	20 e2       	ldi	r18, 0x20	; 32
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d7a:	3f b9       	out	0x0f, r19	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d7c:	77 9b       	sbis	0x0e, 7	; 14
     d7e:	fe cf       	rjmp	.-4      	; 0xd7c <fill_spaces+0x8>
  SPDR = byte;                        //send payload
     d80:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d82:	77 9b       	sbis	0x0e, 7	; 14
     d84:	fe cf       	rjmp	.-4      	; 0xd82 <fill_spaces+0xe>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d86:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d8a:	88 60       	ori	r24, 0x08	; 8
     d8c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d90:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d94:	87 7f       	andi	r24, 0xF7	; 247
     d96:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d9a:	85 ed       	ldi	r24, 0xD5	; 213
     d9c:	8a 95       	dec	r24
     d9e:	f1 f7       	brne	.-4      	; 0xd9c <fill_spaces+0x28>
     da0:	00 00       	nop
     da2:	91 50       	subi	r25, 0x01	; 1
//                          fill_spaces   
//
//Fill an entire line with spaces.
void fill_spaces(void){
	uint8_t i;
	for (i=0; i<=(NUM_LCD_CHARS-1); i++){
     da4:	51 f7       	brne	.-44     	; 0xd7a <fill_spaces+0x6>
		send_lcd(CHAR_BYTE, ' '); 
                _delay_us(40);  //40us wait between characters
	}
}  
     da6:	08 95       	ret

00000da8 <char2lcd>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     da8:	91 e0       	ldi	r25, 0x01	; 1
     daa:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     dac:	77 9b       	sbis	0x0e, 7	; 14
     dae:	fe cf       	rjmp	.-4      	; 0xdac <char2lcd+0x4>
  SPDR = byte;                        //send payload
     db0:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     db2:	77 9b       	sbis	0x0e, 7	; 14
     db4:	fe cf       	rjmp	.-4      	; 0xdb2 <char2lcd+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     db6:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dba:	88 60       	ori	r24, 0x08	; 8
     dbc:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dc0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dc4:	87 7f       	andi	r24, 0xF7	; 247
     dc6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dca:	08 95       	ret

00000dcc <string2lcd>:

//----------------------------------------------------------------------------
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
     dcc:	fc 01       	movw	r30, r24
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     dce:	40 e0       	ldi	r20, 0x00	; 0
     dd0:	50 e0       	ldi	r21, 0x00	; 0
     dd2:	60 e0       	ldi	r22, 0x00	; 0
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     dd4:	71 e0       	ldi	r23, 0x01	; 1
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     dd6:	df 01       	movw	r26, r30
     dd8:	a4 0f       	add	r26, r20
     dda:	b5 1f       	adc	r27, r21
     ddc:	8c 91       	ld	r24, X
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     dde:	7f b9       	out	0x0f, r23	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     de0:	77 9b       	sbis	0x0e, 7	; 14
     de2:	fe cf       	rjmp	.-4      	; 0xde0 <string2lcd+0x14>
  SPDR = byte;                        //send payload
     de4:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     de6:	77 9b       	sbis	0x0e, 7	; 14
     de8:	fe cf       	rjmp	.-4      	; 0xde6 <string2lcd+0x1a>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     dea:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dee:	98 60       	ori	r25, 0x08	; 8
     df0:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     df4:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     df8:	97 7f       	andi	r25, 0xF7	; 247
     dfa:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dfe:	85 ed       	ldi	r24, 0xD5	; 213
     e00:	8a 95       	dec	r24
     e02:	f1 f7       	brne	.-4      	; 0xe00 <string2lcd+0x34>
     e04:	00 00       	nop
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     e06:	6f 5f       	subi	r22, 0xFF	; 255
     e08:	46 2f       	mov	r20, r22
     e0a:	50 e0       	ldi	r21, 0x00	; 0
     e0c:	df 01       	movw	r26, r30
     e0e:	0d 90       	ld	r0, X+
     e10:	00 20       	and	r0, r0
     e12:	e9 f7       	brne	.-6      	; 0xe0e <string2lcd+0x42>
     e14:	9d 01       	movw	r18, r26
     e16:	2e 1b       	sub	r18, r30
     e18:	3f 0b       	sbc	r19, r31
     e1a:	22 50       	subi	r18, 0x02	; 2
     e1c:	31 09       	sbc	r19, r1
     e1e:	24 17       	cp	r18, r20
     e20:	35 07       	cpc	r19, r21
     e22:	c8 f6       	brcc	.-78     	; 0xdd6 <string2lcd+0xa>
  _delay_us(40);  //execution takes 37us per character
  }                  
} 
     e24:	08 95       	ret

00000e26 <lcd_init>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     e26:	8f ef       	ldi	r24, 0xFF	; 255
     e28:	99 ef       	ldi	r25, 0xF9	; 249
     e2a:	01 97       	sbiw	r24, 0x01	; 1
     e2c:	f1 f7       	brne	.-4      	; 0xe2a <lcd_init+0x4>
     e2e:	00 c0       	rjmp	.+0      	; 0xe30 <lcd_init+0xa>
     e30:	00 00       	nop
//
void lcd_init(void){
  _delay_ms(16);      //power up delay
#if SPI_MODE==1       //assumption is that the SPI port is intialized
  //TODO: kludge alert! setting of DDRF should not be here, but is probably harmless.
  DDRF=0x08;          //port F bit 3 is enable for LCD in SPI mode
     e32:	88 e0       	ldi	r24, 0x08	; 8
     e34:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e38:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e3a:	77 9b       	sbis	0x0e, 7	; 14
     e3c:	fe cf       	rjmp	.-4      	; 0xe3a <lcd_init+0x14>
  SPDR = byte;                        //send payload
     e3e:	80 e3       	ldi	r24, 0x30	; 48
     e40:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e42:	77 9b       	sbis	0x0e, 7	; 14
     e44:	fe cf       	rjmp	.-4      	; 0xe42 <lcd_init+0x1c>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     e46:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e4a:	88 60       	ori	r24, 0x08	; 8
     e4c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e50:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e54:	87 7f       	andi	r24, 0xF7	; 247
     e56:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e5a:	8f e5       	ldi	r24, 0x5F	; 95
     e5c:	9d e6       	ldi	r25, 0x6D	; 109
     e5e:	01 97       	sbiw	r24, 0x01	; 1
     e60:	f1 f7       	brne	.-4      	; 0xe5e <lcd_init+0x38>
     e62:	00 c0       	rjmp	.+0      	; 0xe64 <lcd_init+0x3e>
     e64:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e66:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e68:	77 9b       	sbis	0x0e, 7	; 14
     e6a:	fe cf       	rjmp	.-4      	; 0xe68 <lcd_init+0x42>
  SPDR = byte;                        //send payload
     e6c:	80 e3       	ldi	r24, 0x30	; 48
     e6e:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e70:	77 9b       	sbis	0x0e, 7	; 14
     e72:	fe cf       	rjmp	.-4      	; 0xe70 <lcd_init+0x4a>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     e74:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e78:	88 60       	ori	r24, 0x08	; 8
     e7a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e7e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e82:	87 7f       	andi	r24, 0xF7	; 247
     e84:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e88:	8f e5       	ldi	r24, 0x5F	; 95
     e8a:	9d e6       	ldi	r25, 0x6D	; 109
     e8c:	01 97       	sbiw	r24, 0x01	; 1
     e8e:	f1 f7       	brne	.-4      	; 0xe8c <lcd_init+0x66>
     e90:	00 c0       	rjmp	.+0      	; 0xe92 <lcd_init+0x6c>
     e92:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e94:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e96:	77 9b       	sbis	0x0e, 7	; 14
     e98:	fe cf       	rjmp	.-4      	; 0xe96 <lcd_init+0x70>
  SPDR = byte;                        //send payload
     e9a:	80 e3       	ldi	r24, 0x30	; 48
     e9c:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e9e:	77 9b       	sbis	0x0e, 7	; 14
     ea0:	fe cf       	rjmp	.-4      	; 0xe9e <lcd_init+0x78>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     ea2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ea6:	88 60       	ori	r24, 0x08	; 8
     ea8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     eac:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     eb0:	87 7f       	andi	r24, 0xF7	; 247
     eb2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     eb6:	8f e5       	ldi	r24, 0x5F	; 95
     eb8:	9d e6       	ldi	r25, 0x6D	; 109
     eba:	01 97       	sbiw	r24, 0x01	; 1
     ebc:	f1 f7       	brne	.-4      	; 0xeba <lcd_init+0x94>
     ebe:	00 c0       	rjmp	.+0      	; 0xec0 <lcd_init+0x9a>
     ec0:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ec2:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ec4:	77 9b       	sbis	0x0e, 7	; 14
     ec6:	fe cf       	rjmp	.-4      	; 0xec4 <lcd_init+0x9e>
  SPDR = byte;                        //send payload
     ec8:	88 e3       	ldi	r24, 0x38	; 56
     eca:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ecc:	77 9b       	sbis	0x0e, 7	; 14
     ece:	fe cf       	rjmp	.-4      	; 0xecc <lcd_init+0xa6>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     ed0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ed4:	88 60       	ori	r24, 0x08	; 8
     ed6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     eda:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ede:	87 7f       	andi	r24, 0xF7	; 247
     ee0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ee4:	8f e1       	ldi	r24, 0x1F	; 31
     ee6:	9e e4       	ldi	r25, 0x4E	; 78
     ee8:	01 97       	sbiw	r24, 0x01	; 1
     eea:	f1 f7       	brne	.-4      	; 0xee8 <lcd_init+0xc2>
     eec:	00 c0       	rjmp	.+0      	; 0xeee <lcd_init+0xc8>
     eee:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ef0:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ef2:	77 9b       	sbis	0x0e, 7	; 14
     ef4:	fe cf       	rjmp	.-4      	; 0xef2 <lcd_init+0xcc>
  SPDR = byte;                        //send payload
     ef6:	88 e0       	ldi	r24, 0x08	; 8
     ef8:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     efa:	77 9b       	sbis	0x0e, 7	; 14
     efc:	fe cf       	rjmp	.-4      	; 0xefa <lcd_init+0xd4>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     efe:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f02:	88 60       	ori	r24, 0x08	; 8
     f04:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f08:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f0c:	87 7f       	andi	r24, 0xF7	; 247
     f0e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f12:	8f e1       	ldi	r24, 0x1F	; 31
     f14:	9e e4       	ldi	r25, 0x4E	; 78
     f16:	01 97       	sbiw	r24, 0x01	; 1
     f18:	f1 f7       	brne	.-4      	; 0xf16 <lcd_init+0xf0>
     f1a:	00 c0       	rjmp	.+0      	; 0xf1c <lcd_init+0xf6>
     f1c:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     f1e:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f20:	77 9b       	sbis	0x0e, 7	; 14
     f22:	fe cf       	rjmp	.-4      	; 0xf20 <lcd_init+0xfa>
  SPDR = byte;                        //send payload
     f24:	81 e0       	ldi	r24, 0x01	; 1
     f26:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f28:	77 9b       	sbis	0x0e, 7	; 14
     f2a:	fe cf       	rjmp	.-4      	; 0xf28 <lcd_init+0x102>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     f2c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f30:	88 60       	ori	r24, 0x08	; 8
     f32:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f36:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f3a:	87 7f       	andi	r24, 0xF7	; 247
     f3c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f40:	8f e1       	ldi	r24, 0x1F	; 31
     f42:	9e e4       	ldi	r25, 0x4E	; 78
     f44:	01 97       	sbiw	r24, 0x01	; 1
     f46:	f1 f7       	brne	.-4      	; 0xf44 <lcd_init+0x11e>
     f48:	00 c0       	rjmp	.+0      	; 0xf4a <lcd_init+0x124>
     f4a:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     f4c:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f4e:	77 9b       	sbis	0x0e, 7	; 14
     f50:	fe cf       	rjmp	.-4      	; 0xf4e <lcd_init+0x128>
  SPDR = byte;                        //send payload
     f52:	86 e0       	ldi	r24, 0x06	; 6
     f54:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f56:	77 9b       	sbis	0x0e, 7	; 14
     f58:	fe cf       	rjmp	.-4      	; 0xf56 <lcd_init+0x130>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     f5a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f5e:	88 60       	ori	r24, 0x08	; 8
     f60:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f64:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f68:	87 7f       	andi	r24, 0xF7	; 247
     f6a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f6e:	8f e1       	ldi	r24, 0x1F	; 31
     f70:	9e e4       	ldi	r25, 0x4E	; 78
     f72:	01 97       	sbiw	r24, 0x01	; 1
     f74:	f1 f7       	brne	.-4      	; 0xf72 <lcd_init+0x14c>
     f76:	00 c0       	rjmp	.+0      	; 0xf78 <lcd_init+0x152>
     f78:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     f7a:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f7c:	77 9b       	sbis	0x0e, 7	; 14
     f7e:	fe cf       	rjmp	.-4      	; 0xf7c <lcd_init+0x156>
  SPDR = byte;                        //send payload
     f80:	8c e0       	ldi	r24, 0x0C	; 12
     f82:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f84:	77 9b       	sbis	0x0e, 7	; 14
     f86:	fe cf       	rjmp	.-4      	; 0xf84 <lcd_init+0x15e>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     f88:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f8c:	88 60       	ori	r24, 0x08	; 8
     f8e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f92:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f96:	87 7f       	andi	r24, 0xF7	; 247
     f98:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f9c:	8f e1       	ldi	r24, 0x1F	; 31
     f9e:	9e e4       	ldi	r25, 0x4E	; 78
     fa0:	01 97       	sbiw	r24, 0x01	; 1
     fa2:	f1 f7       	brne	.-4      	; 0xfa0 <lcd_init+0x17a>
     fa4:	00 c0       	rjmp	.+0      	; 0xfa6 <lcd_init+0x180>
     fa6:	00 00       	nop
     fa8:	08 95       	ret

00000faa <lcd_int32>:
void  lcd_int32(int32_t l,          //number to display
                uint8_t fieldwidth, //width of the field for display
                uint8_t decpos,     //0 if no decimal point, otherwise
                uint8_t bSigned,    //non-zero if the number should be treated as signed 
                uint8_t bZeroFill)  //non-zero if a specified fieldwidth is to be zero filled
{
     faa:	4f 92       	push	r4
     fac:	5f 92       	push	r5
     fae:	6f 92       	push	r6
     fb0:	7f 92       	push	r7
     fb2:	8f 92       	push	r8
     fb4:	9f 92       	push	r9
     fb6:	af 92       	push	r10
     fb8:	bf 92       	push	r11
     fba:	cf 92       	push	r12
     fbc:	df 92       	push	r13
     fbe:	ef 92       	push	r14
     fc0:	ff 92       	push	r15
     fc2:	0f 93       	push	r16
     fc4:	1f 93       	push	r17
     fc6:	cf 93       	push	r28
     fc8:	df 93       	push	r29
     fca:	cd b7       	in	r28, 0x3d	; 61
     fcc:	de b7       	in	r29, 0x3e	; 62
     fce:	69 97       	sbiw	r28, 0x19	; 25
     fd0:	0f b6       	in	r0, 0x3f	; 63
     fd2:	f8 94       	cli
     fd4:	de bf       	out	0x3e, r29	; 62
     fd6:	0f be       	out	0x3f, r0	; 63
     fd8:	cd bf       	out	0x3d, r28	; 61
     fda:	14 2f       	mov	r17, r20
     fdc:	42 2e       	mov	r4, r18
     fde:	5e 2c       	mov	r5, r14
      char    fillch;
      ldiv_t  qr;

      qr.quot = l; // initialize the quotient 

      if (bSigned){
     fe0:	00 23       	and	r16, r16
     fe2:	79 f0       	breq	.+30     	; 0x1002 <lcd_int32+0x58>
        bSigned = (qr.quot<0);
     fe4:	6b 01       	movw	r12, r22
     fe6:	7c 01       	movw	r14, r24
     fe8:	cc 24       	eor	r12, r12
     fea:	f7 fc       	sbrc	r15, 7
     fec:	c3 94       	inc	r12
     fee:	dd 24       	eor	r13, r13
     ff0:	ee 24       	eor	r14, r14
     ff2:	ff 24       	eor	r15, r15
     ff4:	0c 2d       	mov	r16, r12
        qr.quot = labs(qr.quot);
     ff6:	6b 01       	movw	r12, r22
     ff8:	7c 01       	movw	r14, r24
     ffa:	97 fd       	sbrc	r25, 7
     ffc:	a3 c0       	rjmp	.+326    	; 0x1144 <__stack+0x45>
     ffe:	c7 01       	movw	r24, r14
    1000:	b6 01       	movw	r22, r12
      }

      // convert the digits to the right of the decimal point 
      if (decpos){
    1002:	44 20       	and	r4, r4
    1004:	09 f4       	brne	.+2      	; 0x1008 <lcd_int32+0x5e>
    1006:	96 c0       	rjmp	.+300    	; 0x1134 <__stack+0x35>
    1008:	9e 01       	movw	r18, r28
    100a:	2f 5f       	subi	r18, 0xFF	; 255
    100c:	3f 4f       	sbci	r19, 0xFF	; 255
    100e:	59 01       	movw	r10, r18
    1010:	49 01       	movw	r8, r18
    1012:	66 24       	eor	r6, r6
    1014:	6a 94       	dec	r6
    1016:	64 0c       	add	r6, r4
    1018:	71 2c       	mov	r7, r1
    101a:	3f ef       	ldi	r19, 0xFF	; 255
    101c:	63 1a       	sub	r6, r19
    101e:	73 0a       	sbc	r7, r19
    1020:	6a 0c       	add	r6, r10
    1022:	7b 1c       	adc	r7, r11
        for (; decpos ; decpos--){
          qr = ldiv(qr.quot, 10);
    1024:	2a e0       	ldi	r18, 0x0A	; 10
    1026:	30 e0       	ldi	r19, 0x00	; 0
    1028:	40 e0       	ldi	r20, 0x00	; 0
    102a:	50 e0       	ldi	r21, 0x00	; 0
    102c:	0e 94 14 0a 	call	0x1428	; 0x1428 <__divmodsi4>
    1030:	e6 2f       	mov	r30, r22
    1032:	2a 8b       	std	Y+18, r18	; 0x12
    1034:	3b 8b       	std	Y+19, r19	; 0x13
    1036:	4c 8b       	std	Y+20, r20	; 0x14
    1038:	5d 8b       	std	Y+21, r21	; 0x15
    103a:	6a 89       	ldd	r22, Y+18	; 0x12
    103c:	7b 89       	ldd	r23, Y+19	; 0x13
    103e:	8c 89       	ldd	r24, Y+20	; 0x14
    1040:	9d 89       	ldd	r25, Y+21	; 0x15
          sline[i++] = qr.rem + '0';
    1042:	20 e3       	ldi	r18, 0x30	; 48
    1044:	2e 0f       	add	r18, r30
    1046:	f4 01       	movw	r30, r8
    1048:	21 93       	st	Z+, r18
    104a:	4f 01       	movw	r8, r30
        qr.quot = labs(qr.quot);
      }

      // convert the digits to the right of the decimal point 
      if (decpos){
        for (; decpos ; decpos--){
    104c:	6e 16       	cp	r6, r30
    104e:	7f 06       	cpc	r7, r31
    1050:	49 f7       	brne	.-46     	; 0x1024 <lcd_int32+0x7a>
          qr = ldiv(qr.quot, 10);
          sline[i++] = qr.rem + '0';
        }
        sline[i++] = '.';
    1052:	99 24       	eor	r9, r9
    1054:	93 94       	inc	r9
    1056:	94 0c       	add	r9, r4
    1058:	f5 01       	movw	r30, r10
    105a:	e4 0d       	add	r30, r4
    105c:	f1 1d       	adc	r31, r1
    105e:	2e e2       	ldi	r18, 0x2E	; 46
    1060:	20 83       	st	Z, r18
      }

      // convert the digits to the left of the decimal point 
      do{
          qr = ldiv(qr.quot, 10);
    1062:	2a e0       	ldi	r18, 0x0A	; 10
    1064:	30 e0       	ldi	r19, 0x00	; 0
    1066:	40 e0       	ldi	r20, 0x00	; 0
    1068:	50 e0       	ldi	r21, 0x00	; 0
    106a:	0e 94 14 0a 	call	0x1428	; 0x1428 <__divmodsi4>
    106e:	e6 2f       	mov	r30, r22
    1070:	2a 8b       	std	Y+18, r18	; 0x12
    1072:	3b 8b       	std	Y+19, r19	; 0x13
    1074:	4c 8b       	std	Y+20, r20	; 0x14
    1076:	5d 8b       	std	Y+21, r21	; 0x15
    1078:	6e 8b       	std	Y+22, r22	; 0x16
    107a:	7f 8b       	std	Y+23, r23	; 0x17
    107c:	88 8f       	std	Y+24, r24	; 0x18
    107e:	99 8f       	std	Y+25, r25	; 0x19
    1080:	6a 89       	ldd	r22, Y+18	; 0x12
    1082:	7b 89       	ldd	r23, Y+19	; 0x13
    1084:	8c 89       	ldd	r24, Y+20	; 0x14
    1086:	9d 89       	ldd	r25, Y+21	; 0x15
          sline[i++] = qr.rem + '0';
    1088:	31 e0       	ldi	r19, 0x01	; 1
    108a:	39 0d       	add	r19, r9
    108c:	d5 01       	movw	r26, r10
    108e:	a9 0d       	add	r26, r9
    1090:	b1 1d       	adc	r27, r1
    1092:	e0 5d       	subi	r30, 0xD0	; 208
    1094:	ec 93       	st	X, r30
    1096:	93 2e       	mov	r9, r19
        }while(qr.quot);
    1098:	61 15       	cp	r22, r1
    109a:	71 05       	cpc	r23, r1
    109c:	81 05       	cpc	r24, r1
    109e:	91 05       	cpc	r25, r1
    10a0:	01 f7       	brne	.-64     	; 0x1062 <lcd_int32+0xb8>

      // fill the whole field if a width was specified
      if (fieldwidth){
    10a2:	11 23       	and	r17, r17
    10a4:	61 f0       	breq	.+24     	; 0x10be <lcd_int32+0x114>
        fillch = bZeroFill? '0': ' '; // determine the fill character
    10a6:	51 10       	cpse	r5, r1
    10a8:	4b c0       	rjmp	.+150    	; 0x1140 <__stack+0x41>
    10aa:	90 e2       	ldi	r25, 0x20	; 32
        for (; i<fieldwidth ; ){sline[i++] = fillch;}
    10ac:	31 17       	cp	r19, r17
    10ae:	38 f4       	brcc	.+14     	; 0x10be <lcd_int32+0x114>
    10b0:	f5 01       	movw	r30, r10
    10b2:	e3 0f       	add	r30, r19
    10b4:	f1 1d       	adc	r31, r1
    10b6:	90 83       	st	Z, r25
    10b8:	3f 5f       	subi	r19, 0xFF	; 255
    10ba:	13 13       	cpse	r17, r19
    10bc:	f9 cf       	rjmp	.-14     	; 0x10b0 <lcd_int32+0x106>
      }

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}
    10be:	00 23       	and	r16, r16
    10c0:	31 f0       	breq	.+12     	; 0x10ce <lcd_int32+0x124>
    10c2:	f5 01       	movw	r30, r10
    10c4:	e3 0f       	add	r30, r19
    10c6:	f1 1d       	adc	r31, r1
    10c8:	9d e2       	ldi	r25, 0x2D	; 45
    10ca:	90 83       	st	Z, r25
    10cc:	3f 5f       	subi	r19, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    10ce:	21 e0       	ldi	r18, 0x01	; 1

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}

      // now output the formatted number
      do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    10d0:	31 50       	subi	r19, 0x01	; 1
    10d2:	f5 01       	movw	r30, r10
    10d4:	e3 0f       	add	r30, r19
    10d6:	f1 1d       	adc	r31, r1
    10d8:	90 81       	ld	r25, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    10da:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    10dc:	77 9b       	sbis	0x0e, 7	; 14
    10de:	fe cf       	rjmp	.-4      	; 0x10dc <lcd_int32+0x132>
  SPDR = byte;                        //send payload
    10e0:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    10e2:	77 9b       	sbis	0x0e, 7	; 14
    10e4:	fe cf       	rjmp	.-4      	; 0x10e2 <lcd_int32+0x138>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    10e6:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10ea:	98 60       	ori	r25, 0x08	; 8
    10ec:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10f0:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10f4:	97 7f       	andi	r25, 0xF7	; 247
    10f6:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    10fa:	85 ed       	ldi	r24, 0xD5	; 213
    10fc:	8a 95       	dec	r24
    10fe:	f1 f7       	brne	.-4      	; 0x10fc <lcd_int32+0x152>
    1100:	00 00       	nop

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}

      // now output the formatted number
      do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    1102:	31 11       	cpse	r19, r1
    1104:	e5 cf       	rjmp	.-54     	; 0x10d0 <lcd_int32+0x126>

}
    1106:	69 96       	adiw	r28, 0x19	; 25
    1108:	0f b6       	in	r0, 0x3f	; 63
    110a:	f8 94       	cli
    110c:	de bf       	out	0x3e, r29	; 62
    110e:	0f be       	out	0x3f, r0	; 63
    1110:	cd bf       	out	0x3d, r28	; 61
    1112:	df 91       	pop	r29
    1114:	cf 91       	pop	r28
    1116:	1f 91       	pop	r17
    1118:	0f 91       	pop	r16
    111a:	ff 90       	pop	r15
    111c:	ef 90       	pop	r14
    111e:	df 90       	pop	r13
    1120:	cf 90       	pop	r12
    1122:	bf 90       	pop	r11
    1124:	af 90       	pop	r10
    1126:	9f 90       	pop	r9
    1128:	8f 90       	pop	r8
    112a:	7f 90       	pop	r7
    112c:	6f 90       	pop	r6
    112e:	5f 90       	pop	r5
    1130:	4f 90       	pop	r4
    1132:	08 95       	ret
                uint8_t decpos,     //0 if no decimal point, otherwise
                uint8_t bSigned,    //non-zero if the number should be treated as signed 
                uint8_t bZeroFill)  //non-zero if a specified fieldwidth is to be zero filled
{
      char    sline[NUM_LCD_CHARS+1];
      uint8_t i=0;
    1134:	91 2c       	mov	r9, r1
    1136:	9e 01       	movw	r18, r28
    1138:	2f 5f       	subi	r18, 0xFF	; 255
    113a:	3f 4f       	sbci	r19, 0xFF	; 255
    113c:	59 01       	movw	r10, r18
    113e:	91 cf       	rjmp	.-222    	; 0x1062 <lcd_int32+0xb8>
          sline[i++] = qr.rem + '0';
        }while(qr.quot);

      // fill the whole field if a width was specified
      if (fieldwidth){
        fillch = bZeroFill? '0': ' '; // determine the fill character
    1140:	90 e3       	ldi	r25, 0x30	; 48
    1142:	b4 cf       	rjmp	.-152    	; 0x10ac <lcd_int32+0x102>

      qr.quot = l; // initialize the quotient 

      if (bSigned){
        bSigned = (qr.quot<0);
        qr.quot = labs(qr.quot);
    1144:	f0 94       	com	r15
    1146:	e0 94       	com	r14
    1148:	d0 94       	com	r13
    114a:	c0 94       	com	r12
    114c:	c1 1c       	adc	r12, r1
    114e:	d1 1c       	adc	r13, r1
    1150:	e1 1c       	adc	r14, r1
    1152:	f1 1c       	adc	r15, r1
    1154:	54 cf       	rjmp	.-344    	; 0xffe <lcd_int32+0x54>

00001156 <lcd_int16>:
void    lcd_int16(int16_t l, 
                  uint8_t fieldwidth, 
                  uint8_t decpos, 
                  uint8_t bSigned,
                  uint8_t bZeroFill)
{
    1156:	5f 92       	push	r5
    1158:	6f 92       	push	r6
    115a:	7f 92       	push	r7
    115c:	8f 92       	push	r8
    115e:	9f 92       	push	r9
    1160:	af 92       	push	r10
    1162:	bf 92       	push	r11
    1164:	cf 92       	push	r12
    1166:	df 92       	push	r13
    1168:	ef 92       	push	r14
    116a:	ff 92       	push	r15
    116c:	0f 93       	push	r16
    116e:	1f 93       	push	r17
    1170:	cf 93       	push	r28
    1172:	df 93       	push	r29
    1174:	cd b7       	in	r28, 0x3d	; 61
    1176:	de b7       	in	r29, 0x3e	; 62
    1178:	61 97       	sbiw	r28, 0x11	; 17
    117a:	0f b6       	in	r0, 0x3f	; 63
    117c:	f8 94       	cli
    117e:	de bf       	out	0x3e, r29	; 62
    1180:	0f be       	out	0x3f, r0	; 63
    1182:	cd bf       	out	0x3d, r28	; 61
    1184:	5c 01       	movw	r10, r24
    1186:	16 2f       	mov	r17, r22
    1188:	74 2e       	mov	r7, r20
//        uint8_t bSigned;   Now an argument for signed or not

        // initialize the quotient 
        qr.quot = l;

        if ( (bSigned=(qr.quot<0)) )
    118a:	6b 2c       	mov	r6, r11
    118c:	66 1c       	adc	r6, r6
    118e:	66 24       	eor	r6, r6
    1190:	66 1c       	adc	r6, r6
    1192:	56 2c       	mov	r5, r6
    1194:	9c 01       	movw	r18, r24
    1196:	97 fd       	sbrc	r25, 7
    1198:	9b c0       	rjmp	.+310    	; 0x12d0 <lcd_int16+0x17a>
                qr.quot = -qr.quot;

        // convert the digits to the right of the decimal point 
        if (decpos){
    119a:	77 20       	and	r7, r7
    119c:	09 f4       	brne	.+2      	; 0x11a0 <lcd_int16+0x4a>
    119e:	8d c0       	rjmp	.+282    	; 0x12ba <lcd_int16+0x164>
    11a0:	ce 01       	movw	r24, r28
    11a2:	01 96       	adiw	r24, 0x01	; 1
    11a4:	7c 01       	movw	r14, r24
    11a6:	6c 01       	movw	r12, r24
    11a8:	88 24       	eor	r8, r8
    11aa:	8a 94       	dec	r8
    11ac:	87 0c       	add	r8, r7
    11ae:	91 2c       	mov	r9, r1
    11b0:	9f ef       	ldi	r25, 0xFF	; 255
    11b2:	89 1a       	sub	r8, r25
    11b4:	99 0a       	sbc	r9, r25
    11b6:	8e 0c       	add	r8, r14
    11b8:	9f 1c       	adc	r9, r15
          for (; decpos ; decpos--){
            qr = div(qr.quot, 10);
    11ba:	6a e0       	ldi	r22, 0x0A	; 10
    11bc:	70 e0       	ldi	r23, 0x00	; 0
    11be:	c9 01       	movw	r24, r18
    11c0:	0e 94 00 0a 	call	0x1400	; 0x1400 <__divmodhi4>
    11c4:	46 2f       	mov	r20, r22
    11c6:	24 2f       	mov	r18, r20
    11c8:	37 2f       	mov	r19, r23
            sline[i++] = qr.rem + '0';
    11ca:	80 5d       	subi	r24, 0xD0	; 208
    11cc:	f6 01       	movw	r30, r12
    11ce:	81 93       	st	Z+, r24
    11d0:	6f 01       	movw	r12, r30
        if ( (bSigned=(qr.quot<0)) )
                qr.quot = -qr.quot;

        // convert the digits to the right of the decimal point 
        if (decpos){
          for (; decpos ; decpos--){
    11d2:	e8 15       	cp	r30, r8
    11d4:	f9 05       	cpc	r31, r9
    11d6:	89 f7       	brne	.-30     	; 0x11ba <lcd_int16+0x64>
            qr = div(qr.quot, 10);
            sline[i++] = qr.rem + '0';
          }
          sline[i++] = '.';
    11d8:	dd 24       	eor	r13, r13
    11da:	d3 94       	inc	r13
    11dc:	d7 0c       	add	r13, r7
    11de:	f7 01       	movw	r30, r14
    11e0:	e7 0d       	add	r30, r7
    11e2:	f1 1d       	adc	r31, r1
    11e4:	8e e2       	ldi	r24, 0x2E	; 46
    11e6:	80 83       	st	Z, r24
    11e8:	01 c0       	rjmp	.+2      	; 0x11ec <lcd_int16+0x96>

        // convert the digits to the left of the decimal point 
        do
        {
                qr = div(qr.quot, 10);
                sline[i++] = qr.rem + '0';
    11ea:	d9 2e       	mov	r13, r25
        }

        // convert the digits to the left of the decimal point 
        do
        {
                qr = div(qr.quot, 10);
    11ec:	6a e0       	ldi	r22, 0x0A	; 10
    11ee:	70 e0       	ldi	r23, 0x00	; 0
    11f0:	c9 01       	movw	r24, r18
    11f2:	0e 94 00 0a 	call	0x1400	; 0x1400 <__divmodhi4>
    11f6:	46 2f       	mov	r20, r22
    11f8:	24 2f       	mov	r18, r20
    11fa:	37 2f       	mov	r19, r23
                sline[i++] = qr.rem + '0';
    11fc:	91 e0       	ldi	r25, 0x01	; 1
    11fe:	9d 0d       	add	r25, r13
    1200:	f7 01       	movw	r30, r14
    1202:	ed 0d       	add	r30, r13
    1204:	f1 1d       	adc	r31, r1
    1206:	80 5d       	subi	r24, 0xD0	; 208
    1208:	80 83       	st	Z, r24
        }
        while(qr.quot);
    120a:	21 15       	cp	r18, r1
    120c:	31 05       	cpc	r19, r1
    120e:	69 f7       	brne	.-38     	; 0x11ea <lcd_int16+0x94>

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
    1210:	01 11       	cpse	r16, r1
    1212:	58 c0       	rjmp	.+176    	; 0x12c4 <lcd_int16+0x16e>
    1214:	b7 fc       	sbrc	r11, 7
    1216:	61 c0       	rjmp	.+194    	; 0x12da <lcd_int16+0x184>
                sline[i++] = '-';
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    1218:	11 23       	and	r17, r17
    121a:	a9 f0       	breq	.+42     	; 0x1246 <lcd_int16+0xf0>
    121c:	71 2c       	mov	r7, r1
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    121e:	80 e2       	ldi	r24, 0x20	; 32
          for (; i<(fieldwidth-bSigned) ; ){ sline[i++] = fillch;}
    1220:	29 2f       	mov	r18, r25
    1222:	30 e0       	ldi	r19, 0x00	; 0
    1224:	41 2f       	mov	r20, r17
    1226:	50 e0       	ldi	r21, 0x00	; 0
    1228:	46 19       	sub	r20, r6
    122a:	57 09       	sbc	r21, r7
    122c:	24 17       	cp	r18, r20
    122e:	35 07       	cpc	r19, r21
    1230:	54 f4       	brge	.+20     	; 0x1246 <lcd_int16+0xf0>
    1232:	9f 5f       	subi	r25, 0xFF	; 255
    1234:	f7 01       	movw	r30, r14
    1236:	e2 0f       	add	r30, r18
    1238:	f3 1f       	adc	r31, r19
    123a:	80 83       	st	Z, r24
    123c:	29 2f       	mov	r18, r25
    123e:	30 e0       	ldi	r19, 0x00	; 0
    1240:	24 17       	cp	r18, r20
    1242:	35 07       	cpc	r19, r21
    1244:	b4 f3       	brlt	.-20     	; 0x1232 <lcd_int16+0xdc>
        }

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}
    1246:	55 20       	and	r5, r5
    1248:	31 f0       	breq	.+12     	; 0x1256 <lcd_int16+0x100>
    124a:	f7 01       	movw	r30, r14
    124c:	e9 0f       	add	r30, r25
    124e:	f1 1d       	adc	r31, r1
    1250:	8d e2       	ldi	r24, 0x2D	; 45
    1252:	80 83       	st	Z, r24
    1254:	9f 5f       	subi	r25, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1256:	21 e0       	ldi	r18, 0x01	; 1

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}

        // now output the formatted number 
            do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    1258:	91 50       	subi	r25, 0x01	; 1
    125a:	f7 01       	movw	r30, r14
    125c:	e9 0f       	add	r30, r25
    125e:	f1 1d       	adc	r31, r1
    1260:	80 81       	ld	r24, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1262:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1264:	77 9b       	sbis	0x0e, 7	; 14
    1266:	fe cf       	rjmp	.-4      	; 0x1264 <lcd_int16+0x10e>
  SPDR = byte;                        //send payload
    1268:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    126a:	77 9b       	sbis	0x0e, 7	; 14
    126c:	fe cf       	rjmp	.-4      	; 0x126a <lcd_int16+0x114>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    126e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1272:	88 60       	ori	r24, 0x08	; 8
    1274:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1278:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    127c:	87 7f       	andi	r24, 0xF7	; 247
    127e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1282:	e5 ed       	ldi	r30, 0xD5	; 213
    1284:	ea 95       	dec	r30
    1286:	f1 f7       	brne	.-4      	; 0x1284 <lcd_int16+0x12e>
    1288:	00 00       	nop

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}

        // now output the formatted number 
            do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    128a:	91 11       	cpse	r25, r1
    128c:	e5 cf       	rjmp	.-54     	; 0x1258 <lcd_int16+0x102>
}
    128e:	61 96       	adiw	r28, 0x11	; 17
    1290:	0f b6       	in	r0, 0x3f	; 63
    1292:	f8 94       	cli
    1294:	de bf       	out	0x3e, r29	; 62
    1296:	0f be       	out	0x3f, r0	; 63
    1298:	cd bf       	out	0x3d, r28	; 61
    129a:	df 91       	pop	r29
    129c:	cf 91       	pop	r28
    129e:	1f 91       	pop	r17
    12a0:	0f 91       	pop	r16
    12a2:	ff 90       	pop	r15
    12a4:	ef 90       	pop	r14
    12a6:	df 90       	pop	r13
    12a8:	cf 90       	pop	r12
    12aa:	bf 90       	pop	r11
    12ac:	af 90       	pop	r10
    12ae:	9f 90       	pop	r9
    12b0:	8f 90       	pop	r8
    12b2:	7f 90       	pop	r7
    12b4:	6f 90       	pop	r6
    12b6:	5f 90       	pop	r5
    12b8:	08 95       	ret
                  uint8_t decpos, 
                  uint8_t bSigned,
                  uint8_t bZeroFill)
{
        char    sline[NUM_LCD_CHARS+1];
        uint8_t i=0;
    12ba:	d1 2c       	mov	r13, r1
    12bc:	ce 01       	movw	r24, r28
    12be:	01 96       	adiw	r24, 0x01	; 1
    12c0:	7c 01       	movw	r14, r24
    12c2:	94 cf       	rjmp	.-216    	; 0x11ec <lcd_int16+0x96>
                sline[i++] = '-';
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    12c4:	11 23       	and	r17, r17
    12c6:	09 f4       	brne	.+2      	; 0x12ca <lcd_int16+0x174>
    12c8:	be cf       	rjmp	.-132    	; 0x1246 <lcd_int16+0xf0>
    12ca:	71 2c       	mov	r7, r1
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    12cc:	80 e3       	ldi	r24, 0x30	; 48
    12ce:	a8 cf       	rjmp	.-176    	; 0x1220 <lcd_int16+0xca>
    12d0:	22 27       	eor	r18, r18
    12d2:	33 27       	eor	r19, r19
    12d4:	28 1b       	sub	r18, r24
    12d6:	39 0b       	sbc	r19, r25
    12d8:	60 cf       	rjmp	.-320    	; 0x119a <lcd_int16+0x44>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    12da:	d3 94       	inc	r13
    12dc:	d3 94       	inc	r13
    12de:	f7 01       	movw	r30, r14
    12e0:	e9 0f       	add	r30, r25
    12e2:	f1 1d       	adc	r31, r1
    12e4:	8d e2       	ldi	r24, 0x2D	; 45
    12e6:	80 83       	st	Z, r24
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    12e8:	11 23       	and	r17, r17
    12ea:	59 f0       	breq	.+22     	; 0x1302 <lcd_int16+0x1ac>
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
          for (; i<(fieldwidth-bSigned) ; ){ sline[i++] = fillch;}
    12ec:	2d 2d       	mov	r18, r13
    12ee:	30 e0       	ldi	r19, 0x00	; 0
    12f0:	41 2f       	mov	r20, r17
    12f2:	50 e0       	ldi	r21, 0x00	; 0
    12f4:	24 17       	cp	r18, r20
    12f6:	35 07       	cpc	r19, r21
    12f8:	24 f4       	brge	.+8      	; 0x1302 <lcd_int16+0x1ac>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    12fa:	9d 2d       	mov	r25, r13
                bSigned = 0;
    12fc:	51 2c       	mov	r5, r1
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    12fe:	80 e2       	ldi	r24, 0x20	; 32
    1300:	98 cf       	rjmp	.-208    	; 0x1232 <lcd_int16+0xdc>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    1302:	9d 2d       	mov	r25, r13
    1304:	a8 cf       	rjmp	.-176    	; 0x1256 <lcd_int16+0x100>

00001306 <main>:
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
    1306:	87 b3       	in	r24, 0x17	; 23
    1308:	87 60       	ori	r24, 0x07	; 7
    130a:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
    130c:	8d b1       	in	r24, 0x0d	; 13
    130e:	8c 65       	ori	r24, 0x5C	; 92
    1310:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
    1312:	70 9a       	sbi	0x0e, 0	; 14
Description: Timer counter 0 is initialized in normal mode with no prescale
	and will be used as a seconds counter for the clock
Parameters: NA
**********************************************************************/
void tcnt0_init(){
   ASSR |= (1<<AS0);
    1314:	80 b7       	in	r24, 0x30	; 48
    1316:	88 60       	ori	r24, 0x08	; 8
    1318:	80 bf       	out	0x30, r24	; 48
   TIMSK |= (1<<TOIE0);			//enable interrupts
    131a:	87 b7       	in	r24, 0x37	; 55
    131c:	81 60       	ori	r24, 0x01	; 1
    131e:	87 bf       	out	0x37, r24	; 55
   TCCR0 |= (1<<CS00);			//normal mode, no prescale
    1320:	83 b7       	in	r24, 0x33	; 51
    1322:	81 60       	ori	r24, 0x01	; 1
    1324:	83 bf       	out	0x33, r24	; 51
Description: Timer counter 1 is initialized in CTC mode, 64 bit prescaler
	so that it can be used to generate an alarm frequency
Parameters: NA
**********************************************************************/
void tcnt1_init(){
   TCCR1B |= (1<<CS11) | (1<<CS10) | (1<<WGM12);		//CTC mode, 64bit prescaler
    1326:	8e b5       	in	r24, 0x2e	; 46
    1328:	8b 60       	ori	r24, 0x0B	; 11
    132a:	8e bd       	out	0x2e, r24	; 46
   TCCR1C = 0x00;
    132c:	10 92 7a 00 	sts	0x007A, r1	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
   TIMSK  |= (1<<OCIE1A);	//enable flag for interrupt 
    1330:	87 b7       	in	r24, 0x37	; 55
    1332:	80 61       	ori	r24, 0x10	; 16
    1334:	87 bf       	out	0x37, r24	; 55
   OCR1A = 0x0040;		//compare match at 64
    1336:	80 e4       	ldi	r24, 0x40	; 64
    1338:	90 e0       	ldi	r25, 0x00	; 0
    133a:	9b bd       	out	0x2b, r25	; 43
    133c:	8a bd       	out	0x2a, r24	; 42
	normal mode with a 64 bit prescaler. OCRA2 is adjusted to change
	the pwn produced.
Parameters: NA
**********************************************************************/
void tcnt2_init(){
   TCCR2 |= (1<<WGM21) | (1<<WGM20)| (1<<CS20) | (1<<COM21);			
    133e:	85 b5       	in	r24, 0x25	; 37
    1340:	89 66       	ori	r24, 0x69	; 105
    1342:	85 bd       	out	0x25, r24	; 37
Description: This timer is used as a volume control for the audio amp.
	I adjust the value of OCR3A to change the pwm.
Parameters: NA
**********************************************************************/
void tcnt3_init(){
   TCCR3A |= (1<<COM3A1) | (1<<WGM31);	 //Clear on OCR3A match
    1344:	80 91 8b 00 	lds	r24, 0x008B	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
    1348:	82 68       	ori	r24, 0x82	; 130
    134a:	80 93 8b 00 	sts	0x008B, r24	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
   TCCR3B |= (1<<CS30) | (1<<WGM32) | (1<<WGM33);		//Fast PWM mode, no prescaler
    134e:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
    1352:	89 61       	ori	r24, 0x19	; 25
    1354:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
   TCCR3C = 0x00;
    1358:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x7e008c>
   ICR3 = 0x9F;				//Setting the TOP value
    135c:	8f e9       	ldi	r24, 0x9F	; 159
    135e:	90 e0       	ldi	r25, 0x00	; 0
    1360:	90 93 81 00 	sts	0x0081, r25	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
    1364:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
   TCNT3 = 0x0000; 			//Initialize TNCT1 to 0
    1368:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    136c:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
   OCR3A = 0x9F;			//Volume Control 0x9F=Max 0x00=Min
    1370:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
    1374:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
   spi_init();				//Initalize spi, counters,adc, and lcd
   tcnt0_init();
   tcnt1_init();
   tcnt2_init();
   tcnt3_init();
   port_init();
    1378:	0e 94 f5 03 	call	0x7ea	; 0x7ea <port_init>
Description: Basic adc initialization used for single shot adc readings
Parameters: NA
**********************************************************************/
void adc_init(){
//Initalize ADC and its ports
   DDRF  &= ~(_BV(DDF7)); //make port F bit 7 is ADC input  
    137c:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
    1380:	8f 77       	andi	r24, 0x7F	; 127
    1382:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
   PORTF &= ~(_BV(PF7));  //port F bit 7 pullups must be off
    1386:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    138a:	8f 77       	andi	r24, 0x7F	; 127
    138c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
   ADMUX |= (1<<REFS0) | (1<<MUX2)| (1<<MUX1)| (1<<MUX0); //single-ended, input PORTF bit 7, right adjusted, 10 bits
    1390:	87 b1       	in	r24, 0x07	; 7
    1392:	87 64       	ori	r24, 0x47	; 71
    1394:	87 b9       	out	0x07, r24	; 7

   ADCSRA |= (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);//ADC enabled, don't start yet, single shot mode 
    1396:	86 b1       	in	r24, 0x06	; 6
    1398:	87 68       	ori	r24, 0x87	; 135
    139a:	86 b9       	out	0x06, r24	; 6
   tcnt2_init();
   tcnt3_init();
   port_init();
   adc_init();

   lcd_init();
    139c:	0e 94 13 07 	call	0xe26	; 0xe26 <lcd_init>
   sei();				//Enable interrupts
    13a0:	78 94       	sei
	 }
	 PORTA = segment_data[j];	//Writes the segment data to PORTA aka the segments
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
				//the digit to be displayed is in pin 4, 5, and 6 
         _delay_us(200);		//delay so that the display does not flicker
         PORTA = 0xFF;
    13a2:	cf ef       	ldi	r28, 0xFF	; 255
Description: This function disables the snooze variable once the alarm
	seconds equals the normal seconds. 
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
    13a4:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <snooze>
    13a8:	81 11       	cpse	r24, r1
    13aa:	27 c0       	rjmp	.+78     	; 0x13fa <main+0xf4>

   lcd_init();
   sei();				//Enable interrupts
   while(1){
      snoozin();
      fetch_adc();
    13ac:	0e 94 8b 04 	call	0x916	; 0x916 <fetch_adc>
      clock_time();
    13b0:	0e 94 2d 03 	call	0x65a	; 0x65a <clock_time>
      change_alarm_state();
    13b4:	0e 94 08 04 	call	0x810	; 0x810 <change_alarm_state>
    13b8:	ee e2       	ldi	r30, 0x2E	; 46
    13ba:	f1 e0       	ldi	r31, 0x01	; 1
    13bc:	80 e0       	ldi	r24, 0x00	; 0
      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
         if(alarm){
    13be:	90 91 3b 01 	lds	r25, 0x013B	; 0x80013b <alarm>
    13c2:	99 23       	and	r25, r25
    13c4:	29 f0       	breq	.+10     	; 0x13d0 <main+0xca>
	    segment_data[2] &= 0b011;
    13c6:	90 91 30 01 	lds	r25, 0x0130	; 0x800130 <__data_end+0x2>
    13ca:	93 70       	andi	r25, 0x03	; 3
    13cc:	90 93 30 01 	sts	0x0130, r25	; 0x800130 <__data_end+0x2>
	 }
	 PORTA = segment_data[j];	//Writes the segment data to PORTA aka the segments
    13d0:	91 91       	ld	r25, Z+
    13d2:	9b bb       	out	0x1b, r25	; 27
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
    13d4:	98 2f       	mov	r25, r24
    13d6:	92 95       	swap	r25
    13d8:	90 7f       	andi	r25, 0xF0	; 240
    13da:	98 bb       	out	0x18, r25	; 24
    13dc:	af e1       	ldi	r26, 0x1F	; 31
    13de:	b3 e0       	ldi	r27, 0x03	; 3
    13e0:	11 97       	sbiw	r26, 0x01	; 1
    13e2:	f1 f7       	brne	.-4      	; 0x13e0 <main+0xda>
    13e4:	00 c0       	rjmp	.+0      	; 0x13e6 <main+0xe0>
    13e6:	00 00       	nop
				//the digit to be displayed is in pin 4, 5, and 6 
         _delay_us(200);		//delay so that the display does not flicker
         PORTA = 0xFF;
    13e8:	cb bb       	out	0x1b, r28	; 27
    13ea:	8f 5f       	subi	r24, 0xFF	; 255
   while(1){
      snoozin();
      fetch_adc();
      clock_time();
      change_alarm_state();
      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
    13ec:	85 30       	cpi	r24, 0x05	; 5
    13ee:	39 f7       	brne	.-50     	; 0x13be <main+0xb8>
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
				//the digit to be displayed is in pin 4, 5, and 6 
         _delay_us(200);		//delay so that the display does not flicker
         PORTA = 0xFF;
      }
	PORTB = 0x00;;
    13f0:	18 ba       	out	0x18, r1	; 24
Description: This function disables the snooze variable once the alarm
	seconds equals the normal seconds. 
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
    13f2:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <snooze>
    13f6:	88 23       	and	r24, r24
    13f8:	c9 f2       	breq	.-78     	; 0x13ac <main+0xa6>
    13fa:	0e 94 67 00 	call	0xce	; 0xce <snoozin.part.1>
    13fe:	d6 cf       	rjmp	.-84     	; 0x13ac <main+0xa6>

00001400 <__divmodhi4>:
    1400:	97 fb       	bst	r25, 7
    1402:	07 2e       	mov	r0, r23
    1404:	16 f4       	brtc	.+4      	; 0x140a <__divmodhi4+0xa>
    1406:	00 94       	com	r0
    1408:	07 d0       	rcall	.+14     	; 0x1418 <__divmodhi4_neg1>
    140a:	77 fd       	sbrc	r23, 7
    140c:	09 d0       	rcall	.+18     	; 0x1420 <__divmodhi4_neg2>
    140e:	0e 94 33 0a 	call	0x1466	; 0x1466 <__udivmodhi4>
    1412:	07 fc       	sbrc	r0, 7
    1414:	05 d0       	rcall	.+10     	; 0x1420 <__divmodhi4_neg2>
    1416:	3e f4       	brtc	.+14     	; 0x1426 <__divmodhi4_exit>

00001418 <__divmodhi4_neg1>:
    1418:	90 95       	com	r25
    141a:	81 95       	neg	r24
    141c:	9f 4f       	sbci	r25, 0xFF	; 255
    141e:	08 95       	ret

00001420 <__divmodhi4_neg2>:
    1420:	70 95       	com	r23
    1422:	61 95       	neg	r22
    1424:	7f 4f       	sbci	r23, 0xFF	; 255

00001426 <__divmodhi4_exit>:
    1426:	08 95       	ret

00001428 <__divmodsi4>:
    1428:	05 2e       	mov	r0, r21
    142a:	97 fb       	bst	r25, 7
    142c:	1e f4       	brtc	.+6      	; 0x1434 <__divmodsi4+0xc>
    142e:	00 94       	com	r0
    1430:	0e 94 2b 0a 	call	0x1456	; 0x1456 <__negsi2>
    1434:	57 fd       	sbrc	r21, 7
    1436:	07 d0       	rcall	.+14     	; 0x1446 <__divmodsi4_neg2>
    1438:	0e 94 47 0a 	call	0x148e	; 0x148e <__udivmodsi4>
    143c:	07 fc       	sbrc	r0, 7
    143e:	03 d0       	rcall	.+6      	; 0x1446 <__divmodsi4_neg2>
    1440:	4e f4       	brtc	.+18     	; 0x1454 <__divmodsi4_exit>
    1442:	0c 94 2b 0a 	jmp	0x1456	; 0x1456 <__negsi2>

00001446 <__divmodsi4_neg2>:
    1446:	50 95       	com	r21
    1448:	40 95       	com	r20
    144a:	30 95       	com	r19
    144c:	21 95       	neg	r18
    144e:	3f 4f       	sbci	r19, 0xFF	; 255
    1450:	4f 4f       	sbci	r20, 0xFF	; 255
    1452:	5f 4f       	sbci	r21, 0xFF	; 255

00001454 <__divmodsi4_exit>:
    1454:	08 95       	ret

00001456 <__negsi2>:
    1456:	90 95       	com	r25
    1458:	80 95       	com	r24
    145a:	70 95       	com	r23
    145c:	61 95       	neg	r22
    145e:	7f 4f       	sbci	r23, 0xFF	; 255
    1460:	8f 4f       	sbci	r24, 0xFF	; 255
    1462:	9f 4f       	sbci	r25, 0xFF	; 255
    1464:	08 95       	ret

00001466 <__udivmodhi4>:
    1466:	aa 1b       	sub	r26, r26
    1468:	bb 1b       	sub	r27, r27
    146a:	51 e1       	ldi	r21, 0x11	; 17
    146c:	07 c0       	rjmp	.+14     	; 0x147c <__udivmodhi4_ep>

0000146e <__udivmodhi4_loop>:
    146e:	aa 1f       	adc	r26, r26
    1470:	bb 1f       	adc	r27, r27
    1472:	a6 17       	cp	r26, r22
    1474:	b7 07       	cpc	r27, r23
    1476:	10 f0       	brcs	.+4      	; 0x147c <__udivmodhi4_ep>
    1478:	a6 1b       	sub	r26, r22
    147a:	b7 0b       	sbc	r27, r23

0000147c <__udivmodhi4_ep>:
    147c:	88 1f       	adc	r24, r24
    147e:	99 1f       	adc	r25, r25
    1480:	5a 95       	dec	r21
    1482:	a9 f7       	brne	.-22     	; 0x146e <__udivmodhi4_loop>
    1484:	80 95       	com	r24
    1486:	90 95       	com	r25
    1488:	bc 01       	movw	r22, r24
    148a:	cd 01       	movw	r24, r26
    148c:	08 95       	ret

0000148e <__udivmodsi4>:
    148e:	a1 e2       	ldi	r26, 0x21	; 33
    1490:	1a 2e       	mov	r1, r26
    1492:	aa 1b       	sub	r26, r26
    1494:	bb 1b       	sub	r27, r27
    1496:	fd 01       	movw	r30, r26
    1498:	0d c0       	rjmp	.+26     	; 0x14b4 <__udivmodsi4_ep>

0000149a <__udivmodsi4_loop>:
    149a:	aa 1f       	adc	r26, r26
    149c:	bb 1f       	adc	r27, r27
    149e:	ee 1f       	adc	r30, r30
    14a0:	ff 1f       	adc	r31, r31
    14a2:	a2 17       	cp	r26, r18
    14a4:	b3 07       	cpc	r27, r19
    14a6:	e4 07       	cpc	r30, r20
    14a8:	f5 07       	cpc	r31, r21
    14aa:	20 f0       	brcs	.+8      	; 0x14b4 <__udivmodsi4_ep>
    14ac:	a2 1b       	sub	r26, r18
    14ae:	b3 0b       	sbc	r27, r19
    14b0:	e4 0b       	sbc	r30, r20
    14b2:	f5 0b       	sbc	r31, r21

000014b4 <__udivmodsi4_ep>:
    14b4:	66 1f       	adc	r22, r22
    14b6:	77 1f       	adc	r23, r23
    14b8:	88 1f       	adc	r24, r24
    14ba:	99 1f       	adc	r25, r25
    14bc:	1a 94       	dec	r1
    14be:	69 f7       	brne	.-38     	; 0x149a <__udivmodsi4_loop>
    14c0:	60 95       	com	r22
    14c2:	70 95       	com	r23
    14c4:	80 95       	com	r24
    14c6:	90 95       	com	r25
    14c8:	9b 01       	movw	r18, r22
    14ca:	ac 01       	movw	r20, r24
    14cc:	bd 01       	movw	r22, r26
    14ce:	cf 01       	movw	r24, r30
    14d0:	08 95       	ret

000014d2 <_exit>:
    14d2:	f8 94       	cli

000014d4 <__stop_program>:
    14d4:	ff cf       	rjmp	.-2      	; 0x14d4 <__stop_program>
