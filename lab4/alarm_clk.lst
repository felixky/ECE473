
alarm_clk.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000002c  00800100  00001262  000012f6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001262  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000005a  0080012c  0080012c  00001322  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001322  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001354  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000048  00000000  00000000  00001390  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000021b1  00000000  00000000  000013d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ce3  00000000  00000000  00003589  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000f40  00000000  00000000  0000426c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000370  00000000  00000000  000051ac  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000659  00000000  00000000  0000551c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000018f8  00000000  00000000  00005b75  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000b0  00000000  00000000  0000746d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      40:	0c 94 40 02 	jmp	0x480	; 0x480 <__vector_16>
      44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      54:	0c 94 c5 03 	jmp	0x78a	; 0x78a <__vector_21>
      58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	11 e0       	ldi	r17, 0x01	; 1
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e2 e6       	ldi	r30, 0x62	; 98
      a0:	f2 e1       	ldi	r31, 0x12	; 18
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	ac 32       	cpi	r26, 0x2C	; 44
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	21 e0       	ldi	r18, 0x01	; 1
      b4:	ac e2       	ldi	r26, 0x2C	; 44
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	a6 38       	cpi	r26, 0x86	; 134
      be:	b2 07       	cpc	r27, r18
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	0e 94 85 08 	call	0x110a	; 0x110a <main>
      c6:	0c 94 2f 09 	jmp	0x125e	; 0x125e <_exit>

000000ca <__bad_interrupt>:
      ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <spi_init>:
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
      ce:	87 b3       	in	r24, 0x17	; 23
      d0:	87 60       	ori	r24, 0x07	; 7
      d2:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
      d4:	8d b1       	in	r24, 0x0d	; 13
      d6:	8c 65       	ori	r24, 0x5C	; 92
      d8:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
      da:	70 9a       	sbi	0x0e, 0	; 14
      dc:	08 95       	ret

000000de <tcnt0_init>:
Function:
Description:
Parameters:
**********************************************************************/
void tcnt0_init(){
   ASSR |= (1<<AS0);
      de:	80 b7       	in	r24, 0x30	; 48
      e0:	88 60       	ori	r24, 0x08	; 8
      e2:	80 bf       	out	0x30, r24	; 48
   TIMSK |= (1<<TOIE0);			//enable interrupts
      e4:	87 b7       	in	r24, 0x37	; 55
      e6:	81 60       	ori	r24, 0x01	; 1
      e8:	87 bf       	out	0x37, r24	; 55
   TCCR0 |= (1<<CS00);			//normal mode, no prescale
      ea:	83 b7       	in	r24, 0x33	; 51
      ec:	81 60       	ori	r24, 0x01	; 1
      ee:	83 bf       	out	0x33, r24	; 51
      f0:	08 95       	ret

000000f2 <tcnt1_init>:
      f2:	08 95       	ret

000000f4 <tcnt2_init>:
Function:
Description:
Parameters:
**********************************************************************/
void tcnt2_init(){
   ASSR |= (1<<AS0);
      f4:	80 b7       	in	r24, 0x30	; 48
      f6:	88 60       	ori	r24, 0x08	; 8
      f8:	80 bf       	out	0x30, r24	; 48
   TIMSK |= (1<<TOIE0);			//enable interrupts
      fa:	87 b7       	in	r24, 0x37	; 55
      fc:	81 60       	ori	r24, 0x01	; 1
      fe:	87 bf       	out	0x37, r24	; 55
   TCCR2 |= (1<<WGM21) | (1<<WGM20)| (1<<CS20) | (1<<COM21);			//normal mode, no prescale
     100:	85 b5       	in	r24, 0x25	; 37
     102:	89 66       	ori	r24, 0x69	; 105
     104:	85 bd       	out	0x25, r24	; 37
   OCR2  |= 0xD0;
     106:	83 b5       	in	r24, 0x23	; 35
     108:	80 6d       	ori	r24, 0xD0	; 208
     10a:	83 bd       	out	0x23, r24	; 35
     10c:	08 95       	ret

0000010e <tcnt3_init>:
/**********************************************************************
Function:
Description:
Parameters:
**********************************************************************/
void tcnt3_init(){
     10e:	08 95       	ret

00000110 <spi_read>:
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
     110:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
     112:	77 9b       	sbis	0x0e, 7	; 14
     114:	fe cf       	rjmp	.-4      	; 0x112 <spi_read+0x2>
   return SPDR;
     116:	8f b1       	in	r24, 0x0f	; 15
}
     118:	08 95       	ret

0000011a <chk_buttons>:
	be implemented at the same time. Adapted to check all buttons from 
	Ganssel's "Guide to Debouncing" Expects active low pushbuttons on PINA 
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
     11a:	48 2f       	mov	r20, r24
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
     11c:	e8 2f       	mov	r30, r24
     11e:	f0 e0       	ldi	r31, 0x00	; 0
     120:	99 b3       	in	r25, 0x19	; 25
     122:	ee 0f       	add	r30, r30
     124:	ff 1f       	adc	r31, r31
     126:	ed 5b       	subi	r30, 0xBD	; 189
     128:	fe 4f       	sbci	r31, 0xFE	; 254
     12a:	20 81       	ld	r18, Z
     12c:	31 81       	ldd	r19, Z+1	; 0x01
     12e:	22 0f       	add	r18, r18
     130:	33 1f       	adc	r19, r19
     132:	30 6e       	ori	r19, 0xE0	; 224
     134:	89 2f       	mov	r24, r25
     136:	90 e0       	ldi	r25, 0x00	; 0
     138:	02 c0       	rjmp	.+4      	; 0x13e <chk_buttons+0x24>
     13a:	95 95       	asr	r25
     13c:	87 95       	ror	r24
     13e:	4a 95       	dec	r20
     140:	e2 f7       	brpl	.-8      	; 0x13a <chk_buttons+0x20>
     142:	81 70       	andi	r24, 0x01	; 1
     144:	99 27       	eor	r25, r25
     146:	28 2b       	or	r18, r24
     148:	39 2b       	or	r19, r25
     14a:	31 83       	std	Z+1, r19	; 0x01
     14c:	20 83       	st	Z, r18
     14e:	81 e0       	ldi	r24, 0x01	; 1
     150:	21 15       	cp	r18, r1
     152:	30 4f       	sbci	r19, 0xF0	; 240
     154:	09 f0       	breq	.+2      	; 0x158 <chk_buttons+0x3e>
     156:	80 e0       	ldi	r24, 0x00	; 0
  if (state[button] == 0xF000)
    return 1;
return 0;
}
     158:	08 95       	ret

0000015a <bars>:
Description:This function reads in the button board and updates the 
	LEDs on the bargraph through the serial port.
Parameters: NA
**********************************************************************/
void bars() {
   DDRA = 0x00;				//Set all as inputs
     15a:	1a ba       	out	0x1a, r1	; 26
   PORTA = 0xFF;			//Pull up resistors
     15c:	8f ef       	ldi	r24, 0xFF	; 255
     15e:	8b bb       	out	0x1b, r24	; 27
   PORTB |= PINB | 0x70;		//Enable tristate buffer
     160:	86 b3       	in	r24, 0x16	; 22
     162:	98 b3       	in	r25, 0x18	; 24
     164:	80 67       	ori	r24, 0x70	; 112
     166:	89 2b       	or	r24, r25
     168:	88 bb       	out	0x18, r24	; 24
     16a:	e3 e4       	ldi	r30, 0x43	; 67
     16c:	f1 e0       	ldi	r31, 0x01	; 1

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     16e:	20 e0       	ldi	r18, 0x00	; 0
     170:	30 e0       	ldi	r19, 0x00	; 0
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
     172:	61 e0       	ldi	r22, 0x01	; 1
     174:	70 e0       	ldi	r23, 0x00	; 0
     176:	05 c0       	rjmp	.+10     	; 0x182 <bars+0x28>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     178:	2f 5f       	subi	r18, 0xFF	; 255
     17a:	3f 4f       	sbci	r19, 0xFF	; 255
     17c:	28 30       	cpi	r18, 0x08	; 8
     17e:	31 05       	cpc	r19, r1
     180:	39 f1       	breq	.+78     	; 0x1d0 <bars+0x76>
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
     182:	99 b3       	in	r25, 0x19	; 25
     184:	40 81       	ld	r20, Z
     186:	51 81       	ldd	r21, Z+1	; 0x01
     188:	44 0f       	add	r20, r20
     18a:	55 1f       	adc	r21, r21
     18c:	89 2f       	mov	r24, r25
     18e:	90 e0       	ldi	r25, 0x00	; 0
     190:	02 2e       	mov	r0, r18
     192:	02 c0       	rjmp	.+4      	; 0x198 <bars+0x3e>
     194:	95 95       	asr	r25
     196:	87 95       	ror	r24
     198:	0a 94       	dec	r0
     19a:	e2 f7       	brpl	.-8      	; 0x194 <bars+0x3a>
     19c:	81 70       	andi	r24, 0x01	; 1
     19e:	99 27       	eor	r25, r25
     1a0:	84 2b       	or	r24, r20
     1a2:	95 2b       	or	r25, r21
     1a4:	90 6e       	ori	r25, 0xE0	; 224
     1a6:	81 93       	st	Z+, r24
     1a8:	91 93       	st	Z+, r25
  if (state[button] == 0xF000)
     1aa:	81 15       	cp	r24, r1
     1ac:	90 4f       	sbci	r25, 0xF0	; 240
     1ae:	21 f7       	brne	.-56     	; 0x178 <bars+0x1e>
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
     1b0:	cb 01       	movw	r24, r22
     1b2:	02 2e       	mov	r0, r18
     1b4:	02 c0       	rjmp	.+4      	; 0x1ba <bars+0x60>
     1b6:	88 0f       	add	r24, r24
     1b8:	99 1f       	adc	r25, r25
     1ba:	0a 94       	dec	r0
     1bc:	e2 f7       	brpl	.-8      	; 0x1b6 <bars+0x5c>
     1be:	90 93 36 01 	sts	0x0136, r25	; 0x800136 <mult+0x1>
     1c2:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <mult>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     1c6:	2f 5f       	subi	r18, 0xFF	; 255
     1c8:	3f 4f       	sbci	r19, 0xFF	; 255
     1ca:	28 30       	cpi	r18, 0x08	; 8
     1cc:	31 05       	cpc	r19, r1
     1ce:	c9 f6       	brne	.-78     	; 0x182 <bars+0x28>
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
     1d0:	88 b3       	in	r24, 0x18	; 24
     1d2:	18 ba       	out	0x18, r1	; 24
   if(mult == 128){			//Button 8 toggles base 10 and 16
     1d4:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <mult>
     1d8:	90 91 36 01 	lds	r25, 0x0136	; 0x800136 <mult+0x1>
     1dc:	80 38       	cpi	r24, 0x80	; 128
     1de:	91 05       	cpc	r25, r1
     1e0:	09 f4       	brne	.+2      	; 0x1e4 <bars+0x8a>
     1e2:	42 c0       	rjmp	.+132    	; 0x268 <bars+0x10e>
      alarm = !(alarm);			//on the LED display
   }
   if(mult > 4) {			//I only want values from the
     1e4:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <mult>
     1e8:	90 91 36 01 	lds	r25, 0x0136	; 0x800136 <mult+0x1>
     1ec:	05 97       	sbiw	r24, 0x05	; 5
     1ee:	20 f0       	brcs	.+8      	; 0x1f8 <bars+0x9e>
      mult = 0;				//first three buttons
     1f0:	10 92 36 01 	sts	0x0136, r1	; 0x800136 <mult+0x1>
     1f4:	10 92 35 01 	sts	0x0135, r1	; 0x800135 <mult>
   }
   if(mult == 4){
     1f8:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <mult>
     1fc:	90 91 36 01 	lds	r25, 0x0136	; 0x800136 <mult+0x1>
     200:	04 97       	sbiw	r24, 0x04	; 4
     202:	71 f1       	breq	.+92     	; 0x260 <bars+0x106>
      snooze = 1;
   }
   //This switch statement is used to enable a 'toggle' functionality
   //so that modes can be selected an deselected
   switch(mult) {
     204:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <mult>
     208:	90 91 36 01 	lds	r25, 0x0136	; 0x800136 <mult+0x1>
     20c:	81 30       	cpi	r24, 0x01	; 1
     20e:	91 05       	cpc	r25, r1
     210:	19 f0       	breq	.+6      	; 0x218 <bars+0xbe>
     212:	82 30       	cpi	r24, 0x02	; 2
     214:	91 05       	cpc	r25, r1
     216:	f9 f4       	brne	.+62     	; 0x256 <bars+0xfc>
	 }
	 else
	    mode_sel = 1;		//If not, then change mode
         break;
      case 2:
	 if((mode_sel ^ mult) == 0 ){//if((mode_sel ^ mult) && (mode_sel == 4)){//if cur &prev are diff
     218:	40 91 31 01 	lds	r20, 0x0131	; 0x800131 <mode_sel>
     21c:	50 91 32 01 	lds	r21, 0x0132	; 0x800132 <mode_sel+0x1>
     220:	20 91 35 01 	lds	r18, 0x0135	; 0x800135 <mult>
     224:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <mult+0x1>
     228:	42 17       	cp	r20, r18
     22a:	53 07       	cpc	r21, r19
     22c:	29 f1       	breq	.+74     	; 0x278 <bars+0x11e>
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
         break;*/
      default:
	 mode_sel = mode_sel;		//no/invalid button press
     22e:	90 93 32 01 	sts	0x0132, r25	; 0x800132 <mode_sel+0x1>
     232:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <mode_sel>
   }   
   mult = 0;				//clear mult for next pass
     236:	10 92 36 01 	sts	0x0136, r1	; 0x800136 <mult+0x1>
     23a:	10 92 35 01 	sts	0x0135, r1	; 0x800135 <mult>

   DDRA = 0xFF;				//Set A to alloutputs
     23e:	8f ef       	ldi	r24, 0xFF	; 255
     240:	8a bb       	out	0x1a, r24	; 26
   SPDR = mode_sel;			//Write mode to the Bargraph
     242:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <mode_sel>
     246:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <mode_sel+0x1>
     24a:	8f b9       	out	0x0f, r24	; 15
   while(bit_is_clear(SPSR, SPIF)){}	
     24c:	77 9b       	sbis	0x0e, 7	; 14
     24e:	fe cf       	rjmp	.-4      	; 0x24c <bars+0xf2>
   PORTB |= (1<<PB0);			//Rgclk high on bargraph
     250:	c0 9a       	sbi	0x18, 0	; 24
   PORTB &= 0xFE;			//Rgclk low on bargraph
     252:	c0 98       	cbi	0x18, 0	; 24
   
return ;
     254:	08 95       	ret
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
         break;*/
      default:
	 mode_sel = mode_sel;		//no/invalid button press
     256:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <mode_sel>
     25a:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <mode_sel+0x1>
     25e:	e7 cf       	rjmp	.-50     	; 0x22e <bars+0xd4>
   }
   if(mult > 4) {			//I only want values from the
      mult = 0;				//first three buttons
   }
   if(mult == 4){
      snooze = 1;
     260:	81 e0       	ldi	r24, 0x01	; 1
     262:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <snooze>
     266:	ce cf       	rjmp	.-100    	; 0x204 <bars+0xaa>
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
     268:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <alarm>
     26c:	81 e0       	ldi	r24, 0x01	; 1
     26e:	91 11       	cpse	r25, r1
     270:	08 c0       	rjmp	.+16     	; 0x282 <bars+0x128>
     272:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <alarm>
     276:	b6 cf       	rjmp	.-148    	; 0x1e4 <bars+0x8a>
	 else
	    mode_sel = 1;		//If not, then change mode
         break;
      case 2:
	 if((mode_sel ^ mult) == 0 ){//if((mode_sel ^ mult) && (mode_sel == 4)){//if cur &prev are diff
	    mode_sel = 0;//and prev isn't = 1 then two modes are selected
     278:	10 92 32 01 	sts	0x0132, r1	; 0x800132 <mode_sel+0x1>
     27c:	10 92 31 01 	sts	0x0131, r1	; 0x800131 <mode_sel>
     280:	da cf       	rjmp	.-76     	; 0x236 <bars+0xdc>
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
     282:	80 e0       	ldi	r24, 0x00	; 0
     284:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <alarm>
     288:	ad cf       	rjmp	.-166    	; 0x1e4 <bars+0x8a>

0000028a <read_encoder>:
   int8_t value = 0x00;
   uint8_t ec_a;
   uint8_t ec_b;

   //Shift_LD_N low
   PORTE &= 0x00;	//Begining of SHIFT_LD_N pulse. It is low here
     28a:	83 b1       	in	r24, 0x03	; 3
     28c:	13 b8       	out	0x03, r1	; 3
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     28e:	87 ec       	ldi	r24, 0xC7	; 199
     290:	90 e0       	ldi	r25, 0x00	; 0
     292:	01 97       	sbiw	r24, 0x01	; 1
     294:	f1 f7       	brne	.-4      	; 0x292 <read_encoder+0x8>
     296:	00 c0       	rjmp	.+0      	; 0x298 <read_encoder+0xe>
     298:	00 00       	nop
   _delay_us(50);
   PORTE |= 0xFF;	//End of SHIFT_LD_N pulse. back to high
     29a:	83 b1       	in	r24, 0x03	; 3
     29c:	8f ef       	ldi	r24, 0xFF	; 255
     29e:	83 b9       	out	0x03, r24	; 3
   PORTD &= 0x00;	//CLK_INH low
     2a0:	82 b3       	in	r24, 0x12	; 18
     2a2:	12 ba       	out	0x12, r1	; 18
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
     2a4:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
     2a6:	77 9b       	sbis	0x0e, 7	; 14
     2a8:	fe cf       	rjmp	.-4      	; 0x2a6 <read_encoder+0x1c>
   return SPDR;
     2aa:	9f b1       	in	r25, 0x0f	; 15
   _delay_us(50);
   PORTE |= 0xFF;	//End of SHIFT_LD_N pulse. back to high
   PORTD &= 0x00;	//CLK_INH low

   encoder_value = spi_read();
   PORTD |= 0x02;	//CLK_INH high
     2ac:	91 9a       	sbi	0x12, 1	; 18
   value = mode_sel;
     2ae:	20 91 31 01 	lds	r18, 0x0131	; 0x800131 <mode_sel>
     2b2:	30 91 32 01 	lds	r19, 0x0132	; 0x800132 <mode_sel+0x1>
     2b6:	82 2f       	mov	r24, r18
   ec_a = encoder_value & 0x03;  //Only grabs these bits 0000_0011
     2b8:	49 2f       	mov	r20, r25
     2ba:	43 70       	andi	r20, 0x03	; 3
   ec_b = encoder_value & 0x0C;  //Only grabs these bits 0000_1100 
     2bc:	9c 70       	andi	r25, 0x0C	; 12
   ec_b = (ec_b >> 2);
     2be:	96 95       	lsr	r25
     2c0:	96 95       	lsr	r25

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
     2c2:	20 91 31 01 	lds	r18, 0x0131	; 0x800131 <mode_sel>
     2c6:	30 91 32 01 	lds	r19, 0x0132	; 0x800132 <mode_sel+0x1>
     2ca:	21 30       	cpi	r18, 0x01	; 1
     2cc:	31 05       	cpc	r19, r1
     2ce:	09 f4       	brne	.+2      	; 0x2d2 <read_encoder+0x48>
     2d0:	44 c0       	rjmp	.+136    	; 0x35a <read_encoder+0xd0>
         else
	    value = 0;
      }
   }
//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 2){
     2d2:	20 91 31 01 	lds	r18, 0x0131	; 0x800131 <mode_sel>
     2d6:	30 91 32 01 	lds	r19, 0x0132	; 0x800132 <mode_sel+0x1>
     2da:	22 30       	cpi	r18, 0x02	; 2
     2dc:	31 05       	cpc	r19, r1
     2de:	29 f0       	breq	.+10     	; 0x2ea <read_encoder+0x60>
         else
	    value = 0;
      }
   }
//Saves previous values into volatile variables
EC_a_prev = ec_a;
     2e0:	40 93 55 01 	sts	0x0155, r20	; 0x800155 <EC_a_prev>
EC_b_prev = ec_b;
     2e4:	90 93 54 01 	sts	0x0154, r25	; 0x800154 <EC_b_prev>

return value;
}
     2e8:	08 95       	ret
	    value = 0;
      }
   }
//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 2){
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     2ea:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <EC_a_prev>
     2ee:	64 2f       	mov	r22, r20
     2f0:	70 e0       	ldi	r23, 0x00	; 0
     2f2:	02 2e       	mov	r0, r18
     2f4:	00 0c       	add	r0, r0
     2f6:	33 0b       	sbc	r19, r19
     2f8:	62 17       	cp	r22, r18
     2fa:	73 07       	cpc	r23, r19
     2fc:	d1 f0       	breq	.+52     	; 0x332 <read_encoder+0xa8>
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     2fe:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <EC_a_prev>
     302:	21 11       	cpse	r18, r1
     304:	03 c0       	rjmp	.+6      	; 0x30c <read_encoder+0x82>
     306:	41 30       	cpi	r20, 0x01	; 1
     308:	09 f4       	brne	.+2      	; 0x30c <read_encoder+0x82>
     30a:	89 c0       	rjmp	.+274    	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
            a_hour_count = a_hour_count + 1;//value = value;
	    if(a_hour_count == 24)
	       a_hour_count = 0;
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     30c:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <EC_a_prev>
     310:	21 11       	cpse	r18, r1
     312:	1d c0       	rjmp	.+58     	; 0x34e <read_encoder+0xc4>
     314:	42 30       	cpi	r20, 0x02	; 2
     316:	d9 f4       	brne	.+54     	; 0x34e <read_encoder+0xc4>
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
	    a_min_count = a_min_count - 1; //value = -(value);
	    if(a_min_count < 0){
	       a_min_count = 59;
	       a_hour_count--;
     318:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <a_hour_count>
     31c:	21 50       	subi	r18, 0x01	; 1
     31e:	20 93 3b 01 	sts	0x013B, r18	; 0x80013b <a_hour_count>
	       if(a_hour_count < 0){
     322:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <a_hour_count>
     326:	27 ff       	sbrs	r18, 7
     328:	db cf       	rjmp	.-74     	; 0x2e0 <read_encoder+0x56>
	          a_hour_count = 23;
     32a:	27 e1       	ldi	r18, 0x17	; 23
     32c:	20 93 3b 01 	sts	0x013B, r18	; 0x80013b <a_hour_count>
     330:	d7 cf       	rjmp	.-82     	; 0x2e0 <read_encoder+0x56>
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
     332:	20 91 54 01 	lds	r18, 0x0154	; 0x800154 <EC_b_prev>
     336:	21 11       	cpse	r18, r1
     338:	03 c0       	rjmp	.+6      	; 0x340 <read_encoder+0xb6>
     33a:	91 30       	cpi	r25, 0x01	; 1
     33c:	09 f4       	brne	.+2      	; 0x340 <read_encoder+0xb6>
     33e:	89 c0       	rjmp	.+274    	; 0x452 <__LOCK_REGION_LENGTH__+0x52>
	       a_hour_count++;
	       if(a_hour_count > 23)
	          a_hour_count = 0;
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
     340:	20 91 54 01 	lds	r18, 0x0154	; 0x800154 <EC_b_prev>
     344:	21 11       	cpse	r18, r1
     346:	03 c0       	rjmp	.+6      	; 0x34e <read_encoder+0xc4>
     348:	92 30       	cpi	r25, 0x02	; 2
     34a:	09 f4       	brne	.+2      	; 0x34e <read_encoder+0xc4>
     34c:	75 c0       	rjmp	.+234    	; 0x438 <__LOCK_REGION_LENGTH__+0x38>
	    a_hour_count = a_hour_count - 1;//value = -(value);
	    if(a_hour_count < 0)
	       a_hour_count = 23; 
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
     34e:	80 e0       	ldi	r24, 0x00	; 0
         else
	    value = 0;
      }
   }
//Saves previous values into volatile variables
EC_a_prev = ec_a;
     350:	40 93 55 01 	sts	0x0155, r20	; 0x800155 <EC_a_prev>
EC_b_prev = ec_b;
     354:	90 93 54 01 	sts	0x0154, r25	; 0x800154 <EC_b_prev>

return value;
}
     358:	08 95       	ret
   ec_b = encoder_value & 0x0C;  //Only grabs these bits 0000_1100 
   ec_b = (ec_b >> 2);

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     35a:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <EC_a_prev>
     35e:	64 2f       	mov	r22, r20
     360:	70 e0       	ldi	r23, 0x00	; 0
     362:	02 2e       	mov	r0, r18
     364:	00 0c       	add	r0, r0
     366:	33 0b       	sbc	r19, r19
     368:	62 17       	cp	r22, r18
     36a:	73 07       	cpc	r23, r19
     36c:	d1 f0       	breq	.+52     	; 0x3a2 <read_encoder+0x118>
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     36e:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <EC_a_prev>
     372:	22 23       	and	r18, r18
     374:	49 f0       	breq	.+18     	; 0x388 <read_encoder+0xfe>
            hour_count = hour_count + 1;//value = value;
	    if(hour_count == 24)
	       hour_count = 0;
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     376:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <EC_a_prev>
     37a:	21 11       	cpse	r18, r1
     37c:	03 c0       	rjmp	.+6      	; 0x384 <read_encoder+0xfa>
     37e:	42 30       	cpi	r20, 0x02	; 2
     380:	09 f4       	brne	.+2      	; 0x384 <read_encoder+0xfa>
     382:	40 c0       	rjmp	.+128    	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
	    hour_count = hour_count - 1;//value = -(value);
	    if(hour_count < 0)
	       hour_count = 23; 
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
     384:	80 e0       	ldi	r24, 0x00	; 0
     386:	a5 cf       	rjmp	.-182    	; 0x2d2 <read_encoder+0x48>
   ec_b = (ec_b >> 2);

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     388:	41 30       	cpi	r20, 0x01	; 1
     38a:	a9 f7       	brne	.-22     	; 0x376 <read_encoder+0xec>
            hour_count = hour_count + 1;//value = value;
     38c:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <hour_count>
     390:	2f 5f       	subi	r18, 0xFF	; 255
     392:	20 93 3e 01 	sts	0x013E, r18	; 0x80013e <hour_count>
	    if(hour_count == 24)
     396:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <hour_count>
     39a:	28 31       	cpi	r18, 0x18	; 24
     39c:	09 f0       	breq	.+2      	; 0x3a0 <read_encoder+0x116>
     39e:	99 cf       	rjmp	.-206    	; 0x2d2 <read_encoder+0x48>
     3a0:	1c c0       	rjmp	.+56     	; 0x3da <read_encoder+0x150>
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
     3a2:	20 91 54 01 	lds	r18, 0x0154	; 0x800154 <EC_b_prev>
     3a6:	21 11       	cpse	r18, r1
     3a8:	1b c0       	rjmp	.+54     	; 0x3e0 <read_encoder+0x156>
     3aa:	91 30       	cpi	r25, 0x01	; 1
     3ac:	c9 f4       	brne	.+50     	; 0x3e0 <read_encoder+0x156>
            min_count = min_count + 1;//value = value;
     3ae:	20 91 3f 01 	lds	r18, 0x013F	; 0x80013f <min_count>
     3b2:	2f 5f       	subi	r18, 0xFF	; 255
     3b4:	20 93 3f 01 	sts	0x013F, r18	; 0x80013f <min_count>
	    if(min_count == 60){
     3b8:	20 91 3f 01 	lds	r18, 0x013F	; 0x80013f <min_count>
     3bc:	2c 33       	cpi	r18, 0x3C	; 60
     3be:	09 f0       	breq	.+2      	; 0x3c2 <read_encoder+0x138>
     3c0:	88 cf       	rjmp	.-240    	; 0x2d2 <read_encoder+0x48>
	       min_count = 0; 
     3c2:	10 92 3f 01 	sts	0x013F, r1	; 0x80013f <min_count>
	       hour_count++;
     3c6:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <hour_count>
     3ca:	2f 5f       	subi	r18, 0xFF	; 255
     3cc:	20 93 3e 01 	sts	0x013E, r18	; 0x80013e <hour_count>
	       if(hour_count > 23)
     3d0:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <hour_count>
     3d4:	28 31       	cpi	r18, 0x18	; 24
     3d6:	0c f4       	brge	.+2      	; 0x3da <read_encoder+0x150>
     3d8:	7c cf       	rjmp	.-264    	; 0x2d2 <read_encoder+0x48>
	          hour_count = 0;
     3da:	10 92 3e 01 	sts	0x013E, r1	; 0x80013e <hour_count>
     3de:	79 cf       	rjmp	.-270    	; 0x2d2 <read_encoder+0x48>
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
     3e0:	20 91 54 01 	lds	r18, 0x0154	; 0x800154 <EC_b_prev>
     3e4:	21 11       	cpse	r18, r1
     3e6:	ce cf       	rjmp	.-100    	; 0x384 <read_encoder+0xfa>
     3e8:	92 30       	cpi	r25, 0x02	; 2
     3ea:	61 f6       	brne	.-104    	; 0x384 <read_encoder+0xfa>
	    min_count = min_count - 1; //value = -(value);
     3ec:	20 91 3f 01 	lds	r18, 0x013F	; 0x80013f <min_count>
     3f0:	21 50       	subi	r18, 0x01	; 1
     3f2:	20 93 3f 01 	sts	0x013F, r18	; 0x80013f <min_count>
	    if(min_count < 0){
     3f6:	20 91 3f 01 	lds	r18, 0x013F	; 0x80013f <min_count>
     3fa:	27 ff       	sbrs	r18, 7
     3fc:	6a cf       	rjmp	.-300    	; 0x2d2 <read_encoder+0x48>
	       min_count = 59;
     3fe:	2b e3       	ldi	r18, 0x3B	; 59
     400:	20 93 3f 01 	sts	0x013F, r18	; 0x80013f <min_count>
	       hour_count--;
     404:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <hour_count>
     408:	21 50       	subi	r18, 0x01	; 1
     40a:	20 93 3e 01 	sts	0x013E, r18	; 0x80013e <hour_count>
	       if(hour_count < 0){
     40e:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <hour_count>
     412:	27 ff       	sbrs	r18, 7
     414:	5e cf       	rjmp	.-324    	; 0x2d2 <read_encoder+0x48>
	          hour_count = 23;
     416:	27 e1       	ldi	r18, 0x17	; 23
     418:	20 93 3e 01 	sts	0x013E, r18	; 0x80013e <hour_count>
     41c:	5a cf       	rjmp	.-332    	; 0x2d2 <read_encoder+0x48>
   }
//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 2){
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
            a_hour_count = a_hour_count + 1;//value = value;
     41e:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <a_hour_count>
     422:	2f 5f       	subi	r18, 0xFF	; 255
     424:	20 93 3b 01 	sts	0x013B, r18	; 0x80013b <a_hour_count>
	    if(a_hour_count == 24)
     428:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <a_hour_count>
     42c:	28 31       	cpi	r18, 0x18	; 24
     42e:	09 f0       	breq	.+2      	; 0x432 <__LOCK_REGION_LENGTH__+0x32>
     430:	57 cf       	rjmp	.-338    	; 0x2e0 <read_encoder+0x56>
            a_min_count = a_min_count + 1;//value = value;
	    if(a_min_count == 60){
	       a_min_count = 0; 
	       a_hour_count++;
	       if(a_hour_count > 23)
	          a_hour_count = 0;
     432:	10 92 3b 01 	sts	0x013B, r1	; 0x80013b <a_hour_count>
     436:	54 cf       	rjmp	.-344    	; 0x2e0 <read_encoder+0x56>
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
	    a_min_count = a_min_count - 1; //value = -(value);
     438:	20 91 3c 01 	lds	r18, 0x013C	; 0x80013c <a_min_count>
     43c:	21 50       	subi	r18, 0x01	; 1
     43e:	20 93 3c 01 	sts	0x013C, r18	; 0x80013c <a_min_count>
	    if(a_min_count < 0){
     442:	20 91 3c 01 	lds	r18, 0x013C	; 0x80013c <a_min_count>
     446:	27 ff       	sbrs	r18, 7
     448:	4b cf       	rjmp	.-362    	; 0x2e0 <read_encoder+0x56>
	       a_min_count = 59;
     44a:	2b e3       	ldi	r18, 0x3B	; 59
     44c:	20 93 3c 01 	sts	0x013C, r18	; 0x80013c <a_min_count>
     450:	63 cf       	rjmp	.-314    	; 0x318 <read_encoder+0x8e>
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
            a_min_count = a_min_count + 1;//value = value;
     452:	20 91 3c 01 	lds	r18, 0x013C	; 0x80013c <a_min_count>
     456:	2f 5f       	subi	r18, 0xFF	; 255
     458:	20 93 3c 01 	sts	0x013C, r18	; 0x80013c <a_min_count>
	    if(a_min_count == 60){
     45c:	20 91 3c 01 	lds	r18, 0x013C	; 0x80013c <a_min_count>
     460:	2c 33       	cpi	r18, 0x3C	; 60
     462:	09 f0       	breq	.+2      	; 0x466 <__LOCK_REGION_LENGTH__+0x66>
     464:	3d cf       	rjmp	.-390    	; 0x2e0 <read_encoder+0x56>
	       a_min_count = 0; 
     466:	10 92 3c 01 	sts	0x013C, r1	; 0x80013c <a_min_count>
	       a_hour_count++;
     46a:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <a_hour_count>
     46e:	2f 5f       	subi	r18, 0xFF	; 255
     470:	20 93 3b 01 	sts	0x013B, r18	; 0x80013b <a_hour_count>
	       if(a_hour_count > 23)
     474:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <a_hour_count>
     478:	28 31       	cpi	r18, 0x18	; 24
     47a:	0c f4       	brge	.+2      	; 0x47e <__LOCK_REGION_LENGTH__+0x7e>
     47c:	31 cf       	rjmp	.-414    	; 0x2e0 <read_encoder+0x56>
     47e:	d9 cf       	rjmp	.-78     	; 0x432 <__LOCK_REGION_LENGTH__+0x32>

00000480 <__vector_16>:
	update the mode and bargraph. Then I change the sum based on	
	the value returned from the encoder reading. Sum is then bounded
	from 0-1023. 1023+1=1 and 0-any number > 0 = 1023.
Parameters: NA
**********************************************************************/
ISR(TIMER0_OVF_vect) {
     480:	1f 92       	push	r1
     482:	0f 92       	push	r0
     484:	0f b6       	in	r0, 0x3f	; 63
     486:	0f 92       	push	r0
     488:	11 24       	eor	r1, r1
     48a:	0b b6       	in	r0, 0x3b	; 59
     48c:	0f 92       	push	r0
     48e:	2f 93       	push	r18
     490:	3f 93       	push	r19
     492:	4f 93       	push	r20
     494:	5f 93       	push	r21
     496:	6f 93       	push	r22
     498:	7f 93       	push	r23
     49a:	8f 93       	push	r24
     49c:	9f 93       	push	r25
     49e:	af 93       	push	r26
     4a0:	bf 93       	push	r27
     4a2:	ef 93       	push	r30
     4a4:	ff 93       	push	r31
   static uint8_t count_7_8125ms = 0;

   count_7_8125ms++;
     4a6:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <count_7_8125ms.2010>
     4aa:	8f 5f       	subi	r24, 0xFF	; 255
     4ac:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <count_7_8125ms.2010>
   if((count_7_8125ms % 128) == 0) { //interrupts every 1 second
     4b0:	8f 77       	andi	r24, 0x7F	; 127
     4b2:	29 f4       	brne	.+10     	; 0x4be <__vector_16+0x3e>
      sec_count++;
     4b4:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <sec_count>
     4b8:	8f 5f       	subi	r24, 0xFF	; 255
     4ba:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <sec_count>
   }
   bars();  
     4be:	0e 94 ad 00 	call	0x15a	; 0x15a <bars>
   read_encoder();      
     4c2:	0e 94 45 01 	call	0x28a	; 0x28a <read_encoder>

}
     4c6:	ff 91       	pop	r31
     4c8:	ef 91       	pop	r30
     4ca:	bf 91       	pop	r27
     4cc:	af 91       	pop	r26
     4ce:	9f 91       	pop	r25
     4d0:	8f 91       	pop	r24
     4d2:	7f 91       	pop	r23
     4d4:	6f 91       	pop	r22
     4d6:	5f 91       	pop	r21
     4d8:	4f 91       	pop	r20
     4da:	3f 91       	pop	r19
     4dc:	2f 91       	pop	r18
     4de:	0f 90       	pop	r0
     4e0:	0b be       	out	0x3b, r0	; 59
     4e2:	0f 90       	pop	r0
     4e4:	0f be       	out	0x3f, r0	; 63
     4e6:	0f 90       	pop	r0
     4e8:	1f 90       	pop	r1
     4ea:	18 95       	reti

000004ec <clock_time>:
Description:
Parameters:
**********************************************************************/
void clock_time(){ //by default we use military time
   
   if(sec_count > 59){
     4ec:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <sec_count>
     4f0:	8c 33       	cpi	r24, 0x3C	; 60
     4f2:	60 f0       	brcs	.+24     	; 0x50c <clock_time+0x20>
      min_count++;
     4f4:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <min_count>
     4f8:	8f 5f       	subi	r24, 0xFF	; 255
     4fa:	80 93 3f 01 	sts	0x013F, r24	; 0x80013f <min_count>
      sec_count = 0;
     4fe:	10 92 40 01 	sts	0x0140, r1	; 0x800140 <sec_count>
      if(min_count > 59){
     502:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <min_count>
     506:	8c 33       	cpi	r24, 0x3C	; 60
     508:	0c f0       	brlt	.+2      	; 0x50c <clock_time+0x20>
     50a:	61 c0       	rjmp	.+194    	; 0x5ce <clock_time+0xe2>
         hour_count = 12;
      }    
   }*/

//This is where the digits are written to the data array
      if(mode_sel == 2){
     50c:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <mode_sel>
     510:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <mode_sel+0x1>
     514:	02 97       	sbiw	r24, 0x02	; 2
     516:	09 f4       	brne	.+2      	; 0x51a <clock_time+0x2e>
     518:	6f c0       	rjmp	.+222    	; 0x5f8 <clock_time+0x10c>
         else {segment_data[2] = 0b111;}		//Turn colon off
         segment_data[1] = dec_to_7seg[a_min_count/10];
         segment_data[0] = dec_to_7seg[a_min_count%10];
      }
      else{
         segment_data[4] = dec_to_7seg[hour_count/10];
     51a:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <hour_count>
     51e:	87 e6       	ldi	r24, 0x67	; 103
     520:	98 02       	muls	r25, r24
     522:	e1 2d       	mov	r30, r1
     524:	11 24       	eor	r1, r1
     526:	e5 95       	asr	r30
     528:	e5 95       	asr	r30
     52a:	97 fd       	sbrc	r25, 7
     52c:	e3 95       	inc	r30
     52e:	0e 2e       	mov	r0, r30
     530:	00 0c       	add	r0, r0
     532:	ff 0b       	sbc	r31, r31
     534:	e0 50       	subi	r30, 0x00	; 0
     536:	ff 4f       	sbci	r31, 0xFF	; 255
     538:	90 81       	ld	r25, Z
     53a:	90 93 30 01 	sts	0x0130, r25	; 0x800130 <__data_end+0x4>
         segment_data[3] = dec_to_7seg[hour_count%10];
     53e:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <hour_count>
     542:	e8 02       	muls	r30, r24
     544:	81 2d       	mov	r24, r1
     546:	11 24       	eor	r1, r1
     548:	85 95       	asr	r24
     54a:	85 95       	asr	r24
     54c:	e7 fd       	sbrc	r30, 7
     54e:	83 95       	inc	r24
     550:	9a e0       	ldi	r25, 0x0A	; 10
     552:	89 9f       	mul	r24, r25
     554:	e0 19       	sub	r30, r0
     556:	11 24       	eor	r1, r1
     558:	0e 2e       	mov	r0, r30
     55a:	00 0c       	add	r0, r0
     55c:	ff 0b       	sbc	r31, r31
     55e:	e0 50       	subi	r30, 0x00	; 0
     560:	ff 4f       	sbci	r31, 0xFF	; 255
     562:	80 81       	ld	r24, Z
     564:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <__data_end+0x3>
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     568:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <sec_count>
     56c:	80 fd       	sbrc	r24, 0
     56e:	2b c0       	rjmp	.+86     	; 0x5c6 <clock_time+0xda>
         else {segment_data[2] = 0b111;}		//Turn colon off
     570:	87 e0       	ldi	r24, 0x07	; 7
     572:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <__data_end+0x2>
         segment_data[1] = dec_to_7seg[min_count/10];
     576:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <min_count>
     57a:	87 e6       	ldi	r24, 0x67	; 103
     57c:	98 02       	muls	r25, r24
     57e:	e1 2d       	mov	r30, r1
     580:	11 24       	eor	r1, r1
     582:	e5 95       	asr	r30
     584:	e5 95       	asr	r30
     586:	97 fd       	sbrc	r25, 7
     588:	e3 95       	inc	r30
     58a:	0e 2e       	mov	r0, r30
     58c:	00 0c       	add	r0, r0
     58e:	ff 0b       	sbc	r31, r31
     590:	e0 50       	subi	r30, 0x00	; 0
     592:	ff 4f       	sbci	r31, 0xFF	; 255
     594:	90 81       	ld	r25, Z
     596:	90 93 2d 01 	sts	0x012D, r25	; 0x80012d <__data_end+0x1>
         segment_data[0] = dec_to_7seg[min_count%10];
     59a:	e0 91 3f 01 	lds	r30, 0x013F	; 0x80013f <min_count>
     59e:	e8 02       	muls	r30, r24
     5a0:	81 2d       	mov	r24, r1
     5a2:	11 24       	eor	r1, r1
     5a4:	85 95       	asr	r24
     5a6:	85 95       	asr	r24
     5a8:	e7 fd       	sbrc	r30, 7
     5aa:	83 95       	inc	r24
     5ac:	9a e0       	ldi	r25, 0x0A	; 10
     5ae:	89 9f       	mul	r24, r25
     5b0:	e0 19       	sub	r30, r0
     5b2:	11 24       	eor	r1, r1
     5b4:	0e 2e       	mov	r0, r30
     5b6:	00 0c       	add	r0, r0
     5b8:	ff 0b       	sbc	r31, r31
     5ba:	e0 50       	subi	r30, 0x00	; 0
     5bc:	ff 4f       	sbci	r31, 0xFF	; 255
     5be:	80 81       	ld	r24, Z
     5c0:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <__data_end>
     5c4:	08 95       	ret
         segment_data[0] = dec_to_7seg[a_min_count%10];
      }
      else{
         segment_data[4] = dec_to_7seg[hour_count/10];
         segment_data[3] = dec_to_7seg[hour_count%10];
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     5c6:	84 e0       	ldi	r24, 0x04	; 4
     5c8:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <__data_end+0x2>
     5cc:	d4 cf       	rjmp	.-88     	; 0x576 <clock_time+0x8a>
   
   if(sec_count > 59){
      min_count++;
      sec_count = 0;
      if(min_count > 59){
	 hour_count++;
     5ce:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <hour_count>
     5d2:	8f 5f       	subi	r24, 0xFF	; 255
     5d4:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <hour_count>
	 min_count = 0;
     5d8:	10 92 3f 01 	sts	0x013F, r1	; 0x80013f <min_count>
	 if(hour_count > 23){
     5dc:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <hour_count>
     5e0:	88 31       	cpi	r24, 0x18	; 24
     5e2:	0c f4       	brge	.+2      	; 0x5e6 <clock_time+0xfa>
     5e4:	93 cf       	rjmp	.-218    	; 0x50c <clock_time+0x20>
	    hour_count = 0;
     5e6:	10 92 3e 01 	sts	0x013E, r1	; 0x80013e <hour_count>
         hour_count = 12;
      }    
   }*/

//This is where the digits are written to the data array
      if(mode_sel == 2){
     5ea:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <mode_sel>
     5ee:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <mode_sel+0x1>
     5f2:	02 97       	sbiw	r24, 0x02	; 2
     5f4:	09 f0       	breq	.+2      	; 0x5f8 <clock_time+0x10c>
     5f6:	91 cf       	rjmp	.-222    	; 0x51a <clock_time+0x2e>
         segment_data[4] = dec_to_7seg[a_hour_count/10];
     5f8:	90 91 3b 01 	lds	r25, 0x013B	; 0x80013b <a_hour_count>
     5fc:	87 e6       	ldi	r24, 0x67	; 103
     5fe:	98 02       	muls	r25, r24
     600:	e1 2d       	mov	r30, r1
     602:	11 24       	eor	r1, r1
     604:	e5 95       	asr	r30
     606:	e5 95       	asr	r30
     608:	97 fd       	sbrc	r25, 7
     60a:	e3 95       	inc	r30
     60c:	0e 2e       	mov	r0, r30
     60e:	00 0c       	add	r0, r0
     610:	ff 0b       	sbc	r31, r31
     612:	e0 50       	subi	r30, 0x00	; 0
     614:	ff 4f       	sbci	r31, 0xFF	; 255
     616:	90 81       	ld	r25, Z
     618:	90 93 30 01 	sts	0x0130, r25	; 0x800130 <__data_end+0x4>
         segment_data[3] = dec_to_7seg[a_hour_count%10];
     61c:	e0 91 3b 01 	lds	r30, 0x013B	; 0x80013b <a_hour_count>
     620:	e8 02       	muls	r30, r24
     622:	81 2d       	mov	r24, r1
     624:	11 24       	eor	r1, r1
     626:	85 95       	asr	r24
     628:	85 95       	asr	r24
     62a:	e7 fd       	sbrc	r30, 7
     62c:	83 95       	inc	r24
     62e:	9a e0       	ldi	r25, 0x0A	; 10
     630:	89 9f       	mul	r24, r25
     632:	e0 19       	sub	r30, r0
     634:	11 24       	eor	r1, r1
     636:	0e 2e       	mov	r0, r30
     638:	00 0c       	add	r0, r0
     63a:	ff 0b       	sbc	r31, r31
     63c:	e0 50       	subi	r30, 0x00	; 0
     63e:	ff 4f       	sbci	r31, 0xFF	; 255
     640:	80 81       	ld	r24, Z
     642:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <__data_end+0x3>
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     646:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <sec_count>
     64a:	80 fd       	sbrc	r24, 0
     64c:	18 c0       	rjmp	.+48     	; 0x67e <clock_time+0x192>
         else {segment_data[2] = 0b111;}		//Turn colon off
     64e:	87 e0       	ldi	r24, 0x07	; 7
     650:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <__data_end+0x2>
         segment_data[1] = dec_to_7seg[a_min_count/10];
     654:	90 91 3c 01 	lds	r25, 0x013C	; 0x80013c <a_min_count>
     658:	87 e6       	ldi	r24, 0x67	; 103
     65a:	98 02       	muls	r25, r24
     65c:	e1 2d       	mov	r30, r1
     65e:	11 24       	eor	r1, r1
     660:	e5 95       	asr	r30
     662:	e5 95       	asr	r30
     664:	97 fd       	sbrc	r25, 7
     666:	e3 95       	inc	r30
     668:	0e 2e       	mov	r0, r30
     66a:	00 0c       	add	r0, r0
     66c:	ff 0b       	sbc	r31, r31
     66e:	e0 50       	subi	r30, 0x00	; 0
     670:	ff 4f       	sbci	r31, 0xFF	; 255
     672:	90 81       	ld	r25, Z
     674:	90 93 2d 01 	sts	0x012D, r25	; 0x80012d <__data_end+0x1>
         segment_data[0] = dec_to_7seg[a_min_count%10];
     678:	e0 91 3c 01 	lds	r30, 0x013C	; 0x80013c <a_min_count>
     67c:	90 cf       	rjmp	.-224    	; 0x59e <clock_time+0xb2>

//This is where the digits are written to the data array
      if(mode_sel == 2){
         segment_data[4] = dec_to_7seg[a_hour_count/10];
         segment_data[3] = dec_to_7seg[a_hour_count%10];
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     67e:	84 e0       	ldi	r24, 0x04	; 4
     680:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <__data_end+0x2>
     684:	e7 cf       	rjmp	.-50     	; 0x654 <clock_time+0x168>

00000686 <port_init>:
Function:
Description:
Parameters:
**********************************************************************/
void port_init(){
   DDRC |= 0xFF; 
     686:	84 b3       	in	r24, 0x14	; 20
     688:	9f ef       	ldi	r25, 0xFF	; 255
     68a:	94 bb       	out	0x14, r25	; 20
   DDRB |= 0xF0;				//PB4-6 is SEL0-2, PB7 is PWM
     68c:	87 b3       	in	r24, 0x17	; 23
     68e:	80 6f       	ori	r24, 0xF0	; 240
     690:	87 bb       	out	0x17, r24	; 23
   DDRE |= 0x40;				//PE6 is SHIFT_LD_N
     692:	16 9a       	sbi	0x02, 6	; 2
   DDRD |= 0x0B;				//PE1 is CLK_INH and PE2 is SRCLK
     694:	81 b3       	in	r24, 0x11	; 17
     696:	8b 60       	ori	r24, 0x0B	; 11
     698:	81 bb       	out	0x11, r24	; 17
   PORTC |= 0x00;
     69a:	85 b3       	in	r24, 0x15	; 21
     69c:	85 bb       	out	0x15, r24	; 21
   PORTD |= 0x02;
     69e:	91 9a       	sbi	0x12, 1	; 18
   PORTE |= 0xFF;
     6a0:	83 b1       	in	r24, 0x03	; 3
     6a2:	93 b9       	out	0x03, r25	; 3
     6a4:	08 95       	ret

000006a6 <change_alarm_state>:
/**********************************************************************
Function:
Description:
Parameters:
**********************************************************************/
void change_alarm_state(){
     6a6:	0f 93       	push	r16
   static uint8_t curr = 0;

   if(alarm && (curr == 0)){
     6a8:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <alarm>
     6ac:	88 23       	and	r24, r24
     6ae:	c1 f1       	breq	.+112    	; 0x720 <change_alarm_state+0x7a>
     6b0:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <curr.2017>
     6b4:	81 11       	cpse	r24, r1
     6b6:	34 c0       	rjmp	.+104    	; 0x720 <change_alarm_state+0x7a>
      if((a_hour_count > 9) && (a_min_count > 9)){
     6b8:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <a_hour_count>
     6bc:	8a 30       	cpi	r24, 0x0A	; 10
     6be:	2c f0       	brlt	.+10     	; 0x6ca <change_alarm_state+0x24>
     6c0:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <a_min_count>
     6c4:	8a 30       	cpi	r24, 0x0A	; 10
     6c6:	0c f0       	brlt	.+2      	; 0x6ca <change_alarm_state+0x24>
     6c8:	5d c0       	rjmp	.+186    	; 0x784 <change_alarm_state+0xde>
         string2lcd("ALARM at ");
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         lcd_int16(a_min_count, 2, 0, 0, 0);
      }
      else if(a_hour_count > 9){
     6ca:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <a_hour_count>
     6ce:	8a 30       	cpi	r24, 0x0A	; 10
     6d0:	a4 f5       	brge	.+104    	; 0x73a <change_alarm_state+0x94>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         string2lcd("0");
         lcd_int16(a_min_count, 1, 0, 0, 0);
      }
      else if(a_min_count > 9){
     6d2:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <a_min_count>
     6d6:	8a 30       	cpi	r24, 0x0A	; 10
     6d8:	0c f4       	brge	.+2      	; 0x6dc <change_alarm_state+0x36>
     6da:	51 c0       	rjmp	.+162    	; 0x77e <change_alarm_state+0xd8>
         string2lcd("ALARM at");
     6dc:	83 e2       	ldi	r24, 0x23	; 35
     6de:	91 e0       	ldi	r25, 0x01	; 1
     6e0:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <string2lcd>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
     6e4:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <a_hour_count>
     6e8:	00 e0       	ldi	r16, 0x00	; 0
     6ea:	20 e0       	ldi	r18, 0x00	; 0
     6ec:	40 e0       	ldi	r20, 0x00	; 0
     6ee:	62 e0       	ldi	r22, 0x02	; 2
     6f0:	08 2e       	mov	r0, r24
     6f2:	00 0c       	add	r0, r0
     6f4:	99 0b       	sbc	r25, r25
     6f6:	0e 94 ad 07 	call	0xf5a	; 0xf5a <lcd_int16>
         string2lcd(":");
     6fa:	8f e1       	ldi	r24, 0x1F	; 31
     6fc:	91 e0       	ldi	r25, 0x01	; 1
     6fe:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <string2lcd>
         lcd_int16(a_min_count, 2, 0, 0, 0);
     702:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <a_min_count>
     706:	20 e0       	ldi	r18, 0x00	; 0
     708:	40 e0       	ldi	r20, 0x00	; 0
     70a:	62 e0       	ldi	r22, 0x02	; 2
     70c:	08 2e       	mov	r0, r24
     70e:	00 0c       	add	r0, r0
     710:	99 0b       	sbc	r25, r25
     712:	0e 94 ad 07 	call	0xf5a	; 0xf5a <lcd_int16>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         string2lcd("0");
         lcd_int16(a_min_count, 1, 0, 0, 0);
      }
      curr = 1;
     716:	81 e0       	ldi	r24, 0x01	; 1
     718:	80 93 41 01 	sts	0x0141, r24	; 0x800141 <curr.2017>
   else if((!alarm) && (curr == 1)){
      curr = 0;
      clear_display();
   }
   else{}
}
     71c:	0f 91       	pop	r16
     71e:	08 95       	ret
         string2lcd("0");
         lcd_int16(a_min_count, 1, 0, 0, 0);
      }
      curr = 1;
   }
   else if((!alarm) && (curr == 1)){
     720:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <alarm>
     724:	81 11       	cpse	r24, r1
     726:	fa cf       	rjmp	.-12     	; 0x71c <change_alarm_state+0x76>
     728:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <curr.2017>
     72c:	81 30       	cpi	r24, 0x01	; 1
     72e:	b1 f7       	brne	.-20     	; 0x71c <change_alarm_state+0x76>
      curr = 0;
     730:	10 92 41 01 	sts	0x0141, r1	; 0x800141 <curr.2017>
      clear_display();
   }
   else{}
}
     734:	0f 91       	pop	r16
      }
      curr = 1;
   }
   else if((!alarm) && (curr == 1)){
      curr = 0;
      clear_display();
     736:	0c 94 60 05 	jmp	0xac0	; 0xac0 <clear_display>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         lcd_int16(a_min_count, 2, 0, 0, 0);
      }
      else if(a_hour_count > 9){
         string2lcd("ALARM at ");
     73a:	85 e1       	ldi	r24, 0x15	; 21
     73c:	91 e0       	ldi	r25, 0x01	; 1
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         lcd_int16(a_min_count, 2, 0, 0, 0);
      }
      else {
         string2lcd("ALARM at");
     73e:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <string2lcd>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
     742:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <a_hour_count>
     746:	00 e0       	ldi	r16, 0x00	; 0
     748:	20 e0       	ldi	r18, 0x00	; 0
     74a:	40 e0       	ldi	r20, 0x00	; 0
     74c:	62 e0       	ldi	r22, 0x02	; 2
     74e:	08 2e       	mov	r0, r24
     750:	00 0c       	add	r0, r0
     752:	99 0b       	sbc	r25, r25
     754:	0e 94 ad 07 	call	0xf5a	; 0xf5a <lcd_int16>
         string2lcd(":");
     758:	8f e1       	ldi	r24, 0x1F	; 31
     75a:	91 e0       	ldi	r25, 0x01	; 1
     75c:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <string2lcd>
         string2lcd("0");
     760:	81 e2       	ldi	r24, 0x21	; 33
     762:	91 e0       	ldi	r25, 0x01	; 1
     764:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <string2lcd>
         lcd_int16(a_min_count, 1, 0, 0, 0);
     768:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <a_min_count>
     76c:	20 e0       	ldi	r18, 0x00	; 0
     76e:	40 e0       	ldi	r20, 0x00	; 0
     770:	61 e0       	ldi	r22, 0x01	; 1
     772:	08 2e       	mov	r0, r24
     774:	00 0c       	add	r0, r0
     776:	99 0b       	sbc	r25, r25
     778:	0e 94 ad 07 	call	0xf5a	; 0xf5a <lcd_int16>
     77c:	cc cf       	rjmp	.-104    	; 0x716 <change_alarm_state+0x70>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         lcd_int16(a_min_count, 2, 0, 0, 0);
      }
      else {
         string2lcd("ALARM at");
     77e:	83 e2       	ldi	r24, 0x23	; 35
     780:	91 e0       	ldi	r25, 0x01	; 1
     782:	dd cf       	rjmp	.-70     	; 0x73e <change_alarm_state+0x98>
void change_alarm_state(){
   static uint8_t curr = 0;

   if(alarm && (curr == 0)){
      if((a_hour_count > 9) && (a_min_count > 9)){
         string2lcd("ALARM at ");
     784:	85 e1       	ldi	r24, 0x15	; 21
     786:	91 e0       	ldi	r25, 0x01	; 1
     788:	ab cf       	rjmp	.-170    	; 0x6e0 <change_alarm_state+0x3a>

0000078a <__vector_21>:
/**********************************************************************
Function:
Description:
Parameters:
**********************************************************************/
ISR(ADC_vect){
     78a:	1f 92       	push	r1
     78c:	0f 92       	push	r0
     78e:	0f b6       	in	r0, 0x3f	; 63
     790:	0f 92       	push	r0
     792:	11 24       	eor	r1, r1

}
     794:	0f 90       	pop	r0
     796:	0f be       	out	0x3f, r0	; 63
     798:	0f 90       	pop	r0
     79a:	1f 90       	pop	r1
     79c:	18 95       	reti

0000079e <send_lcd>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     79e:	91 e0       	ldi	r25, 0x01	; 1
     7a0:	81 11       	cpse	r24, r1
     7a2:	01 c0       	rjmp	.+2      	; 0x7a6 <send_lcd+0x8>
     7a4:	90 e0       	ldi	r25, 0x00	; 0
     7a6:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     7a8:	77 9b       	sbis	0x0e, 7	; 14
     7aa:	fe cf       	rjmp	.-4      	; 0x7a8 <send_lcd+0xa>
  SPDR = byte;                        //send payload
     7ac:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     7ae:	77 9b       	sbis	0x0e, 7	; 14
     7b0:	fe cf       	rjmp	.-4      	; 0x7ae <send_lcd+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     7b2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     7b6:	88 60       	ori	r24, 0x08	; 8
     7b8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     7bc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     7c0:	87 7f       	andi	r24, 0xF7	; 247
     7c2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     7c6:	08 95       	ret

000007c8 <refresh_lcd>:
//
void refresh_lcd(char lcd_string_array[]) {

  static uint8_t i=0;           // index into string array 

 send_lcd(CHAR_BYTE,lcd_string_array[i]);
     7c8:	20 91 53 01 	lds	r18, 0x0153	; 0x800153 <i.2095>
     7cc:	82 0f       	add	r24, r18
     7ce:	91 1d       	adc	r25, r1
     7d0:	fc 01       	movw	r30, r24
     7d2:	80 81       	ld	r24, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     7d4:	91 e0       	ldi	r25, 0x01	; 1
     7d6:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     7d8:	77 9b       	sbis	0x0e, 7	; 14
     7da:	fe cf       	rjmp	.-4      	; 0x7d8 <refresh_lcd+0x10>
  SPDR = byte;                        //send payload
     7dc:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     7de:	77 9b       	sbis	0x0e, 7	; 14
     7e0:	fe cf       	rjmp	.-4      	; 0x7de <refresh_lcd+0x16>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     7e2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     7e6:	88 60       	ori	r24, 0x08	; 8
     7e8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     7ec:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     7f0:	87 7f       	andi	r24, 0xF7	; 247
     7f2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
void refresh_lcd(char lcd_string_array[]) {

  static uint8_t i=0;           // index into string array 

 send_lcd(CHAR_BYTE,lcd_string_array[i]);
 i++;   //increment to next character
     7f6:	80 91 53 01 	lds	r24, 0x0153	; 0x800153 <i.2095>
     7fa:	8f 5f       	subi	r24, 0xFF	; 255
     7fc:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <i.2095>
 //delays are inserted to allow character to be written before moving
 //the cursor to the next line.
 if(i == 16){_delay_us(40); line2_col1();      } //goto line 2, 1st char 
     800:	80 31       	cpi	r24, 0x10	; 16
     802:	f9 f0       	breq	.+62     	; 0x842 <refresh_lcd+0x7a>
 if(i == 32){_delay_us(40); line1_col1(); i=0; } //goto line 1, 1st char 
     804:	80 32       	cpi	r24, 0x20	; 32
     806:	09 f0       	breq	.+2      	; 0x80a <refresh_lcd+0x42>
     808:	08 95       	ret
     80a:	e5 ed       	ldi	r30, 0xD5	; 213
     80c:	ea 95       	dec	r30
     80e:	f1 f7       	brne	.-4      	; 0x80c <refresh_lcd+0x44>
     810:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     812:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     814:	77 9b       	sbis	0x0e, 7	; 14
     816:	fe cf       	rjmp	.-4      	; 0x814 <refresh_lcd+0x4c>
  SPDR = byte;                        //send payload
     818:	80 e8       	ldi	r24, 0x80	; 128
     81a:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     81c:	77 9b       	sbis	0x0e, 7	; 14
     81e:	fe cf       	rjmp	.-4      	; 0x81c <refresh_lcd+0x54>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     820:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     824:	88 60       	ori	r24, 0x08	; 8
     826:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     82a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     82e:	87 7f       	andi	r24, 0xF7	; 247
     830:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     834:	f5 ed       	ldi	r31, 0xD5	; 213
     836:	fa 95       	dec	r31
     838:	f1 f7       	brne	.-4      	; 0x836 <refresh_lcd+0x6e>
     83a:	00 00       	nop
 send_lcd(CHAR_BYTE,lcd_string_array[i]);
 i++;   //increment to next character
 //delays are inserted to allow character to be written before moving
 //the cursor to the next line.
 if(i == 16){_delay_us(40); line2_col1();      } //goto line 2, 1st char 
 if(i == 32){_delay_us(40); line1_col1(); i=0; } //goto line 1, 1st char 
     83c:	10 92 53 01 	sts	0x0153, r1	; 0x800153 <i.2095>
     840:	08 95       	ret
     842:	f5 ed       	ldi	r31, 0xD5	; 213
     844:	fa 95       	dec	r31
     846:	f1 f7       	brne	.-4      	; 0x844 <refresh_lcd+0x7c>
     848:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     84a:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     84c:	77 9b       	sbis	0x0e, 7	; 14
     84e:	fe cf       	rjmp	.-4      	; 0x84c <refresh_lcd+0x84>
  SPDR = byte;                        //send payload
     850:	80 ec       	ldi	r24, 0xC0	; 192
     852:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     854:	77 9b       	sbis	0x0e, 7	; 14
     856:	fe cf       	rjmp	.-4      	; 0x854 <refresh_lcd+0x8c>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     858:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     85c:	88 60       	ori	r24, 0x08	; 8
     85e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     862:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     866:	87 7f       	andi	r24, 0xF7	; 247
     868:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     86c:	85 ed       	ldi	r24, 0xD5	; 213
     86e:	8a 95       	dec	r24
     870:	f1 f7       	brne	.-4      	; 0x86e <refresh_lcd+0xa6>
     872:	00 00       	nop
     874:	80 91 53 01 	lds	r24, 0x0153	; 0x800153 <i.2095>
     878:	c5 cf       	rjmp	.-118    	; 0x804 <refresh_lcd+0x3c>

0000087a <set_custom_character>:
//address, such as send_lcd(CHAR_BYTE, 0x01, 1) or it can be insteretd into a string 
//via a forward slash escape as in string2lcd("this is my music note \1")

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
     87a:	66 0f       	add	r22, r22
     87c:	66 0f       	add	r22, r22
     87e:	66 0f       	add	r22, r22
     880:	60 5c       	subi	r22, 0xC0	; 192
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     882:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     884:	77 9b       	sbis	0x0e, 7	; 14
     886:	fe cf       	rjmp	.-4      	; 0x884 <set_custom_character+0xa>
  SPDR = byte;                        //send payload
     888:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     88a:	77 9b       	sbis	0x0e, 7	; 14
     88c:	fe cf       	rjmp	.-4      	; 0x88a <set_custom_character+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     88e:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     892:	28 60       	ori	r18, 0x08	; 8
     894:	20 93 62 00 	sts	0x0062, r18	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     898:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     89c:	27 7f       	andi	r18, 0xF7	; 247
     89e:	20 93 62 00 	sts	0x0062, r18	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8a2:	25 ed       	ldi	r18, 0xD5	; 213
     8a4:	2a 95       	dec	r18
     8a6:	f1 f7       	brne	.-4      	; 0x8a4 <set_custom_character+0x2a>
     8a8:	00 00       	nop
     8aa:	fc 01       	movw	r30, r24
     8ac:	9c 01       	movw	r18, r24
     8ae:	28 5f       	subi	r18, 0xF8	; 248
     8b0:	3f 4f       	sbci	r19, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     8b2:	91 e0       	ldi	r25, 0x01	; 1

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
    for(i=0; i<8; i++){
      send_lcd(CHAR_BYTE, data[i]); _delay_us(40); //each char byte takes 37us to execute
     8b4:	81 91       	ld	r24, Z+
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     8b6:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     8b8:	77 9b       	sbis	0x0e, 7	; 14
     8ba:	fe cf       	rjmp	.-4      	; 0x8b8 <set_custom_character+0x3e>
  SPDR = byte;                        //send payload
     8bc:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     8be:	77 9b       	sbis	0x0e, 7	; 14
     8c0:	fe cf       	rjmp	.-4      	; 0x8be <set_custom_character+0x44>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     8c2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8c6:	88 60       	ori	r24, 0x08	; 8
     8c8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8cc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8d0:	87 7f       	andi	r24, 0xF7	; 247
     8d2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8d6:	85 ed       	ldi	r24, 0xD5	; 213
     8d8:	8a 95       	dec	r24
     8da:	f1 f7       	brne	.-4      	; 0x8d8 <set_custom_character+0x5e>
     8dc:	00 00       	nop
//via a forward slash escape as in string2lcd("this is my music note \1")

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
    for(i=0; i<8; i++){
     8de:	e2 17       	cp	r30, r18
     8e0:	f3 07       	cpc	r31, r19
     8e2:	41 f7       	brne	.-48     	; 0x8b4 <set_custom_character+0x3a>
      send_lcd(CHAR_BYTE, data[i]); _delay_us(40); //each char byte takes 37us to execute
    }
}
     8e4:	08 95       	ret

000008e6 <set_cursor>:
//                          set_cursor 
//
//Sets the cursor to an arbitrary potition on the screen, row is either 1 or 2
//col is a number form 0-15, counting from left to right
void set_cursor(uint8_t row, uint8_t col){
    send_lcd(CMD_BYTE, 0x80 + col + ((row-1)*0x40));
     8e6:	90 e4       	ldi	r25, 0x40	; 64
     8e8:	89 9f       	mul	r24, r25
     8ea:	60 0d       	add	r22, r0
     8ec:	11 24       	eor	r1, r1
     8ee:	60 5c       	subi	r22, 0xC0	; 192
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     8f0:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     8f2:	77 9b       	sbis	0x0e, 7	; 14
     8f4:	fe cf       	rjmp	.-4      	; 0x8f2 <set_cursor+0xc>
  SPDR = byte;                        //send payload
     8f6:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     8f8:	77 9b       	sbis	0x0e, 7	; 14
     8fa:	fe cf       	rjmp	.-4      	; 0x8f8 <set_cursor+0x12>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     8fc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     900:	88 60       	ori	r24, 0x08	; 8
     902:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     906:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     90a:	87 7f       	andi	r24, 0xF7	; 247
     90c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     910:	08 95       	ret

00000912 <uint2lcd>:
//not displayed.  
//TODO: optimize by removing the mod operators
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
     912:	81 11       	cpse	r24, r1
     914:	13 c0       	rjmp	.+38     	; 0x93c <uint2lcd+0x2a>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     916:	81 e0       	ldi	r24, 0x01	; 1
     918:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     91a:	77 9b       	sbis	0x0e, 7	; 14
     91c:	fe cf       	rjmp	.-4      	; 0x91a <uint2lcd+0x8>
  SPDR = byte;                        //send payload
     91e:	80 e3       	ldi	r24, 0x30	; 48
     920:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     922:	77 9b       	sbis	0x0e, 7	; 14
     924:	fe cf       	rjmp	.-4      	; 0x922 <uint2lcd+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     926:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     92a:	88 60       	ori	r24, 0x08	; 8
     92c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     930:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     934:	87 7f       	andi	r24, 0xF7	; 247
     936:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     93a:	08 95       	ret
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
     93c:	84 36       	cpi	r24, 0x64	; 100
     93e:	b0 f4       	brcc	.+44     	; 0x96c <uint2lcd+0x5a>
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
     940:	8a 30       	cpi	r24, 0x0A	; 10
     942:	60 f5       	brcc	.+88     	; 0x99c <uint2lcd+0x8a>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     944:	91 e0       	ldi	r25, 0x01	; 1
     946:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     948:	77 9b       	sbis	0x0e, 7	; 14
     94a:	fe cf       	rjmp	.-4      	; 0x948 <uint2lcd+0x36>
void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
      if(number >= 1)  {send_lcd(CHAR_BYTE, 0x30+(number%10)    ); }
     94c:	9d ec       	ldi	r25, 0xCD	; 205
     94e:	89 9f       	mul	r24, r25
     950:	91 2d       	mov	r25, r1
     952:	11 24       	eor	r1, r1
     954:	96 95       	lsr	r25
     956:	96 95       	lsr	r25
     958:	96 95       	lsr	r25
     95a:	2a e0       	ldi	r18, 0x0A	; 10
     95c:	92 9f       	mul	r25, r18
     95e:	80 19       	sub	r24, r0
     960:	11 24       	eor	r1, r1
     962:	80 5d       	subi	r24, 0xD0	; 208
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
  SPDR = byte;                        //send payload
     964:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     966:	77 9b       	sbis	0x0e, 7	; 14
     968:	fe cf       	rjmp	.-4      	; 0x966 <uint2lcd+0x54>
     96a:	dd cf       	rjmp	.-70     	; 0x926 <uint2lcd+0x14>
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
     96c:	99 e2       	ldi	r25, 0x29	; 41
     96e:	89 9f       	mul	r24, r25
     970:	91 2d       	mov	r25, r1
     972:	11 24       	eor	r1, r1
     974:	92 95       	swap	r25
     976:	9f 70       	andi	r25, 0x0F	; 15
     978:	90 5d       	subi	r25, 0xD0	; 208
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     97a:	21 e0       	ldi	r18, 0x01	; 1
     97c:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     97e:	77 9b       	sbis	0x0e, 7	; 14
     980:	fe cf       	rjmp	.-4      	; 0x97e <uint2lcd+0x6c>
  SPDR = byte;                        //send payload
     982:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     984:	77 9b       	sbis	0x0e, 7	; 14
     986:	fe cf       	rjmp	.-4      	; 0x984 <uint2lcd+0x72>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     988:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     98c:	98 60       	ori	r25, 0x08	; 8
     98e:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     992:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     996:	97 7f       	andi	r25, 0xF7	; 247
     998:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
     99c:	99 e2       	ldi	r25, 0x29	; 41
     99e:	89 9f       	mul	r24, r25
     9a0:	91 2d       	mov	r25, r1
     9a2:	11 24       	eor	r1, r1
     9a4:	92 95       	swap	r25
     9a6:	9f 70       	andi	r25, 0x0F	; 15
     9a8:	38 2f       	mov	r19, r24
     9aa:	24 e6       	ldi	r18, 0x64	; 100
     9ac:	92 9f       	mul	r25, r18
     9ae:	30 19       	sub	r19, r0
     9b0:	11 24       	eor	r1, r1
     9b2:	2d ec       	ldi	r18, 0xCD	; 205
     9b4:	32 9f       	mul	r19, r18
     9b6:	91 2d       	mov	r25, r1
     9b8:	11 24       	eor	r1, r1
     9ba:	96 95       	lsr	r25
     9bc:	96 95       	lsr	r25
     9be:	96 95       	lsr	r25
     9c0:	90 5d       	subi	r25, 0xD0	; 208
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     9c2:	21 e0       	ldi	r18, 0x01	; 1
     9c4:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     9c6:	77 9b       	sbis	0x0e, 7	; 14
     9c8:	fe cf       	rjmp	.-4      	; 0x9c6 <uint2lcd+0xb4>
  SPDR = byte;                        //send payload
     9ca:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     9cc:	77 9b       	sbis	0x0e, 7	; 14
     9ce:	fe cf       	rjmp	.-4      	; 0x9cc <uint2lcd+0xba>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     9d0:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9d4:	98 60       	ori	r25, 0x08	; 8
     9d6:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9da:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9de:	97 7f       	andi	r25, 0xF7	; 247
     9e0:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9e4:	af cf       	rjmp	.-162    	; 0x944 <uint2lcd+0x32>

000009e6 <int2lcd>:
//Takes a 8bit signed and displays it in base ten on the LCD. Leading 0's are 
//not displayed.
//
void int2lcd(int8_t number){
    //if < 0, print minus sign, then take 2's complement of number and display
    if(number < 0){send_lcd(CHAR_BYTE, '-'); _delay_us(40); uint2lcd(~number+1);}  
     9e6:	87 ff       	sbrs	r24, 7
    else          {uint2lcd(number);                                            }
     9e8:	0c 94 89 04 	jmp	0x912	; 0x912 <uint2lcd>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     9ec:	91 e0       	ldi	r25, 0x01	; 1
     9ee:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     9f0:	77 9b       	sbis	0x0e, 7	; 14
     9f2:	fe cf       	rjmp	.-4      	; 0x9f0 <int2lcd+0xa>
  SPDR = byte;                        //send payload
     9f4:	9d e2       	ldi	r25, 0x2D	; 45
     9f6:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     9f8:	77 9b       	sbis	0x0e, 7	; 14
     9fa:	fe cf       	rjmp	.-4      	; 0x9f8 <int2lcd+0x12>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     9fc:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a00:	98 60       	ori	r25, 0x08	; 8
     a02:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a06:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a0a:	97 7f       	andi	r25, 0xF7	; 247
     a0c:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a10:	95 ed       	ldi	r25, 0xD5	; 213
     a12:	9a 95       	dec	r25
     a14:	f1 f7       	brne	.-4      	; 0xa12 <int2lcd+0x2c>
     a16:	00 00       	nop
//Takes a 8bit signed and displays it in base ten on the LCD. Leading 0's are 
//not displayed.
//
void int2lcd(int8_t number){
    //if < 0, print minus sign, then take 2's complement of number and display
    if(number < 0){send_lcd(CHAR_BYTE, '-'); _delay_us(40); uint2lcd(~number+1);}  
     a18:	81 95       	neg	r24
     a1a:	0c 94 89 04 	jmp	0x912	; 0x912 <uint2lcd>

00000a1e <cursor_on>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     a1e:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a20:	77 9b       	sbis	0x0e, 7	; 14
     a22:	fe cf       	rjmp	.-4      	; 0xa20 <cursor_on+0x2>
  SPDR = byte;                        //send payload
     a24:	8e e0       	ldi	r24, 0x0E	; 14
     a26:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a28:	77 9b       	sbis	0x0e, 7	; 14
     a2a:	fe cf       	rjmp	.-4      	; 0xa28 <cursor_on+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     a2c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a30:	88 60       	ori	r24, 0x08	; 8
     a32:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a36:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a3a:	87 7f       	andi	r24, 0xF7	; 247
     a3c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a40:	08 95       	ret

00000a42 <cursor_off>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     a42:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a44:	77 9b       	sbis	0x0e, 7	; 14
     a46:	fe cf       	rjmp	.-4      	; 0xa44 <cursor_off+0x2>
  SPDR = byte;                        //send payload
     a48:	8c e0       	ldi	r24, 0x0C	; 12
     a4a:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a4c:	77 9b       	sbis	0x0e, 7	; 14
     a4e:	fe cf       	rjmp	.-4      	; 0xa4c <cursor_off+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     a50:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a54:	88 60       	ori	r24, 0x08	; 8
     a56:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a5a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a5e:	87 7f       	andi	r24, 0xF7	; 247
     a60:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a64:	08 95       	ret

00000a66 <shift_right>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     a66:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a68:	77 9b       	sbis	0x0e, 7	; 14
     a6a:	fe cf       	rjmp	.-4      	; 0xa68 <shift_right+0x2>
  SPDR = byte;                        //send payload
     a6c:	8e e1       	ldi	r24, 0x1E	; 30
     a6e:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a70:	77 9b       	sbis	0x0e, 7	; 14
     a72:	fe cf       	rjmp	.-4      	; 0xa70 <shift_right+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     a74:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a78:	88 60       	ori	r24, 0x08	; 8
     a7a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a7e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a82:	87 7f       	andi	r24, 0xF7	; 247
     a84:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a88:	08 95       	ret

00000a8a <shift_left>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     a8a:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a8c:	77 9b       	sbis	0x0e, 7	; 14
     a8e:	fe cf       	rjmp	.-4      	; 0xa8c <shift_left+0x2>
  SPDR = byte;                        //send payload
     a90:	88 e1       	ldi	r24, 0x18	; 24
     a92:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a94:	77 9b       	sbis	0x0e, 7	; 14
     a96:	fe cf       	rjmp	.-4      	; 0xa94 <shift_left+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     a98:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a9c:	88 60       	ori	r24, 0x08	; 8
     a9e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     aa2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     aa6:	87 7f       	andi	r24, 0xF7	; 247
     aa8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     aac:	08 95       	ret

00000aae <strobe_lcd>:
     aae:	e2 e6       	ldi	r30, 0x62	; 98
     ab0:	f0 e0       	ldi	r31, 0x00	; 0
     ab2:	80 81       	ld	r24, Z
     ab4:	88 60       	ori	r24, 0x08	; 8
     ab6:	80 83       	st	Z, r24
     ab8:	80 81       	ld	r24, Z
     aba:	87 7f       	andi	r24, 0xF7	; 247
     abc:	80 83       	st	Z, r24
     abe:	08 95       	ret

00000ac0 <clear_display>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ac0:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ac2:	77 9b       	sbis	0x0e, 7	; 14
     ac4:	fe cf       	rjmp	.-4      	; 0xac2 <clear_display+0x2>
  SPDR = byte;                        //send payload
     ac6:	81 e0       	ldi	r24, 0x01	; 1
     ac8:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     aca:	77 9b       	sbis	0x0e, 7	; 14
     acc:	fe cf       	rjmp	.-4      	; 0xaca <clear_display+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     ace:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ad2:	88 60       	ori	r24, 0x08	; 8
     ad4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ad8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     adc:	87 7f       	andi	r24, 0xF7	; 247
     ade:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ae2:	8f e1       	ldi	r24, 0x1F	; 31
     ae4:	9c e1       	ldi	r25, 0x1C	; 28
     ae6:	01 97       	sbiw	r24, 0x01	; 1
     ae8:	f1 f7       	brne	.-4      	; 0xae6 <clear_display+0x26>
     aea:	00 c0       	rjmp	.+0      	; 0xaec <clear_display+0x2c>
     aec:	00 00       	nop
     aee:	08 95       	ret

00000af0 <cursor_home>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     af0:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     af2:	77 9b       	sbis	0x0e, 7	; 14
     af4:	fe cf       	rjmp	.-4      	; 0xaf2 <cursor_home+0x2>
  SPDR = byte;                        //send payload
     af6:	82 e0       	ldi	r24, 0x02	; 2
     af8:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     afa:	77 9b       	sbis	0x0e, 7	; 14
     afc:	fe cf       	rjmp	.-4      	; 0xafa <cursor_home+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     afe:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b02:	88 60       	ori	r24, 0x08	; 8
     b04:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b08:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b0c:	87 7f       	andi	r24, 0xF7	; 247
     b0e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b12:	8f e6       	ldi	r24, 0x6F	; 111
     b14:	97 e1       	ldi	r25, 0x17	; 23
     b16:	01 97       	sbiw	r24, 0x01	; 1
     b18:	f1 f7       	brne	.-4      	; 0xb16 <cursor_home+0x26>
     b1a:	00 c0       	rjmp	.+0      	; 0xb1c <cursor_home+0x2c>
     b1c:	00 00       	nop
     b1e:	08 95       	ret

00000b20 <line2_col1>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b20:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b22:	77 9b       	sbis	0x0e, 7	; 14
     b24:	fe cf       	rjmp	.-4      	; 0xb22 <line2_col1+0x2>
  SPDR = byte;                        //send payload
     b26:	80 ec       	ldi	r24, 0xC0	; 192
     b28:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b2a:	77 9b       	sbis	0x0e, 7	; 14
     b2c:	fe cf       	rjmp	.-4      	; 0xb2a <line2_col1+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b2e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b32:	88 60       	ori	r24, 0x08	; 8
     b34:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b38:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b3c:	87 7f       	andi	r24, 0xF7	; 247
     b3e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b42:	85 ed       	ldi	r24, 0xD5	; 213
     b44:	8a 95       	dec	r24
     b46:	f1 f7       	brne	.-4      	; 0xb44 <line2_col1+0x24>
     b48:	00 00       	nop
     b4a:	08 95       	ret

00000b4c <line1_col1>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b4c:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b4e:	77 9b       	sbis	0x0e, 7	; 14
     b50:	fe cf       	rjmp	.-4      	; 0xb4e <line1_col1+0x2>
  SPDR = byte;                        //send payload
     b52:	80 e8       	ldi	r24, 0x80	; 128
     b54:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b56:	77 9b       	sbis	0x0e, 7	; 14
     b58:	fe cf       	rjmp	.-4      	; 0xb56 <line1_col1+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b5a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b5e:	88 60       	ori	r24, 0x08	; 8
     b60:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b64:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b68:	87 7f       	andi	r24, 0xF7	; 247
     b6a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b6e:	85 ed       	ldi	r24, 0xD5	; 213
     b70:	8a 95       	dec	r24
     b72:	f1 f7       	brne	.-4      	; 0xb70 <line1_col1+0x24>
     b74:	00 00       	nop
     b76:	08 95       	ret

00000b78 <fill_spaces>:

//-----------------------------------------------------------------------------
//                          fill_spaces   
//
//Fill an entire line with spaces.
void fill_spaces(void){
     b78:	90 e1       	ldi	r25, 0x10	; 16
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b7a:	31 e0       	ldi	r19, 0x01	; 1
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
  SPDR = byte;                        //send payload
     b7c:	20 e2       	ldi	r18, 0x20	; 32
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b7e:	3f b9       	out	0x0f, r19	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b80:	77 9b       	sbis	0x0e, 7	; 14
     b82:	fe cf       	rjmp	.-4      	; 0xb80 <fill_spaces+0x8>
  SPDR = byte;                        //send payload
     b84:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b86:	77 9b       	sbis	0x0e, 7	; 14
     b88:	fe cf       	rjmp	.-4      	; 0xb86 <fill_spaces+0xe>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b8a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b8e:	88 60       	ori	r24, 0x08	; 8
     b90:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b94:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b98:	87 7f       	andi	r24, 0xF7	; 247
     b9a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b9e:	85 ed       	ldi	r24, 0xD5	; 213
     ba0:	8a 95       	dec	r24
     ba2:	f1 f7       	brne	.-4      	; 0xba0 <fill_spaces+0x28>
     ba4:	00 00       	nop
     ba6:	91 50       	subi	r25, 0x01	; 1
//                          fill_spaces   
//
//Fill an entire line with spaces.
void fill_spaces(void){
	uint8_t i;
	for (i=0; i<=(NUM_LCD_CHARS-1); i++){
     ba8:	51 f7       	brne	.-44     	; 0xb7e <fill_spaces+0x6>
		send_lcd(CHAR_BYTE, ' '); 
                _delay_us(40);  //40us wait between characters
	}
}  
     baa:	08 95       	ret

00000bac <char2lcd>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     bac:	91 e0       	ldi	r25, 0x01	; 1
     bae:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     bb0:	77 9b       	sbis	0x0e, 7	; 14
     bb2:	fe cf       	rjmp	.-4      	; 0xbb0 <char2lcd+0x4>
  SPDR = byte;                        //send payload
     bb4:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     bb6:	77 9b       	sbis	0x0e, 7	; 14
     bb8:	fe cf       	rjmp	.-4      	; 0xbb6 <char2lcd+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     bba:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bbe:	88 60       	ori	r24, 0x08	; 8
     bc0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bc4:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bc8:	87 7f       	andi	r24, 0xF7	; 247
     bca:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bce:	08 95       	ret

00000bd0 <string2lcd>:

//----------------------------------------------------------------------------
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
     bd0:	fc 01       	movw	r30, r24
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     bd2:	40 e0       	ldi	r20, 0x00	; 0
     bd4:	50 e0       	ldi	r21, 0x00	; 0
     bd6:	60 e0       	ldi	r22, 0x00	; 0
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     bd8:	71 e0       	ldi	r23, 0x01	; 1
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     bda:	df 01       	movw	r26, r30
     bdc:	a4 0f       	add	r26, r20
     bde:	b5 1f       	adc	r27, r21
     be0:	8c 91       	ld	r24, X
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     be2:	7f b9       	out	0x0f, r23	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     be4:	77 9b       	sbis	0x0e, 7	; 14
     be6:	fe cf       	rjmp	.-4      	; 0xbe4 <string2lcd+0x14>
  SPDR = byte;                        //send payload
     be8:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     bea:	77 9b       	sbis	0x0e, 7	; 14
     bec:	fe cf       	rjmp	.-4      	; 0xbea <string2lcd+0x1a>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     bee:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bf2:	98 60       	ori	r25, 0x08	; 8
     bf4:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bf8:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bfc:	97 7f       	andi	r25, 0xF7	; 247
     bfe:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c02:	85 ed       	ldi	r24, 0xD5	; 213
     c04:	8a 95       	dec	r24
     c06:	f1 f7       	brne	.-4      	; 0xc04 <string2lcd+0x34>
     c08:	00 00       	nop
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     c0a:	6f 5f       	subi	r22, 0xFF	; 255
     c0c:	46 2f       	mov	r20, r22
     c0e:	50 e0       	ldi	r21, 0x00	; 0
     c10:	df 01       	movw	r26, r30
     c12:	0d 90       	ld	r0, X+
     c14:	00 20       	and	r0, r0
     c16:	e9 f7       	brne	.-6      	; 0xc12 <string2lcd+0x42>
     c18:	9d 01       	movw	r18, r26
     c1a:	2e 1b       	sub	r18, r30
     c1c:	3f 0b       	sbc	r19, r31
     c1e:	22 50       	subi	r18, 0x02	; 2
     c20:	31 09       	sbc	r19, r1
     c22:	24 17       	cp	r18, r20
     c24:	35 07       	cpc	r19, r21
     c26:	c8 f6       	brcc	.-78     	; 0xbda <string2lcd+0xa>
  _delay_us(40);  //execution takes 37us per character
  }                  
} 
     c28:	08 95       	ret

00000c2a <lcd_init>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     c2a:	8f ef       	ldi	r24, 0xFF	; 255
     c2c:	99 ef       	ldi	r25, 0xF9	; 249
     c2e:	01 97       	sbiw	r24, 0x01	; 1
     c30:	f1 f7       	brne	.-4      	; 0xc2e <lcd_init+0x4>
     c32:	00 c0       	rjmp	.+0      	; 0xc34 <lcd_init+0xa>
     c34:	00 00       	nop
//
void lcd_init(void){
  _delay_ms(16);      //power up delay
#if SPI_MODE==1       //assumption is that the SPI port is intialized
  //TODO: kludge alert! setting of DDRF should not be here, but is probably harmless.
  DDRF=0x08;          //port F bit 3 is enable for LCD in SPI mode
     c36:	88 e0       	ldi	r24, 0x08	; 8
     c38:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c3c:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c3e:	77 9b       	sbis	0x0e, 7	; 14
     c40:	fe cf       	rjmp	.-4      	; 0xc3e <lcd_init+0x14>
  SPDR = byte;                        //send payload
     c42:	80 e3       	ldi	r24, 0x30	; 48
     c44:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c46:	77 9b       	sbis	0x0e, 7	; 14
     c48:	fe cf       	rjmp	.-4      	; 0xc46 <lcd_init+0x1c>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     c4a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c4e:	88 60       	ori	r24, 0x08	; 8
     c50:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c54:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c58:	87 7f       	andi	r24, 0xF7	; 247
     c5a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c5e:	8f e5       	ldi	r24, 0x5F	; 95
     c60:	9d e6       	ldi	r25, 0x6D	; 109
     c62:	01 97       	sbiw	r24, 0x01	; 1
     c64:	f1 f7       	brne	.-4      	; 0xc62 <lcd_init+0x38>
     c66:	00 c0       	rjmp	.+0      	; 0xc68 <lcd_init+0x3e>
     c68:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c6a:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c6c:	77 9b       	sbis	0x0e, 7	; 14
     c6e:	fe cf       	rjmp	.-4      	; 0xc6c <lcd_init+0x42>
  SPDR = byte;                        //send payload
     c70:	80 e3       	ldi	r24, 0x30	; 48
     c72:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c74:	77 9b       	sbis	0x0e, 7	; 14
     c76:	fe cf       	rjmp	.-4      	; 0xc74 <lcd_init+0x4a>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     c78:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c7c:	88 60       	ori	r24, 0x08	; 8
     c7e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c82:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c86:	87 7f       	andi	r24, 0xF7	; 247
     c88:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c8c:	8f e5       	ldi	r24, 0x5F	; 95
     c8e:	9d e6       	ldi	r25, 0x6D	; 109
     c90:	01 97       	sbiw	r24, 0x01	; 1
     c92:	f1 f7       	brne	.-4      	; 0xc90 <lcd_init+0x66>
     c94:	00 c0       	rjmp	.+0      	; 0xc96 <lcd_init+0x6c>
     c96:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c98:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c9a:	77 9b       	sbis	0x0e, 7	; 14
     c9c:	fe cf       	rjmp	.-4      	; 0xc9a <lcd_init+0x70>
  SPDR = byte;                        //send payload
     c9e:	80 e3       	ldi	r24, 0x30	; 48
     ca0:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ca2:	77 9b       	sbis	0x0e, 7	; 14
     ca4:	fe cf       	rjmp	.-4      	; 0xca2 <lcd_init+0x78>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     ca6:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     caa:	88 60       	ori	r24, 0x08	; 8
     cac:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cb0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cb4:	87 7f       	andi	r24, 0xF7	; 247
     cb6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cba:	8f e5       	ldi	r24, 0x5F	; 95
     cbc:	9d e6       	ldi	r25, 0x6D	; 109
     cbe:	01 97       	sbiw	r24, 0x01	; 1
     cc0:	f1 f7       	brne	.-4      	; 0xcbe <lcd_init+0x94>
     cc2:	00 c0       	rjmp	.+0      	; 0xcc4 <lcd_init+0x9a>
     cc4:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     cc6:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     cc8:	77 9b       	sbis	0x0e, 7	; 14
     cca:	fe cf       	rjmp	.-4      	; 0xcc8 <lcd_init+0x9e>
  SPDR = byte;                        //send payload
     ccc:	88 e3       	ldi	r24, 0x38	; 56
     cce:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     cd0:	77 9b       	sbis	0x0e, 7	; 14
     cd2:	fe cf       	rjmp	.-4      	; 0xcd0 <lcd_init+0xa6>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     cd4:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cd8:	88 60       	ori	r24, 0x08	; 8
     cda:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cde:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ce2:	87 7f       	andi	r24, 0xF7	; 247
     ce4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ce8:	8f e1       	ldi	r24, 0x1F	; 31
     cea:	9e e4       	ldi	r25, 0x4E	; 78
     cec:	01 97       	sbiw	r24, 0x01	; 1
     cee:	f1 f7       	brne	.-4      	; 0xcec <lcd_init+0xc2>
     cf0:	00 c0       	rjmp	.+0      	; 0xcf2 <lcd_init+0xc8>
     cf2:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     cf4:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     cf6:	77 9b       	sbis	0x0e, 7	; 14
     cf8:	fe cf       	rjmp	.-4      	; 0xcf6 <lcd_init+0xcc>
  SPDR = byte;                        //send payload
     cfa:	88 e0       	ldi	r24, 0x08	; 8
     cfc:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     cfe:	77 9b       	sbis	0x0e, 7	; 14
     d00:	fe cf       	rjmp	.-4      	; 0xcfe <lcd_init+0xd4>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d02:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d06:	88 60       	ori	r24, 0x08	; 8
     d08:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d0c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d10:	87 7f       	andi	r24, 0xF7	; 247
     d12:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d16:	8f e1       	ldi	r24, 0x1F	; 31
     d18:	9e e4       	ldi	r25, 0x4E	; 78
     d1a:	01 97       	sbiw	r24, 0x01	; 1
     d1c:	f1 f7       	brne	.-4      	; 0xd1a <lcd_init+0xf0>
     d1e:	00 c0       	rjmp	.+0      	; 0xd20 <lcd_init+0xf6>
     d20:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d22:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d24:	77 9b       	sbis	0x0e, 7	; 14
     d26:	fe cf       	rjmp	.-4      	; 0xd24 <lcd_init+0xfa>
  SPDR = byte;                        //send payload
     d28:	81 e0       	ldi	r24, 0x01	; 1
     d2a:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d2c:	77 9b       	sbis	0x0e, 7	; 14
     d2e:	fe cf       	rjmp	.-4      	; 0xd2c <lcd_init+0x102>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d30:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d34:	88 60       	ori	r24, 0x08	; 8
     d36:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d3a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d3e:	87 7f       	andi	r24, 0xF7	; 247
     d40:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d44:	8f e1       	ldi	r24, 0x1F	; 31
     d46:	9e e4       	ldi	r25, 0x4E	; 78
     d48:	01 97       	sbiw	r24, 0x01	; 1
     d4a:	f1 f7       	brne	.-4      	; 0xd48 <lcd_init+0x11e>
     d4c:	00 c0       	rjmp	.+0      	; 0xd4e <lcd_init+0x124>
     d4e:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d50:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d52:	77 9b       	sbis	0x0e, 7	; 14
     d54:	fe cf       	rjmp	.-4      	; 0xd52 <lcd_init+0x128>
  SPDR = byte;                        //send payload
     d56:	86 e0       	ldi	r24, 0x06	; 6
     d58:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d5a:	77 9b       	sbis	0x0e, 7	; 14
     d5c:	fe cf       	rjmp	.-4      	; 0xd5a <lcd_init+0x130>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d5e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d62:	88 60       	ori	r24, 0x08	; 8
     d64:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d68:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d6c:	87 7f       	andi	r24, 0xF7	; 247
     d6e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d72:	8f e1       	ldi	r24, 0x1F	; 31
     d74:	9e e4       	ldi	r25, 0x4E	; 78
     d76:	01 97       	sbiw	r24, 0x01	; 1
     d78:	f1 f7       	brne	.-4      	; 0xd76 <lcd_init+0x14c>
     d7a:	00 c0       	rjmp	.+0      	; 0xd7c <lcd_init+0x152>
     d7c:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d7e:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d80:	77 9b       	sbis	0x0e, 7	; 14
     d82:	fe cf       	rjmp	.-4      	; 0xd80 <lcd_init+0x156>
  SPDR = byte;                        //send payload
     d84:	8c e0       	ldi	r24, 0x0C	; 12
     d86:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d88:	77 9b       	sbis	0x0e, 7	; 14
     d8a:	fe cf       	rjmp	.-4      	; 0xd88 <lcd_init+0x15e>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d8c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d90:	88 60       	ori	r24, 0x08	; 8
     d92:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d96:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d9a:	87 7f       	andi	r24, 0xF7	; 247
     d9c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     da0:	8f e1       	ldi	r24, 0x1F	; 31
     da2:	9e e4       	ldi	r25, 0x4E	; 78
     da4:	01 97       	sbiw	r24, 0x01	; 1
     da6:	f1 f7       	brne	.-4      	; 0xda4 <lcd_init+0x17a>
     da8:	00 c0       	rjmp	.+0      	; 0xdaa <lcd_init+0x180>
     daa:	00 00       	nop
     dac:	08 95       	ret

00000dae <lcd_int32>:
void  lcd_int32(int32_t l,          //number to display
                uint8_t fieldwidth, //width of the field for display
                uint8_t decpos,     //0 if no decimal point, otherwise
                uint8_t bSigned,    //non-zero if the number should be treated as signed 
                uint8_t bZeroFill)  //non-zero if a specified fieldwidth is to be zero filled
{
     dae:	4f 92       	push	r4
     db0:	5f 92       	push	r5
     db2:	6f 92       	push	r6
     db4:	7f 92       	push	r7
     db6:	8f 92       	push	r8
     db8:	9f 92       	push	r9
     dba:	af 92       	push	r10
     dbc:	bf 92       	push	r11
     dbe:	cf 92       	push	r12
     dc0:	df 92       	push	r13
     dc2:	ef 92       	push	r14
     dc4:	ff 92       	push	r15
     dc6:	0f 93       	push	r16
     dc8:	1f 93       	push	r17
     dca:	cf 93       	push	r28
     dcc:	df 93       	push	r29
     dce:	cd b7       	in	r28, 0x3d	; 61
     dd0:	de b7       	in	r29, 0x3e	; 62
     dd2:	69 97       	sbiw	r28, 0x19	; 25
     dd4:	0f b6       	in	r0, 0x3f	; 63
     dd6:	f8 94       	cli
     dd8:	de bf       	out	0x3e, r29	; 62
     dda:	0f be       	out	0x3f, r0	; 63
     ddc:	cd bf       	out	0x3d, r28	; 61
     dde:	14 2f       	mov	r17, r20
     de0:	42 2e       	mov	r4, r18
     de2:	5e 2c       	mov	r5, r14
      char    fillch;
      ldiv_t  qr;

      qr.quot = l; // initialize the quotient 

      if (bSigned){
     de4:	00 23       	and	r16, r16
     de6:	79 f0       	breq	.+30     	; 0xe06 <lcd_int32+0x58>
        bSigned = (qr.quot<0);
     de8:	6b 01       	movw	r12, r22
     dea:	7c 01       	movw	r14, r24
     dec:	cc 24       	eor	r12, r12
     dee:	f7 fc       	sbrc	r15, 7
     df0:	c3 94       	inc	r12
     df2:	dd 24       	eor	r13, r13
     df4:	ee 24       	eor	r14, r14
     df6:	ff 24       	eor	r15, r15
     df8:	0c 2d       	mov	r16, r12
        qr.quot = labs(qr.quot);
     dfa:	6b 01       	movw	r12, r22
     dfc:	7c 01       	movw	r14, r24
     dfe:	97 fd       	sbrc	r25, 7
     e00:	a3 c0       	rjmp	.+326    	; 0xf48 <lcd_int32+0x19a>
     e02:	c7 01       	movw	r24, r14
     e04:	b6 01       	movw	r22, r12
      }

      // convert the digits to the right of the decimal point 
      if (decpos){
     e06:	44 20       	and	r4, r4
     e08:	09 f4       	brne	.+2      	; 0xe0c <lcd_int32+0x5e>
     e0a:	96 c0       	rjmp	.+300    	; 0xf38 <lcd_int32+0x18a>
     e0c:	9e 01       	movw	r18, r28
     e0e:	2f 5f       	subi	r18, 0xFF	; 255
     e10:	3f 4f       	sbci	r19, 0xFF	; 255
     e12:	59 01       	movw	r10, r18
     e14:	49 01       	movw	r8, r18
     e16:	66 24       	eor	r6, r6
     e18:	6a 94       	dec	r6
     e1a:	64 0c       	add	r6, r4
     e1c:	71 2c       	mov	r7, r1
     e1e:	3f ef       	ldi	r19, 0xFF	; 255
     e20:	63 1a       	sub	r6, r19
     e22:	73 0a       	sbc	r7, r19
     e24:	6a 0c       	add	r6, r10
     e26:	7b 1c       	adc	r7, r11
        for (; decpos ; decpos--){
          qr = ldiv(qr.quot, 10);
     e28:	2a e0       	ldi	r18, 0x0A	; 10
     e2a:	30 e0       	ldi	r19, 0x00	; 0
     e2c:	40 e0       	ldi	r20, 0x00	; 0
     e2e:	50 e0       	ldi	r21, 0x00	; 0
     e30:	0e 94 da 08 	call	0x11b4	; 0x11b4 <__divmodsi4>
     e34:	e6 2f       	mov	r30, r22
     e36:	2a 8b       	std	Y+18, r18	; 0x12
     e38:	3b 8b       	std	Y+19, r19	; 0x13
     e3a:	4c 8b       	std	Y+20, r20	; 0x14
     e3c:	5d 8b       	std	Y+21, r21	; 0x15
     e3e:	6a 89       	ldd	r22, Y+18	; 0x12
     e40:	7b 89       	ldd	r23, Y+19	; 0x13
     e42:	8c 89       	ldd	r24, Y+20	; 0x14
     e44:	9d 89       	ldd	r25, Y+21	; 0x15
          sline[i++] = qr.rem + '0';
     e46:	20 e3       	ldi	r18, 0x30	; 48
     e48:	2e 0f       	add	r18, r30
     e4a:	f4 01       	movw	r30, r8
     e4c:	21 93       	st	Z+, r18
     e4e:	4f 01       	movw	r8, r30
        qr.quot = labs(qr.quot);
      }

      // convert the digits to the right of the decimal point 
      if (decpos){
        for (; decpos ; decpos--){
     e50:	6e 16       	cp	r6, r30
     e52:	7f 06       	cpc	r7, r31
     e54:	49 f7       	brne	.-46     	; 0xe28 <lcd_int32+0x7a>
          qr = ldiv(qr.quot, 10);
          sline[i++] = qr.rem + '0';
        }
        sline[i++] = '.';
     e56:	99 24       	eor	r9, r9
     e58:	93 94       	inc	r9
     e5a:	94 0c       	add	r9, r4
     e5c:	f5 01       	movw	r30, r10
     e5e:	e4 0d       	add	r30, r4
     e60:	f1 1d       	adc	r31, r1
     e62:	2e e2       	ldi	r18, 0x2E	; 46
     e64:	20 83       	st	Z, r18
      }

      // convert the digits to the left of the decimal point 
      do{
          qr = ldiv(qr.quot, 10);
     e66:	2a e0       	ldi	r18, 0x0A	; 10
     e68:	30 e0       	ldi	r19, 0x00	; 0
     e6a:	40 e0       	ldi	r20, 0x00	; 0
     e6c:	50 e0       	ldi	r21, 0x00	; 0
     e6e:	0e 94 da 08 	call	0x11b4	; 0x11b4 <__divmodsi4>
     e72:	e6 2f       	mov	r30, r22
     e74:	2a 8b       	std	Y+18, r18	; 0x12
     e76:	3b 8b       	std	Y+19, r19	; 0x13
     e78:	4c 8b       	std	Y+20, r20	; 0x14
     e7a:	5d 8b       	std	Y+21, r21	; 0x15
     e7c:	6e 8b       	std	Y+22, r22	; 0x16
     e7e:	7f 8b       	std	Y+23, r23	; 0x17
     e80:	88 8f       	std	Y+24, r24	; 0x18
     e82:	99 8f       	std	Y+25, r25	; 0x19
     e84:	6a 89       	ldd	r22, Y+18	; 0x12
     e86:	7b 89       	ldd	r23, Y+19	; 0x13
     e88:	8c 89       	ldd	r24, Y+20	; 0x14
     e8a:	9d 89       	ldd	r25, Y+21	; 0x15
          sline[i++] = qr.rem + '0';
     e8c:	31 e0       	ldi	r19, 0x01	; 1
     e8e:	39 0d       	add	r19, r9
     e90:	d5 01       	movw	r26, r10
     e92:	a9 0d       	add	r26, r9
     e94:	b1 1d       	adc	r27, r1
     e96:	e0 5d       	subi	r30, 0xD0	; 208
     e98:	ec 93       	st	X, r30
     e9a:	93 2e       	mov	r9, r19
        }while(qr.quot);
     e9c:	61 15       	cp	r22, r1
     e9e:	71 05       	cpc	r23, r1
     ea0:	81 05       	cpc	r24, r1
     ea2:	91 05       	cpc	r25, r1
     ea4:	01 f7       	brne	.-64     	; 0xe66 <lcd_int32+0xb8>

      // fill the whole field if a width was specified
      if (fieldwidth){
     ea6:	11 23       	and	r17, r17
     ea8:	61 f0       	breq	.+24     	; 0xec2 <lcd_int32+0x114>
        fillch = bZeroFill? '0': ' '; // determine the fill character
     eaa:	51 10       	cpse	r5, r1
     eac:	4b c0       	rjmp	.+150    	; 0xf44 <lcd_int32+0x196>
     eae:	90 e2       	ldi	r25, 0x20	; 32
        for (; i<fieldwidth ; ){sline[i++] = fillch;}
     eb0:	31 17       	cp	r19, r17
     eb2:	38 f4       	brcc	.+14     	; 0xec2 <lcd_int32+0x114>
     eb4:	f5 01       	movw	r30, r10
     eb6:	e3 0f       	add	r30, r19
     eb8:	f1 1d       	adc	r31, r1
     eba:	90 83       	st	Z, r25
     ebc:	3f 5f       	subi	r19, 0xFF	; 255
     ebe:	13 13       	cpse	r17, r19
     ec0:	f9 cf       	rjmp	.-14     	; 0xeb4 <lcd_int32+0x106>
      }

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}
     ec2:	00 23       	and	r16, r16
     ec4:	31 f0       	breq	.+12     	; 0xed2 <lcd_int32+0x124>
     ec6:	f5 01       	movw	r30, r10
     ec8:	e3 0f       	add	r30, r19
     eca:	f1 1d       	adc	r31, r1
     ecc:	9d e2       	ldi	r25, 0x2D	; 45
     ece:	90 83       	st	Z, r25
     ed0:	3f 5f       	subi	r19, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ed2:	21 e0       	ldi	r18, 0x01	; 1

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}

      // now output the formatted number
      do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
     ed4:	31 50       	subi	r19, 0x01	; 1
     ed6:	f5 01       	movw	r30, r10
     ed8:	e3 0f       	add	r30, r19
     eda:	f1 1d       	adc	r31, r1
     edc:	90 81       	ld	r25, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ede:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ee0:	77 9b       	sbis	0x0e, 7	; 14
     ee2:	fe cf       	rjmp	.-4      	; 0xee0 <lcd_int32+0x132>
  SPDR = byte;                        //send payload
     ee4:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ee6:	77 9b       	sbis	0x0e, 7	; 14
     ee8:	fe cf       	rjmp	.-4      	; 0xee6 <lcd_int32+0x138>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     eea:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     eee:	98 60       	ori	r25, 0x08	; 8
     ef0:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ef4:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ef8:	97 7f       	andi	r25, 0xF7	; 247
     efa:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     efe:	85 ed       	ldi	r24, 0xD5	; 213
     f00:	8a 95       	dec	r24
     f02:	f1 f7       	brne	.-4      	; 0xf00 <lcd_int32+0x152>
     f04:	00 00       	nop

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}

      // now output the formatted number
      do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
     f06:	31 11       	cpse	r19, r1
     f08:	e5 cf       	rjmp	.-54     	; 0xed4 <lcd_int32+0x126>

}
     f0a:	69 96       	adiw	r28, 0x19	; 25
     f0c:	0f b6       	in	r0, 0x3f	; 63
     f0e:	f8 94       	cli
     f10:	de bf       	out	0x3e, r29	; 62
     f12:	0f be       	out	0x3f, r0	; 63
     f14:	cd bf       	out	0x3d, r28	; 61
     f16:	df 91       	pop	r29
     f18:	cf 91       	pop	r28
     f1a:	1f 91       	pop	r17
     f1c:	0f 91       	pop	r16
     f1e:	ff 90       	pop	r15
     f20:	ef 90       	pop	r14
     f22:	df 90       	pop	r13
     f24:	cf 90       	pop	r12
     f26:	bf 90       	pop	r11
     f28:	af 90       	pop	r10
     f2a:	9f 90       	pop	r9
     f2c:	8f 90       	pop	r8
     f2e:	7f 90       	pop	r7
     f30:	6f 90       	pop	r6
     f32:	5f 90       	pop	r5
     f34:	4f 90       	pop	r4
     f36:	08 95       	ret
                uint8_t decpos,     //0 if no decimal point, otherwise
                uint8_t bSigned,    //non-zero if the number should be treated as signed 
                uint8_t bZeroFill)  //non-zero if a specified fieldwidth is to be zero filled
{
      char    sline[NUM_LCD_CHARS+1];
      uint8_t i=0;
     f38:	91 2c       	mov	r9, r1
     f3a:	9e 01       	movw	r18, r28
     f3c:	2f 5f       	subi	r18, 0xFF	; 255
     f3e:	3f 4f       	sbci	r19, 0xFF	; 255
     f40:	59 01       	movw	r10, r18
     f42:	91 cf       	rjmp	.-222    	; 0xe66 <lcd_int32+0xb8>
          sline[i++] = qr.rem + '0';
        }while(qr.quot);

      // fill the whole field if a width was specified
      if (fieldwidth){
        fillch = bZeroFill? '0': ' '; // determine the fill character
     f44:	90 e3       	ldi	r25, 0x30	; 48
     f46:	b4 cf       	rjmp	.-152    	; 0xeb0 <lcd_int32+0x102>

      qr.quot = l; // initialize the quotient 

      if (bSigned){
        bSigned = (qr.quot<0);
        qr.quot = labs(qr.quot);
     f48:	f0 94       	com	r15
     f4a:	e0 94       	com	r14
     f4c:	d0 94       	com	r13
     f4e:	c0 94       	com	r12
     f50:	c1 1c       	adc	r12, r1
     f52:	d1 1c       	adc	r13, r1
     f54:	e1 1c       	adc	r14, r1
     f56:	f1 1c       	adc	r15, r1
     f58:	54 cf       	rjmp	.-344    	; 0xe02 <lcd_int32+0x54>

00000f5a <lcd_int16>:
void    lcd_int16(int16_t l, 
                  uint8_t fieldwidth, 
                  uint8_t decpos, 
                  uint8_t bSigned,
                  uint8_t bZeroFill)
{
     f5a:	5f 92       	push	r5
     f5c:	6f 92       	push	r6
     f5e:	7f 92       	push	r7
     f60:	8f 92       	push	r8
     f62:	9f 92       	push	r9
     f64:	af 92       	push	r10
     f66:	bf 92       	push	r11
     f68:	cf 92       	push	r12
     f6a:	df 92       	push	r13
     f6c:	ef 92       	push	r14
     f6e:	ff 92       	push	r15
     f70:	0f 93       	push	r16
     f72:	1f 93       	push	r17
     f74:	cf 93       	push	r28
     f76:	df 93       	push	r29
     f78:	cd b7       	in	r28, 0x3d	; 61
     f7a:	de b7       	in	r29, 0x3e	; 62
     f7c:	61 97       	sbiw	r28, 0x11	; 17
     f7e:	0f b6       	in	r0, 0x3f	; 63
     f80:	f8 94       	cli
     f82:	de bf       	out	0x3e, r29	; 62
     f84:	0f be       	out	0x3f, r0	; 63
     f86:	cd bf       	out	0x3d, r28	; 61
     f88:	5c 01       	movw	r10, r24
     f8a:	16 2f       	mov	r17, r22
     f8c:	74 2e       	mov	r7, r20
//        uint8_t bSigned;   Now an argument for signed or not

        // initialize the quotient 
        qr.quot = l;

        if ( (bSigned=(qr.quot<0)) )
     f8e:	6b 2c       	mov	r6, r11
     f90:	66 1c       	adc	r6, r6
     f92:	66 24       	eor	r6, r6
     f94:	66 1c       	adc	r6, r6
     f96:	56 2c       	mov	r5, r6
     f98:	9c 01       	movw	r18, r24
     f9a:	97 fd       	sbrc	r25, 7
     f9c:	9b c0       	rjmp	.+310    	; 0x10d4 <lcd_int16+0x17a>
                qr.quot = -qr.quot;

        // convert the digits to the right of the decimal point 
        if (decpos){
     f9e:	77 20       	and	r7, r7
     fa0:	09 f4       	brne	.+2      	; 0xfa4 <lcd_int16+0x4a>
     fa2:	8d c0       	rjmp	.+282    	; 0x10be <lcd_int16+0x164>
     fa4:	ce 01       	movw	r24, r28
     fa6:	01 96       	adiw	r24, 0x01	; 1
     fa8:	7c 01       	movw	r14, r24
     faa:	6c 01       	movw	r12, r24
     fac:	88 24       	eor	r8, r8
     fae:	8a 94       	dec	r8
     fb0:	87 0c       	add	r8, r7
     fb2:	91 2c       	mov	r9, r1
     fb4:	9f ef       	ldi	r25, 0xFF	; 255
     fb6:	89 1a       	sub	r8, r25
     fb8:	99 0a       	sbc	r9, r25
     fba:	8e 0c       	add	r8, r14
     fbc:	9f 1c       	adc	r9, r15
          for (; decpos ; decpos--){
            qr = div(qr.quot, 10);
     fbe:	6a e0       	ldi	r22, 0x0A	; 10
     fc0:	70 e0       	ldi	r23, 0x00	; 0
     fc2:	c9 01       	movw	r24, r18
     fc4:	0e 94 c6 08 	call	0x118c	; 0x118c <__divmodhi4>
     fc8:	46 2f       	mov	r20, r22
     fca:	24 2f       	mov	r18, r20
     fcc:	37 2f       	mov	r19, r23
            sline[i++] = qr.rem + '0';
     fce:	80 5d       	subi	r24, 0xD0	; 208
     fd0:	f6 01       	movw	r30, r12
     fd2:	81 93       	st	Z+, r24
     fd4:	6f 01       	movw	r12, r30
        if ( (bSigned=(qr.quot<0)) )
                qr.quot = -qr.quot;

        // convert the digits to the right of the decimal point 
        if (decpos){
          for (; decpos ; decpos--){
     fd6:	e8 15       	cp	r30, r8
     fd8:	f9 05       	cpc	r31, r9
     fda:	89 f7       	brne	.-30     	; 0xfbe <lcd_int16+0x64>
            qr = div(qr.quot, 10);
            sline[i++] = qr.rem + '0';
          }
          sline[i++] = '.';
     fdc:	dd 24       	eor	r13, r13
     fde:	d3 94       	inc	r13
     fe0:	d7 0c       	add	r13, r7
     fe2:	f7 01       	movw	r30, r14
     fe4:	e7 0d       	add	r30, r7
     fe6:	f1 1d       	adc	r31, r1
     fe8:	8e e2       	ldi	r24, 0x2E	; 46
     fea:	80 83       	st	Z, r24
     fec:	01 c0       	rjmp	.+2      	; 0xff0 <lcd_int16+0x96>

        // convert the digits to the left of the decimal point 
        do
        {
                qr = div(qr.quot, 10);
                sline[i++] = qr.rem + '0';
     fee:	d9 2e       	mov	r13, r25
        }

        // convert the digits to the left of the decimal point 
        do
        {
                qr = div(qr.quot, 10);
     ff0:	6a e0       	ldi	r22, 0x0A	; 10
     ff2:	70 e0       	ldi	r23, 0x00	; 0
     ff4:	c9 01       	movw	r24, r18
     ff6:	0e 94 c6 08 	call	0x118c	; 0x118c <__divmodhi4>
     ffa:	46 2f       	mov	r20, r22
     ffc:	24 2f       	mov	r18, r20
     ffe:	37 2f       	mov	r19, r23
                sline[i++] = qr.rem + '0';
    1000:	91 e0       	ldi	r25, 0x01	; 1
    1002:	9d 0d       	add	r25, r13
    1004:	f7 01       	movw	r30, r14
    1006:	ed 0d       	add	r30, r13
    1008:	f1 1d       	adc	r31, r1
    100a:	80 5d       	subi	r24, 0xD0	; 208
    100c:	80 83       	st	Z, r24
        }
        while(qr.quot);
    100e:	21 15       	cp	r18, r1
    1010:	31 05       	cpc	r19, r1
    1012:	69 f7       	brne	.-38     	; 0xfee <lcd_int16+0x94>

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
    1014:	01 11       	cpse	r16, r1
    1016:	58 c0       	rjmp	.+176    	; 0x10c8 <lcd_int16+0x16e>
    1018:	b7 fc       	sbrc	r11, 7
    101a:	61 c0       	rjmp	.+194    	; 0x10de <lcd_int16+0x184>
                sline[i++] = '-';
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    101c:	11 23       	and	r17, r17
    101e:	a9 f0       	breq	.+42     	; 0x104a <lcd_int16+0xf0>
    1020:	71 2c       	mov	r7, r1
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    1022:	80 e2       	ldi	r24, 0x20	; 32
          for (; i<(fieldwidth-bSigned) ; ){ sline[i++] = fillch;}
    1024:	29 2f       	mov	r18, r25
    1026:	30 e0       	ldi	r19, 0x00	; 0
    1028:	41 2f       	mov	r20, r17
    102a:	50 e0       	ldi	r21, 0x00	; 0
    102c:	46 19       	sub	r20, r6
    102e:	57 09       	sbc	r21, r7
    1030:	24 17       	cp	r18, r20
    1032:	35 07       	cpc	r19, r21
    1034:	54 f4       	brge	.+20     	; 0x104a <lcd_int16+0xf0>
    1036:	9f 5f       	subi	r25, 0xFF	; 255
    1038:	f7 01       	movw	r30, r14
    103a:	e2 0f       	add	r30, r18
    103c:	f3 1f       	adc	r31, r19
    103e:	80 83       	st	Z, r24
    1040:	29 2f       	mov	r18, r25
    1042:	30 e0       	ldi	r19, 0x00	; 0
    1044:	24 17       	cp	r18, r20
    1046:	35 07       	cpc	r19, r21
    1048:	b4 f3       	brlt	.-20     	; 0x1036 <lcd_int16+0xdc>
        }

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}
    104a:	55 20       	and	r5, r5
    104c:	31 f0       	breq	.+12     	; 0x105a <lcd_int16+0x100>
    104e:	f7 01       	movw	r30, r14
    1050:	e9 0f       	add	r30, r25
    1052:	f1 1d       	adc	r31, r1
    1054:	8d e2       	ldi	r24, 0x2D	; 45
    1056:	80 83       	st	Z, r24
    1058:	9f 5f       	subi	r25, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    105a:	21 e0       	ldi	r18, 0x01	; 1

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}

        // now output the formatted number 
            do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    105c:	91 50       	subi	r25, 0x01	; 1
    105e:	f7 01       	movw	r30, r14
    1060:	e9 0f       	add	r30, r25
    1062:	f1 1d       	adc	r31, r1
    1064:	80 81       	ld	r24, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1066:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1068:	77 9b       	sbis	0x0e, 7	; 14
    106a:	fe cf       	rjmp	.-4      	; 0x1068 <lcd_int16+0x10e>
  SPDR = byte;                        //send payload
    106c:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    106e:	77 9b       	sbis	0x0e, 7	; 14
    1070:	fe cf       	rjmp	.-4      	; 0x106e <lcd_int16+0x114>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    1072:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1076:	88 60       	ori	r24, 0x08	; 8
    1078:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    107c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1080:	87 7f       	andi	r24, 0xF7	; 247
    1082:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1086:	e5 ed       	ldi	r30, 0xD5	; 213
    1088:	ea 95       	dec	r30
    108a:	f1 f7       	brne	.-4      	; 0x1088 <lcd_int16+0x12e>
    108c:	00 00       	nop

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}

        // now output the formatted number 
            do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    108e:	91 11       	cpse	r25, r1
    1090:	e5 cf       	rjmp	.-54     	; 0x105c <lcd_int16+0x102>
}
    1092:	61 96       	adiw	r28, 0x11	; 17
    1094:	0f b6       	in	r0, 0x3f	; 63
    1096:	f8 94       	cli
    1098:	de bf       	out	0x3e, r29	; 62
    109a:	0f be       	out	0x3f, r0	; 63
    109c:	cd bf       	out	0x3d, r28	; 61
    109e:	df 91       	pop	r29
    10a0:	cf 91       	pop	r28
    10a2:	1f 91       	pop	r17
    10a4:	0f 91       	pop	r16
    10a6:	ff 90       	pop	r15
    10a8:	ef 90       	pop	r14
    10aa:	df 90       	pop	r13
    10ac:	cf 90       	pop	r12
    10ae:	bf 90       	pop	r11
    10b0:	af 90       	pop	r10
    10b2:	9f 90       	pop	r9
    10b4:	8f 90       	pop	r8
    10b6:	7f 90       	pop	r7
    10b8:	6f 90       	pop	r6
    10ba:	5f 90       	pop	r5
    10bc:	08 95       	ret
                  uint8_t decpos, 
                  uint8_t bSigned,
                  uint8_t bZeroFill)
{
        char    sline[NUM_LCD_CHARS+1];
        uint8_t i=0;
    10be:	d1 2c       	mov	r13, r1
    10c0:	ce 01       	movw	r24, r28
    10c2:	01 96       	adiw	r24, 0x01	; 1
    10c4:	7c 01       	movw	r14, r24
    10c6:	94 cf       	rjmp	.-216    	; 0xff0 <lcd_int16+0x96>
                sline[i++] = '-';
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    10c8:	11 23       	and	r17, r17
    10ca:	09 f4       	brne	.+2      	; 0x10ce <lcd_int16+0x174>
    10cc:	be cf       	rjmp	.-132    	; 0x104a <lcd_int16+0xf0>
    10ce:	71 2c       	mov	r7, r1
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    10d0:	80 e3       	ldi	r24, 0x30	; 48
    10d2:	a8 cf       	rjmp	.-176    	; 0x1024 <lcd_int16+0xca>
    10d4:	22 27       	eor	r18, r18
    10d6:	33 27       	eor	r19, r19
    10d8:	28 1b       	sub	r18, r24
    10da:	39 0b       	sbc	r19, r25
    10dc:	60 cf       	rjmp	.-320    	; 0xf9e <lcd_int16+0x44>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    10de:	d3 94       	inc	r13
    10e0:	d3 94       	inc	r13
    10e2:	f7 01       	movw	r30, r14
    10e4:	e9 0f       	add	r30, r25
    10e6:	f1 1d       	adc	r31, r1
    10e8:	8d e2       	ldi	r24, 0x2D	; 45
    10ea:	80 83       	st	Z, r24
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    10ec:	11 23       	and	r17, r17
    10ee:	59 f0       	breq	.+22     	; 0x1106 <__stack+0x7>
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
          for (; i<(fieldwidth-bSigned) ; ){ sline[i++] = fillch;}
    10f0:	2d 2d       	mov	r18, r13
    10f2:	30 e0       	ldi	r19, 0x00	; 0
    10f4:	41 2f       	mov	r20, r17
    10f6:	50 e0       	ldi	r21, 0x00	; 0
    10f8:	24 17       	cp	r18, r20
    10fa:	35 07       	cpc	r19, r21
    10fc:	24 f4       	brge	.+8      	; 0x1106 <__stack+0x7>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    10fe:	9d 2d       	mov	r25, r13
                bSigned = 0;
    1100:	51 2c       	mov	r5, r1
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    1102:	80 e2       	ldi	r24, 0x20	; 32
    1104:	98 cf       	rjmp	.-208    	; 0x1036 <lcd_int16+0xdc>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    1106:	9d 2d       	mov	r25, r13
    1108:	a8 cf       	rjmp	.-176    	; 0x105a <lcd_int16+0x100>

0000110a <main>:
Function:
Description:
Parameters:
**********************************************************************/
void tcnt0_init(){
   ASSR |= (1<<AS0);
    110a:	80 b7       	in	r24, 0x30	; 48
    110c:	88 60       	ori	r24, 0x08	; 8
    110e:	80 bf       	out	0x30, r24	; 48
   TIMSK |= (1<<TOIE0);			//enable interrupts
    1110:	87 b7       	in	r24, 0x37	; 55
    1112:	81 60       	ori	r24, 0x01	; 1
    1114:	87 bf       	out	0x37, r24	; 55
   TCCR0 |= (1<<CS00);			//normal mode, no prescale
    1116:	83 b7       	in	r24, 0x33	; 51
    1118:	81 60       	ori	r24, 0x01	; 1
    111a:	83 bf       	out	0x33, r24	; 51
Function:
Description:
Parameters:
**********************************************************************/
void tcnt2_init(){
   ASSR |= (1<<AS0);
    111c:	80 b7       	in	r24, 0x30	; 48
    111e:	88 60       	ori	r24, 0x08	; 8
    1120:	80 bf       	out	0x30, r24	; 48
   TIMSK |= (1<<TOIE0);			//enable interrupts
    1122:	87 b7       	in	r24, 0x37	; 55
    1124:	81 60       	ori	r24, 0x01	; 1
    1126:	87 bf       	out	0x37, r24	; 55
   TCCR2 |= (1<<WGM21) | (1<<WGM20)| (1<<CS20) | (1<<COM21);			//normal mode, no prescale
    1128:	85 b5       	in	r24, 0x25	; 37
    112a:	89 66       	ori	r24, 0x69	; 105
    112c:	85 bd       	out	0x25, r24	; 37
   OCR2  |= 0xD0;
    112e:	83 b5       	in	r24, 0x23	; 35
    1130:	80 6d       	ori	r24, 0xD0	; 208
    1132:	83 bd       	out	0x23, r24	; 35
int main() {
   tcnt0_init();
   tcnt1_init();
   tcnt2_init();
   tcnt3_init();
   port_init();
    1134:	0e 94 43 03 	call	0x686	; 0x686 <port_init>
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
    1138:	87 b3       	in	r24, 0x17	; 23
    113a:	87 60       	ori	r24, 0x07	; 7
    113c:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
    113e:	8d b1       	in	r24, 0x0d	; 13
    1140:	8c 65       	ori	r24, 0x5C	; 92
    1142:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
    1144:	70 9a       	sbi	0x0e, 0	; 14
   tcnt2_init();
   tcnt3_init();
   port_init();
   
   spi_init();				//Initalize SPI
   lcd_init();
    1146:	0e 94 15 06 	call	0xc2a	; 0xc2a <lcd_init>
   sei();				//Enable interrupts
    114a:	78 94       	sei
   while(1){
      clock_time();
    114c:	0e 94 76 02 	call	0x4ec	; 0x4ec <clock_time>
      change_alarm_state();
    1150:	0e 94 53 03 	call	0x6a6	; 0x6a6 <change_alarm_state>
    1154:	ec e2       	ldi	r30, 0x2C	; 44
    1156:	f1 e0       	ldi	r31, 0x01	; 1
    1158:	80 e0       	ldi	r24, 0x00	; 0
      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
         if(alarm){
    115a:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <alarm>
    115e:	99 23       	and	r25, r25
    1160:	29 f0       	breq	.+10     	; 0x116c <main+0x62>
	    segment_data[2] &= 0b011;
    1162:	90 91 2e 01 	lds	r25, 0x012E	; 0x80012e <__data_end+0x2>
    1166:	93 70       	andi	r25, 0x03	; 3
    1168:	90 93 2e 01 	sts	0x012E, r25	; 0x80012e <__data_end+0x2>
	 }
	 PORTA = segment_data[j];	//Writes the segment data to PORTA aka the segments
    116c:	91 91       	ld	r25, Z+
    116e:	9b bb       	out	0x1b, r25	; 27
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
    1170:	98 2f       	mov	r25, r24
    1172:	92 95       	swap	r25
    1174:	90 7f       	andi	r25, 0xF0	; 240
    1176:	98 bb       	out	0x18, r25	; 24
    1178:	af e1       	ldi	r26, 0x1F	; 31
    117a:	b3 e0       	ldi	r27, 0x03	; 3
    117c:	11 97       	sbiw	r26, 0x01	; 1
    117e:	f1 f7       	brne	.-4      	; 0x117c <main+0x72>
    1180:	00 c0       	rjmp	.+0      	; 0x1182 <main+0x78>
    1182:	00 00       	nop
    1184:	8f 5f       	subi	r24, 0xFF	; 255
   lcd_init();
   sei();				//Enable interrupts
   while(1){
      clock_time();
      change_alarm_state();
      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
    1186:	85 30       	cpi	r24, 0x05	; 5
    1188:	41 f7       	brne	.-48     	; 0x115a <main+0x50>
    118a:	e0 cf       	rjmp	.-64     	; 0x114c <main+0x42>

0000118c <__divmodhi4>:
    118c:	97 fb       	bst	r25, 7
    118e:	07 2e       	mov	r0, r23
    1190:	16 f4       	brtc	.+4      	; 0x1196 <__divmodhi4+0xa>
    1192:	00 94       	com	r0
    1194:	07 d0       	rcall	.+14     	; 0x11a4 <__divmodhi4_neg1>
    1196:	77 fd       	sbrc	r23, 7
    1198:	09 d0       	rcall	.+18     	; 0x11ac <__divmodhi4_neg2>
    119a:	0e 94 f9 08 	call	0x11f2	; 0x11f2 <__udivmodhi4>
    119e:	07 fc       	sbrc	r0, 7
    11a0:	05 d0       	rcall	.+10     	; 0x11ac <__divmodhi4_neg2>
    11a2:	3e f4       	brtc	.+14     	; 0x11b2 <__divmodhi4_exit>

000011a4 <__divmodhi4_neg1>:
    11a4:	90 95       	com	r25
    11a6:	81 95       	neg	r24
    11a8:	9f 4f       	sbci	r25, 0xFF	; 255
    11aa:	08 95       	ret

000011ac <__divmodhi4_neg2>:
    11ac:	70 95       	com	r23
    11ae:	61 95       	neg	r22
    11b0:	7f 4f       	sbci	r23, 0xFF	; 255

000011b2 <__divmodhi4_exit>:
    11b2:	08 95       	ret

000011b4 <__divmodsi4>:
    11b4:	05 2e       	mov	r0, r21
    11b6:	97 fb       	bst	r25, 7
    11b8:	1e f4       	brtc	.+6      	; 0x11c0 <__divmodsi4+0xc>
    11ba:	00 94       	com	r0
    11bc:	0e 94 f1 08 	call	0x11e2	; 0x11e2 <__negsi2>
    11c0:	57 fd       	sbrc	r21, 7
    11c2:	07 d0       	rcall	.+14     	; 0x11d2 <__divmodsi4_neg2>
    11c4:	0e 94 0d 09 	call	0x121a	; 0x121a <__udivmodsi4>
    11c8:	07 fc       	sbrc	r0, 7
    11ca:	03 d0       	rcall	.+6      	; 0x11d2 <__divmodsi4_neg2>
    11cc:	4e f4       	brtc	.+18     	; 0x11e0 <__divmodsi4_exit>
    11ce:	0c 94 f1 08 	jmp	0x11e2	; 0x11e2 <__negsi2>

000011d2 <__divmodsi4_neg2>:
    11d2:	50 95       	com	r21
    11d4:	40 95       	com	r20
    11d6:	30 95       	com	r19
    11d8:	21 95       	neg	r18
    11da:	3f 4f       	sbci	r19, 0xFF	; 255
    11dc:	4f 4f       	sbci	r20, 0xFF	; 255
    11de:	5f 4f       	sbci	r21, 0xFF	; 255

000011e0 <__divmodsi4_exit>:
    11e0:	08 95       	ret

000011e2 <__negsi2>:
    11e2:	90 95       	com	r25
    11e4:	80 95       	com	r24
    11e6:	70 95       	com	r23
    11e8:	61 95       	neg	r22
    11ea:	7f 4f       	sbci	r23, 0xFF	; 255
    11ec:	8f 4f       	sbci	r24, 0xFF	; 255
    11ee:	9f 4f       	sbci	r25, 0xFF	; 255
    11f0:	08 95       	ret

000011f2 <__udivmodhi4>:
    11f2:	aa 1b       	sub	r26, r26
    11f4:	bb 1b       	sub	r27, r27
    11f6:	51 e1       	ldi	r21, 0x11	; 17
    11f8:	07 c0       	rjmp	.+14     	; 0x1208 <__udivmodhi4_ep>

000011fa <__udivmodhi4_loop>:
    11fa:	aa 1f       	adc	r26, r26
    11fc:	bb 1f       	adc	r27, r27
    11fe:	a6 17       	cp	r26, r22
    1200:	b7 07       	cpc	r27, r23
    1202:	10 f0       	brcs	.+4      	; 0x1208 <__udivmodhi4_ep>
    1204:	a6 1b       	sub	r26, r22
    1206:	b7 0b       	sbc	r27, r23

00001208 <__udivmodhi4_ep>:
    1208:	88 1f       	adc	r24, r24
    120a:	99 1f       	adc	r25, r25
    120c:	5a 95       	dec	r21
    120e:	a9 f7       	brne	.-22     	; 0x11fa <__udivmodhi4_loop>
    1210:	80 95       	com	r24
    1212:	90 95       	com	r25
    1214:	bc 01       	movw	r22, r24
    1216:	cd 01       	movw	r24, r26
    1218:	08 95       	ret

0000121a <__udivmodsi4>:
    121a:	a1 e2       	ldi	r26, 0x21	; 33
    121c:	1a 2e       	mov	r1, r26
    121e:	aa 1b       	sub	r26, r26
    1220:	bb 1b       	sub	r27, r27
    1222:	fd 01       	movw	r30, r26
    1224:	0d c0       	rjmp	.+26     	; 0x1240 <__udivmodsi4_ep>

00001226 <__udivmodsi4_loop>:
    1226:	aa 1f       	adc	r26, r26
    1228:	bb 1f       	adc	r27, r27
    122a:	ee 1f       	adc	r30, r30
    122c:	ff 1f       	adc	r31, r31
    122e:	a2 17       	cp	r26, r18
    1230:	b3 07       	cpc	r27, r19
    1232:	e4 07       	cpc	r30, r20
    1234:	f5 07       	cpc	r31, r21
    1236:	20 f0       	brcs	.+8      	; 0x1240 <__udivmodsi4_ep>
    1238:	a2 1b       	sub	r26, r18
    123a:	b3 0b       	sbc	r27, r19
    123c:	e4 0b       	sbc	r30, r20
    123e:	f5 0b       	sbc	r31, r21

00001240 <__udivmodsi4_ep>:
    1240:	66 1f       	adc	r22, r22
    1242:	77 1f       	adc	r23, r23
    1244:	88 1f       	adc	r24, r24
    1246:	99 1f       	adc	r25, r25
    1248:	1a 94       	dec	r1
    124a:	69 f7       	brne	.-38     	; 0x1226 <__udivmodsi4_loop>
    124c:	60 95       	com	r22
    124e:	70 95       	com	r23
    1250:	80 95       	com	r24
    1252:	90 95       	com	r25
    1254:	9b 01       	movw	r18, r22
    1256:	ac 01       	movw	r20, r24
    1258:	bd 01       	movw	r22, r26
    125a:	cf 01       	movw	r24, r30
    125c:	08 95       	ret

0000125e <_exit>:
    125e:	f8 94       	cli

00001260 <__stop_program>:
    1260:	ff cf       	rjmp	.-2      	; 0x1260 <__stop_program>
