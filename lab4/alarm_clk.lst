
alarm_clk.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000002c  00800100  0000121c  000012b0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000121c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000005a  0080012c  0080012c  000012dc  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000012dc  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000130c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000048  00000000  00000000  00001348  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000216b  00000000  00000000  00001390  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ce9  00000000  00000000  000034fb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000efe  00000000  00000000  000041e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000344  00000000  00000000  000050e4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000642  00000000  00000000  00005428  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000018c9  00000000  00000000  00005a6a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000b0  00000000  00000000  00007333  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      40:	0c 94 33 02 	jmp	0x466	; 0x466 <__vector_16>
      44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	11 e0       	ldi	r17, 0x01	; 1
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	ec e1       	ldi	r30, 0x1C	; 28
      a0:	f2 e1       	ldi	r31, 0x12	; 18
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	ac 32       	cpi	r26, 0x2C	; 44
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	21 e0       	ldi	r18, 0x01	; 1
      b4:	ac e2       	ldi	r26, 0x2C	; 44
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	a6 38       	cpi	r26, 0x86	; 134
      be:	b2 07       	cpc	r27, r18
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	0e 94 6e 08 	call	0x10dc	; 0x10dc <main>
      c6:	0c 94 0c 09 	jmp	0x1218	; 0x1218 <_exit>

000000ca <__bad_interrupt>:
      ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <spi_init>:
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
      ce:	87 b3       	in	r24, 0x17	; 23
      d0:	87 60       	ori	r24, 0x07	; 7
      d2:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
      d4:	8d b1       	in	r24, 0x0d	; 13
      d6:	8c 65       	ori	r24, 0x5C	; 92
      d8:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
      da:	70 9a       	sbi	0x0e, 0	; 14
      dc:	08 95       	ret

000000de <tcnt0_init>:
Function:
Description:
Parameters:
**********************************************************************/
void tcnt0_init(){
   ASSR |= (1<<AS0);
      de:	80 b7       	in	r24, 0x30	; 48
      e0:	88 60       	ori	r24, 0x08	; 8
      e2:	80 bf       	out	0x30, r24	; 48
   TIMSK |= (1<<TOIE0);			//enable interrupts
      e4:	87 b7       	in	r24, 0x37	; 55
      e6:	81 60       	ori	r24, 0x01	; 1
      e8:	87 bf       	out	0x37, r24	; 55
   TCCR0 |= (1<<CS00);			//normal mode, no prescale
      ea:	83 b7       	in	r24, 0x33	; 51
      ec:	81 60       	ori	r24, 0x01	; 1
      ee:	83 bf       	out	0x33, r24	; 51
      f0:	08 95       	ret

000000f2 <tcnt1_init>:
      f2:	08 95       	ret

000000f4 <tcnt3_init>:
/**********************************************************************
Function:
Description:
Parameters:
**********************************************************************/
void tcnt3_init(){
      f4:	08 95       	ret

000000f6 <spi_read>:
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
      f6:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
      f8:	77 9b       	sbis	0x0e, 7	; 14
      fa:	fe cf       	rjmp	.-4      	; 0xf8 <spi_read+0x2>
   return SPDR;
      fc:	8f b1       	in	r24, 0x0f	; 15
}
      fe:	08 95       	ret

00000100 <chk_buttons>:
	be implemented at the same time. Adapted to check all buttons from 
	Ganssel's "Guide to Debouncing" Expects active low pushbuttons on PINA 
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
     100:	48 2f       	mov	r20, r24
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
     102:	e8 2f       	mov	r30, r24
     104:	f0 e0       	ldi	r31, 0x00	; 0
     106:	99 b3       	in	r25, 0x19	; 25
     108:	ee 0f       	add	r30, r30
     10a:	ff 1f       	adc	r31, r31
     10c:	ed 5b       	subi	r30, 0xBD	; 189
     10e:	fe 4f       	sbci	r31, 0xFE	; 254
     110:	20 81       	ld	r18, Z
     112:	31 81       	ldd	r19, Z+1	; 0x01
     114:	22 0f       	add	r18, r18
     116:	33 1f       	adc	r19, r19
     118:	30 6e       	ori	r19, 0xE0	; 224
     11a:	89 2f       	mov	r24, r25
     11c:	90 e0       	ldi	r25, 0x00	; 0
     11e:	02 c0       	rjmp	.+4      	; 0x124 <chk_buttons+0x24>
     120:	95 95       	asr	r25
     122:	87 95       	ror	r24
     124:	4a 95       	dec	r20
     126:	e2 f7       	brpl	.-8      	; 0x120 <chk_buttons+0x20>
     128:	81 70       	andi	r24, 0x01	; 1
     12a:	99 27       	eor	r25, r25
     12c:	28 2b       	or	r18, r24
     12e:	39 2b       	or	r19, r25
     130:	31 83       	std	Z+1, r19	; 0x01
     132:	20 83       	st	Z, r18
     134:	81 e0       	ldi	r24, 0x01	; 1
     136:	21 15       	cp	r18, r1
     138:	30 4f       	sbci	r19, 0xF0	; 240
     13a:	09 f0       	breq	.+2      	; 0x13e <chk_buttons+0x3e>
     13c:	80 e0       	ldi	r24, 0x00	; 0
  if (state[button] == 0xF000)
    return 1;
return 0;
}
     13e:	08 95       	ret

00000140 <bars>:
Description:This function reads in the button board and updates the 
	LEDs on the bargraph through the serial port.
Parameters: NA
**********************************************************************/
void bars() {
   DDRA = 0x00;				//Set all as inputs
     140:	1a ba       	out	0x1a, r1	; 26
   PORTA = 0xFF;			//Pull up resistors
     142:	8f ef       	ldi	r24, 0xFF	; 255
     144:	8b bb       	out	0x1b, r24	; 27
   PORTB |= PINB | 0x70;		//Enable tristate buffer
     146:	86 b3       	in	r24, 0x16	; 22
     148:	98 b3       	in	r25, 0x18	; 24
     14a:	80 67       	ori	r24, 0x70	; 112
     14c:	89 2b       	or	r24, r25
     14e:	88 bb       	out	0x18, r24	; 24
     150:	e3 e4       	ldi	r30, 0x43	; 67
     152:	f1 e0       	ldi	r31, 0x01	; 1

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     154:	20 e0       	ldi	r18, 0x00	; 0
     156:	30 e0       	ldi	r19, 0x00	; 0
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
     158:	61 e0       	ldi	r22, 0x01	; 1
     15a:	70 e0       	ldi	r23, 0x00	; 0
     15c:	05 c0       	rjmp	.+10     	; 0x168 <bars+0x28>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     15e:	2f 5f       	subi	r18, 0xFF	; 255
     160:	3f 4f       	sbci	r19, 0xFF	; 255
     162:	28 30       	cpi	r18, 0x08	; 8
     164:	31 05       	cpc	r19, r1
     166:	39 f1       	breq	.+78     	; 0x1b6 <bars+0x76>
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
     168:	99 b3       	in	r25, 0x19	; 25
     16a:	40 81       	ld	r20, Z
     16c:	51 81       	ldd	r21, Z+1	; 0x01
     16e:	44 0f       	add	r20, r20
     170:	55 1f       	adc	r21, r21
     172:	89 2f       	mov	r24, r25
     174:	90 e0       	ldi	r25, 0x00	; 0
     176:	02 2e       	mov	r0, r18
     178:	02 c0       	rjmp	.+4      	; 0x17e <bars+0x3e>
     17a:	95 95       	asr	r25
     17c:	87 95       	ror	r24
     17e:	0a 94       	dec	r0
     180:	e2 f7       	brpl	.-8      	; 0x17a <bars+0x3a>
     182:	81 70       	andi	r24, 0x01	; 1
     184:	99 27       	eor	r25, r25
     186:	84 2b       	or	r24, r20
     188:	95 2b       	or	r25, r21
     18a:	90 6e       	ori	r25, 0xE0	; 224
     18c:	81 93       	st	Z+, r24
     18e:	91 93       	st	Z+, r25
  if (state[button] == 0xF000)
     190:	81 15       	cp	r24, r1
     192:	90 4f       	sbci	r25, 0xF0	; 240
     194:	21 f7       	brne	.-56     	; 0x15e <bars+0x1e>
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
     196:	cb 01       	movw	r24, r22
     198:	02 2e       	mov	r0, r18
     19a:	02 c0       	rjmp	.+4      	; 0x1a0 <bars+0x60>
     19c:	88 0f       	add	r24, r24
     19e:	99 1f       	adc	r25, r25
     1a0:	0a 94       	dec	r0
     1a2:	e2 f7       	brpl	.-8      	; 0x19c <bars+0x5c>
     1a4:	90 93 36 01 	sts	0x0136, r25	; 0x800136 <mult+0x1>
     1a8:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <mult>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     1ac:	2f 5f       	subi	r18, 0xFF	; 255
     1ae:	3f 4f       	sbci	r19, 0xFF	; 255
     1b0:	28 30       	cpi	r18, 0x08	; 8
     1b2:	31 05       	cpc	r19, r1
     1b4:	c9 f6       	brne	.-78     	; 0x168 <bars+0x28>
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
     1b6:	88 b3       	in	r24, 0x18	; 24
     1b8:	18 ba       	out	0x18, r1	; 24
   if(mult == 128){			//Button 8 toggles base 10 and 16
     1ba:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <mult>
     1be:	90 91 36 01 	lds	r25, 0x0136	; 0x800136 <mult+0x1>
     1c2:	80 38       	cpi	r24, 0x80	; 128
     1c4:	91 05       	cpc	r25, r1
     1c6:	09 f4       	brne	.+2      	; 0x1ca <bars+0x8a>
     1c8:	42 c0       	rjmp	.+132    	; 0x24e <bars+0x10e>
      alarm = !(alarm);			//on the LED display
   }
   if(mult > 4) {			//I only want values from the
     1ca:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <mult>
     1ce:	90 91 36 01 	lds	r25, 0x0136	; 0x800136 <mult+0x1>
     1d2:	05 97       	sbiw	r24, 0x05	; 5
     1d4:	20 f0       	brcs	.+8      	; 0x1de <bars+0x9e>
      mult = 0;				//first three buttons
     1d6:	10 92 36 01 	sts	0x0136, r1	; 0x800136 <mult+0x1>
     1da:	10 92 35 01 	sts	0x0135, r1	; 0x800135 <mult>
   }
   if(mult == 4){
     1de:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <mult>
     1e2:	90 91 36 01 	lds	r25, 0x0136	; 0x800136 <mult+0x1>
     1e6:	04 97       	sbiw	r24, 0x04	; 4
     1e8:	71 f1       	breq	.+92     	; 0x246 <bars+0x106>
      snooze = 1;
   }
   //This switch statement is used to enable a 'toggle' functionality
   //so that modes can be selected an deselected
   switch(mult) {
     1ea:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <mult>
     1ee:	90 91 36 01 	lds	r25, 0x0136	; 0x800136 <mult+0x1>
     1f2:	81 30       	cpi	r24, 0x01	; 1
     1f4:	91 05       	cpc	r25, r1
     1f6:	19 f0       	breq	.+6      	; 0x1fe <bars+0xbe>
     1f8:	82 30       	cpi	r24, 0x02	; 2
     1fa:	91 05       	cpc	r25, r1
     1fc:	f9 f4       	brne	.+62     	; 0x23c <bars+0xfc>
	 }
	 else
	    mode_sel = 1;		//If not, then change mode
         break;
      case 2:
	 if((mode_sel ^ mult) == 0 ){//if((mode_sel ^ mult) && (mode_sel == 4)){//if cur &prev are diff
     1fe:	40 91 31 01 	lds	r20, 0x0131	; 0x800131 <mode_sel>
     202:	50 91 32 01 	lds	r21, 0x0132	; 0x800132 <mode_sel+0x1>
     206:	20 91 35 01 	lds	r18, 0x0135	; 0x800135 <mult>
     20a:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <mult+0x1>
     20e:	42 17       	cp	r20, r18
     210:	53 07       	cpc	r21, r19
     212:	29 f1       	breq	.+74     	; 0x25e <bars+0x11e>
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
         break;*/
      default:
	 mode_sel = mode_sel;		//no/invalid button press
     214:	90 93 32 01 	sts	0x0132, r25	; 0x800132 <mode_sel+0x1>
     218:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <mode_sel>
   }   
   mult = 0;				//clear mult for next pass
     21c:	10 92 36 01 	sts	0x0136, r1	; 0x800136 <mult+0x1>
     220:	10 92 35 01 	sts	0x0135, r1	; 0x800135 <mult>

   DDRA = 0xFF;				//Set A to alloutputs
     224:	8f ef       	ldi	r24, 0xFF	; 255
     226:	8a bb       	out	0x1a, r24	; 26
   SPDR = mode_sel;			//Write mode to the Bargraph
     228:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <mode_sel>
     22c:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <mode_sel+0x1>
     230:	8f b9       	out	0x0f, r24	; 15
   while(bit_is_clear(SPSR, SPIF)){}	
     232:	77 9b       	sbis	0x0e, 7	; 14
     234:	fe cf       	rjmp	.-4      	; 0x232 <bars+0xf2>
   PORTB |= (1<<PB0);			//Rgclk high on bargraph
     236:	c0 9a       	sbi	0x18, 0	; 24
   PORTB &= 0xFE;			//Rgclk low on bargraph
     238:	c0 98       	cbi	0x18, 0	; 24
   
return ;
     23a:	08 95       	ret
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
         break;*/
      default:
	 mode_sel = mode_sel;		//no/invalid button press
     23c:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <mode_sel>
     240:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <mode_sel+0x1>
     244:	e7 cf       	rjmp	.-50     	; 0x214 <bars+0xd4>
   }
   if(mult > 4) {			//I only want values from the
      mult = 0;				//first three buttons
   }
   if(mult == 4){
      snooze = 1;
     246:	81 e0       	ldi	r24, 0x01	; 1
     248:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <snooze>
     24c:	ce cf       	rjmp	.-100    	; 0x1ea <bars+0xaa>
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
     24e:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <alarm>
     252:	81 e0       	ldi	r24, 0x01	; 1
     254:	91 11       	cpse	r25, r1
     256:	08 c0       	rjmp	.+16     	; 0x268 <bars+0x128>
     258:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <alarm>
     25c:	b6 cf       	rjmp	.-148    	; 0x1ca <bars+0x8a>
	 else
	    mode_sel = 1;		//If not, then change mode
         break;
      case 2:
	 if((mode_sel ^ mult) == 0 ){//if((mode_sel ^ mult) && (mode_sel == 4)){//if cur &prev are diff
	    mode_sel = 0;//and prev isn't = 1 then two modes are selected
     25e:	10 92 32 01 	sts	0x0132, r1	; 0x800132 <mode_sel+0x1>
     262:	10 92 31 01 	sts	0x0131, r1	; 0x800131 <mode_sel>
     266:	da cf       	rjmp	.-76     	; 0x21c <bars+0xdc>
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
     268:	80 e0       	ldi	r24, 0x00	; 0
     26a:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <alarm>
     26e:	ad cf       	rjmp	.-166    	; 0x1ca <bars+0x8a>

00000270 <read_encoder>:
   int8_t value = 0x00;
   uint8_t ec_a;
   uint8_t ec_b;

   //Shift_LD_N low
   PORTE &= 0x00;	//Begining of SHIFT_LD_N pulse. It is low here
     270:	83 b1       	in	r24, 0x03	; 3
     272:	13 b8       	out	0x03, r1	; 3
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     274:	87 ec       	ldi	r24, 0xC7	; 199
     276:	90 e0       	ldi	r25, 0x00	; 0
     278:	01 97       	sbiw	r24, 0x01	; 1
     27a:	f1 f7       	brne	.-4      	; 0x278 <read_encoder+0x8>
     27c:	00 c0       	rjmp	.+0      	; 0x27e <read_encoder+0xe>
     27e:	00 00       	nop
   _delay_us(50);
   PORTE |= 0xFF;	//End of SHIFT_LD_N pulse. back to high
     280:	83 b1       	in	r24, 0x03	; 3
     282:	8f ef       	ldi	r24, 0xFF	; 255
     284:	83 b9       	out	0x03, r24	; 3
   PORTD &= 0x00;	//CLK_INH low
     286:	82 b3       	in	r24, 0x12	; 18
     288:	12 ba       	out	0x12, r1	; 18
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
     28a:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
     28c:	77 9b       	sbis	0x0e, 7	; 14
     28e:	fe cf       	rjmp	.-4      	; 0x28c <read_encoder+0x1c>
   return SPDR;
     290:	9f b1       	in	r25, 0x0f	; 15
   _delay_us(50);
   PORTE |= 0xFF;	//End of SHIFT_LD_N pulse. back to high
   PORTD &= 0x00;	//CLK_INH low

   encoder_value = spi_read();
   PORTD |= 0x02;	//CLK_INH high
     292:	91 9a       	sbi	0x12, 1	; 18
   value = mode_sel;
     294:	20 91 31 01 	lds	r18, 0x0131	; 0x800131 <mode_sel>
     298:	30 91 32 01 	lds	r19, 0x0132	; 0x800132 <mode_sel+0x1>
     29c:	82 2f       	mov	r24, r18
   ec_a = encoder_value & 0x03;  //Only grabs these bits 0000_0011
     29e:	49 2f       	mov	r20, r25
     2a0:	43 70       	andi	r20, 0x03	; 3
   ec_b = encoder_value & 0x0C;  //Only grabs these bits 0000_1100 
     2a2:	9c 70       	andi	r25, 0x0C	; 12
   ec_b = (ec_b >> 2);
     2a4:	96 95       	lsr	r25
     2a6:	96 95       	lsr	r25

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
     2a8:	20 91 31 01 	lds	r18, 0x0131	; 0x800131 <mode_sel>
     2ac:	30 91 32 01 	lds	r19, 0x0132	; 0x800132 <mode_sel+0x1>
     2b0:	21 30       	cpi	r18, 0x01	; 1
     2b2:	31 05       	cpc	r19, r1
     2b4:	09 f4       	brne	.+2      	; 0x2b8 <read_encoder+0x48>
     2b6:	44 c0       	rjmp	.+136    	; 0x340 <read_encoder+0xd0>
         else
	    value = 0;
      }
   }
//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 2){
     2b8:	20 91 31 01 	lds	r18, 0x0131	; 0x800131 <mode_sel>
     2bc:	30 91 32 01 	lds	r19, 0x0132	; 0x800132 <mode_sel+0x1>
     2c0:	22 30       	cpi	r18, 0x02	; 2
     2c2:	31 05       	cpc	r19, r1
     2c4:	29 f0       	breq	.+10     	; 0x2d0 <read_encoder+0x60>
         else
	    value = 0;
      }
   }
//Saves previous values into volatile variables
EC_a_prev = ec_a;
     2c6:	40 93 55 01 	sts	0x0155, r20	; 0x800155 <EC_a_prev>
EC_b_prev = ec_b;
     2ca:	90 93 54 01 	sts	0x0154, r25	; 0x800154 <EC_b_prev>

return value;
}
     2ce:	08 95       	ret
	    value = 0;
      }
   }
//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 2){
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     2d0:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <EC_a_prev>
     2d4:	64 2f       	mov	r22, r20
     2d6:	70 e0       	ldi	r23, 0x00	; 0
     2d8:	02 2e       	mov	r0, r18
     2da:	00 0c       	add	r0, r0
     2dc:	33 0b       	sbc	r19, r19
     2de:	62 17       	cp	r22, r18
     2e0:	73 07       	cpc	r23, r19
     2e2:	d1 f0       	breq	.+52     	; 0x318 <read_encoder+0xa8>
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     2e4:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <EC_a_prev>
     2e8:	21 11       	cpse	r18, r1
     2ea:	03 c0       	rjmp	.+6      	; 0x2f2 <read_encoder+0x82>
     2ec:	41 30       	cpi	r20, 0x01	; 1
     2ee:	09 f4       	brne	.+2      	; 0x2f2 <read_encoder+0x82>
     2f0:	89 c0       	rjmp	.+274    	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
            a_hour_count = a_hour_count + 1;//value = value;
	    if(a_hour_count == 24)
	       a_hour_count = 0;
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     2f2:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <EC_a_prev>
     2f6:	21 11       	cpse	r18, r1
     2f8:	1d c0       	rjmp	.+58     	; 0x334 <read_encoder+0xc4>
     2fa:	42 30       	cpi	r20, 0x02	; 2
     2fc:	d9 f4       	brne	.+54     	; 0x334 <read_encoder+0xc4>
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
	    a_min_count = a_min_count - 1; //value = -(value);
	    if(a_min_count < 0){
	       a_min_count = 59;
	       a_hour_count--;
     2fe:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <a_hour_count>
     302:	21 50       	subi	r18, 0x01	; 1
     304:	20 93 3b 01 	sts	0x013B, r18	; 0x80013b <a_hour_count>
	       if(a_hour_count < 0){
     308:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <a_hour_count>
     30c:	27 ff       	sbrs	r18, 7
     30e:	db cf       	rjmp	.-74     	; 0x2c6 <read_encoder+0x56>
	          a_hour_count = 23;
     310:	27 e1       	ldi	r18, 0x17	; 23
     312:	20 93 3b 01 	sts	0x013B, r18	; 0x80013b <a_hour_count>
     316:	d7 cf       	rjmp	.-82     	; 0x2c6 <read_encoder+0x56>
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
     318:	20 91 54 01 	lds	r18, 0x0154	; 0x800154 <EC_b_prev>
     31c:	21 11       	cpse	r18, r1
     31e:	03 c0       	rjmp	.+6      	; 0x326 <read_encoder+0xb6>
     320:	91 30       	cpi	r25, 0x01	; 1
     322:	09 f4       	brne	.+2      	; 0x326 <read_encoder+0xb6>
     324:	89 c0       	rjmp	.+274    	; 0x438 <__LOCK_REGION_LENGTH__+0x38>
	       a_hour_count++;
	       if(a_hour_count > 23)
	          a_hour_count = 0;
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
     326:	20 91 54 01 	lds	r18, 0x0154	; 0x800154 <EC_b_prev>
     32a:	21 11       	cpse	r18, r1
     32c:	03 c0       	rjmp	.+6      	; 0x334 <read_encoder+0xc4>
     32e:	92 30       	cpi	r25, 0x02	; 2
     330:	09 f4       	brne	.+2      	; 0x334 <read_encoder+0xc4>
     332:	75 c0       	rjmp	.+234    	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
	    a_hour_count = a_hour_count - 1;//value = -(value);
	    if(a_hour_count < 0)
	       a_hour_count = 23; 
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
     334:	80 e0       	ldi	r24, 0x00	; 0
         else
	    value = 0;
      }
   }
//Saves previous values into volatile variables
EC_a_prev = ec_a;
     336:	40 93 55 01 	sts	0x0155, r20	; 0x800155 <EC_a_prev>
EC_b_prev = ec_b;
     33a:	90 93 54 01 	sts	0x0154, r25	; 0x800154 <EC_b_prev>

return value;
}
     33e:	08 95       	ret
   ec_b = encoder_value & 0x0C;  //Only grabs these bits 0000_1100 
   ec_b = (ec_b >> 2);

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     340:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <EC_a_prev>
     344:	64 2f       	mov	r22, r20
     346:	70 e0       	ldi	r23, 0x00	; 0
     348:	02 2e       	mov	r0, r18
     34a:	00 0c       	add	r0, r0
     34c:	33 0b       	sbc	r19, r19
     34e:	62 17       	cp	r22, r18
     350:	73 07       	cpc	r23, r19
     352:	d1 f0       	breq	.+52     	; 0x388 <read_encoder+0x118>
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     354:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <EC_a_prev>
     358:	22 23       	and	r18, r18
     35a:	49 f0       	breq	.+18     	; 0x36e <read_encoder+0xfe>
            hour_count = hour_count + 1;//value = value;
	    if(hour_count == 24)
	       hour_count = 0;
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     35c:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <EC_a_prev>
     360:	21 11       	cpse	r18, r1
     362:	03 c0       	rjmp	.+6      	; 0x36a <read_encoder+0xfa>
     364:	42 30       	cpi	r20, 0x02	; 2
     366:	09 f4       	brne	.+2      	; 0x36a <read_encoder+0xfa>
     368:	40 c0       	rjmp	.+128    	; 0x3ea <read_encoder+0x17a>
	    hour_count = hour_count - 1;//value = -(value);
	    if(hour_count < 0)
	       hour_count = 23; 
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
     36a:	80 e0       	ldi	r24, 0x00	; 0
     36c:	a5 cf       	rjmp	.-182    	; 0x2b8 <read_encoder+0x48>
   ec_b = (ec_b >> 2);

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     36e:	41 30       	cpi	r20, 0x01	; 1
     370:	a9 f7       	brne	.-22     	; 0x35c <read_encoder+0xec>
            hour_count = hour_count + 1;//value = value;
     372:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <hour_count>
     376:	2f 5f       	subi	r18, 0xFF	; 255
     378:	20 93 3e 01 	sts	0x013E, r18	; 0x80013e <hour_count>
	    if(hour_count == 24)
     37c:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <hour_count>
     380:	28 31       	cpi	r18, 0x18	; 24
     382:	09 f0       	breq	.+2      	; 0x386 <read_encoder+0x116>
     384:	99 cf       	rjmp	.-206    	; 0x2b8 <read_encoder+0x48>
     386:	1c c0       	rjmp	.+56     	; 0x3c0 <read_encoder+0x150>
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
     388:	20 91 54 01 	lds	r18, 0x0154	; 0x800154 <EC_b_prev>
     38c:	21 11       	cpse	r18, r1
     38e:	1b c0       	rjmp	.+54     	; 0x3c6 <read_encoder+0x156>
     390:	91 30       	cpi	r25, 0x01	; 1
     392:	c9 f4       	brne	.+50     	; 0x3c6 <read_encoder+0x156>
            min_count = min_count + 1;//value = value;
     394:	20 91 3f 01 	lds	r18, 0x013F	; 0x80013f <min_count>
     398:	2f 5f       	subi	r18, 0xFF	; 255
     39a:	20 93 3f 01 	sts	0x013F, r18	; 0x80013f <min_count>
	    if(min_count == 60){
     39e:	20 91 3f 01 	lds	r18, 0x013F	; 0x80013f <min_count>
     3a2:	2c 33       	cpi	r18, 0x3C	; 60
     3a4:	09 f0       	breq	.+2      	; 0x3a8 <read_encoder+0x138>
     3a6:	88 cf       	rjmp	.-240    	; 0x2b8 <read_encoder+0x48>
	       min_count = 0; 
     3a8:	10 92 3f 01 	sts	0x013F, r1	; 0x80013f <min_count>
	       hour_count++;
     3ac:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <hour_count>
     3b0:	2f 5f       	subi	r18, 0xFF	; 255
     3b2:	20 93 3e 01 	sts	0x013E, r18	; 0x80013e <hour_count>
	       if(hour_count > 23)
     3b6:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <hour_count>
     3ba:	28 31       	cpi	r18, 0x18	; 24
     3bc:	0c f4       	brge	.+2      	; 0x3c0 <read_encoder+0x150>
     3be:	7c cf       	rjmp	.-264    	; 0x2b8 <read_encoder+0x48>
	          hour_count = 0;
     3c0:	10 92 3e 01 	sts	0x013E, r1	; 0x80013e <hour_count>
     3c4:	79 cf       	rjmp	.-270    	; 0x2b8 <read_encoder+0x48>
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
     3c6:	20 91 54 01 	lds	r18, 0x0154	; 0x800154 <EC_b_prev>
     3ca:	21 11       	cpse	r18, r1
     3cc:	ce cf       	rjmp	.-100    	; 0x36a <read_encoder+0xfa>
     3ce:	92 30       	cpi	r25, 0x02	; 2
     3d0:	61 f6       	brne	.-104    	; 0x36a <read_encoder+0xfa>
	    min_count = min_count - 1; //value = -(value);
     3d2:	20 91 3f 01 	lds	r18, 0x013F	; 0x80013f <min_count>
     3d6:	21 50       	subi	r18, 0x01	; 1
     3d8:	20 93 3f 01 	sts	0x013F, r18	; 0x80013f <min_count>
	    if(min_count < 0){
     3dc:	20 91 3f 01 	lds	r18, 0x013F	; 0x80013f <min_count>
     3e0:	27 ff       	sbrs	r18, 7
     3e2:	6a cf       	rjmp	.-300    	; 0x2b8 <read_encoder+0x48>
	       min_count = 59;
     3e4:	2b e3       	ldi	r18, 0x3B	; 59
     3e6:	20 93 3f 01 	sts	0x013F, r18	; 0x80013f <min_count>
	       hour_count--;
     3ea:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <hour_count>
     3ee:	21 50       	subi	r18, 0x01	; 1
     3f0:	20 93 3e 01 	sts	0x013E, r18	; 0x80013e <hour_count>
	       if(hour_count < 0){
     3f4:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <hour_count>
     3f8:	27 ff       	sbrs	r18, 7
     3fa:	5e cf       	rjmp	.-324    	; 0x2b8 <read_encoder+0x48>
	          hour_count = 23;
     3fc:	27 e1       	ldi	r18, 0x17	; 23
     3fe:	20 93 3e 01 	sts	0x013E, r18	; 0x80013e <hour_count>
     402:	5a cf       	rjmp	.-332    	; 0x2b8 <read_encoder+0x48>
   }
//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 2){
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
            a_hour_count = a_hour_count + 1;//value = value;
     404:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <a_hour_count>
     408:	2f 5f       	subi	r18, 0xFF	; 255
     40a:	20 93 3b 01 	sts	0x013B, r18	; 0x80013b <a_hour_count>
	    if(a_hour_count == 24)
     40e:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <a_hour_count>
     412:	28 31       	cpi	r18, 0x18	; 24
     414:	09 f0       	breq	.+2      	; 0x418 <__LOCK_REGION_LENGTH__+0x18>
     416:	57 cf       	rjmp	.-338    	; 0x2c6 <read_encoder+0x56>
            a_min_count = a_min_count + 1;//value = value;
	    if(a_min_count == 60){
	       a_min_count = 0; 
	       a_hour_count++;
	       if(a_hour_count > 23)
	          a_hour_count = 0;
     418:	10 92 3b 01 	sts	0x013B, r1	; 0x80013b <a_hour_count>
     41c:	54 cf       	rjmp	.-344    	; 0x2c6 <read_encoder+0x56>
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
	    a_min_count = a_min_count - 1; //value = -(value);
     41e:	20 91 3c 01 	lds	r18, 0x013C	; 0x80013c <a_min_count>
     422:	21 50       	subi	r18, 0x01	; 1
     424:	20 93 3c 01 	sts	0x013C, r18	; 0x80013c <a_min_count>
	    if(a_min_count < 0){
     428:	20 91 3c 01 	lds	r18, 0x013C	; 0x80013c <a_min_count>
     42c:	27 ff       	sbrs	r18, 7
     42e:	4b cf       	rjmp	.-362    	; 0x2c6 <read_encoder+0x56>
	       a_min_count = 59;
     430:	2b e3       	ldi	r18, 0x3B	; 59
     432:	20 93 3c 01 	sts	0x013C, r18	; 0x80013c <a_min_count>
     436:	63 cf       	rjmp	.-314    	; 0x2fe <read_encoder+0x8e>
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
            a_min_count = a_min_count + 1;//value = value;
     438:	20 91 3c 01 	lds	r18, 0x013C	; 0x80013c <a_min_count>
     43c:	2f 5f       	subi	r18, 0xFF	; 255
     43e:	20 93 3c 01 	sts	0x013C, r18	; 0x80013c <a_min_count>
	    if(a_min_count == 60){
     442:	20 91 3c 01 	lds	r18, 0x013C	; 0x80013c <a_min_count>
     446:	2c 33       	cpi	r18, 0x3C	; 60
     448:	09 f0       	breq	.+2      	; 0x44c <__LOCK_REGION_LENGTH__+0x4c>
     44a:	3d cf       	rjmp	.-390    	; 0x2c6 <read_encoder+0x56>
	       a_min_count = 0; 
     44c:	10 92 3c 01 	sts	0x013C, r1	; 0x80013c <a_min_count>
	       a_hour_count++;
     450:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <a_hour_count>
     454:	2f 5f       	subi	r18, 0xFF	; 255
     456:	20 93 3b 01 	sts	0x013B, r18	; 0x80013b <a_hour_count>
	       if(a_hour_count > 23)
     45a:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <a_hour_count>
     45e:	28 31       	cpi	r18, 0x18	; 24
     460:	0c f4       	brge	.+2      	; 0x464 <__LOCK_REGION_LENGTH__+0x64>
     462:	31 cf       	rjmp	.-414    	; 0x2c6 <read_encoder+0x56>
     464:	d9 cf       	rjmp	.-78     	; 0x418 <__LOCK_REGION_LENGTH__+0x18>

00000466 <__vector_16>:
	update the mode and bargraph. Then I change the sum based on	
	the value returned from the encoder reading. Sum is then bounded
	from 0-1023. 1023+1=1 and 0-any number > 0 = 1023.
Parameters: NA
**********************************************************************/
ISR(TIMER0_OVF_vect) {
     466:	1f 92       	push	r1
     468:	0f 92       	push	r0
     46a:	0f b6       	in	r0, 0x3f	; 63
     46c:	0f 92       	push	r0
     46e:	11 24       	eor	r1, r1
     470:	0b b6       	in	r0, 0x3b	; 59
     472:	0f 92       	push	r0
     474:	2f 93       	push	r18
     476:	3f 93       	push	r19
     478:	4f 93       	push	r20
     47a:	5f 93       	push	r21
     47c:	6f 93       	push	r22
     47e:	7f 93       	push	r23
     480:	8f 93       	push	r24
     482:	9f 93       	push	r25
     484:	af 93       	push	r26
     486:	bf 93       	push	r27
     488:	ef 93       	push	r30
     48a:	ff 93       	push	r31
   static uint8_t count_7_8125ms = 0;

   count_7_8125ms++;
     48c:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <count_7_8125ms.2008>
     490:	8f 5f       	subi	r24, 0xFF	; 255
     492:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <count_7_8125ms.2008>
   if((count_7_8125ms % 128) == 0) { //interrupts every 1 second
     496:	8f 77       	andi	r24, 0x7F	; 127
     498:	29 f4       	brne	.+10     	; 0x4a4 <__vector_16+0x3e>
      sec_count++;
     49a:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <sec_count>
     49e:	8f 5f       	subi	r24, 0xFF	; 255
     4a0:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <sec_count>
   }
   bars();  
     4a4:	0e 94 a0 00 	call	0x140	; 0x140 <bars>
   read_encoder();      
     4a8:	0e 94 38 01 	call	0x270	; 0x270 <read_encoder>

}
     4ac:	ff 91       	pop	r31
     4ae:	ef 91       	pop	r30
     4b0:	bf 91       	pop	r27
     4b2:	af 91       	pop	r26
     4b4:	9f 91       	pop	r25
     4b6:	8f 91       	pop	r24
     4b8:	7f 91       	pop	r23
     4ba:	6f 91       	pop	r22
     4bc:	5f 91       	pop	r21
     4be:	4f 91       	pop	r20
     4c0:	3f 91       	pop	r19
     4c2:	2f 91       	pop	r18
     4c4:	0f 90       	pop	r0
     4c6:	0b be       	out	0x3b, r0	; 59
     4c8:	0f 90       	pop	r0
     4ca:	0f be       	out	0x3f, r0	; 63
     4cc:	0f 90       	pop	r0
     4ce:	1f 90       	pop	r1
     4d0:	18 95       	reti

000004d2 <clock_time>:
Description:
Parameters:
**********************************************************************/
void clock_time(){ //by default we use military time
   
   if(sec_count > 59){
     4d2:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <sec_count>
     4d6:	8c 33       	cpi	r24, 0x3C	; 60
     4d8:	60 f0       	brcs	.+24     	; 0x4f2 <clock_time+0x20>
      min_count++;
     4da:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <min_count>
     4de:	8f 5f       	subi	r24, 0xFF	; 255
     4e0:	80 93 3f 01 	sts	0x013F, r24	; 0x80013f <min_count>
      sec_count = 0;
     4e4:	10 92 40 01 	sts	0x0140, r1	; 0x800140 <sec_count>
      if(min_count > 59){
     4e8:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <min_count>
     4ec:	8c 33       	cpi	r24, 0x3C	; 60
     4ee:	0c f0       	brlt	.+2      	; 0x4f2 <clock_time+0x20>
     4f0:	61 c0       	rjmp	.+194    	; 0x5b4 <clock_time+0xe2>
         hour_count = 12;
      }    
   }*/

//This is where the digits are written to the data array
      if(mode_sel == 2){
     4f2:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <mode_sel>
     4f6:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <mode_sel+0x1>
     4fa:	02 97       	sbiw	r24, 0x02	; 2
     4fc:	09 f4       	brne	.+2      	; 0x500 <clock_time+0x2e>
     4fe:	6f c0       	rjmp	.+222    	; 0x5de <clock_time+0x10c>
         else {segment_data[2] = 0b111;}		//Turn colon off
         segment_data[1] = dec_to_7seg[a_min_count/10];
         segment_data[0] = dec_to_7seg[a_min_count%10];
      }
      else{
         segment_data[4] = dec_to_7seg[hour_count/10];
     500:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <hour_count>
     504:	87 e6       	ldi	r24, 0x67	; 103
     506:	98 02       	muls	r25, r24
     508:	e1 2d       	mov	r30, r1
     50a:	11 24       	eor	r1, r1
     50c:	e5 95       	asr	r30
     50e:	e5 95       	asr	r30
     510:	97 fd       	sbrc	r25, 7
     512:	e3 95       	inc	r30
     514:	0e 2e       	mov	r0, r30
     516:	00 0c       	add	r0, r0
     518:	ff 0b       	sbc	r31, r31
     51a:	e0 50       	subi	r30, 0x00	; 0
     51c:	ff 4f       	sbci	r31, 0xFF	; 255
     51e:	90 81       	ld	r25, Z
     520:	90 93 30 01 	sts	0x0130, r25	; 0x800130 <__data_end+0x4>
         segment_data[3] = dec_to_7seg[hour_count%10];
     524:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <hour_count>
     528:	e8 02       	muls	r30, r24
     52a:	81 2d       	mov	r24, r1
     52c:	11 24       	eor	r1, r1
     52e:	85 95       	asr	r24
     530:	85 95       	asr	r24
     532:	e7 fd       	sbrc	r30, 7
     534:	83 95       	inc	r24
     536:	9a e0       	ldi	r25, 0x0A	; 10
     538:	89 9f       	mul	r24, r25
     53a:	e0 19       	sub	r30, r0
     53c:	11 24       	eor	r1, r1
     53e:	0e 2e       	mov	r0, r30
     540:	00 0c       	add	r0, r0
     542:	ff 0b       	sbc	r31, r31
     544:	e0 50       	subi	r30, 0x00	; 0
     546:	ff 4f       	sbci	r31, 0xFF	; 255
     548:	80 81       	ld	r24, Z
     54a:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <__data_end+0x3>
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     54e:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <sec_count>
     552:	80 fd       	sbrc	r24, 0
     554:	2b c0       	rjmp	.+86     	; 0x5ac <clock_time+0xda>
         else {segment_data[2] = 0b111;}		//Turn colon off
     556:	87 e0       	ldi	r24, 0x07	; 7
     558:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <__data_end+0x2>
         segment_data[1] = dec_to_7seg[min_count/10];
     55c:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <min_count>
     560:	87 e6       	ldi	r24, 0x67	; 103
     562:	98 02       	muls	r25, r24
     564:	e1 2d       	mov	r30, r1
     566:	11 24       	eor	r1, r1
     568:	e5 95       	asr	r30
     56a:	e5 95       	asr	r30
     56c:	97 fd       	sbrc	r25, 7
     56e:	e3 95       	inc	r30
     570:	0e 2e       	mov	r0, r30
     572:	00 0c       	add	r0, r0
     574:	ff 0b       	sbc	r31, r31
     576:	e0 50       	subi	r30, 0x00	; 0
     578:	ff 4f       	sbci	r31, 0xFF	; 255
     57a:	90 81       	ld	r25, Z
     57c:	90 93 2d 01 	sts	0x012D, r25	; 0x80012d <__data_end+0x1>
         segment_data[0] = dec_to_7seg[min_count%10];
     580:	e0 91 3f 01 	lds	r30, 0x013F	; 0x80013f <min_count>
     584:	e8 02       	muls	r30, r24
     586:	81 2d       	mov	r24, r1
     588:	11 24       	eor	r1, r1
     58a:	85 95       	asr	r24
     58c:	85 95       	asr	r24
     58e:	e7 fd       	sbrc	r30, 7
     590:	83 95       	inc	r24
     592:	9a e0       	ldi	r25, 0x0A	; 10
     594:	89 9f       	mul	r24, r25
     596:	e0 19       	sub	r30, r0
     598:	11 24       	eor	r1, r1
     59a:	0e 2e       	mov	r0, r30
     59c:	00 0c       	add	r0, r0
     59e:	ff 0b       	sbc	r31, r31
     5a0:	e0 50       	subi	r30, 0x00	; 0
     5a2:	ff 4f       	sbci	r31, 0xFF	; 255
     5a4:	80 81       	ld	r24, Z
     5a6:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <__data_end>
     5aa:	08 95       	ret
         segment_data[0] = dec_to_7seg[a_min_count%10];
      }
      else{
         segment_data[4] = dec_to_7seg[hour_count/10];
         segment_data[3] = dec_to_7seg[hour_count%10];
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     5ac:	84 e0       	ldi	r24, 0x04	; 4
     5ae:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <__data_end+0x2>
     5b2:	d4 cf       	rjmp	.-88     	; 0x55c <clock_time+0x8a>
   
   if(sec_count > 59){
      min_count++;
      sec_count = 0;
      if(min_count > 59){
	 hour_count++;
     5b4:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <hour_count>
     5b8:	8f 5f       	subi	r24, 0xFF	; 255
     5ba:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <hour_count>
	 min_count = 0;
     5be:	10 92 3f 01 	sts	0x013F, r1	; 0x80013f <min_count>
	 if(hour_count > 23){
     5c2:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <hour_count>
     5c6:	88 31       	cpi	r24, 0x18	; 24
     5c8:	0c f4       	brge	.+2      	; 0x5cc <clock_time+0xfa>
     5ca:	93 cf       	rjmp	.-218    	; 0x4f2 <clock_time+0x20>
	    hour_count = 0;
     5cc:	10 92 3e 01 	sts	0x013E, r1	; 0x80013e <hour_count>
         hour_count = 12;
      }    
   }*/

//This is where the digits are written to the data array
      if(mode_sel == 2){
     5d0:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <mode_sel>
     5d4:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <mode_sel+0x1>
     5d8:	02 97       	sbiw	r24, 0x02	; 2
     5da:	09 f0       	breq	.+2      	; 0x5de <clock_time+0x10c>
     5dc:	91 cf       	rjmp	.-222    	; 0x500 <clock_time+0x2e>
         segment_data[4] = dec_to_7seg[a_hour_count/10];
     5de:	90 91 3b 01 	lds	r25, 0x013B	; 0x80013b <a_hour_count>
     5e2:	87 e6       	ldi	r24, 0x67	; 103
     5e4:	98 02       	muls	r25, r24
     5e6:	e1 2d       	mov	r30, r1
     5e8:	11 24       	eor	r1, r1
     5ea:	e5 95       	asr	r30
     5ec:	e5 95       	asr	r30
     5ee:	97 fd       	sbrc	r25, 7
     5f0:	e3 95       	inc	r30
     5f2:	0e 2e       	mov	r0, r30
     5f4:	00 0c       	add	r0, r0
     5f6:	ff 0b       	sbc	r31, r31
     5f8:	e0 50       	subi	r30, 0x00	; 0
     5fa:	ff 4f       	sbci	r31, 0xFF	; 255
     5fc:	90 81       	ld	r25, Z
     5fe:	90 93 30 01 	sts	0x0130, r25	; 0x800130 <__data_end+0x4>
         segment_data[3] = dec_to_7seg[a_hour_count%10];
     602:	e0 91 3b 01 	lds	r30, 0x013B	; 0x80013b <a_hour_count>
     606:	e8 02       	muls	r30, r24
     608:	81 2d       	mov	r24, r1
     60a:	11 24       	eor	r1, r1
     60c:	85 95       	asr	r24
     60e:	85 95       	asr	r24
     610:	e7 fd       	sbrc	r30, 7
     612:	83 95       	inc	r24
     614:	9a e0       	ldi	r25, 0x0A	; 10
     616:	89 9f       	mul	r24, r25
     618:	e0 19       	sub	r30, r0
     61a:	11 24       	eor	r1, r1
     61c:	0e 2e       	mov	r0, r30
     61e:	00 0c       	add	r0, r0
     620:	ff 0b       	sbc	r31, r31
     622:	e0 50       	subi	r30, 0x00	; 0
     624:	ff 4f       	sbci	r31, 0xFF	; 255
     626:	80 81       	ld	r24, Z
     628:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <__data_end+0x3>
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     62c:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <sec_count>
     630:	80 fd       	sbrc	r24, 0
     632:	18 c0       	rjmp	.+48     	; 0x664 <clock_time+0x192>
         else {segment_data[2] = 0b111;}		//Turn colon off
     634:	87 e0       	ldi	r24, 0x07	; 7
     636:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <__data_end+0x2>
         segment_data[1] = dec_to_7seg[a_min_count/10];
     63a:	90 91 3c 01 	lds	r25, 0x013C	; 0x80013c <a_min_count>
     63e:	87 e6       	ldi	r24, 0x67	; 103
     640:	98 02       	muls	r25, r24
     642:	e1 2d       	mov	r30, r1
     644:	11 24       	eor	r1, r1
     646:	e5 95       	asr	r30
     648:	e5 95       	asr	r30
     64a:	97 fd       	sbrc	r25, 7
     64c:	e3 95       	inc	r30
     64e:	0e 2e       	mov	r0, r30
     650:	00 0c       	add	r0, r0
     652:	ff 0b       	sbc	r31, r31
     654:	e0 50       	subi	r30, 0x00	; 0
     656:	ff 4f       	sbci	r31, 0xFF	; 255
     658:	90 81       	ld	r25, Z
     65a:	90 93 2d 01 	sts	0x012D, r25	; 0x80012d <__data_end+0x1>
         segment_data[0] = dec_to_7seg[a_min_count%10];
     65e:	e0 91 3c 01 	lds	r30, 0x013C	; 0x80013c <a_min_count>
     662:	90 cf       	rjmp	.-224    	; 0x584 <clock_time+0xb2>

//This is where the digits are written to the data array
      if(mode_sel == 2){
         segment_data[4] = dec_to_7seg[a_hour_count/10];
         segment_data[3] = dec_to_7seg[a_hour_count%10];
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     664:	84 e0       	ldi	r24, 0x04	; 4
     666:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <__data_end+0x2>
     66a:	e7 cf       	rjmp	.-50     	; 0x63a <clock_time+0x168>

0000066c <port_init>:
Function:
Description:
Parameters:
**********************************************************************/
void port_init(){
   DDRC |= 0xFF; 
     66c:	84 b3       	in	r24, 0x14	; 20
     66e:	9f ef       	ldi	r25, 0xFF	; 255
     670:	94 bb       	out	0x14, r25	; 20
   DDRB |= 0xF0;				//PB4-6 is SEL0-2, PB7 is PWM
     672:	87 b3       	in	r24, 0x17	; 23
     674:	80 6f       	ori	r24, 0xF0	; 240
     676:	87 bb       	out	0x17, r24	; 23
   DDRE |= 0x40;				//PE6 is SHIFT_LD_N
     678:	16 9a       	sbi	0x02, 6	; 2
   DDRD |= 0x0B;				//PE1 is CLK_INH and PE2 is SRCLK
     67a:	81 b3       	in	r24, 0x11	; 17
     67c:	8b 60       	ori	r24, 0x0B	; 11
     67e:	81 bb       	out	0x11, r24	; 17
   PORTC |= 0x00;
     680:	85 b3       	in	r24, 0x15	; 21
     682:	85 bb       	out	0x15, r24	; 21
   PORTD |= 0x02;
     684:	91 9a       	sbi	0x12, 1	; 18
   PORTE |= 0xFF;
     686:	83 b1       	in	r24, 0x03	; 3
     688:	93 b9       	out	0x03, r25	; 3
     68a:	08 95       	ret

0000068c <change_alarm_state>:
/**********************************************************************
Function:
Description:
Parameters:
**********************************************************************/
void change_alarm_state(){
     68c:	0f 93       	push	r16
   static uint8_t curr = 0;

   if(alarm && (curr == 0)){
     68e:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <alarm>
     692:	88 23       	and	r24, r24
     694:	c1 f1       	breq	.+112    	; 0x706 <change_alarm_state+0x7a>
     696:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <curr.2015>
     69a:	81 11       	cpse	r24, r1
     69c:	34 c0       	rjmp	.+104    	; 0x706 <change_alarm_state+0x7a>
      if((a_hour_count > 9) && (a_min_count > 9)){
     69e:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <a_hour_count>
     6a2:	8a 30       	cpi	r24, 0x0A	; 10
     6a4:	2c f0       	brlt	.+10     	; 0x6b0 <change_alarm_state+0x24>
     6a6:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <a_min_count>
     6aa:	8a 30       	cpi	r24, 0x0A	; 10
     6ac:	0c f0       	brlt	.+2      	; 0x6b0 <change_alarm_state+0x24>
     6ae:	5d c0       	rjmp	.+186    	; 0x76a <change_alarm_state+0xde>
         string2lcd("ALARM at ");
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         lcd_int16(a_min_count, 2, 0, 0, 0);
      }
      else if(a_hour_count > 9){
     6b0:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <a_hour_count>
     6b4:	8a 30       	cpi	r24, 0x0A	; 10
     6b6:	a4 f5       	brge	.+104    	; 0x720 <change_alarm_state+0x94>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         string2lcd("0");
         lcd_int16(a_min_count, 1, 0, 0, 0);
      }
      else if(a_min_count > 9){
     6b8:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <a_min_count>
     6bc:	8a 30       	cpi	r24, 0x0A	; 10
     6be:	0c f4       	brge	.+2      	; 0x6c2 <change_alarm_state+0x36>
     6c0:	51 c0       	rjmp	.+162    	; 0x764 <change_alarm_state+0xd8>
         string2lcd("ALARM at");
     6c2:	83 e2       	ldi	r24, 0x23	; 35
     6c4:	91 e0       	ldi	r25, 0x01	; 1
     6c6:	0e 94 d1 05 	call	0xba2	; 0xba2 <string2lcd>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
     6ca:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <a_hour_count>
     6ce:	00 e0       	ldi	r16, 0x00	; 0
     6d0:	20 e0       	ldi	r18, 0x00	; 0
     6d2:	40 e0       	ldi	r20, 0x00	; 0
     6d4:	62 e0       	ldi	r22, 0x02	; 2
     6d6:	08 2e       	mov	r0, r24
     6d8:	00 0c       	add	r0, r0
     6da:	99 0b       	sbc	r25, r25
     6dc:	0e 94 96 07 	call	0xf2c	; 0xf2c <lcd_int16>
         string2lcd(":");
     6e0:	8f e1       	ldi	r24, 0x1F	; 31
     6e2:	91 e0       	ldi	r25, 0x01	; 1
     6e4:	0e 94 d1 05 	call	0xba2	; 0xba2 <string2lcd>
         lcd_int16(a_min_count, 2, 0, 0, 0);
     6e8:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <a_min_count>
     6ec:	20 e0       	ldi	r18, 0x00	; 0
     6ee:	40 e0       	ldi	r20, 0x00	; 0
     6f0:	62 e0       	ldi	r22, 0x02	; 2
     6f2:	08 2e       	mov	r0, r24
     6f4:	00 0c       	add	r0, r0
     6f6:	99 0b       	sbc	r25, r25
     6f8:	0e 94 96 07 	call	0xf2c	; 0xf2c <lcd_int16>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         string2lcd("0");
         lcd_int16(a_min_count, 1, 0, 0, 0);
      }
      curr = 1;
     6fc:	81 e0       	ldi	r24, 0x01	; 1
     6fe:	80 93 41 01 	sts	0x0141, r24	; 0x800141 <curr.2015>
   else if((!alarm) && (curr == 1)){
      curr = 0;
      clear_display();
   }
   else{}
}
     702:	0f 91       	pop	r16
     704:	08 95       	ret
         string2lcd("0");
         lcd_int16(a_min_count, 1, 0, 0, 0);
      }
      curr = 1;
   }
   else if((!alarm) && (curr == 1)){
     706:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <alarm>
     70a:	81 11       	cpse	r24, r1
     70c:	fa cf       	rjmp	.-12     	; 0x702 <change_alarm_state+0x76>
     70e:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <curr.2015>
     712:	81 30       	cpi	r24, 0x01	; 1
     714:	b1 f7       	brne	.-20     	; 0x702 <change_alarm_state+0x76>
      curr = 0;
     716:	10 92 41 01 	sts	0x0141, r1	; 0x800141 <curr.2015>
      clear_display();
   }
   else{}
}
     71a:	0f 91       	pop	r16
      }
      curr = 1;
   }
   else if((!alarm) && (curr == 1)){
      curr = 0;
      clear_display();
     71c:	0c 94 49 05 	jmp	0xa92	; 0xa92 <clear_display>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         lcd_int16(a_min_count, 2, 0, 0, 0);
      }
      else if(a_hour_count > 9){
         string2lcd("ALARM at ");
     720:	85 e1       	ldi	r24, 0x15	; 21
     722:	91 e0       	ldi	r25, 0x01	; 1
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         lcd_int16(a_min_count, 2, 0, 0, 0);
      }
      else {
         string2lcd("ALARM at");
     724:	0e 94 d1 05 	call	0xba2	; 0xba2 <string2lcd>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
     728:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <a_hour_count>
     72c:	00 e0       	ldi	r16, 0x00	; 0
     72e:	20 e0       	ldi	r18, 0x00	; 0
     730:	40 e0       	ldi	r20, 0x00	; 0
     732:	62 e0       	ldi	r22, 0x02	; 2
     734:	08 2e       	mov	r0, r24
     736:	00 0c       	add	r0, r0
     738:	99 0b       	sbc	r25, r25
     73a:	0e 94 96 07 	call	0xf2c	; 0xf2c <lcd_int16>
         string2lcd(":");
     73e:	8f e1       	ldi	r24, 0x1F	; 31
     740:	91 e0       	ldi	r25, 0x01	; 1
     742:	0e 94 d1 05 	call	0xba2	; 0xba2 <string2lcd>
         string2lcd("0");
     746:	81 e2       	ldi	r24, 0x21	; 33
     748:	91 e0       	ldi	r25, 0x01	; 1
     74a:	0e 94 d1 05 	call	0xba2	; 0xba2 <string2lcd>
         lcd_int16(a_min_count, 1, 0, 0, 0);
     74e:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <a_min_count>
     752:	20 e0       	ldi	r18, 0x00	; 0
     754:	40 e0       	ldi	r20, 0x00	; 0
     756:	61 e0       	ldi	r22, 0x01	; 1
     758:	08 2e       	mov	r0, r24
     75a:	00 0c       	add	r0, r0
     75c:	99 0b       	sbc	r25, r25
     75e:	0e 94 96 07 	call	0xf2c	; 0xf2c <lcd_int16>
     762:	cc cf       	rjmp	.-104    	; 0x6fc <change_alarm_state+0x70>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         lcd_int16(a_min_count, 2, 0, 0, 0);
      }
      else {
         string2lcd("ALARM at");
     764:	83 e2       	ldi	r24, 0x23	; 35
     766:	91 e0       	ldi	r25, 0x01	; 1
     768:	dd cf       	rjmp	.-70     	; 0x724 <change_alarm_state+0x98>
void change_alarm_state(){
   static uint8_t curr = 0;

   if(alarm && (curr == 0)){
      if((a_hour_count > 9) && (a_min_count > 9)){
         string2lcd("ALARM at ");
     76a:	85 e1       	ldi	r24, 0x15	; 21
     76c:	91 e0       	ldi	r25, 0x01	; 1
     76e:	ab cf       	rjmp	.-170    	; 0x6c6 <change_alarm_state+0x3a>

00000770 <send_lcd>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     770:	91 e0       	ldi	r25, 0x01	; 1
     772:	81 11       	cpse	r24, r1
     774:	01 c0       	rjmp	.+2      	; 0x778 <send_lcd+0x8>
     776:	90 e0       	ldi	r25, 0x00	; 0
     778:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     77a:	77 9b       	sbis	0x0e, 7	; 14
     77c:	fe cf       	rjmp	.-4      	; 0x77a <send_lcd+0xa>
  SPDR = byte;                        //send payload
     77e:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     780:	77 9b       	sbis	0x0e, 7	; 14
     782:	fe cf       	rjmp	.-4      	; 0x780 <send_lcd+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     784:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     788:	88 60       	ori	r24, 0x08	; 8
     78a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     78e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     792:	87 7f       	andi	r24, 0xF7	; 247
     794:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     798:	08 95       	ret

0000079a <refresh_lcd>:
//
void refresh_lcd(char lcd_string_array[]) {

  static uint8_t i=0;           // index into string array 

 send_lcd(CHAR_BYTE,lcd_string_array[i]);
     79a:	20 91 53 01 	lds	r18, 0x0153	; 0x800153 <i.2095>
     79e:	82 0f       	add	r24, r18
     7a0:	91 1d       	adc	r25, r1
     7a2:	fc 01       	movw	r30, r24
     7a4:	80 81       	ld	r24, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     7a6:	91 e0       	ldi	r25, 0x01	; 1
     7a8:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     7aa:	77 9b       	sbis	0x0e, 7	; 14
     7ac:	fe cf       	rjmp	.-4      	; 0x7aa <refresh_lcd+0x10>
  SPDR = byte;                        //send payload
     7ae:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     7b0:	77 9b       	sbis	0x0e, 7	; 14
     7b2:	fe cf       	rjmp	.-4      	; 0x7b0 <refresh_lcd+0x16>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     7b4:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     7b8:	88 60       	ori	r24, 0x08	; 8
     7ba:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     7be:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     7c2:	87 7f       	andi	r24, 0xF7	; 247
     7c4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
void refresh_lcd(char lcd_string_array[]) {

  static uint8_t i=0;           // index into string array 

 send_lcd(CHAR_BYTE,lcd_string_array[i]);
 i++;   //increment to next character
     7c8:	80 91 53 01 	lds	r24, 0x0153	; 0x800153 <i.2095>
     7cc:	8f 5f       	subi	r24, 0xFF	; 255
     7ce:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <i.2095>
 //delays are inserted to allow character to be written before moving
 //the cursor to the next line.
 if(i == 16){_delay_us(40); line2_col1();      } //goto line 2, 1st char 
     7d2:	80 31       	cpi	r24, 0x10	; 16
     7d4:	f9 f0       	breq	.+62     	; 0x814 <refresh_lcd+0x7a>
 if(i == 32){_delay_us(40); line1_col1(); i=0; } //goto line 1, 1st char 
     7d6:	80 32       	cpi	r24, 0x20	; 32
     7d8:	09 f0       	breq	.+2      	; 0x7dc <refresh_lcd+0x42>
     7da:	08 95       	ret
     7dc:	e5 ed       	ldi	r30, 0xD5	; 213
     7de:	ea 95       	dec	r30
     7e0:	f1 f7       	brne	.-4      	; 0x7de <refresh_lcd+0x44>
     7e2:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     7e4:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     7e6:	77 9b       	sbis	0x0e, 7	; 14
     7e8:	fe cf       	rjmp	.-4      	; 0x7e6 <refresh_lcd+0x4c>
  SPDR = byte;                        //send payload
     7ea:	80 e8       	ldi	r24, 0x80	; 128
     7ec:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     7ee:	77 9b       	sbis	0x0e, 7	; 14
     7f0:	fe cf       	rjmp	.-4      	; 0x7ee <refresh_lcd+0x54>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     7f2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     7f6:	88 60       	ori	r24, 0x08	; 8
     7f8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     7fc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     800:	87 7f       	andi	r24, 0xF7	; 247
     802:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     806:	f5 ed       	ldi	r31, 0xD5	; 213
     808:	fa 95       	dec	r31
     80a:	f1 f7       	brne	.-4      	; 0x808 <refresh_lcd+0x6e>
     80c:	00 00       	nop
 send_lcd(CHAR_BYTE,lcd_string_array[i]);
 i++;   //increment to next character
 //delays are inserted to allow character to be written before moving
 //the cursor to the next line.
 if(i == 16){_delay_us(40); line2_col1();      } //goto line 2, 1st char 
 if(i == 32){_delay_us(40); line1_col1(); i=0; } //goto line 1, 1st char 
     80e:	10 92 53 01 	sts	0x0153, r1	; 0x800153 <i.2095>
     812:	08 95       	ret
     814:	f5 ed       	ldi	r31, 0xD5	; 213
     816:	fa 95       	dec	r31
     818:	f1 f7       	brne	.-4      	; 0x816 <refresh_lcd+0x7c>
     81a:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     81c:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     81e:	77 9b       	sbis	0x0e, 7	; 14
     820:	fe cf       	rjmp	.-4      	; 0x81e <refresh_lcd+0x84>
  SPDR = byte;                        //send payload
     822:	80 ec       	ldi	r24, 0xC0	; 192
     824:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     826:	77 9b       	sbis	0x0e, 7	; 14
     828:	fe cf       	rjmp	.-4      	; 0x826 <refresh_lcd+0x8c>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     82a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     82e:	88 60       	ori	r24, 0x08	; 8
     830:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     834:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     838:	87 7f       	andi	r24, 0xF7	; 247
     83a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     83e:	85 ed       	ldi	r24, 0xD5	; 213
     840:	8a 95       	dec	r24
     842:	f1 f7       	brne	.-4      	; 0x840 <refresh_lcd+0xa6>
     844:	00 00       	nop
     846:	80 91 53 01 	lds	r24, 0x0153	; 0x800153 <i.2095>
     84a:	c5 cf       	rjmp	.-118    	; 0x7d6 <refresh_lcd+0x3c>

0000084c <set_custom_character>:
//address, such as send_lcd(CHAR_BYTE, 0x01, 1) or it can be insteretd into a string 
//via a forward slash escape as in string2lcd("this is my music note \1")

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
     84c:	66 0f       	add	r22, r22
     84e:	66 0f       	add	r22, r22
     850:	66 0f       	add	r22, r22
     852:	60 5c       	subi	r22, 0xC0	; 192
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     854:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     856:	77 9b       	sbis	0x0e, 7	; 14
     858:	fe cf       	rjmp	.-4      	; 0x856 <set_custom_character+0xa>
  SPDR = byte;                        //send payload
     85a:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     85c:	77 9b       	sbis	0x0e, 7	; 14
     85e:	fe cf       	rjmp	.-4      	; 0x85c <set_custom_character+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     860:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     864:	28 60       	ori	r18, 0x08	; 8
     866:	20 93 62 00 	sts	0x0062, r18	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     86a:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     86e:	27 7f       	andi	r18, 0xF7	; 247
     870:	20 93 62 00 	sts	0x0062, r18	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     874:	25 ed       	ldi	r18, 0xD5	; 213
     876:	2a 95       	dec	r18
     878:	f1 f7       	brne	.-4      	; 0x876 <set_custom_character+0x2a>
     87a:	00 00       	nop
     87c:	fc 01       	movw	r30, r24
     87e:	9c 01       	movw	r18, r24
     880:	28 5f       	subi	r18, 0xF8	; 248
     882:	3f 4f       	sbci	r19, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     884:	91 e0       	ldi	r25, 0x01	; 1

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
    for(i=0; i<8; i++){
      send_lcd(CHAR_BYTE, data[i]); _delay_us(40); //each char byte takes 37us to execute
     886:	81 91       	ld	r24, Z+
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     888:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     88a:	77 9b       	sbis	0x0e, 7	; 14
     88c:	fe cf       	rjmp	.-4      	; 0x88a <set_custom_character+0x3e>
  SPDR = byte;                        //send payload
     88e:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     890:	77 9b       	sbis	0x0e, 7	; 14
     892:	fe cf       	rjmp	.-4      	; 0x890 <set_custom_character+0x44>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     894:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     898:	88 60       	ori	r24, 0x08	; 8
     89a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     89e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8a2:	87 7f       	andi	r24, 0xF7	; 247
     8a4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8a8:	85 ed       	ldi	r24, 0xD5	; 213
     8aa:	8a 95       	dec	r24
     8ac:	f1 f7       	brne	.-4      	; 0x8aa <set_custom_character+0x5e>
     8ae:	00 00       	nop
//via a forward slash escape as in string2lcd("this is my music note \1")

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
    for(i=0; i<8; i++){
     8b0:	e2 17       	cp	r30, r18
     8b2:	f3 07       	cpc	r31, r19
     8b4:	41 f7       	brne	.-48     	; 0x886 <set_custom_character+0x3a>
      send_lcd(CHAR_BYTE, data[i]); _delay_us(40); //each char byte takes 37us to execute
    }
}
     8b6:	08 95       	ret

000008b8 <set_cursor>:
//                          set_cursor 
//
//Sets the cursor to an arbitrary potition on the screen, row is either 1 or 2
//col is a number form 0-15, counting from left to right
void set_cursor(uint8_t row, uint8_t col){
    send_lcd(CMD_BYTE, 0x80 + col + ((row-1)*0x40));
     8b8:	90 e4       	ldi	r25, 0x40	; 64
     8ba:	89 9f       	mul	r24, r25
     8bc:	60 0d       	add	r22, r0
     8be:	11 24       	eor	r1, r1
     8c0:	60 5c       	subi	r22, 0xC0	; 192
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     8c2:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     8c4:	77 9b       	sbis	0x0e, 7	; 14
     8c6:	fe cf       	rjmp	.-4      	; 0x8c4 <set_cursor+0xc>
  SPDR = byte;                        //send payload
     8c8:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     8ca:	77 9b       	sbis	0x0e, 7	; 14
     8cc:	fe cf       	rjmp	.-4      	; 0x8ca <set_cursor+0x12>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     8ce:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8d2:	88 60       	ori	r24, 0x08	; 8
     8d4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8d8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8dc:	87 7f       	andi	r24, 0xF7	; 247
     8de:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8e2:	08 95       	ret

000008e4 <uint2lcd>:
//not displayed.  
//TODO: optimize by removing the mod operators
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
     8e4:	81 11       	cpse	r24, r1
     8e6:	13 c0       	rjmp	.+38     	; 0x90e <uint2lcd+0x2a>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     8e8:	81 e0       	ldi	r24, 0x01	; 1
     8ea:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     8ec:	77 9b       	sbis	0x0e, 7	; 14
     8ee:	fe cf       	rjmp	.-4      	; 0x8ec <uint2lcd+0x8>
  SPDR = byte;                        //send payload
     8f0:	80 e3       	ldi	r24, 0x30	; 48
     8f2:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     8f4:	77 9b       	sbis	0x0e, 7	; 14
     8f6:	fe cf       	rjmp	.-4      	; 0x8f4 <uint2lcd+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     8f8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8fc:	88 60       	ori	r24, 0x08	; 8
     8fe:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     902:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     906:	87 7f       	andi	r24, 0xF7	; 247
     908:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     90c:	08 95       	ret
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
     90e:	84 36       	cpi	r24, 0x64	; 100
     910:	b0 f4       	brcc	.+44     	; 0x93e <uint2lcd+0x5a>
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
     912:	8a 30       	cpi	r24, 0x0A	; 10
     914:	60 f5       	brcc	.+88     	; 0x96e <uint2lcd+0x8a>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     916:	91 e0       	ldi	r25, 0x01	; 1
     918:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     91a:	77 9b       	sbis	0x0e, 7	; 14
     91c:	fe cf       	rjmp	.-4      	; 0x91a <uint2lcd+0x36>
void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
      if(number >= 1)  {send_lcd(CHAR_BYTE, 0x30+(number%10)    ); }
     91e:	9d ec       	ldi	r25, 0xCD	; 205
     920:	89 9f       	mul	r24, r25
     922:	91 2d       	mov	r25, r1
     924:	11 24       	eor	r1, r1
     926:	96 95       	lsr	r25
     928:	96 95       	lsr	r25
     92a:	96 95       	lsr	r25
     92c:	2a e0       	ldi	r18, 0x0A	; 10
     92e:	92 9f       	mul	r25, r18
     930:	80 19       	sub	r24, r0
     932:	11 24       	eor	r1, r1
     934:	80 5d       	subi	r24, 0xD0	; 208
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
  SPDR = byte;                        //send payload
     936:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     938:	77 9b       	sbis	0x0e, 7	; 14
     93a:	fe cf       	rjmp	.-4      	; 0x938 <uint2lcd+0x54>
     93c:	dd cf       	rjmp	.-70     	; 0x8f8 <uint2lcd+0x14>
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
     93e:	99 e2       	ldi	r25, 0x29	; 41
     940:	89 9f       	mul	r24, r25
     942:	91 2d       	mov	r25, r1
     944:	11 24       	eor	r1, r1
     946:	92 95       	swap	r25
     948:	9f 70       	andi	r25, 0x0F	; 15
     94a:	90 5d       	subi	r25, 0xD0	; 208
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     94c:	21 e0       	ldi	r18, 0x01	; 1
     94e:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     950:	77 9b       	sbis	0x0e, 7	; 14
     952:	fe cf       	rjmp	.-4      	; 0x950 <uint2lcd+0x6c>
  SPDR = byte;                        //send payload
     954:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     956:	77 9b       	sbis	0x0e, 7	; 14
     958:	fe cf       	rjmp	.-4      	; 0x956 <uint2lcd+0x72>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     95a:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     95e:	98 60       	ori	r25, 0x08	; 8
     960:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     964:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     968:	97 7f       	andi	r25, 0xF7	; 247
     96a:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
     96e:	99 e2       	ldi	r25, 0x29	; 41
     970:	89 9f       	mul	r24, r25
     972:	91 2d       	mov	r25, r1
     974:	11 24       	eor	r1, r1
     976:	92 95       	swap	r25
     978:	9f 70       	andi	r25, 0x0F	; 15
     97a:	38 2f       	mov	r19, r24
     97c:	24 e6       	ldi	r18, 0x64	; 100
     97e:	92 9f       	mul	r25, r18
     980:	30 19       	sub	r19, r0
     982:	11 24       	eor	r1, r1
     984:	2d ec       	ldi	r18, 0xCD	; 205
     986:	32 9f       	mul	r19, r18
     988:	91 2d       	mov	r25, r1
     98a:	11 24       	eor	r1, r1
     98c:	96 95       	lsr	r25
     98e:	96 95       	lsr	r25
     990:	96 95       	lsr	r25
     992:	90 5d       	subi	r25, 0xD0	; 208
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     994:	21 e0       	ldi	r18, 0x01	; 1
     996:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     998:	77 9b       	sbis	0x0e, 7	; 14
     99a:	fe cf       	rjmp	.-4      	; 0x998 <uint2lcd+0xb4>
  SPDR = byte;                        //send payload
     99c:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     99e:	77 9b       	sbis	0x0e, 7	; 14
     9a0:	fe cf       	rjmp	.-4      	; 0x99e <uint2lcd+0xba>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     9a2:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9a6:	98 60       	ori	r25, 0x08	; 8
     9a8:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9ac:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9b0:	97 7f       	andi	r25, 0xF7	; 247
     9b2:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9b6:	af cf       	rjmp	.-162    	; 0x916 <uint2lcd+0x32>

000009b8 <int2lcd>:
//Takes a 8bit signed and displays it in base ten on the LCD. Leading 0's are 
//not displayed.
//
void int2lcd(int8_t number){
    //if < 0, print minus sign, then take 2's complement of number and display
    if(number < 0){send_lcd(CHAR_BYTE, '-'); _delay_us(40); uint2lcd(~number+1);}  
     9b8:	87 ff       	sbrs	r24, 7
    else          {uint2lcd(number);                                            }
     9ba:	0c 94 72 04 	jmp	0x8e4	; 0x8e4 <uint2lcd>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     9be:	91 e0       	ldi	r25, 0x01	; 1
     9c0:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     9c2:	77 9b       	sbis	0x0e, 7	; 14
     9c4:	fe cf       	rjmp	.-4      	; 0x9c2 <int2lcd+0xa>
  SPDR = byte;                        //send payload
     9c6:	9d e2       	ldi	r25, 0x2D	; 45
     9c8:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     9ca:	77 9b       	sbis	0x0e, 7	; 14
     9cc:	fe cf       	rjmp	.-4      	; 0x9ca <int2lcd+0x12>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     9ce:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9d2:	98 60       	ori	r25, 0x08	; 8
     9d4:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9d8:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9dc:	97 7f       	andi	r25, 0xF7	; 247
     9de:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9e2:	95 ed       	ldi	r25, 0xD5	; 213
     9e4:	9a 95       	dec	r25
     9e6:	f1 f7       	brne	.-4      	; 0x9e4 <int2lcd+0x2c>
     9e8:	00 00       	nop
//Takes a 8bit signed and displays it in base ten on the LCD. Leading 0's are 
//not displayed.
//
void int2lcd(int8_t number){
    //if < 0, print minus sign, then take 2's complement of number and display
    if(number < 0){send_lcd(CHAR_BYTE, '-'); _delay_us(40); uint2lcd(~number+1);}  
     9ea:	81 95       	neg	r24
     9ec:	0c 94 72 04 	jmp	0x8e4	; 0x8e4 <uint2lcd>

000009f0 <cursor_on>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     9f0:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     9f2:	77 9b       	sbis	0x0e, 7	; 14
     9f4:	fe cf       	rjmp	.-4      	; 0x9f2 <cursor_on+0x2>
  SPDR = byte;                        //send payload
     9f6:	8e e0       	ldi	r24, 0x0E	; 14
     9f8:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     9fa:	77 9b       	sbis	0x0e, 7	; 14
     9fc:	fe cf       	rjmp	.-4      	; 0x9fa <cursor_on+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     9fe:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a02:	88 60       	ori	r24, 0x08	; 8
     a04:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a08:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a0c:	87 7f       	andi	r24, 0xF7	; 247
     a0e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a12:	08 95       	ret

00000a14 <cursor_off>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     a14:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a16:	77 9b       	sbis	0x0e, 7	; 14
     a18:	fe cf       	rjmp	.-4      	; 0xa16 <cursor_off+0x2>
  SPDR = byte;                        //send payload
     a1a:	8c e0       	ldi	r24, 0x0C	; 12
     a1c:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a1e:	77 9b       	sbis	0x0e, 7	; 14
     a20:	fe cf       	rjmp	.-4      	; 0xa1e <cursor_off+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     a22:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a26:	88 60       	ori	r24, 0x08	; 8
     a28:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a2c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a30:	87 7f       	andi	r24, 0xF7	; 247
     a32:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a36:	08 95       	ret

00000a38 <shift_right>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     a38:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a3a:	77 9b       	sbis	0x0e, 7	; 14
     a3c:	fe cf       	rjmp	.-4      	; 0xa3a <shift_right+0x2>
  SPDR = byte;                        //send payload
     a3e:	8e e1       	ldi	r24, 0x1E	; 30
     a40:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a42:	77 9b       	sbis	0x0e, 7	; 14
     a44:	fe cf       	rjmp	.-4      	; 0xa42 <shift_right+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     a46:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a4a:	88 60       	ori	r24, 0x08	; 8
     a4c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a50:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a54:	87 7f       	andi	r24, 0xF7	; 247
     a56:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a5a:	08 95       	ret

00000a5c <shift_left>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     a5c:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a5e:	77 9b       	sbis	0x0e, 7	; 14
     a60:	fe cf       	rjmp	.-4      	; 0xa5e <shift_left+0x2>
  SPDR = byte;                        //send payload
     a62:	88 e1       	ldi	r24, 0x18	; 24
     a64:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a66:	77 9b       	sbis	0x0e, 7	; 14
     a68:	fe cf       	rjmp	.-4      	; 0xa66 <shift_left+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     a6a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a6e:	88 60       	ori	r24, 0x08	; 8
     a70:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a74:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a78:	87 7f       	andi	r24, 0xF7	; 247
     a7a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a7e:	08 95       	ret

00000a80 <strobe_lcd>:
     a80:	e2 e6       	ldi	r30, 0x62	; 98
     a82:	f0 e0       	ldi	r31, 0x00	; 0
     a84:	80 81       	ld	r24, Z
     a86:	88 60       	ori	r24, 0x08	; 8
     a88:	80 83       	st	Z, r24
     a8a:	80 81       	ld	r24, Z
     a8c:	87 7f       	andi	r24, 0xF7	; 247
     a8e:	80 83       	st	Z, r24
     a90:	08 95       	ret

00000a92 <clear_display>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     a92:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a94:	77 9b       	sbis	0x0e, 7	; 14
     a96:	fe cf       	rjmp	.-4      	; 0xa94 <clear_display+0x2>
  SPDR = byte;                        //send payload
     a98:	81 e0       	ldi	r24, 0x01	; 1
     a9a:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a9c:	77 9b       	sbis	0x0e, 7	; 14
     a9e:	fe cf       	rjmp	.-4      	; 0xa9c <clear_display+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     aa0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     aa4:	88 60       	ori	r24, 0x08	; 8
     aa6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     aaa:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     aae:	87 7f       	andi	r24, 0xF7	; 247
     ab0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ab4:	8f e1       	ldi	r24, 0x1F	; 31
     ab6:	9c e1       	ldi	r25, 0x1C	; 28
     ab8:	01 97       	sbiw	r24, 0x01	; 1
     aba:	f1 f7       	brne	.-4      	; 0xab8 <clear_display+0x26>
     abc:	00 c0       	rjmp	.+0      	; 0xabe <clear_display+0x2c>
     abe:	00 00       	nop
     ac0:	08 95       	ret

00000ac2 <cursor_home>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ac2:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ac4:	77 9b       	sbis	0x0e, 7	; 14
     ac6:	fe cf       	rjmp	.-4      	; 0xac4 <cursor_home+0x2>
  SPDR = byte;                        //send payload
     ac8:	82 e0       	ldi	r24, 0x02	; 2
     aca:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     acc:	77 9b       	sbis	0x0e, 7	; 14
     ace:	fe cf       	rjmp	.-4      	; 0xacc <cursor_home+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     ad0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ad4:	88 60       	ori	r24, 0x08	; 8
     ad6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ada:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ade:	87 7f       	andi	r24, 0xF7	; 247
     ae0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ae4:	8f e6       	ldi	r24, 0x6F	; 111
     ae6:	97 e1       	ldi	r25, 0x17	; 23
     ae8:	01 97       	sbiw	r24, 0x01	; 1
     aea:	f1 f7       	brne	.-4      	; 0xae8 <cursor_home+0x26>
     aec:	00 c0       	rjmp	.+0      	; 0xaee <cursor_home+0x2c>
     aee:	00 00       	nop
     af0:	08 95       	ret

00000af2 <line2_col1>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     af2:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     af4:	77 9b       	sbis	0x0e, 7	; 14
     af6:	fe cf       	rjmp	.-4      	; 0xaf4 <line2_col1+0x2>
  SPDR = byte;                        //send payload
     af8:	80 ec       	ldi	r24, 0xC0	; 192
     afa:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     afc:	77 9b       	sbis	0x0e, 7	; 14
     afe:	fe cf       	rjmp	.-4      	; 0xafc <line2_col1+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b00:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b04:	88 60       	ori	r24, 0x08	; 8
     b06:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b0a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b0e:	87 7f       	andi	r24, 0xF7	; 247
     b10:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b14:	85 ed       	ldi	r24, 0xD5	; 213
     b16:	8a 95       	dec	r24
     b18:	f1 f7       	brne	.-4      	; 0xb16 <line2_col1+0x24>
     b1a:	00 00       	nop
     b1c:	08 95       	ret

00000b1e <line1_col1>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b1e:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b20:	77 9b       	sbis	0x0e, 7	; 14
     b22:	fe cf       	rjmp	.-4      	; 0xb20 <line1_col1+0x2>
  SPDR = byte;                        //send payload
     b24:	80 e8       	ldi	r24, 0x80	; 128
     b26:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b28:	77 9b       	sbis	0x0e, 7	; 14
     b2a:	fe cf       	rjmp	.-4      	; 0xb28 <line1_col1+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b2c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b30:	88 60       	ori	r24, 0x08	; 8
     b32:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b36:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b3a:	87 7f       	andi	r24, 0xF7	; 247
     b3c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b40:	85 ed       	ldi	r24, 0xD5	; 213
     b42:	8a 95       	dec	r24
     b44:	f1 f7       	brne	.-4      	; 0xb42 <line1_col1+0x24>
     b46:	00 00       	nop
     b48:	08 95       	ret

00000b4a <fill_spaces>:

//-----------------------------------------------------------------------------
//                          fill_spaces   
//
//Fill an entire line with spaces.
void fill_spaces(void){
     b4a:	90 e1       	ldi	r25, 0x10	; 16
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b4c:	31 e0       	ldi	r19, 0x01	; 1
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
  SPDR = byte;                        //send payload
     b4e:	20 e2       	ldi	r18, 0x20	; 32
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b50:	3f b9       	out	0x0f, r19	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b52:	77 9b       	sbis	0x0e, 7	; 14
     b54:	fe cf       	rjmp	.-4      	; 0xb52 <fill_spaces+0x8>
  SPDR = byte;                        //send payload
     b56:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b58:	77 9b       	sbis	0x0e, 7	; 14
     b5a:	fe cf       	rjmp	.-4      	; 0xb58 <fill_spaces+0xe>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b5c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b60:	88 60       	ori	r24, 0x08	; 8
     b62:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b66:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b6a:	87 7f       	andi	r24, 0xF7	; 247
     b6c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b70:	85 ed       	ldi	r24, 0xD5	; 213
     b72:	8a 95       	dec	r24
     b74:	f1 f7       	brne	.-4      	; 0xb72 <fill_spaces+0x28>
     b76:	00 00       	nop
     b78:	91 50       	subi	r25, 0x01	; 1
//                          fill_spaces   
//
//Fill an entire line with spaces.
void fill_spaces(void){
	uint8_t i;
	for (i=0; i<=(NUM_LCD_CHARS-1); i++){
     b7a:	51 f7       	brne	.-44     	; 0xb50 <fill_spaces+0x6>
		send_lcd(CHAR_BYTE, ' '); 
                _delay_us(40);  //40us wait between characters
	}
}  
     b7c:	08 95       	ret

00000b7e <char2lcd>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b7e:	91 e0       	ldi	r25, 0x01	; 1
     b80:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b82:	77 9b       	sbis	0x0e, 7	; 14
     b84:	fe cf       	rjmp	.-4      	; 0xb82 <char2lcd+0x4>
  SPDR = byte;                        //send payload
     b86:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b88:	77 9b       	sbis	0x0e, 7	; 14
     b8a:	fe cf       	rjmp	.-4      	; 0xb88 <char2lcd+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b8c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b90:	88 60       	ori	r24, 0x08	; 8
     b92:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b96:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b9a:	87 7f       	andi	r24, 0xF7	; 247
     b9c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ba0:	08 95       	ret

00000ba2 <string2lcd>:

//----------------------------------------------------------------------------
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
     ba2:	fc 01       	movw	r30, r24
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     ba4:	40 e0       	ldi	r20, 0x00	; 0
     ba6:	50 e0       	ldi	r21, 0x00	; 0
     ba8:	60 e0       	ldi	r22, 0x00	; 0
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     baa:	71 e0       	ldi	r23, 0x01	; 1
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     bac:	df 01       	movw	r26, r30
     bae:	a4 0f       	add	r26, r20
     bb0:	b5 1f       	adc	r27, r21
     bb2:	8c 91       	ld	r24, X
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     bb4:	7f b9       	out	0x0f, r23	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     bb6:	77 9b       	sbis	0x0e, 7	; 14
     bb8:	fe cf       	rjmp	.-4      	; 0xbb6 <string2lcd+0x14>
  SPDR = byte;                        //send payload
     bba:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     bbc:	77 9b       	sbis	0x0e, 7	; 14
     bbe:	fe cf       	rjmp	.-4      	; 0xbbc <string2lcd+0x1a>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     bc0:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bc4:	98 60       	ori	r25, 0x08	; 8
     bc6:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bca:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bce:	97 7f       	andi	r25, 0xF7	; 247
     bd0:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bd4:	85 ed       	ldi	r24, 0xD5	; 213
     bd6:	8a 95       	dec	r24
     bd8:	f1 f7       	brne	.-4      	; 0xbd6 <string2lcd+0x34>
     bda:	00 00       	nop
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     bdc:	6f 5f       	subi	r22, 0xFF	; 255
     bde:	46 2f       	mov	r20, r22
     be0:	50 e0       	ldi	r21, 0x00	; 0
     be2:	df 01       	movw	r26, r30
     be4:	0d 90       	ld	r0, X+
     be6:	00 20       	and	r0, r0
     be8:	e9 f7       	brne	.-6      	; 0xbe4 <string2lcd+0x42>
     bea:	9d 01       	movw	r18, r26
     bec:	2e 1b       	sub	r18, r30
     bee:	3f 0b       	sbc	r19, r31
     bf0:	22 50       	subi	r18, 0x02	; 2
     bf2:	31 09       	sbc	r19, r1
     bf4:	24 17       	cp	r18, r20
     bf6:	35 07       	cpc	r19, r21
     bf8:	c8 f6       	brcc	.-78     	; 0xbac <string2lcd+0xa>
  _delay_us(40);  //execution takes 37us per character
  }                  
} 
     bfa:	08 95       	ret

00000bfc <lcd_init>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     bfc:	8f ef       	ldi	r24, 0xFF	; 255
     bfe:	99 ef       	ldi	r25, 0xF9	; 249
     c00:	01 97       	sbiw	r24, 0x01	; 1
     c02:	f1 f7       	brne	.-4      	; 0xc00 <lcd_init+0x4>
     c04:	00 c0       	rjmp	.+0      	; 0xc06 <lcd_init+0xa>
     c06:	00 00       	nop
//
void lcd_init(void){
  _delay_ms(16);      //power up delay
#if SPI_MODE==1       //assumption is that the SPI port is intialized
  //TODO: kludge alert! setting of DDRF should not be here, but is probably harmless.
  DDRF=0x08;          //port F bit 3 is enable for LCD in SPI mode
     c08:	88 e0       	ldi	r24, 0x08	; 8
     c0a:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c0e:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c10:	77 9b       	sbis	0x0e, 7	; 14
     c12:	fe cf       	rjmp	.-4      	; 0xc10 <lcd_init+0x14>
  SPDR = byte;                        //send payload
     c14:	80 e3       	ldi	r24, 0x30	; 48
     c16:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c18:	77 9b       	sbis	0x0e, 7	; 14
     c1a:	fe cf       	rjmp	.-4      	; 0xc18 <lcd_init+0x1c>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     c1c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c20:	88 60       	ori	r24, 0x08	; 8
     c22:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c26:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c2a:	87 7f       	andi	r24, 0xF7	; 247
     c2c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c30:	8f e5       	ldi	r24, 0x5F	; 95
     c32:	9d e6       	ldi	r25, 0x6D	; 109
     c34:	01 97       	sbiw	r24, 0x01	; 1
     c36:	f1 f7       	brne	.-4      	; 0xc34 <lcd_init+0x38>
     c38:	00 c0       	rjmp	.+0      	; 0xc3a <lcd_init+0x3e>
     c3a:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c3c:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c3e:	77 9b       	sbis	0x0e, 7	; 14
     c40:	fe cf       	rjmp	.-4      	; 0xc3e <lcd_init+0x42>
  SPDR = byte;                        //send payload
     c42:	80 e3       	ldi	r24, 0x30	; 48
     c44:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c46:	77 9b       	sbis	0x0e, 7	; 14
     c48:	fe cf       	rjmp	.-4      	; 0xc46 <lcd_init+0x4a>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     c4a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c4e:	88 60       	ori	r24, 0x08	; 8
     c50:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c54:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c58:	87 7f       	andi	r24, 0xF7	; 247
     c5a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c5e:	8f e5       	ldi	r24, 0x5F	; 95
     c60:	9d e6       	ldi	r25, 0x6D	; 109
     c62:	01 97       	sbiw	r24, 0x01	; 1
     c64:	f1 f7       	brne	.-4      	; 0xc62 <lcd_init+0x66>
     c66:	00 c0       	rjmp	.+0      	; 0xc68 <lcd_init+0x6c>
     c68:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c6a:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c6c:	77 9b       	sbis	0x0e, 7	; 14
     c6e:	fe cf       	rjmp	.-4      	; 0xc6c <lcd_init+0x70>
  SPDR = byte;                        //send payload
     c70:	80 e3       	ldi	r24, 0x30	; 48
     c72:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c74:	77 9b       	sbis	0x0e, 7	; 14
     c76:	fe cf       	rjmp	.-4      	; 0xc74 <lcd_init+0x78>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     c78:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c7c:	88 60       	ori	r24, 0x08	; 8
     c7e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c82:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c86:	87 7f       	andi	r24, 0xF7	; 247
     c88:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c8c:	8f e5       	ldi	r24, 0x5F	; 95
     c8e:	9d e6       	ldi	r25, 0x6D	; 109
     c90:	01 97       	sbiw	r24, 0x01	; 1
     c92:	f1 f7       	brne	.-4      	; 0xc90 <lcd_init+0x94>
     c94:	00 c0       	rjmp	.+0      	; 0xc96 <lcd_init+0x9a>
     c96:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c98:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c9a:	77 9b       	sbis	0x0e, 7	; 14
     c9c:	fe cf       	rjmp	.-4      	; 0xc9a <lcd_init+0x9e>
  SPDR = byte;                        //send payload
     c9e:	88 e3       	ldi	r24, 0x38	; 56
     ca0:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ca2:	77 9b       	sbis	0x0e, 7	; 14
     ca4:	fe cf       	rjmp	.-4      	; 0xca2 <lcd_init+0xa6>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     ca6:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     caa:	88 60       	ori	r24, 0x08	; 8
     cac:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cb0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cb4:	87 7f       	andi	r24, 0xF7	; 247
     cb6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cba:	8f e1       	ldi	r24, 0x1F	; 31
     cbc:	9e e4       	ldi	r25, 0x4E	; 78
     cbe:	01 97       	sbiw	r24, 0x01	; 1
     cc0:	f1 f7       	brne	.-4      	; 0xcbe <lcd_init+0xc2>
     cc2:	00 c0       	rjmp	.+0      	; 0xcc4 <lcd_init+0xc8>
     cc4:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     cc6:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     cc8:	77 9b       	sbis	0x0e, 7	; 14
     cca:	fe cf       	rjmp	.-4      	; 0xcc8 <lcd_init+0xcc>
  SPDR = byte;                        //send payload
     ccc:	88 e0       	ldi	r24, 0x08	; 8
     cce:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     cd0:	77 9b       	sbis	0x0e, 7	; 14
     cd2:	fe cf       	rjmp	.-4      	; 0xcd0 <lcd_init+0xd4>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     cd4:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cd8:	88 60       	ori	r24, 0x08	; 8
     cda:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cde:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ce2:	87 7f       	andi	r24, 0xF7	; 247
     ce4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ce8:	8f e1       	ldi	r24, 0x1F	; 31
     cea:	9e e4       	ldi	r25, 0x4E	; 78
     cec:	01 97       	sbiw	r24, 0x01	; 1
     cee:	f1 f7       	brne	.-4      	; 0xcec <lcd_init+0xf0>
     cf0:	00 c0       	rjmp	.+0      	; 0xcf2 <lcd_init+0xf6>
     cf2:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     cf4:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     cf6:	77 9b       	sbis	0x0e, 7	; 14
     cf8:	fe cf       	rjmp	.-4      	; 0xcf6 <lcd_init+0xfa>
  SPDR = byte;                        //send payload
     cfa:	81 e0       	ldi	r24, 0x01	; 1
     cfc:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     cfe:	77 9b       	sbis	0x0e, 7	; 14
     d00:	fe cf       	rjmp	.-4      	; 0xcfe <lcd_init+0x102>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d02:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d06:	88 60       	ori	r24, 0x08	; 8
     d08:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d0c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d10:	87 7f       	andi	r24, 0xF7	; 247
     d12:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d16:	8f e1       	ldi	r24, 0x1F	; 31
     d18:	9e e4       	ldi	r25, 0x4E	; 78
     d1a:	01 97       	sbiw	r24, 0x01	; 1
     d1c:	f1 f7       	brne	.-4      	; 0xd1a <lcd_init+0x11e>
     d1e:	00 c0       	rjmp	.+0      	; 0xd20 <lcd_init+0x124>
     d20:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d22:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d24:	77 9b       	sbis	0x0e, 7	; 14
     d26:	fe cf       	rjmp	.-4      	; 0xd24 <lcd_init+0x128>
  SPDR = byte;                        //send payload
     d28:	86 e0       	ldi	r24, 0x06	; 6
     d2a:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d2c:	77 9b       	sbis	0x0e, 7	; 14
     d2e:	fe cf       	rjmp	.-4      	; 0xd2c <lcd_init+0x130>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d30:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d34:	88 60       	ori	r24, 0x08	; 8
     d36:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d3a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d3e:	87 7f       	andi	r24, 0xF7	; 247
     d40:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d44:	8f e1       	ldi	r24, 0x1F	; 31
     d46:	9e e4       	ldi	r25, 0x4E	; 78
     d48:	01 97       	sbiw	r24, 0x01	; 1
     d4a:	f1 f7       	brne	.-4      	; 0xd48 <lcd_init+0x14c>
     d4c:	00 c0       	rjmp	.+0      	; 0xd4e <lcd_init+0x152>
     d4e:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d50:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d52:	77 9b       	sbis	0x0e, 7	; 14
     d54:	fe cf       	rjmp	.-4      	; 0xd52 <lcd_init+0x156>
  SPDR = byte;                        //send payload
     d56:	8c e0       	ldi	r24, 0x0C	; 12
     d58:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d5a:	77 9b       	sbis	0x0e, 7	; 14
     d5c:	fe cf       	rjmp	.-4      	; 0xd5a <lcd_init+0x15e>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d5e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d62:	88 60       	ori	r24, 0x08	; 8
     d64:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d68:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d6c:	87 7f       	andi	r24, 0xF7	; 247
     d6e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d72:	8f e1       	ldi	r24, 0x1F	; 31
     d74:	9e e4       	ldi	r25, 0x4E	; 78
     d76:	01 97       	sbiw	r24, 0x01	; 1
     d78:	f1 f7       	brne	.-4      	; 0xd76 <lcd_init+0x17a>
     d7a:	00 c0       	rjmp	.+0      	; 0xd7c <lcd_init+0x180>
     d7c:	00 00       	nop
     d7e:	08 95       	ret

00000d80 <lcd_int32>:
void  lcd_int32(int32_t l,          //number to display
                uint8_t fieldwidth, //width of the field for display
                uint8_t decpos,     //0 if no decimal point, otherwise
                uint8_t bSigned,    //non-zero if the number should be treated as signed 
                uint8_t bZeroFill)  //non-zero if a specified fieldwidth is to be zero filled
{
     d80:	4f 92       	push	r4
     d82:	5f 92       	push	r5
     d84:	6f 92       	push	r6
     d86:	7f 92       	push	r7
     d88:	8f 92       	push	r8
     d8a:	9f 92       	push	r9
     d8c:	af 92       	push	r10
     d8e:	bf 92       	push	r11
     d90:	cf 92       	push	r12
     d92:	df 92       	push	r13
     d94:	ef 92       	push	r14
     d96:	ff 92       	push	r15
     d98:	0f 93       	push	r16
     d9a:	1f 93       	push	r17
     d9c:	cf 93       	push	r28
     d9e:	df 93       	push	r29
     da0:	cd b7       	in	r28, 0x3d	; 61
     da2:	de b7       	in	r29, 0x3e	; 62
     da4:	69 97       	sbiw	r28, 0x19	; 25
     da6:	0f b6       	in	r0, 0x3f	; 63
     da8:	f8 94       	cli
     daa:	de bf       	out	0x3e, r29	; 62
     dac:	0f be       	out	0x3f, r0	; 63
     dae:	cd bf       	out	0x3d, r28	; 61
     db0:	14 2f       	mov	r17, r20
     db2:	42 2e       	mov	r4, r18
     db4:	5e 2c       	mov	r5, r14
      char    fillch;
      ldiv_t  qr;

      qr.quot = l; // initialize the quotient 

      if (bSigned){
     db6:	00 23       	and	r16, r16
     db8:	79 f0       	breq	.+30     	; 0xdd8 <lcd_int32+0x58>
        bSigned = (qr.quot<0);
     dba:	6b 01       	movw	r12, r22
     dbc:	7c 01       	movw	r14, r24
     dbe:	cc 24       	eor	r12, r12
     dc0:	f7 fc       	sbrc	r15, 7
     dc2:	c3 94       	inc	r12
     dc4:	dd 24       	eor	r13, r13
     dc6:	ee 24       	eor	r14, r14
     dc8:	ff 24       	eor	r15, r15
     dca:	0c 2d       	mov	r16, r12
        qr.quot = labs(qr.quot);
     dcc:	6b 01       	movw	r12, r22
     dce:	7c 01       	movw	r14, r24
     dd0:	97 fd       	sbrc	r25, 7
     dd2:	a3 c0       	rjmp	.+326    	; 0xf1a <lcd_int32+0x19a>
     dd4:	c7 01       	movw	r24, r14
     dd6:	b6 01       	movw	r22, r12
      }

      // convert the digits to the right of the decimal point 
      if (decpos){
     dd8:	44 20       	and	r4, r4
     dda:	09 f4       	brne	.+2      	; 0xdde <lcd_int32+0x5e>
     ddc:	96 c0       	rjmp	.+300    	; 0xf0a <lcd_int32+0x18a>
     dde:	9e 01       	movw	r18, r28
     de0:	2f 5f       	subi	r18, 0xFF	; 255
     de2:	3f 4f       	sbci	r19, 0xFF	; 255
     de4:	59 01       	movw	r10, r18
     de6:	49 01       	movw	r8, r18
     de8:	66 24       	eor	r6, r6
     dea:	6a 94       	dec	r6
     dec:	64 0c       	add	r6, r4
     dee:	71 2c       	mov	r7, r1
     df0:	3f ef       	ldi	r19, 0xFF	; 255
     df2:	63 1a       	sub	r6, r19
     df4:	73 0a       	sbc	r7, r19
     df6:	6a 0c       	add	r6, r10
     df8:	7b 1c       	adc	r7, r11
        for (; decpos ; decpos--){
          qr = ldiv(qr.quot, 10);
     dfa:	2a e0       	ldi	r18, 0x0A	; 10
     dfc:	30 e0       	ldi	r19, 0x00	; 0
     dfe:	40 e0       	ldi	r20, 0x00	; 0
     e00:	50 e0       	ldi	r21, 0x00	; 0
     e02:	0e 94 b7 08 	call	0x116e	; 0x116e <__divmodsi4>
     e06:	e6 2f       	mov	r30, r22
     e08:	2a 8b       	std	Y+18, r18	; 0x12
     e0a:	3b 8b       	std	Y+19, r19	; 0x13
     e0c:	4c 8b       	std	Y+20, r20	; 0x14
     e0e:	5d 8b       	std	Y+21, r21	; 0x15
     e10:	6a 89       	ldd	r22, Y+18	; 0x12
     e12:	7b 89       	ldd	r23, Y+19	; 0x13
     e14:	8c 89       	ldd	r24, Y+20	; 0x14
     e16:	9d 89       	ldd	r25, Y+21	; 0x15
          sline[i++] = qr.rem + '0';
     e18:	20 e3       	ldi	r18, 0x30	; 48
     e1a:	2e 0f       	add	r18, r30
     e1c:	f4 01       	movw	r30, r8
     e1e:	21 93       	st	Z+, r18
     e20:	4f 01       	movw	r8, r30
        qr.quot = labs(qr.quot);
      }

      // convert the digits to the right of the decimal point 
      if (decpos){
        for (; decpos ; decpos--){
     e22:	6e 16       	cp	r6, r30
     e24:	7f 06       	cpc	r7, r31
     e26:	49 f7       	brne	.-46     	; 0xdfa <lcd_int32+0x7a>
          qr = ldiv(qr.quot, 10);
          sline[i++] = qr.rem + '0';
        }
        sline[i++] = '.';
     e28:	99 24       	eor	r9, r9
     e2a:	93 94       	inc	r9
     e2c:	94 0c       	add	r9, r4
     e2e:	f5 01       	movw	r30, r10
     e30:	e4 0d       	add	r30, r4
     e32:	f1 1d       	adc	r31, r1
     e34:	2e e2       	ldi	r18, 0x2E	; 46
     e36:	20 83       	st	Z, r18
      }

      // convert the digits to the left of the decimal point 
      do{
          qr = ldiv(qr.quot, 10);
     e38:	2a e0       	ldi	r18, 0x0A	; 10
     e3a:	30 e0       	ldi	r19, 0x00	; 0
     e3c:	40 e0       	ldi	r20, 0x00	; 0
     e3e:	50 e0       	ldi	r21, 0x00	; 0
     e40:	0e 94 b7 08 	call	0x116e	; 0x116e <__divmodsi4>
     e44:	e6 2f       	mov	r30, r22
     e46:	2a 8b       	std	Y+18, r18	; 0x12
     e48:	3b 8b       	std	Y+19, r19	; 0x13
     e4a:	4c 8b       	std	Y+20, r20	; 0x14
     e4c:	5d 8b       	std	Y+21, r21	; 0x15
     e4e:	6e 8b       	std	Y+22, r22	; 0x16
     e50:	7f 8b       	std	Y+23, r23	; 0x17
     e52:	88 8f       	std	Y+24, r24	; 0x18
     e54:	99 8f       	std	Y+25, r25	; 0x19
     e56:	6a 89       	ldd	r22, Y+18	; 0x12
     e58:	7b 89       	ldd	r23, Y+19	; 0x13
     e5a:	8c 89       	ldd	r24, Y+20	; 0x14
     e5c:	9d 89       	ldd	r25, Y+21	; 0x15
          sline[i++] = qr.rem + '0';
     e5e:	31 e0       	ldi	r19, 0x01	; 1
     e60:	39 0d       	add	r19, r9
     e62:	d5 01       	movw	r26, r10
     e64:	a9 0d       	add	r26, r9
     e66:	b1 1d       	adc	r27, r1
     e68:	e0 5d       	subi	r30, 0xD0	; 208
     e6a:	ec 93       	st	X, r30
     e6c:	93 2e       	mov	r9, r19
        }while(qr.quot);
     e6e:	61 15       	cp	r22, r1
     e70:	71 05       	cpc	r23, r1
     e72:	81 05       	cpc	r24, r1
     e74:	91 05       	cpc	r25, r1
     e76:	01 f7       	brne	.-64     	; 0xe38 <lcd_int32+0xb8>

      // fill the whole field if a width was specified
      if (fieldwidth){
     e78:	11 23       	and	r17, r17
     e7a:	61 f0       	breq	.+24     	; 0xe94 <lcd_int32+0x114>
        fillch = bZeroFill? '0': ' '; // determine the fill character
     e7c:	51 10       	cpse	r5, r1
     e7e:	4b c0       	rjmp	.+150    	; 0xf16 <lcd_int32+0x196>
     e80:	90 e2       	ldi	r25, 0x20	; 32
        for (; i<fieldwidth ; ){sline[i++] = fillch;}
     e82:	31 17       	cp	r19, r17
     e84:	38 f4       	brcc	.+14     	; 0xe94 <lcd_int32+0x114>
     e86:	f5 01       	movw	r30, r10
     e88:	e3 0f       	add	r30, r19
     e8a:	f1 1d       	adc	r31, r1
     e8c:	90 83       	st	Z, r25
     e8e:	3f 5f       	subi	r19, 0xFF	; 255
     e90:	13 13       	cpse	r17, r19
     e92:	f9 cf       	rjmp	.-14     	; 0xe86 <lcd_int32+0x106>
      }

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}
     e94:	00 23       	and	r16, r16
     e96:	31 f0       	breq	.+12     	; 0xea4 <lcd_int32+0x124>
     e98:	f5 01       	movw	r30, r10
     e9a:	e3 0f       	add	r30, r19
     e9c:	f1 1d       	adc	r31, r1
     e9e:	9d e2       	ldi	r25, 0x2D	; 45
     ea0:	90 83       	st	Z, r25
     ea2:	3f 5f       	subi	r19, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ea4:	21 e0       	ldi	r18, 0x01	; 1

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}

      // now output the formatted number
      do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
     ea6:	31 50       	subi	r19, 0x01	; 1
     ea8:	f5 01       	movw	r30, r10
     eaa:	e3 0f       	add	r30, r19
     eac:	f1 1d       	adc	r31, r1
     eae:	90 81       	ld	r25, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     eb0:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     eb2:	77 9b       	sbis	0x0e, 7	; 14
     eb4:	fe cf       	rjmp	.-4      	; 0xeb2 <lcd_int32+0x132>
  SPDR = byte;                        //send payload
     eb6:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     eb8:	77 9b       	sbis	0x0e, 7	; 14
     eba:	fe cf       	rjmp	.-4      	; 0xeb8 <lcd_int32+0x138>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     ebc:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ec0:	98 60       	ori	r25, 0x08	; 8
     ec2:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ec6:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     eca:	97 7f       	andi	r25, 0xF7	; 247
     ecc:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     ed0:	85 ed       	ldi	r24, 0xD5	; 213
     ed2:	8a 95       	dec	r24
     ed4:	f1 f7       	brne	.-4      	; 0xed2 <lcd_int32+0x152>
     ed6:	00 00       	nop

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}

      // now output the formatted number
      do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
     ed8:	31 11       	cpse	r19, r1
     eda:	e5 cf       	rjmp	.-54     	; 0xea6 <lcd_int32+0x126>

}
     edc:	69 96       	adiw	r28, 0x19	; 25
     ede:	0f b6       	in	r0, 0x3f	; 63
     ee0:	f8 94       	cli
     ee2:	de bf       	out	0x3e, r29	; 62
     ee4:	0f be       	out	0x3f, r0	; 63
     ee6:	cd bf       	out	0x3d, r28	; 61
     ee8:	df 91       	pop	r29
     eea:	cf 91       	pop	r28
     eec:	1f 91       	pop	r17
     eee:	0f 91       	pop	r16
     ef0:	ff 90       	pop	r15
     ef2:	ef 90       	pop	r14
     ef4:	df 90       	pop	r13
     ef6:	cf 90       	pop	r12
     ef8:	bf 90       	pop	r11
     efa:	af 90       	pop	r10
     efc:	9f 90       	pop	r9
     efe:	8f 90       	pop	r8
     f00:	7f 90       	pop	r7
     f02:	6f 90       	pop	r6
     f04:	5f 90       	pop	r5
     f06:	4f 90       	pop	r4
     f08:	08 95       	ret
                uint8_t decpos,     //0 if no decimal point, otherwise
                uint8_t bSigned,    //non-zero if the number should be treated as signed 
                uint8_t bZeroFill)  //non-zero if a specified fieldwidth is to be zero filled
{
      char    sline[NUM_LCD_CHARS+1];
      uint8_t i=0;
     f0a:	91 2c       	mov	r9, r1
     f0c:	9e 01       	movw	r18, r28
     f0e:	2f 5f       	subi	r18, 0xFF	; 255
     f10:	3f 4f       	sbci	r19, 0xFF	; 255
     f12:	59 01       	movw	r10, r18
     f14:	91 cf       	rjmp	.-222    	; 0xe38 <lcd_int32+0xb8>
          sline[i++] = qr.rem + '0';
        }while(qr.quot);

      // fill the whole field if a width was specified
      if (fieldwidth){
        fillch = bZeroFill? '0': ' '; // determine the fill character
     f16:	90 e3       	ldi	r25, 0x30	; 48
     f18:	b4 cf       	rjmp	.-152    	; 0xe82 <lcd_int32+0x102>

      qr.quot = l; // initialize the quotient 

      if (bSigned){
        bSigned = (qr.quot<0);
        qr.quot = labs(qr.quot);
     f1a:	f0 94       	com	r15
     f1c:	e0 94       	com	r14
     f1e:	d0 94       	com	r13
     f20:	c0 94       	com	r12
     f22:	c1 1c       	adc	r12, r1
     f24:	d1 1c       	adc	r13, r1
     f26:	e1 1c       	adc	r14, r1
     f28:	f1 1c       	adc	r15, r1
     f2a:	54 cf       	rjmp	.-344    	; 0xdd4 <lcd_int32+0x54>

00000f2c <lcd_int16>:
void    lcd_int16(int16_t l, 
                  uint8_t fieldwidth, 
                  uint8_t decpos, 
                  uint8_t bSigned,
                  uint8_t bZeroFill)
{
     f2c:	5f 92       	push	r5
     f2e:	6f 92       	push	r6
     f30:	7f 92       	push	r7
     f32:	8f 92       	push	r8
     f34:	9f 92       	push	r9
     f36:	af 92       	push	r10
     f38:	bf 92       	push	r11
     f3a:	cf 92       	push	r12
     f3c:	df 92       	push	r13
     f3e:	ef 92       	push	r14
     f40:	ff 92       	push	r15
     f42:	0f 93       	push	r16
     f44:	1f 93       	push	r17
     f46:	cf 93       	push	r28
     f48:	df 93       	push	r29
     f4a:	cd b7       	in	r28, 0x3d	; 61
     f4c:	de b7       	in	r29, 0x3e	; 62
     f4e:	61 97       	sbiw	r28, 0x11	; 17
     f50:	0f b6       	in	r0, 0x3f	; 63
     f52:	f8 94       	cli
     f54:	de bf       	out	0x3e, r29	; 62
     f56:	0f be       	out	0x3f, r0	; 63
     f58:	cd bf       	out	0x3d, r28	; 61
     f5a:	5c 01       	movw	r10, r24
     f5c:	16 2f       	mov	r17, r22
     f5e:	74 2e       	mov	r7, r20
//        uint8_t bSigned;   Now an argument for signed or not

        // initialize the quotient 
        qr.quot = l;

        if ( (bSigned=(qr.quot<0)) )
     f60:	6b 2c       	mov	r6, r11
     f62:	66 1c       	adc	r6, r6
     f64:	66 24       	eor	r6, r6
     f66:	66 1c       	adc	r6, r6
     f68:	56 2c       	mov	r5, r6
     f6a:	9c 01       	movw	r18, r24
     f6c:	97 fd       	sbrc	r25, 7
     f6e:	9b c0       	rjmp	.+310    	; 0x10a6 <lcd_int16+0x17a>
                qr.quot = -qr.quot;

        // convert the digits to the right of the decimal point 
        if (decpos){
     f70:	77 20       	and	r7, r7
     f72:	09 f4       	brne	.+2      	; 0xf76 <lcd_int16+0x4a>
     f74:	8d c0       	rjmp	.+282    	; 0x1090 <lcd_int16+0x164>
     f76:	ce 01       	movw	r24, r28
     f78:	01 96       	adiw	r24, 0x01	; 1
     f7a:	7c 01       	movw	r14, r24
     f7c:	6c 01       	movw	r12, r24
     f7e:	88 24       	eor	r8, r8
     f80:	8a 94       	dec	r8
     f82:	87 0c       	add	r8, r7
     f84:	91 2c       	mov	r9, r1
     f86:	9f ef       	ldi	r25, 0xFF	; 255
     f88:	89 1a       	sub	r8, r25
     f8a:	99 0a       	sbc	r9, r25
     f8c:	8e 0c       	add	r8, r14
     f8e:	9f 1c       	adc	r9, r15
          for (; decpos ; decpos--){
            qr = div(qr.quot, 10);
     f90:	6a e0       	ldi	r22, 0x0A	; 10
     f92:	70 e0       	ldi	r23, 0x00	; 0
     f94:	c9 01       	movw	r24, r18
     f96:	0e 94 a3 08 	call	0x1146	; 0x1146 <__divmodhi4>
     f9a:	46 2f       	mov	r20, r22
     f9c:	24 2f       	mov	r18, r20
     f9e:	37 2f       	mov	r19, r23
            sline[i++] = qr.rem + '0';
     fa0:	80 5d       	subi	r24, 0xD0	; 208
     fa2:	f6 01       	movw	r30, r12
     fa4:	81 93       	st	Z+, r24
     fa6:	6f 01       	movw	r12, r30
        if ( (bSigned=(qr.quot<0)) )
                qr.quot = -qr.quot;

        // convert the digits to the right of the decimal point 
        if (decpos){
          for (; decpos ; decpos--){
     fa8:	e8 15       	cp	r30, r8
     faa:	f9 05       	cpc	r31, r9
     fac:	89 f7       	brne	.-30     	; 0xf90 <lcd_int16+0x64>
            qr = div(qr.quot, 10);
            sline[i++] = qr.rem + '0';
          }
          sline[i++] = '.';
     fae:	dd 24       	eor	r13, r13
     fb0:	d3 94       	inc	r13
     fb2:	d7 0c       	add	r13, r7
     fb4:	f7 01       	movw	r30, r14
     fb6:	e7 0d       	add	r30, r7
     fb8:	f1 1d       	adc	r31, r1
     fba:	8e e2       	ldi	r24, 0x2E	; 46
     fbc:	80 83       	st	Z, r24
     fbe:	01 c0       	rjmp	.+2      	; 0xfc2 <lcd_int16+0x96>

        // convert the digits to the left of the decimal point 
        do
        {
                qr = div(qr.quot, 10);
                sline[i++] = qr.rem + '0';
     fc0:	d9 2e       	mov	r13, r25
        }

        // convert the digits to the left of the decimal point 
        do
        {
                qr = div(qr.quot, 10);
     fc2:	6a e0       	ldi	r22, 0x0A	; 10
     fc4:	70 e0       	ldi	r23, 0x00	; 0
     fc6:	c9 01       	movw	r24, r18
     fc8:	0e 94 a3 08 	call	0x1146	; 0x1146 <__divmodhi4>
     fcc:	46 2f       	mov	r20, r22
     fce:	24 2f       	mov	r18, r20
     fd0:	37 2f       	mov	r19, r23
                sline[i++] = qr.rem + '0';
     fd2:	91 e0       	ldi	r25, 0x01	; 1
     fd4:	9d 0d       	add	r25, r13
     fd6:	f7 01       	movw	r30, r14
     fd8:	ed 0d       	add	r30, r13
     fda:	f1 1d       	adc	r31, r1
     fdc:	80 5d       	subi	r24, 0xD0	; 208
     fde:	80 83       	st	Z, r24
        }
        while(qr.quot);
     fe0:	21 15       	cp	r18, r1
     fe2:	31 05       	cpc	r19, r1
     fe4:	69 f7       	brne	.-38     	; 0xfc0 <lcd_int16+0x94>

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
     fe6:	01 11       	cpse	r16, r1
     fe8:	58 c0       	rjmp	.+176    	; 0x109a <lcd_int16+0x16e>
     fea:	b7 fc       	sbrc	r11, 7
     fec:	61 c0       	rjmp	.+194    	; 0x10b0 <lcd_int16+0x184>
                sline[i++] = '-';
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
     fee:	11 23       	and	r17, r17
     ff0:	a9 f0       	breq	.+42     	; 0x101c <lcd_int16+0xf0>
     ff2:	71 2c       	mov	r7, r1
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
     ff4:	80 e2       	ldi	r24, 0x20	; 32
          for (; i<(fieldwidth-bSigned) ; ){ sline[i++] = fillch;}
     ff6:	29 2f       	mov	r18, r25
     ff8:	30 e0       	ldi	r19, 0x00	; 0
     ffa:	41 2f       	mov	r20, r17
     ffc:	50 e0       	ldi	r21, 0x00	; 0
     ffe:	46 19       	sub	r20, r6
    1000:	57 09       	sbc	r21, r7
    1002:	24 17       	cp	r18, r20
    1004:	35 07       	cpc	r19, r21
    1006:	54 f4       	brge	.+20     	; 0x101c <lcd_int16+0xf0>
    1008:	9f 5f       	subi	r25, 0xFF	; 255
    100a:	f7 01       	movw	r30, r14
    100c:	e2 0f       	add	r30, r18
    100e:	f3 1f       	adc	r31, r19
    1010:	80 83       	st	Z, r24
    1012:	29 2f       	mov	r18, r25
    1014:	30 e0       	ldi	r19, 0x00	; 0
    1016:	24 17       	cp	r18, r20
    1018:	35 07       	cpc	r19, r21
    101a:	b4 f3       	brlt	.-20     	; 0x1008 <lcd_int16+0xdc>
        }

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}
    101c:	55 20       	and	r5, r5
    101e:	31 f0       	breq	.+12     	; 0x102c <lcd_int16+0x100>
    1020:	f7 01       	movw	r30, r14
    1022:	e9 0f       	add	r30, r25
    1024:	f1 1d       	adc	r31, r1
    1026:	8d e2       	ldi	r24, 0x2D	; 45
    1028:	80 83       	st	Z, r24
    102a:	9f 5f       	subi	r25, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    102c:	21 e0       	ldi	r18, 0x01	; 1

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}

        // now output the formatted number 
            do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    102e:	91 50       	subi	r25, 0x01	; 1
    1030:	f7 01       	movw	r30, r14
    1032:	e9 0f       	add	r30, r25
    1034:	f1 1d       	adc	r31, r1
    1036:	80 81       	ld	r24, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1038:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    103a:	77 9b       	sbis	0x0e, 7	; 14
    103c:	fe cf       	rjmp	.-4      	; 0x103a <lcd_int16+0x10e>
  SPDR = byte;                        //send payload
    103e:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1040:	77 9b       	sbis	0x0e, 7	; 14
    1042:	fe cf       	rjmp	.-4      	; 0x1040 <lcd_int16+0x114>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    1044:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1048:	88 60       	ori	r24, 0x08	; 8
    104a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    104e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1052:	87 7f       	andi	r24, 0xF7	; 247
    1054:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1058:	e5 ed       	ldi	r30, 0xD5	; 213
    105a:	ea 95       	dec	r30
    105c:	f1 f7       	brne	.-4      	; 0x105a <lcd_int16+0x12e>
    105e:	00 00       	nop

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}

        // now output the formatted number 
            do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    1060:	91 11       	cpse	r25, r1
    1062:	e5 cf       	rjmp	.-54     	; 0x102e <lcd_int16+0x102>
}
    1064:	61 96       	adiw	r28, 0x11	; 17
    1066:	0f b6       	in	r0, 0x3f	; 63
    1068:	f8 94       	cli
    106a:	de bf       	out	0x3e, r29	; 62
    106c:	0f be       	out	0x3f, r0	; 63
    106e:	cd bf       	out	0x3d, r28	; 61
    1070:	df 91       	pop	r29
    1072:	cf 91       	pop	r28
    1074:	1f 91       	pop	r17
    1076:	0f 91       	pop	r16
    1078:	ff 90       	pop	r15
    107a:	ef 90       	pop	r14
    107c:	df 90       	pop	r13
    107e:	cf 90       	pop	r12
    1080:	bf 90       	pop	r11
    1082:	af 90       	pop	r10
    1084:	9f 90       	pop	r9
    1086:	8f 90       	pop	r8
    1088:	7f 90       	pop	r7
    108a:	6f 90       	pop	r6
    108c:	5f 90       	pop	r5
    108e:	08 95       	ret
                  uint8_t decpos, 
                  uint8_t bSigned,
                  uint8_t bZeroFill)
{
        char    sline[NUM_LCD_CHARS+1];
        uint8_t i=0;
    1090:	d1 2c       	mov	r13, r1
    1092:	ce 01       	movw	r24, r28
    1094:	01 96       	adiw	r24, 0x01	; 1
    1096:	7c 01       	movw	r14, r24
    1098:	94 cf       	rjmp	.-216    	; 0xfc2 <lcd_int16+0x96>
                sline[i++] = '-';
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    109a:	11 23       	and	r17, r17
    109c:	09 f4       	brne	.+2      	; 0x10a0 <lcd_int16+0x174>
    109e:	be cf       	rjmp	.-132    	; 0x101c <lcd_int16+0xf0>
    10a0:	71 2c       	mov	r7, r1
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    10a2:	80 e3       	ldi	r24, 0x30	; 48
    10a4:	a8 cf       	rjmp	.-176    	; 0xff6 <lcd_int16+0xca>
    10a6:	22 27       	eor	r18, r18
    10a8:	33 27       	eor	r19, r19
    10aa:	28 1b       	sub	r18, r24
    10ac:	39 0b       	sbc	r19, r25
    10ae:	60 cf       	rjmp	.-320    	; 0xf70 <lcd_int16+0x44>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    10b0:	d3 94       	inc	r13
    10b2:	d3 94       	inc	r13
    10b4:	f7 01       	movw	r30, r14
    10b6:	e9 0f       	add	r30, r25
    10b8:	f1 1d       	adc	r31, r1
    10ba:	8d e2       	ldi	r24, 0x2D	; 45
    10bc:	80 83       	st	Z, r24
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    10be:	11 23       	and	r17, r17
    10c0:	59 f0       	breq	.+22     	; 0x10d8 <lcd_int16+0x1ac>
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
          for (; i<(fieldwidth-bSigned) ; ){ sline[i++] = fillch;}
    10c2:	2d 2d       	mov	r18, r13
    10c4:	30 e0       	ldi	r19, 0x00	; 0
    10c6:	41 2f       	mov	r20, r17
    10c8:	50 e0       	ldi	r21, 0x00	; 0
    10ca:	24 17       	cp	r18, r20
    10cc:	35 07       	cpc	r19, r21
    10ce:	24 f4       	brge	.+8      	; 0x10d8 <lcd_int16+0x1ac>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    10d0:	9d 2d       	mov	r25, r13
                bSigned = 0;
    10d2:	51 2c       	mov	r5, r1
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    10d4:	80 e2       	ldi	r24, 0x20	; 32
    10d6:	98 cf       	rjmp	.-208    	; 0x1008 <lcd_int16+0xdc>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    10d8:	9d 2d       	mov	r25, r13
    10da:	a8 cf       	rjmp	.-176    	; 0x102c <lcd_int16+0x100>

000010dc <main>:
Function:
Description:
Parameters:
**********************************************************************/
void tcnt0_init(){
   ASSR |= (1<<AS0);
    10dc:	80 b7       	in	r24, 0x30	; 48
    10de:	88 60       	ori	r24, 0x08	; 8
    10e0:	80 bf       	out	0x30, r24	; 48
   TIMSK |= (1<<TOIE0);			//enable interrupts
    10e2:	87 b7       	in	r24, 0x37	; 55
    10e4:	81 60       	ori	r24, 0x01	; 1
    10e6:	87 bf       	out	0x37, r24	; 55
   TCCR0 |= (1<<CS00);			//normal mode, no prescale
    10e8:	83 b7       	in	r24, 0x33	; 51
    10ea:	81 60       	ori	r24, 0x01	; 1
    10ec:	83 bf       	out	0x33, r24	; 51
**********************************************************************/
int main() {
   tcnt0_init();
   tcnt1_init();
   tcnt3_init();
   port_init();
    10ee:	0e 94 36 03 	call	0x66c	; 0x66c <port_init>
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
    10f2:	87 b3       	in	r24, 0x17	; 23
    10f4:	87 60       	ori	r24, 0x07	; 7
    10f6:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
    10f8:	8d b1       	in	r24, 0x0d	; 13
    10fa:	8c 65       	ori	r24, 0x5C	; 92
    10fc:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
    10fe:	70 9a       	sbi	0x0e, 0	; 14
   tcnt1_init();
   tcnt3_init();
   port_init();
   
   spi_init();				//Initalize SPI
   lcd_init();
    1100:	0e 94 fe 05 	call	0xbfc	; 0xbfc <lcd_init>
   sei();				//Enable interrupts
    1104:	78 94       	sei
   while(1){
      clock_time();
    1106:	0e 94 69 02 	call	0x4d2	; 0x4d2 <clock_time>
      change_alarm_state();
    110a:	0e 94 46 03 	call	0x68c	; 0x68c <change_alarm_state>
    110e:	ec e2       	ldi	r30, 0x2C	; 44
    1110:	f1 e0       	ldi	r31, 0x01	; 1
    1112:	80 e0       	ldi	r24, 0x00	; 0
      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
         if(alarm){
    1114:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <alarm>
    1118:	99 23       	and	r25, r25
    111a:	29 f0       	breq	.+10     	; 0x1126 <__stack+0x27>
	    segment_data[2] &= 0b011;
    111c:	90 91 2e 01 	lds	r25, 0x012E	; 0x80012e <__data_end+0x2>
    1120:	93 70       	andi	r25, 0x03	; 3
    1122:	90 93 2e 01 	sts	0x012E, r25	; 0x80012e <__data_end+0x2>
	 }
	 PORTA = segment_data[j];	//Writes the segment data to PORTA aka the segments
    1126:	91 91       	ld	r25, Z+
    1128:	9b bb       	out	0x1b, r25	; 27
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
    112a:	98 2f       	mov	r25, r24
    112c:	92 95       	swap	r25
    112e:	90 7f       	andi	r25, 0xF0	; 240
    1130:	98 bb       	out	0x18, r25	; 24
    1132:	af e1       	ldi	r26, 0x1F	; 31
    1134:	b3 e0       	ldi	r27, 0x03	; 3
    1136:	11 97       	sbiw	r26, 0x01	; 1
    1138:	f1 f7       	brne	.-4      	; 0x1136 <__stack+0x37>
    113a:	00 c0       	rjmp	.+0      	; 0x113c <__stack+0x3d>
    113c:	00 00       	nop
    113e:	8f 5f       	subi	r24, 0xFF	; 255
   lcd_init();
   sei();				//Enable interrupts
   while(1){
      clock_time();
      change_alarm_state();
      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
    1140:	85 30       	cpi	r24, 0x05	; 5
    1142:	41 f7       	brne	.-48     	; 0x1114 <__stack+0x15>
    1144:	e0 cf       	rjmp	.-64     	; 0x1106 <__stack+0x7>

00001146 <__divmodhi4>:
    1146:	97 fb       	bst	r25, 7
    1148:	07 2e       	mov	r0, r23
    114a:	16 f4       	brtc	.+4      	; 0x1150 <__divmodhi4+0xa>
    114c:	00 94       	com	r0
    114e:	07 d0       	rcall	.+14     	; 0x115e <__divmodhi4_neg1>
    1150:	77 fd       	sbrc	r23, 7
    1152:	09 d0       	rcall	.+18     	; 0x1166 <__divmodhi4_neg2>
    1154:	0e 94 d6 08 	call	0x11ac	; 0x11ac <__udivmodhi4>
    1158:	07 fc       	sbrc	r0, 7
    115a:	05 d0       	rcall	.+10     	; 0x1166 <__divmodhi4_neg2>
    115c:	3e f4       	brtc	.+14     	; 0x116c <__divmodhi4_exit>

0000115e <__divmodhi4_neg1>:
    115e:	90 95       	com	r25
    1160:	81 95       	neg	r24
    1162:	9f 4f       	sbci	r25, 0xFF	; 255
    1164:	08 95       	ret

00001166 <__divmodhi4_neg2>:
    1166:	70 95       	com	r23
    1168:	61 95       	neg	r22
    116a:	7f 4f       	sbci	r23, 0xFF	; 255

0000116c <__divmodhi4_exit>:
    116c:	08 95       	ret

0000116e <__divmodsi4>:
    116e:	05 2e       	mov	r0, r21
    1170:	97 fb       	bst	r25, 7
    1172:	1e f4       	brtc	.+6      	; 0x117a <__divmodsi4+0xc>
    1174:	00 94       	com	r0
    1176:	0e 94 ce 08 	call	0x119c	; 0x119c <__negsi2>
    117a:	57 fd       	sbrc	r21, 7
    117c:	07 d0       	rcall	.+14     	; 0x118c <__divmodsi4_neg2>
    117e:	0e 94 ea 08 	call	0x11d4	; 0x11d4 <__udivmodsi4>
    1182:	07 fc       	sbrc	r0, 7
    1184:	03 d0       	rcall	.+6      	; 0x118c <__divmodsi4_neg2>
    1186:	4e f4       	brtc	.+18     	; 0x119a <__divmodsi4_exit>
    1188:	0c 94 ce 08 	jmp	0x119c	; 0x119c <__negsi2>

0000118c <__divmodsi4_neg2>:
    118c:	50 95       	com	r21
    118e:	40 95       	com	r20
    1190:	30 95       	com	r19
    1192:	21 95       	neg	r18
    1194:	3f 4f       	sbci	r19, 0xFF	; 255
    1196:	4f 4f       	sbci	r20, 0xFF	; 255
    1198:	5f 4f       	sbci	r21, 0xFF	; 255

0000119a <__divmodsi4_exit>:
    119a:	08 95       	ret

0000119c <__negsi2>:
    119c:	90 95       	com	r25
    119e:	80 95       	com	r24
    11a0:	70 95       	com	r23
    11a2:	61 95       	neg	r22
    11a4:	7f 4f       	sbci	r23, 0xFF	; 255
    11a6:	8f 4f       	sbci	r24, 0xFF	; 255
    11a8:	9f 4f       	sbci	r25, 0xFF	; 255
    11aa:	08 95       	ret

000011ac <__udivmodhi4>:
    11ac:	aa 1b       	sub	r26, r26
    11ae:	bb 1b       	sub	r27, r27
    11b0:	51 e1       	ldi	r21, 0x11	; 17
    11b2:	07 c0       	rjmp	.+14     	; 0x11c2 <__udivmodhi4_ep>

000011b4 <__udivmodhi4_loop>:
    11b4:	aa 1f       	adc	r26, r26
    11b6:	bb 1f       	adc	r27, r27
    11b8:	a6 17       	cp	r26, r22
    11ba:	b7 07       	cpc	r27, r23
    11bc:	10 f0       	brcs	.+4      	; 0x11c2 <__udivmodhi4_ep>
    11be:	a6 1b       	sub	r26, r22
    11c0:	b7 0b       	sbc	r27, r23

000011c2 <__udivmodhi4_ep>:
    11c2:	88 1f       	adc	r24, r24
    11c4:	99 1f       	adc	r25, r25
    11c6:	5a 95       	dec	r21
    11c8:	a9 f7       	brne	.-22     	; 0x11b4 <__udivmodhi4_loop>
    11ca:	80 95       	com	r24
    11cc:	90 95       	com	r25
    11ce:	bc 01       	movw	r22, r24
    11d0:	cd 01       	movw	r24, r26
    11d2:	08 95       	ret

000011d4 <__udivmodsi4>:
    11d4:	a1 e2       	ldi	r26, 0x21	; 33
    11d6:	1a 2e       	mov	r1, r26
    11d8:	aa 1b       	sub	r26, r26
    11da:	bb 1b       	sub	r27, r27
    11dc:	fd 01       	movw	r30, r26
    11de:	0d c0       	rjmp	.+26     	; 0x11fa <__udivmodsi4_ep>

000011e0 <__udivmodsi4_loop>:
    11e0:	aa 1f       	adc	r26, r26
    11e2:	bb 1f       	adc	r27, r27
    11e4:	ee 1f       	adc	r30, r30
    11e6:	ff 1f       	adc	r31, r31
    11e8:	a2 17       	cp	r26, r18
    11ea:	b3 07       	cpc	r27, r19
    11ec:	e4 07       	cpc	r30, r20
    11ee:	f5 07       	cpc	r31, r21
    11f0:	20 f0       	brcs	.+8      	; 0x11fa <__udivmodsi4_ep>
    11f2:	a2 1b       	sub	r26, r18
    11f4:	b3 0b       	sbc	r27, r19
    11f6:	e4 0b       	sbc	r30, r20
    11f8:	f5 0b       	sbc	r31, r21

000011fa <__udivmodsi4_ep>:
    11fa:	66 1f       	adc	r22, r22
    11fc:	77 1f       	adc	r23, r23
    11fe:	88 1f       	adc	r24, r24
    1200:	99 1f       	adc	r25, r25
    1202:	1a 94       	dec	r1
    1204:	69 f7       	brne	.-38     	; 0x11e0 <__udivmodsi4_loop>
    1206:	60 95       	com	r22
    1208:	70 95       	com	r23
    120a:	80 95       	com	r24
    120c:	90 95       	com	r25
    120e:	9b 01       	movw	r18, r22
    1210:	ac 01       	movw	r20, r24
    1212:	bd 01       	movw	r22, r26
    1214:	cf 01       	movw	r24, r30
    1216:	08 95       	ret

00001218 <_exit>:
    1218:	f8 94       	cli

0000121a <__stop_program>:
    121a:	ff cf       	rjmp	.-2      	; 0x121a <__stop_program>
