
alarm_clk.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000002c  00800100  000013c6  0000145a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000013c6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000005a  0080012c  0080012c  00001486  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001486  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000014b8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000048  00000000  00000000  000014f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002281  00000000  00000000  0000153c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000d0c  00000000  00000000  000037bd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001082  00000000  00000000  000044c9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000384  00000000  00000000  0000554c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000682  00000000  00000000  000058d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001908  00000000  00000000  00005f52  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000e8  00000000  00000000  0000785a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      40:	0c 94 85 02 	jmp	0x50a	; 0x50a <__vector_16>
      44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	11 e0       	ldi	r17, 0x01	; 1
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e6 ec       	ldi	r30, 0xC6	; 198
      a0:	f3 e1       	ldi	r31, 0x13	; 19
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	ac 32       	cpi	r26, 0x2C	; 44
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	21 e0       	ldi	r18, 0x01	; 1
      b4:	ac e2       	ldi	r26, 0x2C	; 44
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	a6 38       	cpi	r26, 0x86	; 134
      be:	b2 07       	cpc	r27, r18
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	0e 94 fc 08 	call	0x11f8	; 0x11f8 <main>
      c6:	0c 94 e1 09 	jmp	0x13c2	; 0x13c2 <_exit>

000000ca <__bad_interrupt>:
      ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <spi_init>:
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
      ce:	87 b3       	in	r24, 0x17	; 23
      d0:	87 60       	ori	r24, 0x07	; 7
      d2:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
      d4:	8d b1       	in	r24, 0x0d	; 13
      d6:	8c 65       	ori	r24, 0x5C	; 92
      d8:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
      da:	70 9a       	sbi	0x0e, 0	; 14
      dc:	08 95       	ret

000000de <tcnt0_init>:
Function:
Description:
Parameters:
**********************************************************************/
void tcnt0_init(){
   ASSR |= (1<<AS0);
      de:	80 b7       	in	r24, 0x30	; 48
      e0:	88 60       	ori	r24, 0x08	; 8
      e2:	80 bf       	out	0x30, r24	; 48
   TIMSK |= (1<<TOIE0);			//enable interrupts
      e4:	87 b7       	in	r24, 0x37	; 55
      e6:	81 60       	ori	r24, 0x01	; 1
      e8:	87 bf       	out	0x37, r24	; 55
   TCCR0 |= (1<<CS00);			//normal mode, no prescale
      ea:	83 b7       	in	r24, 0x33	; 51
      ec:	81 60       	ori	r24, 0x01	; 1
      ee:	83 bf       	out	0x33, r24	; 51
      f0:	08 95       	ret

000000f2 <tcnt1_init>:
Function:
Description:
Parameters:
**********************************************************************/
void tcnt1_init(){
   TCCR1A |= 0x00;//(1<<COM1A0); //Toggle on OCR1A match
      f2:	8f b5       	in	r24, 0x2f	; 47
      f4:	8f bd       	out	0x2f, r24	; 47
   TCCR1B |= 0x00; //(1<<CS11) | (1<<CS10) | (1<<WGM12);		//CTC mode, 64bit prescaler
      f6:	8e b5       	in	r24, 0x2e	; 46
      f8:	8e bd       	out	0x2e, r24	; 46
   TCCR1C = 0x00;
      fa:	10 92 7a 00 	sts	0x007A, r1	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
   TIMSK  |= (1<<OCIE1A);// | (1<<TOIE1); 
      fe:	87 b7       	in	r24, 0x37	; 55
     100:	80 61       	ori	r24, 0x10	; 16
     102:	87 bf       	out	0x37, r24	; 55
   TIFR   |= (1<<OCF1A);// | (1<<TOV1);
     104:	86 b7       	in	r24, 0x36	; 54
     106:	80 61       	ori	r24, 0x10	; 16
     108:	86 bf       	out	0x36, r24	; 54
   TCNT1 = 0x0000; 		//Initialize TNCT1 to 0
     10a:	1d bc       	out	0x2d, r1	; 45
     10c:	1c bc       	out	0x2c, r1	; 44
   OCR1A = 0x80;
     10e:	80 e8       	ldi	r24, 0x80	; 128
     110:	90 e0       	ldi	r25, 0x00	; 0
     112:	9b bd       	out	0x2b, r25	; 43
     114:	8a bd       	out	0x2a, r24	; 42
     116:	08 95       	ret

00000118 <tcnt2_init>:
Function:
Description:
Parameters:
**********************************************************************/
void tcnt2_init(){
   TCCR2 |= (1<<WGM21) | (1<<WGM20)| (1<<CS20) | (1<<COM21);			//normal mode, no prescale
     118:	85 b5       	in	r24, 0x25	; 37
     11a:	89 66       	ori	r24, 0x69	; 105
     11c:	85 bd       	out	0x25, r24	; 37
     11e:	08 95       	ret

00000120 <tcnt3_init>:
Function:
Description:
Parameters:
**********************************************************************/
void tcnt3_init(){
   TCCR3A |= (1<<COM3A1);// | (1<<COM3A0); //Set on OCR1A match
     120:	eb e8       	ldi	r30, 0x8B	; 139
     122:	f0 e0       	ldi	r31, 0x00	; 0
     124:	80 81       	ld	r24, Z
     126:	80 68       	ori	r24, 0x80	; 128
     128:	80 83       	st	Z, r24
   TCCR3B |= (0<<CS31) | (1<<CS30) | (1<<WGM32) | (1<<WGM30);		//Fast PWM mode, 64bit prescaler
     12a:	ea e8       	ldi	r30, 0x8A	; 138
     12c:	f0 e0       	ldi	r31, 0x00	; 0
     12e:	80 81       	ld	r24, Z
     130:	89 60       	ori	r24, 0x09	; 9
     132:	80 83       	st	Z, r24
   TCCR3C = 0x00;
     134:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x7e008c>
   TIMSK  |= (1<<OCIE3A);
     138:	87 b7       	in	r24, 0x37	; 55
     13a:	80 61       	ori	r24, 0x10	; 16
     13c:	87 bf       	out	0x37, r24	; 55
   TIFR   |= (1<<OCF3A);
     13e:	86 b7       	in	r24, 0x36	; 54
     140:	80 61       	ori	r24, 0x10	; 16
     142:	86 bf       	out	0x36, r24	; 54
   ICR3 = 159;			//Setting the TOP value of the PWM
     144:	8f e9       	ldi	r24, 0x9F	; 159
     146:	90 e0       	ldi	r25, 0x00	; 0
     148:	90 93 81 00 	sts	0x0081, r25	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
     14c:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
   TCNT3 = 0x0000; 		//Initialize TNCT1 to 0
     150:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     154:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
   OCR3A = 0;			//Makes PWM almost completly off
     158:	10 92 87 00 	sts	0x0087, r1	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     15c:	10 92 86 00 	sts	0x0086, r1	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
     160:	08 95       	ret

00000162 <spi_read>:
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
     162:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
     164:	77 9b       	sbis	0x0e, 7	; 14
     166:	fe cf       	rjmp	.-4      	; 0x164 <spi_read+0x2>
   return SPDR;
     168:	8f b1       	in	r24, 0x0f	; 15
}
     16a:	08 95       	ret

0000016c <chk_buttons>:
	be implemented at the same time. Adapted to check all buttons from 
	Ganssel's "Guide to Debouncing" Expects active low pushbuttons on PINA 
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
     16c:	48 2f       	mov	r20, r24
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
     16e:	e8 2f       	mov	r30, r24
     170:	f0 e0       	ldi	r31, 0x00	; 0
     172:	99 b3       	in	r25, 0x19	; 25
     174:	ee 0f       	add	r30, r30
     176:	ff 1f       	adc	r31, r31
     178:	ed 5b       	subi	r30, 0xBD	; 189
     17a:	fe 4f       	sbci	r31, 0xFE	; 254
     17c:	20 81       	ld	r18, Z
     17e:	31 81       	ldd	r19, Z+1	; 0x01
     180:	22 0f       	add	r18, r18
     182:	33 1f       	adc	r19, r19
     184:	30 6e       	ori	r19, 0xE0	; 224
     186:	89 2f       	mov	r24, r25
     188:	90 e0       	ldi	r25, 0x00	; 0
     18a:	02 c0       	rjmp	.+4      	; 0x190 <chk_buttons+0x24>
     18c:	95 95       	asr	r25
     18e:	87 95       	ror	r24
     190:	4a 95       	dec	r20
     192:	e2 f7       	brpl	.-8      	; 0x18c <chk_buttons+0x20>
     194:	81 70       	andi	r24, 0x01	; 1
     196:	99 27       	eor	r25, r25
     198:	28 2b       	or	r18, r24
     19a:	39 2b       	or	r19, r25
     19c:	31 83       	std	Z+1, r19	; 0x01
     19e:	20 83       	st	Z, r18
     1a0:	81 e0       	ldi	r24, 0x01	; 1
     1a2:	21 15       	cp	r18, r1
     1a4:	30 4f       	sbci	r19, 0xF0	; 240
     1a6:	09 f0       	breq	.+2      	; 0x1aa <chk_buttons+0x3e>
     1a8:	80 e0       	ldi	r24, 0x00	; 0
  if (state[button] == 0xF000)
    return 1;
return 0;
}
     1aa:	08 95       	ret

000001ac <bars>:
Description:This function reads in the button board and updates the 
	LEDs on the bargraph through the serial port.
Parameters: NA
**********************************************************************/
void bars() {
   DDRA = 0x00;				//Set all as inputs
     1ac:	1a ba       	out	0x1a, r1	; 26
   PORTA = 0xFF;			//Pull up resistors
     1ae:	8f ef       	ldi	r24, 0xFF	; 255
     1b0:	8b bb       	out	0x1b, r24	; 27
   PORTB |= PINB | 0x70;		//Enable tristate buffer
     1b2:	86 b3       	in	r24, 0x16	; 22
     1b4:	98 b3       	in	r25, 0x18	; 24
     1b6:	80 67       	ori	r24, 0x70	; 112
     1b8:	89 2b       	or	r24, r25
     1ba:	88 bb       	out	0x18, r24	; 24
     1bc:	e3 e4       	ldi	r30, 0x43	; 67
     1be:	f1 e0       	ldi	r31, 0x01	; 1

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     1c0:	20 e0       	ldi	r18, 0x00	; 0
     1c2:	30 e0       	ldi	r19, 0x00	; 0
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
     1c4:	61 e0       	ldi	r22, 0x01	; 1
     1c6:	70 e0       	ldi	r23, 0x00	; 0
     1c8:	05 c0       	rjmp	.+10     	; 0x1d4 <bars+0x28>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     1ca:	2f 5f       	subi	r18, 0xFF	; 255
     1cc:	3f 4f       	sbci	r19, 0xFF	; 255
     1ce:	28 30       	cpi	r18, 0x08	; 8
     1d0:	31 05       	cpc	r19, r1
     1d2:	39 f1       	breq	.+78     	; 0x222 <bars+0x76>
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
     1d4:	99 b3       	in	r25, 0x19	; 25
     1d6:	40 81       	ld	r20, Z
     1d8:	51 81       	ldd	r21, Z+1	; 0x01
     1da:	44 0f       	add	r20, r20
     1dc:	55 1f       	adc	r21, r21
     1de:	89 2f       	mov	r24, r25
     1e0:	90 e0       	ldi	r25, 0x00	; 0
     1e2:	02 2e       	mov	r0, r18
     1e4:	02 c0       	rjmp	.+4      	; 0x1ea <bars+0x3e>
     1e6:	95 95       	asr	r25
     1e8:	87 95       	ror	r24
     1ea:	0a 94       	dec	r0
     1ec:	e2 f7       	brpl	.-8      	; 0x1e6 <bars+0x3a>
     1ee:	81 70       	andi	r24, 0x01	; 1
     1f0:	99 27       	eor	r25, r25
     1f2:	84 2b       	or	r24, r20
     1f4:	95 2b       	or	r25, r21
     1f6:	90 6e       	ori	r25, 0xE0	; 224
     1f8:	81 93       	st	Z+, r24
     1fa:	91 93       	st	Z+, r25
  if (state[button] == 0xF000)
     1fc:	81 15       	cp	r24, r1
     1fe:	90 4f       	sbci	r25, 0xF0	; 240
     200:	21 f7       	brne	.-56     	; 0x1ca <bars+0x1e>
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
     202:	cb 01       	movw	r24, r22
     204:	02 2e       	mov	r0, r18
     206:	02 c0       	rjmp	.+4      	; 0x20c <bars+0x60>
     208:	88 0f       	add	r24, r24
     20a:	99 1f       	adc	r25, r25
     20c:	0a 94       	dec	r0
     20e:	e2 f7       	brpl	.-8      	; 0x208 <bars+0x5c>
     210:	90 93 36 01 	sts	0x0136, r25	; 0x800136 <mult+0x1>
     214:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <mult>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     218:	2f 5f       	subi	r18, 0xFF	; 255
     21a:	3f 4f       	sbci	r19, 0xFF	; 255
     21c:	28 30       	cpi	r18, 0x08	; 8
     21e:	31 05       	cpc	r19, r1
     220:	c9 f6       	brne	.-78     	; 0x1d4 <bars+0x28>
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
     222:	88 b3       	in	r24, 0x18	; 24
     224:	18 ba       	out	0x18, r1	; 24
   if(mult == 128){			//Button 8 toggles base 10 and 16
     226:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <mult>
     22a:	90 91 36 01 	lds	r25, 0x0136	; 0x800136 <mult+0x1>
     22e:	80 38       	cpi	r24, 0x80	; 128
     230:	91 05       	cpc	r25, r1
     232:	09 f4       	brne	.+2      	; 0x236 <bars+0x8a>
     234:	47 c0       	rjmp	.+142    	; 0x2c4 <bars+0x118>
      alarm = !(alarm);			//on the LED display
   }
   if(mult == 64){			//Button 8 toggles base 10 and 16
     236:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <mult>
     23a:	90 91 36 01 	lds	r25, 0x0136	; 0x800136 <mult+0x1>
     23e:	80 34       	cpi	r24, 0x40	; 64
     240:	91 05       	cpc	r25, r1
     242:	09 f4       	brne	.+2      	; 0x246 <bars+0x9a>
     244:	4e c0       	rjmp	.+156    	; 0x2e2 <bars+0x136>
      snooze = !(snooze);			//on the LED display
   }
   if(mult > 4) {			//I only want values from the
     246:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <mult>
     24a:	90 91 36 01 	lds	r25, 0x0136	; 0x800136 <mult+0x1>
     24e:	05 97       	sbiw	r24, 0x05	; 5
     250:	20 f0       	brcs	.+8      	; 0x25a <bars+0xae>
      mult = 0;				//first three buttons
     252:	10 92 36 01 	sts	0x0136, r1	; 0x800136 <mult+0x1>
     256:	10 92 35 01 	sts	0x0135, r1	; 0x800135 <mult>
   }
   if(mult == 4){
     25a:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <mult>
     25e:	90 91 36 01 	lds	r25, 0x0136	; 0x800136 <mult+0x1>
     262:	04 97       	sbiw	r24, 0x04	; 4
     264:	09 f4       	brne	.+2      	; 0x268 <bars+0xbc>
     266:	45 c0       	rjmp	.+138    	; 0x2f2 <bars+0x146>
      snooze = 1;
   }
   //This switch statement is used to enable a 'toggle' functionality
   //so that modes can be selected an deselected
   switch(mult) {
     268:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <mult>
     26c:	90 91 36 01 	lds	r25, 0x0136	; 0x800136 <mult+0x1>
     270:	81 30       	cpi	r24, 0x01	; 1
     272:	91 05       	cpc	r25, r1
     274:	19 f0       	breq	.+6      	; 0x27c <bars+0xd0>
     276:	82 30       	cpi	r24, 0x02	; 2
     278:	91 05       	cpc	r25, r1
     27a:	f9 f4       	brne	.+62     	; 0x2ba <bars+0x10e>
	 }
	 else
	    mode_sel = 1;		//If not, then change mode
         break;
      case 2:
	 if((mode_sel ^ mult) == 0 ){//if((mode_sel ^ mult) && (mode_sel == 4)){//if cur &prev are diff
     27c:	40 91 31 01 	lds	r20, 0x0131	; 0x800131 <mode_sel>
     280:	50 91 32 01 	lds	r21, 0x0132	; 0x800132 <mode_sel+0x1>
     284:	20 91 35 01 	lds	r18, 0x0135	; 0x800135 <mult>
     288:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <mult+0x1>
     28c:	42 17       	cp	r20, r18
     28e:	53 07       	cpc	r21, r19
     290:	a1 f1       	breq	.+104    	; 0x2fa <bars+0x14e>
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
         break;*/
      default:
	 mode_sel = mode_sel;		//no/invalid button press
     292:	90 93 32 01 	sts	0x0132, r25	; 0x800132 <mode_sel+0x1>
     296:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <mode_sel>
   }   
   mult = 0;				//clear mult for next pass
     29a:	10 92 36 01 	sts	0x0136, r1	; 0x800136 <mult+0x1>
     29e:	10 92 35 01 	sts	0x0135, r1	; 0x800135 <mult>

   DDRA = 0xFF;				//Set A to alloutputs
     2a2:	8f ef       	ldi	r24, 0xFF	; 255
     2a4:	8a bb       	out	0x1a, r24	; 26
   SPDR = mode_sel;			//Write mode to the Bargraph
     2a6:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <mode_sel>
     2aa:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <mode_sel+0x1>
     2ae:	8f b9       	out	0x0f, r24	; 15
   while(bit_is_clear(SPSR, SPIF)){}	
     2b0:	77 9b       	sbis	0x0e, 7	; 14
     2b2:	fe cf       	rjmp	.-4      	; 0x2b0 <bars+0x104>
   PORTB |= (1<<PB0);			//Rgclk high on bargraph
     2b4:	c0 9a       	sbi	0x18, 0	; 24
   PORTB &= 0xFE;			//Rgclk low on bargraph
     2b6:	c0 98       	cbi	0x18, 0	; 24
   
return ;
     2b8:	08 95       	ret
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
         break;*/
      default:
	 mode_sel = mode_sel;		//no/invalid button press
     2ba:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <mode_sel>
     2be:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <mode_sel+0x1>
     2c2:	e7 cf       	rjmp	.-50     	; 0x292 <bars+0xe6>
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
     2c4:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <alarm>
     2c8:	81 e0       	ldi	r24, 0x01	; 1
     2ca:	91 11       	cpse	r25, r1
     2cc:	1f c0       	rjmp	.+62     	; 0x30c <bars+0x160>
     2ce:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <alarm>
   }
   if(mult == 64){			//Button 8 toggles base 10 and 16
     2d2:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <mult>
     2d6:	90 91 36 01 	lds	r25, 0x0136	; 0x800136 <mult+0x1>
     2da:	80 34       	cpi	r24, 0x40	; 64
     2dc:	91 05       	cpc	r25, r1
     2de:	09 f0       	breq	.+2      	; 0x2e2 <bars+0x136>
     2e0:	b2 cf       	rjmp	.-156    	; 0x246 <bars+0x9a>
      snooze = !(snooze);			//on the LED display
     2e2:	90 91 38 01 	lds	r25, 0x0138	; 0x800138 <snooze>
     2e6:	81 e0       	ldi	r24, 0x01	; 1
     2e8:	91 11       	cpse	r25, r1
     2ea:	0c c0       	rjmp	.+24     	; 0x304 <bars+0x158>
     2ec:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <snooze>
     2f0:	aa cf       	rjmp	.-172    	; 0x246 <bars+0x9a>
   }
   if(mult > 4) {			//I only want values from the
      mult = 0;				//first three buttons
   }
   if(mult == 4){
      snooze = 1;
     2f2:	81 e0       	ldi	r24, 0x01	; 1
     2f4:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <snooze>
     2f8:	b7 cf       	rjmp	.-146    	; 0x268 <bars+0xbc>
	 else
	    mode_sel = 1;		//If not, then change mode
         break;
      case 2:
	 if((mode_sel ^ mult) == 0 ){//if((mode_sel ^ mult) && (mode_sel == 4)){//if cur &prev are diff
	    mode_sel = 0;//and prev isn't = 1 then two modes are selected
     2fa:	10 92 32 01 	sts	0x0132, r1	; 0x800132 <mode_sel+0x1>
     2fe:	10 92 31 01 	sts	0x0131, r1	; 0x800131 <mode_sel>
     302:	cb cf       	rjmp	.-106    	; 0x29a <bars+0xee>
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
   }
   if(mult == 64){			//Button 8 toggles base 10 and 16
      snooze = !(snooze);			//on the LED display
     304:	80 e0       	ldi	r24, 0x00	; 0
     306:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <snooze>
     30a:	9d cf       	rjmp	.-198    	; 0x246 <bars+0x9a>
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
     30c:	80 e0       	ldi	r24, 0x00	; 0
     30e:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <alarm>
     312:	df cf       	rjmp	.-66     	; 0x2d2 <bars+0x126>

00000314 <read_encoder>:
   int8_t value = 0x00;
   uint8_t ec_a;
   uint8_t ec_b;

   //Shift_LD_N low
   PORTE &= 0x00;	//Begining of SHIFT_LD_N pulse. It is low here
     314:	83 b1       	in	r24, 0x03	; 3
     316:	13 b8       	out	0x03, r1	; 3
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     318:	87 ec       	ldi	r24, 0xC7	; 199
     31a:	90 e0       	ldi	r25, 0x00	; 0
     31c:	01 97       	sbiw	r24, 0x01	; 1
     31e:	f1 f7       	brne	.-4      	; 0x31c <read_encoder+0x8>
     320:	00 c0       	rjmp	.+0      	; 0x322 <read_encoder+0xe>
     322:	00 00       	nop
   _delay_us(50);
   PORTE |= 0xFF;	//End of SHIFT_LD_N pulse. back to high
     324:	83 b1       	in	r24, 0x03	; 3
     326:	8f ef       	ldi	r24, 0xFF	; 255
     328:	83 b9       	out	0x03, r24	; 3
   PORTD &= 0x00;	//CLK_INH low
     32a:	82 b3       	in	r24, 0x12	; 18
     32c:	12 ba       	out	0x12, r1	; 18
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
     32e:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
     330:	77 9b       	sbis	0x0e, 7	; 14
     332:	fe cf       	rjmp	.-4      	; 0x330 <read_encoder+0x1c>
   return SPDR;
     334:	9f b1       	in	r25, 0x0f	; 15
   _delay_us(50);
   PORTE |= 0xFF;	//End of SHIFT_LD_N pulse. back to high
   PORTD &= 0x00;	//CLK_INH low

   encoder_value = spi_read();
   PORTD |= 0x02;	//CLK_INH high
     336:	91 9a       	sbi	0x12, 1	; 18
   value = mode_sel;
     338:	20 91 31 01 	lds	r18, 0x0131	; 0x800131 <mode_sel>
     33c:	30 91 32 01 	lds	r19, 0x0132	; 0x800132 <mode_sel+0x1>
     340:	82 2f       	mov	r24, r18
   ec_a = encoder_value & 0x03;  //Only grabs these bits 0000_0011
     342:	49 2f       	mov	r20, r25
     344:	43 70       	andi	r20, 0x03	; 3
   ec_b = encoder_value & 0x0C;  //Only grabs these bits 0000_1100 
     346:	9c 70       	andi	r25, 0x0C	; 12
   ec_b = (ec_b >> 2);
     348:	96 95       	lsr	r25
     34a:	96 95       	lsr	r25

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
     34c:	20 91 31 01 	lds	r18, 0x0131	; 0x800131 <mode_sel>
     350:	30 91 32 01 	lds	r19, 0x0132	; 0x800132 <mode_sel+0x1>
     354:	21 30       	cpi	r18, 0x01	; 1
     356:	31 05       	cpc	r19, r1
     358:	09 f4       	brne	.+2      	; 0x35c <read_encoder+0x48>
     35a:	44 c0       	rjmp	.+136    	; 0x3e4 <read_encoder+0xd0>
         else
	    value = 0;
      }
   }
//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 2){
     35c:	20 91 31 01 	lds	r18, 0x0131	; 0x800131 <mode_sel>
     360:	30 91 32 01 	lds	r19, 0x0132	; 0x800132 <mode_sel+0x1>
     364:	22 30       	cpi	r18, 0x02	; 2
     366:	31 05       	cpc	r19, r1
     368:	29 f0       	breq	.+10     	; 0x374 <read_encoder+0x60>
         else
	    value = 0;
      }
   }
//Saves previous values into volatile variables
EC_a_prev = ec_a;
     36a:	40 93 55 01 	sts	0x0155, r20	; 0x800155 <EC_a_prev>
EC_b_prev = ec_b;
     36e:	90 93 54 01 	sts	0x0154, r25	; 0x800154 <EC_b_prev>

return value;
}
     372:	08 95       	ret
	    value = 0;
      }
   }
//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 2){
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     374:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <EC_a_prev>
     378:	64 2f       	mov	r22, r20
     37a:	70 e0       	ldi	r23, 0x00	; 0
     37c:	02 2e       	mov	r0, r18
     37e:	00 0c       	add	r0, r0
     380:	33 0b       	sbc	r19, r19
     382:	62 17       	cp	r22, r18
     384:	73 07       	cpc	r23, r19
     386:	d1 f0       	breq	.+52     	; 0x3bc <read_encoder+0xa8>
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     388:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <EC_a_prev>
     38c:	21 11       	cpse	r18, r1
     38e:	03 c0       	rjmp	.+6      	; 0x396 <read_encoder+0x82>
     390:	41 30       	cpi	r20, 0x01	; 1
     392:	09 f4       	brne	.+2      	; 0x396 <read_encoder+0x82>
     394:	89 c0       	rjmp	.+274    	; 0x4a8 <__LOCK_REGION_LENGTH__+0xa8>
            a_hour_count = a_hour_count + 1;//value = value;
	    if(a_hour_count == 24)
	       a_hour_count = 0;
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     396:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <EC_a_prev>
     39a:	21 11       	cpse	r18, r1
     39c:	1d c0       	rjmp	.+58     	; 0x3d8 <read_encoder+0xc4>
     39e:	42 30       	cpi	r20, 0x02	; 2
     3a0:	d9 f4       	brne	.+54     	; 0x3d8 <read_encoder+0xc4>
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
	    a_min_count = a_min_count - 1; //value = -(value);
	    if(a_min_count < 0){
	       a_min_count = 59;
	       a_hour_count--;
     3a2:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <a_hour_count>
     3a6:	21 50       	subi	r18, 0x01	; 1
     3a8:	20 93 3b 01 	sts	0x013B, r18	; 0x80013b <a_hour_count>
	       if(a_hour_count < 0){
     3ac:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <a_hour_count>
     3b0:	27 ff       	sbrs	r18, 7
     3b2:	db cf       	rjmp	.-74     	; 0x36a <read_encoder+0x56>
	          a_hour_count = 23;
     3b4:	27 e1       	ldi	r18, 0x17	; 23
     3b6:	20 93 3b 01 	sts	0x013B, r18	; 0x80013b <a_hour_count>
     3ba:	d7 cf       	rjmp	.-82     	; 0x36a <read_encoder+0x56>
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
     3bc:	20 91 54 01 	lds	r18, 0x0154	; 0x800154 <EC_b_prev>
     3c0:	21 11       	cpse	r18, r1
     3c2:	03 c0       	rjmp	.+6      	; 0x3ca <read_encoder+0xb6>
     3c4:	91 30       	cpi	r25, 0x01	; 1
     3c6:	09 f4       	brne	.+2      	; 0x3ca <read_encoder+0xb6>
     3c8:	89 c0       	rjmp	.+274    	; 0x4dc <__LOCK_REGION_LENGTH__+0xdc>
	       a_hour_count++;
	       if(a_hour_count > 23)
	          a_hour_count = 0;
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
     3ca:	20 91 54 01 	lds	r18, 0x0154	; 0x800154 <EC_b_prev>
     3ce:	21 11       	cpse	r18, r1
     3d0:	03 c0       	rjmp	.+6      	; 0x3d8 <read_encoder+0xc4>
     3d2:	92 30       	cpi	r25, 0x02	; 2
     3d4:	09 f4       	brne	.+2      	; 0x3d8 <read_encoder+0xc4>
     3d6:	75 c0       	rjmp	.+234    	; 0x4c2 <__LOCK_REGION_LENGTH__+0xc2>
	    a_hour_count = a_hour_count - 1;//value = -(value);
	    if(a_hour_count < 0)
	       a_hour_count = 23; 
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
     3d8:	80 e0       	ldi	r24, 0x00	; 0
         else
	    value = 0;
      }
   }
//Saves previous values into volatile variables
EC_a_prev = ec_a;
     3da:	40 93 55 01 	sts	0x0155, r20	; 0x800155 <EC_a_prev>
EC_b_prev = ec_b;
     3de:	90 93 54 01 	sts	0x0154, r25	; 0x800154 <EC_b_prev>

return value;
}
     3e2:	08 95       	ret
   ec_b = encoder_value & 0x0C;  //Only grabs these bits 0000_1100 
   ec_b = (ec_b >> 2);

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     3e4:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <EC_a_prev>
     3e8:	64 2f       	mov	r22, r20
     3ea:	70 e0       	ldi	r23, 0x00	; 0
     3ec:	02 2e       	mov	r0, r18
     3ee:	00 0c       	add	r0, r0
     3f0:	33 0b       	sbc	r19, r19
     3f2:	62 17       	cp	r22, r18
     3f4:	73 07       	cpc	r23, r19
     3f6:	d1 f0       	breq	.+52     	; 0x42c <__LOCK_REGION_LENGTH__+0x2c>
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     3f8:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <EC_a_prev>
     3fc:	22 23       	and	r18, r18
     3fe:	49 f0       	breq	.+18     	; 0x412 <__LOCK_REGION_LENGTH__+0x12>
            hour_count = hour_count + 1;//value = value;
	    if(hour_count == 24)
	       hour_count = 0;
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     400:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <EC_a_prev>
     404:	21 11       	cpse	r18, r1
     406:	03 c0       	rjmp	.+6      	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
     408:	42 30       	cpi	r20, 0x02	; 2
     40a:	09 f4       	brne	.+2      	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
     40c:	40 c0       	rjmp	.+128    	; 0x48e <__LOCK_REGION_LENGTH__+0x8e>
	    hour_count = hour_count - 1;//value = -(value);
	    if(hour_count < 0)
	       hour_count = 23; 
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
     40e:	80 e0       	ldi	r24, 0x00	; 0
     410:	a5 cf       	rjmp	.-182    	; 0x35c <read_encoder+0x48>
   ec_b = (ec_b >> 2);

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     412:	41 30       	cpi	r20, 0x01	; 1
     414:	a9 f7       	brne	.-22     	; 0x400 <__LOCK_REGION_LENGTH__>
            hour_count = hour_count + 1;//value = value;
     416:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <hour_count>
     41a:	2f 5f       	subi	r18, 0xFF	; 255
     41c:	20 93 3e 01 	sts	0x013E, r18	; 0x80013e <hour_count>
	    if(hour_count == 24)
     420:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <hour_count>
     424:	28 31       	cpi	r18, 0x18	; 24
     426:	09 f0       	breq	.+2      	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
     428:	99 cf       	rjmp	.-206    	; 0x35c <read_encoder+0x48>
     42a:	1c c0       	rjmp	.+56     	; 0x464 <__LOCK_REGION_LENGTH__+0x64>
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
     42c:	20 91 54 01 	lds	r18, 0x0154	; 0x800154 <EC_b_prev>
     430:	21 11       	cpse	r18, r1
     432:	1b c0       	rjmp	.+54     	; 0x46a <__LOCK_REGION_LENGTH__+0x6a>
     434:	91 30       	cpi	r25, 0x01	; 1
     436:	c9 f4       	brne	.+50     	; 0x46a <__LOCK_REGION_LENGTH__+0x6a>
            min_count = min_count + 1;//value = value;
     438:	20 91 3f 01 	lds	r18, 0x013F	; 0x80013f <min_count>
     43c:	2f 5f       	subi	r18, 0xFF	; 255
     43e:	20 93 3f 01 	sts	0x013F, r18	; 0x80013f <min_count>
	    if(min_count == 60){
     442:	20 91 3f 01 	lds	r18, 0x013F	; 0x80013f <min_count>
     446:	2c 33       	cpi	r18, 0x3C	; 60
     448:	09 f0       	breq	.+2      	; 0x44c <__LOCK_REGION_LENGTH__+0x4c>
     44a:	88 cf       	rjmp	.-240    	; 0x35c <read_encoder+0x48>
	       min_count = 0; 
     44c:	10 92 3f 01 	sts	0x013F, r1	; 0x80013f <min_count>
	       hour_count++;
     450:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <hour_count>
     454:	2f 5f       	subi	r18, 0xFF	; 255
     456:	20 93 3e 01 	sts	0x013E, r18	; 0x80013e <hour_count>
	       if(hour_count > 23)
     45a:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <hour_count>
     45e:	28 31       	cpi	r18, 0x18	; 24
     460:	0c f4       	brge	.+2      	; 0x464 <__LOCK_REGION_LENGTH__+0x64>
     462:	7c cf       	rjmp	.-264    	; 0x35c <read_encoder+0x48>
	          hour_count = 0;
     464:	10 92 3e 01 	sts	0x013E, r1	; 0x80013e <hour_count>
     468:	79 cf       	rjmp	.-270    	; 0x35c <read_encoder+0x48>
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
     46a:	20 91 54 01 	lds	r18, 0x0154	; 0x800154 <EC_b_prev>
     46e:	21 11       	cpse	r18, r1
     470:	ce cf       	rjmp	.-100    	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
     472:	92 30       	cpi	r25, 0x02	; 2
     474:	61 f6       	brne	.-104    	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
	    min_count = min_count - 1; //value = -(value);
     476:	20 91 3f 01 	lds	r18, 0x013F	; 0x80013f <min_count>
     47a:	21 50       	subi	r18, 0x01	; 1
     47c:	20 93 3f 01 	sts	0x013F, r18	; 0x80013f <min_count>
	    if(min_count < 0){
     480:	20 91 3f 01 	lds	r18, 0x013F	; 0x80013f <min_count>
     484:	27 ff       	sbrs	r18, 7
     486:	6a cf       	rjmp	.-300    	; 0x35c <read_encoder+0x48>
	       min_count = 59;
     488:	2b e3       	ldi	r18, 0x3B	; 59
     48a:	20 93 3f 01 	sts	0x013F, r18	; 0x80013f <min_count>
	       hour_count--;
     48e:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <hour_count>
     492:	21 50       	subi	r18, 0x01	; 1
     494:	20 93 3e 01 	sts	0x013E, r18	; 0x80013e <hour_count>
	       if(hour_count < 0){
     498:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <hour_count>
     49c:	27 ff       	sbrs	r18, 7
     49e:	5e cf       	rjmp	.-324    	; 0x35c <read_encoder+0x48>
	          hour_count = 23;
     4a0:	27 e1       	ldi	r18, 0x17	; 23
     4a2:	20 93 3e 01 	sts	0x013E, r18	; 0x80013e <hour_count>
     4a6:	5a cf       	rjmp	.-332    	; 0x35c <read_encoder+0x48>
   }
//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 2){
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
            a_hour_count = a_hour_count + 1;//value = value;
     4a8:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <a_hour_count>
     4ac:	2f 5f       	subi	r18, 0xFF	; 255
     4ae:	20 93 3b 01 	sts	0x013B, r18	; 0x80013b <a_hour_count>
	    if(a_hour_count == 24)
     4b2:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <a_hour_count>
     4b6:	28 31       	cpi	r18, 0x18	; 24
     4b8:	09 f0       	breq	.+2      	; 0x4bc <__LOCK_REGION_LENGTH__+0xbc>
     4ba:	57 cf       	rjmp	.-338    	; 0x36a <read_encoder+0x56>
            a_min_count = a_min_count + 1;//value = value;
	    if(a_min_count == 60){
	       a_min_count = 0; 
	       a_hour_count++;
	       if(a_hour_count > 23)
	          a_hour_count = 0;
     4bc:	10 92 3b 01 	sts	0x013B, r1	; 0x80013b <a_hour_count>
     4c0:	54 cf       	rjmp	.-344    	; 0x36a <read_encoder+0x56>
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
	    a_min_count = a_min_count - 1; //value = -(value);
     4c2:	20 91 3c 01 	lds	r18, 0x013C	; 0x80013c <a_min_count>
     4c6:	21 50       	subi	r18, 0x01	; 1
     4c8:	20 93 3c 01 	sts	0x013C, r18	; 0x80013c <a_min_count>
	    if(a_min_count < 0){
     4cc:	20 91 3c 01 	lds	r18, 0x013C	; 0x80013c <a_min_count>
     4d0:	27 ff       	sbrs	r18, 7
     4d2:	4b cf       	rjmp	.-362    	; 0x36a <read_encoder+0x56>
	       a_min_count = 59;
     4d4:	2b e3       	ldi	r18, 0x3B	; 59
     4d6:	20 93 3c 01 	sts	0x013C, r18	; 0x80013c <a_min_count>
     4da:	63 cf       	rjmp	.-314    	; 0x3a2 <read_encoder+0x8e>
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
            a_min_count = a_min_count + 1;//value = value;
     4dc:	20 91 3c 01 	lds	r18, 0x013C	; 0x80013c <a_min_count>
     4e0:	2f 5f       	subi	r18, 0xFF	; 255
     4e2:	20 93 3c 01 	sts	0x013C, r18	; 0x80013c <a_min_count>
	    if(a_min_count == 60){
     4e6:	20 91 3c 01 	lds	r18, 0x013C	; 0x80013c <a_min_count>
     4ea:	2c 33       	cpi	r18, 0x3C	; 60
     4ec:	09 f0       	breq	.+2      	; 0x4f0 <__LOCK_REGION_LENGTH__+0xf0>
     4ee:	3d cf       	rjmp	.-390    	; 0x36a <read_encoder+0x56>
	       a_min_count = 0; 
     4f0:	10 92 3c 01 	sts	0x013C, r1	; 0x80013c <a_min_count>
	       a_hour_count++;
     4f4:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <a_hour_count>
     4f8:	2f 5f       	subi	r18, 0xFF	; 255
     4fa:	20 93 3b 01 	sts	0x013B, r18	; 0x80013b <a_hour_count>
	       if(a_hour_count > 23)
     4fe:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <a_hour_count>
     502:	28 31       	cpi	r18, 0x18	; 24
     504:	0c f4       	brge	.+2      	; 0x508 <__LOCK_REGION_LENGTH__+0x108>
     506:	31 cf       	rjmp	.-414    	; 0x36a <read_encoder+0x56>
     508:	d9 cf       	rjmp	.-78     	; 0x4bc <__LOCK_REGION_LENGTH__+0xbc>

0000050a <__vector_16>:
	update the mode and bargraph. Then I change the sum based on	
	the value returned from the encoder reading. Sum is then bounded
	from 0-1023. 1023+1=1 and 0-any number > 0 = 1023.
Parameters: NA
**********************************************************************/
ISR(TIMER0_OVF_vect) {
     50a:	1f 92       	push	r1
     50c:	0f 92       	push	r0
     50e:	0f b6       	in	r0, 0x3f	; 63
     510:	0f 92       	push	r0
     512:	11 24       	eor	r1, r1
     514:	0b b6       	in	r0, 0x3b	; 59
     516:	0f 92       	push	r0
     518:	2f 93       	push	r18
     51a:	3f 93       	push	r19
     51c:	4f 93       	push	r20
     51e:	5f 93       	push	r21
     520:	6f 93       	push	r22
     522:	7f 93       	push	r23
     524:	8f 93       	push	r24
     526:	9f 93       	push	r25
     528:	af 93       	push	r26
     52a:	bf 93       	push	r27
     52c:	ef 93       	push	r30
     52e:	ff 93       	push	r31
   static uint8_t count_7_8125ms = 0;

   count_7_8125ms++;
     530:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <count_7_8125ms.2010>
     534:	8f 5f       	subi	r24, 0xFF	; 255
     536:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <count_7_8125ms.2010>
   if((count_7_8125ms % 128) == 0) { //interrupts every 1 second
     53a:	8f 77       	andi	r24, 0x7F	; 127
     53c:	29 f4       	brne	.+10     	; 0x548 <__vector_16+0x3e>
      sec_count++;
     53e:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <sec_count>
     542:	8f 5f       	subi	r24, 0xFF	; 255
     544:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <sec_count>
   }
   bars();  
     548:	0e 94 d6 00 	call	0x1ac	; 0x1ac <bars>
   read_encoder();      
     54c:	0e 94 8a 01 	call	0x314	; 0x314 <read_encoder>

}
     550:	ff 91       	pop	r31
     552:	ef 91       	pop	r30
     554:	bf 91       	pop	r27
     556:	af 91       	pop	r26
     558:	9f 91       	pop	r25
     55a:	8f 91       	pop	r24
     55c:	7f 91       	pop	r23
     55e:	6f 91       	pop	r22
     560:	5f 91       	pop	r21
     562:	4f 91       	pop	r20
     564:	3f 91       	pop	r19
     566:	2f 91       	pop	r18
     568:	0f 90       	pop	r0
     56a:	0b be       	out	0x3b, r0	; 59
     56c:	0f 90       	pop	r0
     56e:	0f be       	out	0x3f, r0	; 63
     570:	0f 90       	pop	r0
     572:	1f 90       	pop	r1
     574:	18 95       	reti

00000576 <clock_time>:
Description:
Parameters:
**********************************************************************/
void clock_time(){ //by default we use military time
   
   if(sec_count == 60){
     576:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <sec_count>
     57a:	8c 33       	cpi	r24, 0x3C	; 60
     57c:	09 f4       	brne	.+2      	; 0x580 <clock_time+0xa>
     57e:	a4 c0       	rjmp	.+328    	; 0x6c8 <clock_time+0x152>
         hour_count = 12;
      }    
   }*/

//This is where the digits are written to the data array
      if(mode_sel == 2){
     580:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <mode_sel>
     584:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <mode_sel+0x1>
     588:	02 97       	sbiw	r24, 0x02	; 2
     58a:	09 f4       	brne	.+2      	; 0x58e <clock_time+0x18>
     58c:	5a c0       	rjmp	.+180    	; 0x642 <clock_time+0xcc>
         else {segment_data[2] = 0b111;}		//Turn colon off
         segment_data[1] = dec_to_7seg[a_min_count/10];
         segment_data[0] = dec_to_7seg[a_min_count%10];
      }
      else{
         segment_data[4] = dec_to_7seg[hour_count/10];
     58e:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <hour_count>
     592:	87 e6       	ldi	r24, 0x67	; 103
     594:	98 02       	muls	r25, r24
     596:	e1 2d       	mov	r30, r1
     598:	11 24       	eor	r1, r1
     59a:	e5 95       	asr	r30
     59c:	e5 95       	asr	r30
     59e:	97 fd       	sbrc	r25, 7
     5a0:	e3 95       	inc	r30
     5a2:	0e 2e       	mov	r0, r30
     5a4:	00 0c       	add	r0, r0
     5a6:	ff 0b       	sbc	r31, r31
     5a8:	e0 50       	subi	r30, 0x00	; 0
     5aa:	ff 4f       	sbci	r31, 0xFF	; 255
     5ac:	90 81       	ld	r25, Z
     5ae:	90 93 30 01 	sts	0x0130, r25	; 0x800130 <__data_end+0x4>
         segment_data[3] = dec_to_7seg[hour_count%10];
     5b2:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <hour_count>
     5b6:	e8 02       	muls	r30, r24
     5b8:	81 2d       	mov	r24, r1
     5ba:	11 24       	eor	r1, r1
     5bc:	85 95       	asr	r24
     5be:	85 95       	asr	r24
     5c0:	e7 fd       	sbrc	r30, 7
     5c2:	83 95       	inc	r24
     5c4:	9a e0       	ldi	r25, 0x0A	; 10
     5c6:	89 9f       	mul	r24, r25
     5c8:	e0 19       	sub	r30, r0
     5ca:	11 24       	eor	r1, r1
     5cc:	0e 2e       	mov	r0, r30
     5ce:	00 0c       	add	r0, r0
     5d0:	ff 0b       	sbc	r31, r31
     5d2:	e0 50       	subi	r30, 0x00	; 0
     5d4:	ff 4f       	sbci	r31, 0xFF	; 255
     5d6:	80 81       	ld	r24, Z
     5d8:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <__data_end+0x3>
         //if(sec_count%2 && alarm){segment_data[2] = 0b000;}		//Turn colon on
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     5dc:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <sec_count>
     5e0:	80 fd       	sbrc	r24, 0
     5e2:	2b c0       	rjmp	.+86     	; 0x63a <clock_time+0xc4>
         //else if(alarm){segment_data[2] = 0b011;}		//Turn colon off
         else {segment_data[2] = 0b111;}		//Turn colon off
     5e4:	87 e0       	ldi	r24, 0x07	; 7
     5e6:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <__data_end+0x2>
         segment_data[1] = dec_to_7seg[min_count/10];
     5ea:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <min_count>
     5ee:	87 e6       	ldi	r24, 0x67	; 103
     5f0:	98 02       	muls	r25, r24
     5f2:	e1 2d       	mov	r30, r1
     5f4:	11 24       	eor	r1, r1
     5f6:	e5 95       	asr	r30
     5f8:	e5 95       	asr	r30
     5fa:	97 fd       	sbrc	r25, 7
     5fc:	e3 95       	inc	r30
     5fe:	0e 2e       	mov	r0, r30
     600:	00 0c       	add	r0, r0
     602:	ff 0b       	sbc	r31, r31
     604:	e0 50       	subi	r30, 0x00	; 0
     606:	ff 4f       	sbci	r31, 0xFF	; 255
     608:	90 81       	ld	r25, Z
     60a:	90 93 2d 01 	sts	0x012D, r25	; 0x80012d <__data_end+0x1>
         segment_data[0] = dec_to_7seg[min_count%10];
     60e:	e0 91 3f 01 	lds	r30, 0x013F	; 0x80013f <min_count>
     612:	e8 02       	muls	r30, r24
     614:	81 2d       	mov	r24, r1
     616:	11 24       	eor	r1, r1
     618:	85 95       	asr	r24
     61a:	85 95       	asr	r24
     61c:	e7 fd       	sbrc	r30, 7
     61e:	83 95       	inc	r24
     620:	9a e0       	ldi	r25, 0x0A	; 10
     622:	89 9f       	mul	r24, r25
     624:	e0 19       	sub	r30, r0
     626:	11 24       	eor	r1, r1
     628:	0e 2e       	mov	r0, r30
     62a:	00 0c       	add	r0, r0
     62c:	ff 0b       	sbc	r31, r31
     62e:	e0 50       	subi	r30, 0x00	; 0
     630:	ff 4f       	sbci	r31, 0xFF	; 255
     632:	80 81       	ld	r24, Z
     634:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <__data_end>
     638:	08 95       	ret
      }
      else{
         segment_data[4] = dec_to_7seg[hour_count/10];
         segment_data[3] = dec_to_7seg[hour_count%10];
         //if(sec_count%2 && alarm){segment_data[2] = 0b000;}		//Turn colon on
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     63a:	84 e0       	ldi	r24, 0x04	; 4
     63c:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <__data_end+0x2>
     640:	d4 cf       	rjmp	.-88     	; 0x5ea <clock_time+0x74>
      }    
   }*/

//This is where the digits are written to the data array
      if(mode_sel == 2){
         segment_data[4] = dec_to_7seg[a_hour_count/10];
     642:	90 91 3b 01 	lds	r25, 0x013B	; 0x80013b <a_hour_count>
     646:	87 e6       	ldi	r24, 0x67	; 103
     648:	98 02       	muls	r25, r24
     64a:	e1 2d       	mov	r30, r1
     64c:	11 24       	eor	r1, r1
     64e:	e5 95       	asr	r30
     650:	e5 95       	asr	r30
     652:	97 fd       	sbrc	r25, 7
     654:	e3 95       	inc	r30
     656:	0e 2e       	mov	r0, r30
     658:	00 0c       	add	r0, r0
     65a:	ff 0b       	sbc	r31, r31
     65c:	e0 50       	subi	r30, 0x00	; 0
     65e:	ff 4f       	sbci	r31, 0xFF	; 255
     660:	90 81       	ld	r25, Z
     662:	90 93 30 01 	sts	0x0130, r25	; 0x800130 <__data_end+0x4>
         segment_data[3] = dec_to_7seg[a_hour_count%10];
     666:	e0 91 3b 01 	lds	r30, 0x013B	; 0x80013b <a_hour_count>
     66a:	e8 02       	muls	r30, r24
     66c:	81 2d       	mov	r24, r1
     66e:	11 24       	eor	r1, r1
     670:	85 95       	asr	r24
     672:	85 95       	asr	r24
     674:	e7 fd       	sbrc	r30, 7
     676:	83 95       	inc	r24
     678:	9a e0       	ldi	r25, 0x0A	; 10
     67a:	89 9f       	mul	r24, r25
     67c:	e0 19       	sub	r30, r0
     67e:	11 24       	eor	r1, r1
     680:	0e 2e       	mov	r0, r30
     682:	00 0c       	add	r0, r0
     684:	ff 0b       	sbc	r31, r31
     686:	e0 50       	subi	r30, 0x00	; 0
     688:	ff 4f       	sbci	r31, 0xFF	; 255
     68a:	80 81       	ld	r24, Z
     68c:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <__data_end+0x3>
         //if(sec_count%2 && alarm){segment_data[2] = 0b000;}		//Turn colon on
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     690:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <sec_count>
     694:	80 fd       	sbrc	r24, 0
     696:	33 c0       	rjmp	.+102    	; 0x6fe <clock_time+0x188>
        // else if(alarm){segment_data[2] = 0b011;}		//Turn colon off
         else {segment_data[2] = 0b111;}		//Turn colon off
     698:	87 e0       	ldi	r24, 0x07	; 7
     69a:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <__data_end+0x2>
         segment_data[1] = dec_to_7seg[a_min_count/10];
     69e:	90 91 3c 01 	lds	r25, 0x013C	; 0x80013c <a_min_count>
     6a2:	87 e6       	ldi	r24, 0x67	; 103
     6a4:	98 02       	muls	r25, r24
     6a6:	e1 2d       	mov	r30, r1
     6a8:	11 24       	eor	r1, r1
     6aa:	e5 95       	asr	r30
     6ac:	e5 95       	asr	r30
     6ae:	97 fd       	sbrc	r25, 7
     6b0:	e3 95       	inc	r30
     6b2:	0e 2e       	mov	r0, r30
     6b4:	00 0c       	add	r0, r0
     6b6:	ff 0b       	sbc	r31, r31
     6b8:	e0 50       	subi	r30, 0x00	; 0
     6ba:	ff 4f       	sbci	r31, 0xFF	; 255
     6bc:	90 81       	ld	r25, Z
     6be:	90 93 2d 01 	sts	0x012D, r25	; 0x80012d <__data_end+0x1>
         segment_data[0] = dec_to_7seg[a_min_count%10];
     6c2:	e0 91 3c 01 	lds	r30, 0x013C	; 0x80013c <a_min_count>
     6c6:	a5 cf       	rjmp	.-182    	; 0x612 <clock_time+0x9c>
Parameters:
**********************************************************************/
void clock_time(){ //by default we use military time
   
   if(sec_count == 60){
      min_count++;
     6c8:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <min_count>
     6cc:	8f 5f       	subi	r24, 0xFF	; 255
     6ce:	80 93 3f 01 	sts	0x013F, r24	; 0x80013f <min_count>
      sec_count = 0;
     6d2:	10 92 40 01 	sts	0x0140, r1	; 0x800140 <sec_count>
      if(min_count == 60){
     6d6:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <min_count>
     6da:	8c 33       	cpi	r24, 0x3C	; 60
     6dc:	09 f0       	breq	.+2      	; 0x6e0 <clock_time+0x16a>
     6de:	50 cf       	rjmp	.-352    	; 0x580 <clock_time+0xa>
	 hour_count++;
     6e0:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <hour_count>
     6e4:	8f 5f       	subi	r24, 0xFF	; 255
     6e6:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <hour_count>
	 min_count = 0;
     6ea:	10 92 3f 01 	sts	0x013F, r1	; 0x80013f <min_count>
	 if(hour_count == 24){
     6ee:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <hour_count>
     6f2:	88 31       	cpi	r24, 0x18	; 24
     6f4:	09 f0       	breq	.+2      	; 0x6f8 <clock_time+0x182>
     6f6:	44 cf       	rjmp	.-376    	; 0x580 <clock_time+0xa>
	    hour_count = 0;
     6f8:	10 92 3e 01 	sts	0x013E, r1	; 0x80013e <hour_count>
     6fc:	41 cf       	rjmp	.-382    	; 0x580 <clock_time+0xa>
//This is where the digits are written to the data array
      if(mode_sel == 2){
         segment_data[4] = dec_to_7seg[a_hour_count/10];
         segment_data[3] = dec_to_7seg[a_hour_count%10];
         //if(sec_count%2 && alarm){segment_data[2] = 0b000;}		//Turn colon on
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     6fe:	84 e0       	ldi	r24, 0x04	; 4
     700:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <__data_end+0x2>
     704:	cc cf       	rjmp	.-104    	; 0x69e <clock_time+0x128>

00000706 <port_init>:
Function:
Description:
Parameters:
**********************************************************************/
void port_init(){
   DDRC |= 0xFF; 
     706:	84 b3       	in	r24, 0x14	; 20
     708:	9f ef       	ldi	r25, 0xFF	; 255
     70a:	94 bb       	out	0x14, r25	; 20
   DDRB |= 0xF0;				//PB4-6 is SEL0-2, PB7 is PWM
     70c:	87 b3       	in	r24, 0x17	; 23
     70e:	80 6f       	ori	r24, 0xF0	; 240
     710:	87 bb       	out	0x17, r24	; 23
   DDRE |= 0x40;				//PE6 is SHIFT_LD_N
     712:	16 9a       	sbi	0x02, 6	; 2
   DDRD |= 0x0B;				//PE1 is CLK_INH and PE2 is SRCLK
     714:	81 b3       	in	r24, 0x11	; 17
     716:	8b 60       	ori	r24, 0x0B	; 11
     718:	81 bb       	out	0x11, r24	; 17
   PORTC |= 0x01;
     71a:	a8 9a       	sbi	0x15, 0	; 21
   PORTD |= 0x02;
     71c:	91 9a       	sbi	0x12, 1	; 18
   PORTE |= 0xFF;
     71e:	83 b1       	in	r24, 0x03	; 3
     720:	93 b9       	out	0x03, r25	; 3
     722:	08 95       	ret

00000724 <change_alarm_state>:
/**********************************************************************
Function:
Description:
Parameters:
**********************************************************************/
void change_alarm_state(){
     724:	0f 93       	push	r16
   static uint8_t curr = 0;
   if(alarm && (curr == 0)){
     726:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <alarm>
     72a:	88 23       	and	r24, r24
     72c:	c1 f1       	breq	.+112    	; 0x79e <change_alarm_state+0x7a>
     72e:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <curr.2017>
     732:	81 11       	cpse	r24, r1
     734:	34 c0       	rjmp	.+104    	; 0x79e <change_alarm_state+0x7a>
      if((a_hour_count > 9) && (a_min_count > 9)){
     736:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <a_hour_count>
     73a:	8a 30       	cpi	r24, 0x0A	; 10
     73c:	2c f0       	brlt	.+10     	; 0x748 <change_alarm_state+0x24>
     73e:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <a_min_count>
     742:	8a 30       	cpi	r24, 0x0A	; 10
     744:	0c f0       	brlt	.+2      	; 0x748 <change_alarm_state+0x24>
     746:	5d c0       	rjmp	.+186    	; 0x802 <change_alarm_state+0xde>
         string2lcd("ALARM at ");
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         lcd_int16(a_min_count, 2, 0, 0, 0);
      }
      else if(a_hour_count > 9){
     748:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <a_hour_count>
     74c:	8a 30       	cpi	r24, 0x0A	; 10
     74e:	a4 f5       	brge	.+104    	; 0x7b8 <change_alarm_state+0x94>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         string2lcd("0");
         lcd_int16(a_min_count, 1, 0, 0, 0);
      }
      else if(a_min_count > 9){
     750:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <a_min_count>
     754:	8a 30       	cpi	r24, 0x0A	; 10
     756:	0c f4       	brge	.+2      	; 0x75a <change_alarm_state+0x36>
     758:	51 c0       	rjmp	.+162    	; 0x7fc <change_alarm_state+0xd8>
         string2lcd("ALARM at");
     75a:	83 e2       	ldi	r24, 0x23	; 35
     75c:	91 e0       	ldi	r25, 0x01	; 1
     75e:	0e 94 5f 06 	call	0xcbe	; 0xcbe <string2lcd>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
     762:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <a_hour_count>
     766:	00 e0       	ldi	r16, 0x00	; 0
     768:	20 e0       	ldi	r18, 0x00	; 0
     76a:	40 e0       	ldi	r20, 0x00	; 0
     76c:	62 e0       	ldi	r22, 0x02	; 2
     76e:	08 2e       	mov	r0, r24
     770:	00 0c       	add	r0, r0
     772:	99 0b       	sbc	r25, r25
     774:	0e 94 24 08 	call	0x1048	; 0x1048 <lcd_int16>
         string2lcd(":");
     778:	8f e1       	ldi	r24, 0x1F	; 31
     77a:	91 e0       	ldi	r25, 0x01	; 1
     77c:	0e 94 5f 06 	call	0xcbe	; 0xcbe <string2lcd>
         lcd_int16(a_min_count, 2, 0, 0, 0);
     780:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <a_min_count>
     784:	20 e0       	ldi	r18, 0x00	; 0
     786:	40 e0       	ldi	r20, 0x00	; 0
     788:	62 e0       	ldi	r22, 0x02	; 2
     78a:	08 2e       	mov	r0, r24
     78c:	00 0c       	add	r0, r0
     78e:	99 0b       	sbc	r25, r25
     790:	0e 94 24 08 	call	0x1048	; 0x1048 <lcd_int16>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         string2lcd("0");
         lcd_int16(a_min_count, 1, 0, 0, 0);
      }
      curr = 1;
     794:	81 e0       	ldi	r24, 0x01	; 1
     796:	80 93 41 01 	sts	0x0141, r24	; 0x800141 <curr.2017>
   else if((!alarm) && (curr == 1)){
      curr = 0;
      clear_display();
   }
   else{}
}
     79a:	0f 91       	pop	r16
     79c:	08 95       	ret
         string2lcd("0");
         lcd_int16(a_min_count, 1, 0, 0, 0);
      }
      curr = 1;
   }
   else if((!alarm) && (curr == 1)){
     79e:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <alarm>
     7a2:	81 11       	cpse	r24, r1
     7a4:	fa cf       	rjmp	.-12     	; 0x79a <change_alarm_state+0x76>
     7a6:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <curr.2017>
     7aa:	81 30       	cpi	r24, 0x01	; 1
     7ac:	b1 f7       	brne	.-20     	; 0x79a <change_alarm_state+0x76>
      curr = 0;
     7ae:	10 92 41 01 	sts	0x0141, r1	; 0x800141 <curr.2017>
      clear_display();
   }
   else{}
}
     7b2:	0f 91       	pop	r16
      }
      curr = 1;
   }
   else if((!alarm) && (curr == 1)){
      curr = 0;
      clear_display();
     7b4:	0c 94 d7 05 	jmp	0xbae	; 0xbae <clear_display>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         lcd_int16(a_min_count, 2, 0, 0, 0);
      }
      else if(a_hour_count > 9){
         string2lcd("ALARM at ");
     7b8:	85 e1       	ldi	r24, 0x15	; 21
     7ba:	91 e0       	ldi	r25, 0x01	; 1
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         lcd_int16(a_min_count, 2, 0, 0, 0);
      }
      else {
         string2lcd("ALARM at");
     7bc:	0e 94 5f 06 	call	0xcbe	; 0xcbe <string2lcd>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
     7c0:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <a_hour_count>
     7c4:	00 e0       	ldi	r16, 0x00	; 0
     7c6:	20 e0       	ldi	r18, 0x00	; 0
     7c8:	40 e0       	ldi	r20, 0x00	; 0
     7ca:	62 e0       	ldi	r22, 0x02	; 2
     7cc:	08 2e       	mov	r0, r24
     7ce:	00 0c       	add	r0, r0
     7d0:	99 0b       	sbc	r25, r25
     7d2:	0e 94 24 08 	call	0x1048	; 0x1048 <lcd_int16>
         string2lcd(":");
     7d6:	8f e1       	ldi	r24, 0x1F	; 31
     7d8:	91 e0       	ldi	r25, 0x01	; 1
     7da:	0e 94 5f 06 	call	0xcbe	; 0xcbe <string2lcd>
         string2lcd("0");
     7de:	81 e2       	ldi	r24, 0x21	; 33
     7e0:	91 e0       	ldi	r25, 0x01	; 1
     7e2:	0e 94 5f 06 	call	0xcbe	; 0xcbe <string2lcd>
         lcd_int16(a_min_count, 1, 0, 0, 0);
     7e6:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <a_min_count>
     7ea:	20 e0       	ldi	r18, 0x00	; 0
     7ec:	40 e0       	ldi	r20, 0x00	; 0
     7ee:	61 e0       	ldi	r22, 0x01	; 1
     7f0:	08 2e       	mov	r0, r24
     7f2:	00 0c       	add	r0, r0
     7f4:	99 0b       	sbc	r25, r25
     7f6:	0e 94 24 08 	call	0x1048	; 0x1048 <lcd_int16>
     7fa:	cc cf       	rjmp	.-104    	; 0x794 <change_alarm_state+0x70>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         lcd_int16(a_min_count, 2, 0, 0, 0);
      }
      else {
         string2lcd("ALARM at");
     7fc:	83 e2       	ldi	r24, 0x23	; 35
     7fe:	91 e0       	ldi	r25, 0x01	; 1
     800:	dd cf       	rjmp	.-70     	; 0x7bc <change_alarm_state+0x98>
**********************************************************************/
void change_alarm_state(){
   static uint8_t curr = 0;
   if(alarm && (curr == 0)){
      if((a_hour_count > 9) && (a_min_count > 9)){
         string2lcd("ALARM at ");
     802:	85 e1       	ldi	r24, 0x15	; 21
     804:	91 e0       	ldi	r25, 0x01	; 1
     806:	ab cf       	rjmp	.-170    	; 0x75e <change_alarm_state+0x3a>

00000808 <adc_init>:
Description:
Parameters:
**********************************************************************/
void adc_init(){
//Initalize ADC and its ports
   DDRF  &= ~(_BV(DDF7)); //make port F bit 7 is ADC input  
     808:	e1 e6       	ldi	r30, 0x61	; 97
     80a:	f0 e0       	ldi	r31, 0x00	; 0
     80c:	80 81       	ld	r24, Z
     80e:	8f 77       	andi	r24, 0x7F	; 127
     810:	80 83       	st	Z, r24
   PORTF &= ~(_BV(PF7));  //port F bit 7 pullups must be off
     812:	e2 e6       	ldi	r30, 0x62	; 98
     814:	f0 e0       	ldi	r31, 0x00	; 0
     816:	80 81       	ld	r24, Z
     818:	8f 77       	andi	r24, 0x7F	; 127
     81a:	80 83       	st	Z, r24
   ADMUX |= (1<<REFS0) | (1<<MUX2)| (1<<MUX1)| (1<<MUX0); //single-ended, input PORTF bit 7, right adjusted, 10 bits
     81c:	87 b1       	in	r24, 0x07	; 7
     81e:	87 64       	ori	r24, 0x47	; 71
     820:	87 b9       	out	0x07, r24	; 7

   ADCSRA |= (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);//ADC enabled, don't start yet, single shot mode 
     822:	86 b1       	in	r24, 0x06	; 6
     824:	87 68       	ori	r24, 0x87	; 135
     826:	86 b9       	out	0x06, r24	; 6
     828:	08 95       	ret

0000082a <fetch_adc>:
void fetch_adc(){
   uint16_t adc_result;
   uint16_t step;   
   uint16_t step2;   

   ADCSRA |= (1<<ADSC); //poke ADSC and start conversion
     82a:	36 9a       	sbi	0x06, 6	; 6
   while(bit_is_clear(ADCSRA, ADIF)){} //spin while interrupt flag not set
     82c:	34 9b       	sbis	0x06, 4	; 6
     82e:	fe cf       	rjmp	.-4      	; 0x82c <fetch_adc+0x2>
   ACSR |= (1<<ACI); //its done, clear flag by writing a one 
     830:	44 9a       	sbi	0x08, 4	; 8
   adc_result = ADC;                      //read the ADC output as 16 bits
     832:	24 b1       	in	r18, 0x04	; 4
     834:	35 b1       	in	r19, 0x05	; 5

   step = adc_result/4;
   step2 =  256 - step;
     836:	36 95       	lsr	r19
     838:	27 95       	ror	r18
     83a:	36 95       	lsr	r19
     83c:	27 95       	ror	r18
   if(step2 > 235){
      step2 = 235;
   }
   OCR2 = step2;
     83e:	80 e0       	ldi	r24, 0x00	; 0
     840:	91 e0       	ldi	r25, 0x01	; 1
     842:	82 1b       	sub	r24, r18
     844:	93 0b       	sbc	r25, r19
     846:	8c 3e       	cpi	r24, 0xEC	; 236
     848:	91 05       	cpc	r25, r1
     84a:	10 f0       	brcs	.+4      	; 0x850 <fetch_adc+0x26>
     84c:	8b ee       	ldi	r24, 0xEB	; 235
     84e:	90 e0       	ldi	r25, 0x00	; 0
     850:	83 bd       	out	0x23, r24	; 35
     852:	08 95       	ret

00000854 <alarm_sound>:
Function:
Description:
Parameters:
**********************************************************************/
void alarm_sound() {
   if(alarm && ((hour_count == a_hour_count) && (min_count == a_min_count))){
     854:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <alarm>
     858:	88 23       	and	r24, r24
     85a:	31 f0       	breq	.+12     	; 0x868 <alarm_sound+0x14>
     85c:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <hour_count>
     860:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <a_hour_count>
     864:	98 17       	cp	r25, r24
     866:	29 f0       	breq	.+10     	; 0x872 <alarm_sound+0x1e>
      OCR3A = 158;
   }
   else {
      OCR3A = 0;
     868:	10 92 87 00 	sts	0x0087, r1	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     86c:	10 92 86 00 	sts	0x0086, r1	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
     870:	08 95       	ret
Function:
Description:
Parameters:
**********************************************************************/
void alarm_sound() {
   if(alarm && ((hour_count == a_hour_count) && (min_count == a_min_count))){
     872:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <min_count>
     876:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <a_min_count>
     87a:	98 13       	cpse	r25, r24
     87c:	f5 cf       	rjmp	.-22     	; 0x868 <alarm_sound+0x14>
      OCR3A = 158;
     87e:	8e e9       	ldi	r24, 0x9E	; 158
     880:	90 e0       	ldi	r25, 0x00	; 0
     882:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     886:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
     88a:	08 95       	ret

0000088c <send_lcd>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     88c:	91 e0       	ldi	r25, 0x01	; 1
     88e:	81 11       	cpse	r24, r1
     890:	01 c0       	rjmp	.+2      	; 0x894 <send_lcd+0x8>
     892:	90 e0       	ldi	r25, 0x00	; 0
     894:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     896:	77 9b       	sbis	0x0e, 7	; 14
     898:	fe cf       	rjmp	.-4      	; 0x896 <send_lcd+0xa>
  SPDR = byte;                        //send payload
     89a:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     89c:	77 9b       	sbis	0x0e, 7	; 14
     89e:	fe cf       	rjmp	.-4      	; 0x89c <send_lcd+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     8a0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8a4:	88 60       	ori	r24, 0x08	; 8
     8a6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8aa:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8ae:	87 7f       	andi	r24, 0xF7	; 247
     8b0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8b4:	08 95       	ret

000008b6 <refresh_lcd>:
//
void refresh_lcd(char lcd_string_array[]) {

  static uint8_t i=0;           // index into string array 

 send_lcd(CHAR_BYTE,lcd_string_array[i]);
     8b6:	20 91 53 01 	lds	r18, 0x0153	; 0x800153 <i.2095>
     8ba:	82 0f       	add	r24, r18
     8bc:	91 1d       	adc	r25, r1
     8be:	fc 01       	movw	r30, r24
     8c0:	80 81       	ld	r24, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     8c2:	91 e0       	ldi	r25, 0x01	; 1
     8c4:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     8c6:	77 9b       	sbis	0x0e, 7	; 14
     8c8:	fe cf       	rjmp	.-4      	; 0x8c6 <refresh_lcd+0x10>
  SPDR = byte;                        //send payload
     8ca:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     8cc:	77 9b       	sbis	0x0e, 7	; 14
     8ce:	fe cf       	rjmp	.-4      	; 0x8cc <refresh_lcd+0x16>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     8d0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8d4:	88 60       	ori	r24, 0x08	; 8
     8d6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8da:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     8de:	87 7f       	andi	r24, 0xF7	; 247
     8e0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
void refresh_lcd(char lcd_string_array[]) {

  static uint8_t i=0;           // index into string array 

 send_lcd(CHAR_BYTE,lcd_string_array[i]);
 i++;   //increment to next character
     8e4:	80 91 53 01 	lds	r24, 0x0153	; 0x800153 <i.2095>
     8e8:	8f 5f       	subi	r24, 0xFF	; 255
     8ea:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <i.2095>
 //delays are inserted to allow character to be written before moving
 //the cursor to the next line.
 if(i == 16){_delay_us(40); line2_col1();      } //goto line 2, 1st char 
     8ee:	80 31       	cpi	r24, 0x10	; 16
     8f0:	f9 f0       	breq	.+62     	; 0x930 <refresh_lcd+0x7a>
 if(i == 32){_delay_us(40); line1_col1(); i=0; } //goto line 1, 1st char 
     8f2:	80 32       	cpi	r24, 0x20	; 32
     8f4:	09 f0       	breq	.+2      	; 0x8f8 <refresh_lcd+0x42>
     8f6:	08 95       	ret
     8f8:	e5 ed       	ldi	r30, 0xD5	; 213
     8fa:	ea 95       	dec	r30
     8fc:	f1 f7       	brne	.-4      	; 0x8fa <refresh_lcd+0x44>
     8fe:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     900:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     902:	77 9b       	sbis	0x0e, 7	; 14
     904:	fe cf       	rjmp	.-4      	; 0x902 <refresh_lcd+0x4c>
  SPDR = byte;                        //send payload
     906:	80 e8       	ldi	r24, 0x80	; 128
     908:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     90a:	77 9b       	sbis	0x0e, 7	; 14
     90c:	fe cf       	rjmp	.-4      	; 0x90a <refresh_lcd+0x54>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     90e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     912:	88 60       	ori	r24, 0x08	; 8
     914:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     918:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     91c:	87 7f       	andi	r24, 0xF7	; 247
     91e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     922:	f5 ed       	ldi	r31, 0xD5	; 213
     924:	fa 95       	dec	r31
     926:	f1 f7       	brne	.-4      	; 0x924 <refresh_lcd+0x6e>
     928:	00 00       	nop
 send_lcd(CHAR_BYTE,lcd_string_array[i]);
 i++;   //increment to next character
 //delays are inserted to allow character to be written before moving
 //the cursor to the next line.
 if(i == 16){_delay_us(40); line2_col1();      } //goto line 2, 1st char 
 if(i == 32){_delay_us(40); line1_col1(); i=0; } //goto line 1, 1st char 
     92a:	10 92 53 01 	sts	0x0153, r1	; 0x800153 <i.2095>
     92e:	08 95       	ret
     930:	f5 ed       	ldi	r31, 0xD5	; 213
     932:	fa 95       	dec	r31
     934:	f1 f7       	brne	.-4      	; 0x932 <refresh_lcd+0x7c>
     936:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     938:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     93a:	77 9b       	sbis	0x0e, 7	; 14
     93c:	fe cf       	rjmp	.-4      	; 0x93a <refresh_lcd+0x84>
  SPDR = byte;                        //send payload
     93e:	80 ec       	ldi	r24, 0xC0	; 192
     940:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     942:	77 9b       	sbis	0x0e, 7	; 14
     944:	fe cf       	rjmp	.-4      	; 0x942 <refresh_lcd+0x8c>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     946:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     94a:	88 60       	ori	r24, 0x08	; 8
     94c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     950:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     954:	87 7f       	andi	r24, 0xF7	; 247
     956:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     95a:	85 ed       	ldi	r24, 0xD5	; 213
     95c:	8a 95       	dec	r24
     95e:	f1 f7       	brne	.-4      	; 0x95c <refresh_lcd+0xa6>
     960:	00 00       	nop
     962:	80 91 53 01 	lds	r24, 0x0153	; 0x800153 <i.2095>
     966:	c5 cf       	rjmp	.-118    	; 0x8f2 <refresh_lcd+0x3c>

00000968 <set_custom_character>:
//address, such as send_lcd(CHAR_BYTE, 0x01, 1) or it can be insteretd into a string 
//via a forward slash escape as in string2lcd("this is my music note \1")

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
     968:	66 0f       	add	r22, r22
     96a:	66 0f       	add	r22, r22
     96c:	66 0f       	add	r22, r22
     96e:	60 5c       	subi	r22, 0xC0	; 192
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     970:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     972:	77 9b       	sbis	0x0e, 7	; 14
     974:	fe cf       	rjmp	.-4      	; 0x972 <set_custom_character+0xa>
  SPDR = byte;                        //send payload
     976:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     978:	77 9b       	sbis	0x0e, 7	; 14
     97a:	fe cf       	rjmp	.-4      	; 0x978 <set_custom_character+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     97c:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     980:	28 60       	ori	r18, 0x08	; 8
     982:	20 93 62 00 	sts	0x0062, r18	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     986:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     98a:	27 7f       	andi	r18, 0xF7	; 247
     98c:	20 93 62 00 	sts	0x0062, r18	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     990:	25 ed       	ldi	r18, 0xD5	; 213
     992:	2a 95       	dec	r18
     994:	f1 f7       	brne	.-4      	; 0x992 <set_custom_character+0x2a>
     996:	00 00       	nop
     998:	fc 01       	movw	r30, r24
     99a:	9c 01       	movw	r18, r24
     99c:	28 5f       	subi	r18, 0xF8	; 248
     99e:	3f 4f       	sbci	r19, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     9a0:	91 e0       	ldi	r25, 0x01	; 1

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
    for(i=0; i<8; i++){
      send_lcd(CHAR_BYTE, data[i]); _delay_us(40); //each char byte takes 37us to execute
     9a2:	81 91       	ld	r24, Z+
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     9a4:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     9a6:	77 9b       	sbis	0x0e, 7	; 14
     9a8:	fe cf       	rjmp	.-4      	; 0x9a6 <set_custom_character+0x3e>
  SPDR = byte;                        //send payload
     9aa:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     9ac:	77 9b       	sbis	0x0e, 7	; 14
     9ae:	fe cf       	rjmp	.-4      	; 0x9ac <set_custom_character+0x44>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     9b0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9b4:	88 60       	ori	r24, 0x08	; 8
     9b6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9ba:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9be:	87 7f       	andi	r24, 0xF7	; 247
     9c0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9c4:	85 ed       	ldi	r24, 0xD5	; 213
     9c6:	8a 95       	dec	r24
     9c8:	f1 f7       	brne	.-4      	; 0x9c6 <set_custom_character+0x5e>
     9ca:	00 00       	nop
//via a forward slash escape as in string2lcd("this is my music note \1")

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
    for(i=0; i<8; i++){
     9cc:	e2 17       	cp	r30, r18
     9ce:	f3 07       	cpc	r31, r19
     9d0:	41 f7       	brne	.-48     	; 0x9a2 <set_custom_character+0x3a>
      send_lcd(CHAR_BYTE, data[i]); _delay_us(40); //each char byte takes 37us to execute
    }
}
     9d2:	08 95       	ret

000009d4 <set_cursor>:
//                          set_cursor 
//
//Sets the cursor to an arbitrary potition on the screen, row is either 1 or 2
//col is a number form 0-15, counting from left to right
void set_cursor(uint8_t row, uint8_t col){
    send_lcd(CMD_BYTE, 0x80 + col + ((row-1)*0x40));
     9d4:	90 e4       	ldi	r25, 0x40	; 64
     9d6:	89 9f       	mul	r24, r25
     9d8:	60 0d       	add	r22, r0
     9da:	11 24       	eor	r1, r1
     9dc:	60 5c       	subi	r22, 0xC0	; 192
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     9de:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     9e0:	77 9b       	sbis	0x0e, 7	; 14
     9e2:	fe cf       	rjmp	.-4      	; 0x9e0 <set_cursor+0xc>
  SPDR = byte;                        //send payload
     9e4:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     9e6:	77 9b       	sbis	0x0e, 7	; 14
     9e8:	fe cf       	rjmp	.-4      	; 0x9e6 <set_cursor+0x12>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     9ea:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9ee:	88 60       	ori	r24, 0x08	; 8
     9f0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9f4:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9f8:	87 7f       	andi	r24, 0xF7	; 247
     9fa:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     9fe:	08 95       	ret

00000a00 <uint2lcd>:
//not displayed.  
//TODO: optimize by removing the mod operators
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
     a00:	81 11       	cpse	r24, r1
     a02:	13 c0       	rjmp	.+38     	; 0xa2a <uint2lcd+0x2a>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     a04:	81 e0       	ldi	r24, 0x01	; 1
     a06:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a08:	77 9b       	sbis	0x0e, 7	; 14
     a0a:	fe cf       	rjmp	.-4      	; 0xa08 <uint2lcd+0x8>
  SPDR = byte;                        //send payload
     a0c:	80 e3       	ldi	r24, 0x30	; 48
     a0e:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a10:	77 9b       	sbis	0x0e, 7	; 14
     a12:	fe cf       	rjmp	.-4      	; 0xa10 <uint2lcd+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     a14:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a18:	88 60       	ori	r24, 0x08	; 8
     a1a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a1e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a22:	87 7f       	andi	r24, 0xF7	; 247
     a24:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a28:	08 95       	ret
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
     a2a:	84 36       	cpi	r24, 0x64	; 100
     a2c:	b0 f4       	brcc	.+44     	; 0xa5a <uint2lcd+0x5a>
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
     a2e:	8a 30       	cpi	r24, 0x0A	; 10
     a30:	60 f5       	brcc	.+88     	; 0xa8a <uint2lcd+0x8a>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     a32:	91 e0       	ldi	r25, 0x01	; 1
     a34:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a36:	77 9b       	sbis	0x0e, 7	; 14
     a38:	fe cf       	rjmp	.-4      	; 0xa36 <uint2lcd+0x36>
void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
      if(number >= 1)  {send_lcd(CHAR_BYTE, 0x30+(number%10)    ); }
     a3a:	9d ec       	ldi	r25, 0xCD	; 205
     a3c:	89 9f       	mul	r24, r25
     a3e:	91 2d       	mov	r25, r1
     a40:	11 24       	eor	r1, r1
     a42:	96 95       	lsr	r25
     a44:	96 95       	lsr	r25
     a46:	96 95       	lsr	r25
     a48:	2a e0       	ldi	r18, 0x0A	; 10
     a4a:	92 9f       	mul	r25, r18
     a4c:	80 19       	sub	r24, r0
     a4e:	11 24       	eor	r1, r1
     a50:	80 5d       	subi	r24, 0xD0	; 208
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
  SPDR = byte;                        //send payload
     a52:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a54:	77 9b       	sbis	0x0e, 7	; 14
     a56:	fe cf       	rjmp	.-4      	; 0xa54 <uint2lcd+0x54>
     a58:	dd cf       	rjmp	.-70     	; 0xa14 <uint2lcd+0x14>
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
     a5a:	99 e2       	ldi	r25, 0x29	; 41
     a5c:	89 9f       	mul	r24, r25
     a5e:	91 2d       	mov	r25, r1
     a60:	11 24       	eor	r1, r1
     a62:	92 95       	swap	r25
     a64:	9f 70       	andi	r25, 0x0F	; 15
     a66:	90 5d       	subi	r25, 0xD0	; 208
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     a68:	21 e0       	ldi	r18, 0x01	; 1
     a6a:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a6c:	77 9b       	sbis	0x0e, 7	; 14
     a6e:	fe cf       	rjmp	.-4      	; 0xa6c <uint2lcd+0x6c>
  SPDR = byte;                        //send payload
     a70:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     a72:	77 9b       	sbis	0x0e, 7	; 14
     a74:	fe cf       	rjmp	.-4      	; 0xa72 <uint2lcd+0x72>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     a76:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a7a:	98 60       	ori	r25, 0x08	; 8
     a7c:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a80:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     a84:	97 7f       	andi	r25, 0xF7	; 247
     a86:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
     a8a:	99 e2       	ldi	r25, 0x29	; 41
     a8c:	89 9f       	mul	r24, r25
     a8e:	91 2d       	mov	r25, r1
     a90:	11 24       	eor	r1, r1
     a92:	92 95       	swap	r25
     a94:	9f 70       	andi	r25, 0x0F	; 15
     a96:	38 2f       	mov	r19, r24
     a98:	24 e6       	ldi	r18, 0x64	; 100
     a9a:	92 9f       	mul	r25, r18
     a9c:	30 19       	sub	r19, r0
     a9e:	11 24       	eor	r1, r1
     aa0:	2d ec       	ldi	r18, 0xCD	; 205
     aa2:	32 9f       	mul	r19, r18
     aa4:	91 2d       	mov	r25, r1
     aa6:	11 24       	eor	r1, r1
     aa8:	96 95       	lsr	r25
     aaa:	96 95       	lsr	r25
     aac:	96 95       	lsr	r25
     aae:	90 5d       	subi	r25, 0xD0	; 208
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ab0:	21 e0       	ldi	r18, 0x01	; 1
     ab2:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ab4:	77 9b       	sbis	0x0e, 7	; 14
     ab6:	fe cf       	rjmp	.-4      	; 0xab4 <uint2lcd+0xb4>
  SPDR = byte;                        //send payload
     ab8:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     aba:	77 9b       	sbis	0x0e, 7	; 14
     abc:	fe cf       	rjmp	.-4      	; 0xaba <uint2lcd+0xba>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     abe:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ac2:	98 60       	ori	r25, 0x08	; 8
     ac4:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ac8:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     acc:	97 7f       	andi	r25, 0xF7	; 247
     ace:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ad2:	af cf       	rjmp	.-162    	; 0xa32 <uint2lcd+0x32>

00000ad4 <int2lcd>:
//Takes a 8bit signed and displays it in base ten on the LCD. Leading 0's are 
//not displayed.
//
void int2lcd(int8_t number){
    //if < 0, print minus sign, then take 2's complement of number and display
    if(number < 0){send_lcd(CHAR_BYTE, '-'); _delay_us(40); uint2lcd(~number+1);}  
     ad4:	87 ff       	sbrs	r24, 7
    else          {uint2lcd(number);                                            }
     ad6:	0c 94 00 05 	jmp	0xa00	; 0xa00 <uint2lcd>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ada:	91 e0       	ldi	r25, 0x01	; 1
     adc:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ade:	77 9b       	sbis	0x0e, 7	; 14
     ae0:	fe cf       	rjmp	.-4      	; 0xade <int2lcd+0xa>
  SPDR = byte;                        //send payload
     ae2:	9d e2       	ldi	r25, 0x2D	; 45
     ae4:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ae6:	77 9b       	sbis	0x0e, 7	; 14
     ae8:	fe cf       	rjmp	.-4      	; 0xae6 <int2lcd+0x12>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     aea:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     aee:	98 60       	ori	r25, 0x08	; 8
     af0:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     af4:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     af8:	97 7f       	andi	r25, 0xF7	; 247
     afa:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     afe:	95 ed       	ldi	r25, 0xD5	; 213
     b00:	9a 95       	dec	r25
     b02:	f1 f7       	brne	.-4      	; 0xb00 <int2lcd+0x2c>
     b04:	00 00       	nop
//Takes a 8bit signed and displays it in base ten on the LCD. Leading 0's are 
//not displayed.
//
void int2lcd(int8_t number){
    //if < 0, print minus sign, then take 2's complement of number and display
    if(number < 0){send_lcd(CHAR_BYTE, '-'); _delay_us(40); uint2lcd(~number+1);}  
     b06:	81 95       	neg	r24
     b08:	0c 94 00 05 	jmp	0xa00	; 0xa00 <uint2lcd>

00000b0c <cursor_on>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b0c:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b0e:	77 9b       	sbis	0x0e, 7	; 14
     b10:	fe cf       	rjmp	.-4      	; 0xb0e <cursor_on+0x2>
  SPDR = byte;                        //send payload
     b12:	8e e0       	ldi	r24, 0x0E	; 14
     b14:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b16:	77 9b       	sbis	0x0e, 7	; 14
     b18:	fe cf       	rjmp	.-4      	; 0xb16 <cursor_on+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b1a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b1e:	88 60       	ori	r24, 0x08	; 8
     b20:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b24:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b28:	87 7f       	andi	r24, 0xF7	; 247
     b2a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b2e:	08 95       	ret

00000b30 <cursor_off>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b30:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b32:	77 9b       	sbis	0x0e, 7	; 14
     b34:	fe cf       	rjmp	.-4      	; 0xb32 <cursor_off+0x2>
  SPDR = byte;                        //send payload
     b36:	8c e0       	ldi	r24, 0x0C	; 12
     b38:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b3a:	77 9b       	sbis	0x0e, 7	; 14
     b3c:	fe cf       	rjmp	.-4      	; 0xb3a <cursor_off+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b3e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b42:	88 60       	ori	r24, 0x08	; 8
     b44:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b48:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b4c:	87 7f       	andi	r24, 0xF7	; 247
     b4e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b52:	08 95       	ret

00000b54 <shift_right>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b54:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b56:	77 9b       	sbis	0x0e, 7	; 14
     b58:	fe cf       	rjmp	.-4      	; 0xb56 <shift_right+0x2>
  SPDR = byte;                        //send payload
     b5a:	8e e1       	ldi	r24, 0x1E	; 30
     b5c:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b5e:	77 9b       	sbis	0x0e, 7	; 14
     b60:	fe cf       	rjmp	.-4      	; 0xb5e <shift_right+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b62:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b66:	88 60       	ori	r24, 0x08	; 8
     b68:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b6c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b70:	87 7f       	andi	r24, 0xF7	; 247
     b72:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b76:	08 95       	ret

00000b78 <shift_left>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b78:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b7a:	77 9b       	sbis	0x0e, 7	; 14
     b7c:	fe cf       	rjmp	.-4      	; 0xb7a <shift_left+0x2>
  SPDR = byte;                        //send payload
     b7e:	88 e1       	ldi	r24, 0x18	; 24
     b80:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b82:	77 9b       	sbis	0x0e, 7	; 14
     b84:	fe cf       	rjmp	.-4      	; 0xb82 <shift_left+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b86:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b8a:	88 60       	ori	r24, 0x08	; 8
     b8c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b90:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b94:	87 7f       	andi	r24, 0xF7	; 247
     b96:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b9a:	08 95       	ret

00000b9c <strobe_lcd>:
     b9c:	e2 e6       	ldi	r30, 0x62	; 98
     b9e:	f0 e0       	ldi	r31, 0x00	; 0
     ba0:	80 81       	ld	r24, Z
     ba2:	88 60       	ori	r24, 0x08	; 8
     ba4:	80 83       	st	Z, r24
     ba6:	80 81       	ld	r24, Z
     ba8:	87 7f       	andi	r24, 0xF7	; 247
     baa:	80 83       	st	Z, r24
     bac:	08 95       	ret

00000bae <clear_display>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     bae:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     bb0:	77 9b       	sbis	0x0e, 7	; 14
     bb2:	fe cf       	rjmp	.-4      	; 0xbb0 <clear_display+0x2>
  SPDR = byte;                        //send payload
     bb4:	81 e0       	ldi	r24, 0x01	; 1
     bb6:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     bb8:	77 9b       	sbis	0x0e, 7	; 14
     bba:	fe cf       	rjmp	.-4      	; 0xbb8 <clear_display+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     bbc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bc0:	88 60       	ori	r24, 0x08	; 8
     bc2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bc6:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bca:	87 7f       	andi	r24, 0xF7	; 247
     bcc:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bd0:	8f e1       	ldi	r24, 0x1F	; 31
     bd2:	9c e1       	ldi	r25, 0x1C	; 28
     bd4:	01 97       	sbiw	r24, 0x01	; 1
     bd6:	f1 f7       	brne	.-4      	; 0xbd4 <clear_display+0x26>
     bd8:	00 c0       	rjmp	.+0      	; 0xbda <clear_display+0x2c>
     bda:	00 00       	nop
     bdc:	08 95       	ret

00000bde <cursor_home>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     bde:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     be0:	77 9b       	sbis	0x0e, 7	; 14
     be2:	fe cf       	rjmp	.-4      	; 0xbe0 <cursor_home+0x2>
  SPDR = byte;                        //send payload
     be4:	82 e0       	ldi	r24, 0x02	; 2
     be6:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     be8:	77 9b       	sbis	0x0e, 7	; 14
     bea:	fe cf       	rjmp	.-4      	; 0xbe8 <cursor_home+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     bec:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bf0:	88 60       	ori	r24, 0x08	; 8
     bf2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bf6:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bfa:	87 7f       	andi	r24, 0xF7	; 247
     bfc:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c00:	8f e6       	ldi	r24, 0x6F	; 111
     c02:	97 e1       	ldi	r25, 0x17	; 23
     c04:	01 97       	sbiw	r24, 0x01	; 1
     c06:	f1 f7       	brne	.-4      	; 0xc04 <cursor_home+0x26>
     c08:	00 c0       	rjmp	.+0      	; 0xc0a <cursor_home+0x2c>
     c0a:	00 00       	nop
     c0c:	08 95       	ret

00000c0e <line2_col1>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c0e:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c10:	77 9b       	sbis	0x0e, 7	; 14
     c12:	fe cf       	rjmp	.-4      	; 0xc10 <line2_col1+0x2>
  SPDR = byte;                        //send payload
     c14:	80 ec       	ldi	r24, 0xC0	; 192
     c16:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c18:	77 9b       	sbis	0x0e, 7	; 14
     c1a:	fe cf       	rjmp	.-4      	; 0xc18 <line2_col1+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     c1c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c20:	88 60       	ori	r24, 0x08	; 8
     c22:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c26:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c2a:	87 7f       	andi	r24, 0xF7	; 247
     c2c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c30:	85 ed       	ldi	r24, 0xD5	; 213
     c32:	8a 95       	dec	r24
     c34:	f1 f7       	brne	.-4      	; 0xc32 <line2_col1+0x24>
     c36:	00 00       	nop
     c38:	08 95       	ret

00000c3a <line1_col1>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c3a:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c3c:	77 9b       	sbis	0x0e, 7	; 14
     c3e:	fe cf       	rjmp	.-4      	; 0xc3c <line1_col1+0x2>
  SPDR = byte;                        //send payload
     c40:	80 e8       	ldi	r24, 0x80	; 128
     c42:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c44:	77 9b       	sbis	0x0e, 7	; 14
     c46:	fe cf       	rjmp	.-4      	; 0xc44 <line1_col1+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     c48:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c4c:	88 60       	ori	r24, 0x08	; 8
     c4e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c52:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c56:	87 7f       	andi	r24, 0xF7	; 247
     c58:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c5c:	85 ed       	ldi	r24, 0xD5	; 213
     c5e:	8a 95       	dec	r24
     c60:	f1 f7       	brne	.-4      	; 0xc5e <line1_col1+0x24>
     c62:	00 00       	nop
     c64:	08 95       	ret

00000c66 <fill_spaces>:

//-----------------------------------------------------------------------------
//                          fill_spaces   
//
//Fill an entire line with spaces.
void fill_spaces(void){
     c66:	90 e1       	ldi	r25, 0x10	; 16
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c68:	31 e0       	ldi	r19, 0x01	; 1
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
  SPDR = byte;                        //send payload
     c6a:	20 e2       	ldi	r18, 0x20	; 32
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c6c:	3f b9       	out	0x0f, r19	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c6e:	77 9b       	sbis	0x0e, 7	; 14
     c70:	fe cf       	rjmp	.-4      	; 0xc6e <fill_spaces+0x8>
  SPDR = byte;                        //send payload
     c72:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c74:	77 9b       	sbis	0x0e, 7	; 14
     c76:	fe cf       	rjmp	.-4      	; 0xc74 <fill_spaces+0xe>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     c78:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c7c:	88 60       	ori	r24, 0x08	; 8
     c7e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c82:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c86:	87 7f       	andi	r24, 0xF7	; 247
     c88:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c8c:	85 ed       	ldi	r24, 0xD5	; 213
     c8e:	8a 95       	dec	r24
     c90:	f1 f7       	brne	.-4      	; 0xc8e <fill_spaces+0x28>
     c92:	00 00       	nop
     c94:	91 50       	subi	r25, 0x01	; 1
//                          fill_spaces   
//
//Fill an entire line with spaces.
void fill_spaces(void){
	uint8_t i;
	for (i=0; i<=(NUM_LCD_CHARS-1); i++){
     c96:	51 f7       	brne	.-44     	; 0xc6c <fill_spaces+0x6>
		send_lcd(CHAR_BYTE, ' '); 
                _delay_us(40);  //40us wait between characters
	}
}  
     c98:	08 95       	ret

00000c9a <char2lcd>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c9a:	91 e0       	ldi	r25, 0x01	; 1
     c9c:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c9e:	77 9b       	sbis	0x0e, 7	; 14
     ca0:	fe cf       	rjmp	.-4      	; 0xc9e <char2lcd+0x4>
  SPDR = byte;                        //send payload
     ca2:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ca4:	77 9b       	sbis	0x0e, 7	; 14
     ca6:	fe cf       	rjmp	.-4      	; 0xca4 <char2lcd+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     ca8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cac:	88 60       	ori	r24, 0x08	; 8
     cae:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cb2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cb6:	87 7f       	andi	r24, 0xF7	; 247
     cb8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cbc:	08 95       	ret

00000cbe <string2lcd>:

//----------------------------------------------------------------------------
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
     cbe:	fc 01       	movw	r30, r24
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     cc0:	40 e0       	ldi	r20, 0x00	; 0
     cc2:	50 e0       	ldi	r21, 0x00	; 0
     cc4:	60 e0       	ldi	r22, 0x00	; 0
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     cc6:	71 e0       	ldi	r23, 0x01	; 1
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     cc8:	df 01       	movw	r26, r30
     cca:	a4 0f       	add	r26, r20
     ccc:	b5 1f       	adc	r27, r21
     cce:	8c 91       	ld	r24, X
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     cd0:	7f b9       	out	0x0f, r23	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     cd2:	77 9b       	sbis	0x0e, 7	; 14
     cd4:	fe cf       	rjmp	.-4      	; 0xcd2 <string2lcd+0x14>
  SPDR = byte;                        //send payload
     cd6:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     cd8:	77 9b       	sbis	0x0e, 7	; 14
     cda:	fe cf       	rjmp	.-4      	; 0xcd8 <string2lcd+0x1a>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     cdc:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ce0:	98 60       	ori	r25, 0x08	; 8
     ce2:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ce6:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cea:	97 7f       	andi	r25, 0xF7	; 247
     cec:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cf0:	85 ed       	ldi	r24, 0xD5	; 213
     cf2:	8a 95       	dec	r24
     cf4:	f1 f7       	brne	.-4      	; 0xcf2 <string2lcd+0x34>
     cf6:	00 00       	nop
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     cf8:	6f 5f       	subi	r22, 0xFF	; 255
     cfa:	46 2f       	mov	r20, r22
     cfc:	50 e0       	ldi	r21, 0x00	; 0
     cfe:	df 01       	movw	r26, r30
     d00:	0d 90       	ld	r0, X+
     d02:	00 20       	and	r0, r0
     d04:	e9 f7       	brne	.-6      	; 0xd00 <string2lcd+0x42>
     d06:	9d 01       	movw	r18, r26
     d08:	2e 1b       	sub	r18, r30
     d0a:	3f 0b       	sbc	r19, r31
     d0c:	22 50       	subi	r18, 0x02	; 2
     d0e:	31 09       	sbc	r19, r1
     d10:	24 17       	cp	r18, r20
     d12:	35 07       	cpc	r19, r21
     d14:	c8 f6       	brcc	.-78     	; 0xcc8 <string2lcd+0xa>
  _delay_us(40);  //execution takes 37us per character
  }                  
} 
     d16:	08 95       	ret

00000d18 <lcd_init>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     d18:	8f ef       	ldi	r24, 0xFF	; 255
     d1a:	99 ef       	ldi	r25, 0xF9	; 249
     d1c:	01 97       	sbiw	r24, 0x01	; 1
     d1e:	f1 f7       	brne	.-4      	; 0xd1c <lcd_init+0x4>
     d20:	00 c0       	rjmp	.+0      	; 0xd22 <lcd_init+0xa>
     d22:	00 00       	nop
//
void lcd_init(void){
  _delay_ms(16);      //power up delay
#if SPI_MODE==1       //assumption is that the SPI port is intialized
  //TODO: kludge alert! setting of DDRF should not be here, but is probably harmless.
  DDRF=0x08;          //port F bit 3 is enable for LCD in SPI mode
     d24:	88 e0       	ldi	r24, 0x08	; 8
     d26:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d2a:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d2c:	77 9b       	sbis	0x0e, 7	; 14
     d2e:	fe cf       	rjmp	.-4      	; 0xd2c <lcd_init+0x14>
  SPDR = byte;                        //send payload
     d30:	80 e3       	ldi	r24, 0x30	; 48
     d32:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d34:	77 9b       	sbis	0x0e, 7	; 14
     d36:	fe cf       	rjmp	.-4      	; 0xd34 <lcd_init+0x1c>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d38:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d3c:	88 60       	ori	r24, 0x08	; 8
     d3e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d42:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d46:	87 7f       	andi	r24, 0xF7	; 247
     d48:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d4c:	8f e5       	ldi	r24, 0x5F	; 95
     d4e:	9d e6       	ldi	r25, 0x6D	; 109
     d50:	01 97       	sbiw	r24, 0x01	; 1
     d52:	f1 f7       	brne	.-4      	; 0xd50 <lcd_init+0x38>
     d54:	00 c0       	rjmp	.+0      	; 0xd56 <lcd_init+0x3e>
     d56:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d58:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d5a:	77 9b       	sbis	0x0e, 7	; 14
     d5c:	fe cf       	rjmp	.-4      	; 0xd5a <lcd_init+0x42>
  SPDR = byte;                        //send payload
     d5e:	80 e3       	ldi	r24, 0x30	; 48
     d60:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d62:	77 9b       	sbis	0x0e, 7	; 14
     d64:	fe cf       	rjmp	.-4      	; 0xd62 <lcd_init+0x4a>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d66:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d6a:	88 60       	ori	r24, 0x08	; 8
     d6c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d70:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d74:	87 7f       	andi	r24, 0xF7	; 247
     d76:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d7a:	8f e5       	ldi	r24, 0x5F	; 95
     d7c:	9d e6       	ldi	r25, 0x6D	; 109
     d7e:	01 97       	sbiw	r24, 0x01	; 1
     d80:	f1 f7       	brne	.-4      	; 0xd7e <lcd_init+0x66>
     d82:	00 c0       	rjmp	.+0      	; 0xd84 <lcd_init+0x6c>
     d84:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d86:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d88:	77 9b       	sbis	0x0e, 7	; 14
     d8a:	fe cf       	rjmp	.-4      	; 0xd88 <lcd_init+0x70>
  SPDR = byte;                        //send payload
     d8c:	80 e3       	ldi	r24, 0x30	; 48
     d8e:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d90:	77 9b       	sbis	0x0e, 7	; 14
     d92:	fe cf       	rjmp	.-4      	; 0xd90 <lcd_init+0x78>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d94:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d98:	88 60       	ori	r24, 0x08	; 8
     d9a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d9e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     da2:	87 7f       	andi	r24, 0xF7	; 247
     da4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     da8:	8f e5       	ldi	r24, 0x5F	; 95
     daa:	9d e6       	ldi	r25, 0x6D	; 109
     dac:	01 97       	sbiw	r24, 0x01	; 1
     dae:	f1 f7       	brne	.-4      	; 0xdac <lcd_init+0x94>
     db0:	00 c0       	rjmp	.+0      	; 0xdb2 <lcd_init+0x9a>
     db2:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     db4:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     db6:	77 9b       	sbis	0x0e, 7	; 14
     db8:	fe cf       	rjmp	.-4      	; 0xdb6 <lcd_init+0x9e>
  SPDR = byte;                        //send payload
     dba:	88 e3       	ldi	r24, 0x38	; 56
     dbc:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     dbe:	77 9b       	sbis	0x0e, 7	; 14
     dc0:	fe cf       	rjmp	.-4      	; 0xdbe <lcd_init+0xa6>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     dc2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dc6:	88 60       	ori	r24, 0x08	; 8
     dc8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dcc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dd0:	87 7f       	andi	r24, 0xF7	; 247
     dd2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dd6:	8f e1       	ldi	r24, 0x1F	; 31
     dd8:	9e e4       	ldi	r25, 0x4E	; 78
     dda:	01 97       	sbiw	r24, 0x01	; 1
     ddc:	f1 f7       	brne	.-4      	; 0xdda <lcd_init+0xc2>
     dde:	00 c0       	rjmp	.+0      	; 0xde0 <lcd_init+0xc8>
     de0:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     de2:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     de4:	77 9b       	sbis	0x0e, 7	; 14
     de6:	fe cf       	rjmp	.-4      	; 0xde4 <lcd_init+0xcc>
  SPDR = byte;                        //send payload
     de8:	88 e0       	ldi	r24, 0x08	; 8
     dea:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     dec:	77 9b       	sbis	0x0e, 7	; 14
     dee:	fe cf       	rjmp	.-4      	; 0xdec <lcd_init+0xd4>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     df0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     df4:	88 60       	ori	r24, 0x08	; 8
     df6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dfa:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dfe:	87 7f       	andi	r24, 0xF7	; 247
     e00:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e04:	8f e1       	ldi	r24, 0x1F	; 31
     e06:	9e e4       	ldi	r25, 0x4E	; 78
     e08:	01 97       	sbiw	r24, 0x01	; 1
     e0a:	f1 f7       	brne	.-4      	; 0xe08 <lcd_init+0xf0>
     e0c:	00 c0       	rjmp	.+0      	; 0xe0e <lcd_init+0xf6>
     e0e:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e10:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e12:	77 9b       	sbis	0x0e, 7	; 14
     e14:	fe cf       	rjmp	.-4      	; 0xe12 <lcd_init+0xfa>
  SPDR = byte;                        //send payload
     e16:	81 e0       	ldi	r24, 0x01	; 1
     e18:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e1a:	77 9b       	sbis	0x0e, 7	; 14
     e1c:	fe cf       	rjmp	.-4      	; 0xe1a <lcd_init+0x102>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     e1e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e22:	88 60       	ori	r24, 0x08	; 8
     e24:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e28:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e2c:	87 7f       	andi	r24, 0xF7	; 247
     e2e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e32:	8f e1       	ldi	r24, 0x1F	; 31
     e34:	9e e4       	ldi	r25, 0x4E	; 78
     e36:	01 97       	sbiw	r24, 0x01	; 1
     e38:	f1 f7       	brne	.-4      	; 0xe36 <lcd_init+0x11e>
     e3a:	00 c0       	rjmp	.+0      	; 0xe3c <lcd_init+0x124>
     e3c:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e3e:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e40:	77 9b       	sbis	0x0e, 7	; 14
     e42:	fe cf       	rjmp	.-4      	; 0xe40 <lcd_init+0x128>
  SPDR = byte;                        //send payload
     e44:	86 e0       	ldi	r24, 0x06	; 6
     e46:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e48:	77 9b       	sbis	0x0e, 7	; 14
     e4a:	fe cf       	rjmp	.-4      	; 0xe48 <lcd_init+0x130>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     e4c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e50:	88 60       	ori	r24, 0x08	; 8
     e52:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e56:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e5a:	87 7f       	andi	r24, 0xF7	; 247
     e5c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e60:	8f e1       	ldi	r24, 0x1F	; 31
     e62:	9e e4       	ldi	r25, 0x4E	; 78
     e64:	01 97       	sbiw	r24, 0x01	; 1
     e66:	f1 f7       	brne	.-4      	; 0xe64 <lcd_init+0x14c>
     e68:	00 c0       	rjmp	.+0      	; 0xe6a <lcd_init+0x152>
     e6a:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e6c:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e6e:	77 9b       	sbis	0x0e, 7	; 14
     e70:	fe cf       	rjmp	.-4      	; 0xe6e <lcd_init+0x156>
  SPDR = byte;                        //send payload
     e72:	8c e0       	ldi	r24, 0x0C	; 12
     e74:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e76:	77 9b       	sbis	0x0e, 7	; 14
     e78:	fe cf       	rjmp	.-4      	; 0xe76 <lcd_init+0x15e>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     e7a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e7e:	88 60       	ori	r24, 0x08	; 8
     e80:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e84:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e88:	87 7f       	andi	r24, 0xF7	; 247
     e8a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e8e:	8f e1       	ldi	r24, 0x1F	; 31
     e90:	9e e4       	ldi	r25, 0x4E	; 78
     e92:	01 97       	sbiw	r24, 0x01	; 1
     e94:	f1 f7       	brne	.-4      	; 0xe92 <lcd_init+0x17a>
     e96:	00 c0       	rjmp	.+0      	; 0xe98 <lcd_init+0x180>
     e98:	00 00       	nop
     e9a:	08 95       	ret

00000e9c <lcd_int32>:
void  lcd_int32(int32_t l,          //number to display
                uint8_t fieldwidth, //width of the field for display
                uint8_t decpos,     //0 if no decimal point, otherwise
                uint8_t bSigned,    //non-zero if the number should be treated as signed 
                uint8_t bZeroFill)  //non-zero if a specified fieldwidth is to be zero filled
{
     e9c:	4f 92       	push	r4
     e9e:	5f 92       	push	r5
     ea0:	6f 92       	push	r6
     ea2:	7f 92       	push	r7
     ea4:	8f 92       	push	r8
     ea6:	9f 92       	push	r9
     ea8:	af 92       	push	r10
     eaa:	bf 92       	push	r11
     eac:	cf 92       	push	r12
     eae:	df 92       	push	r13
     eb0:	ef 92       	push	r14
     eb2:	ff 92       	push	r15
     eb4:	0f 93       	push	r16
     eb6:	1f 93       	push	r17
     eb8:	cf 93       	push	r28
     eba:	df 93       	push	r29
     ebc:	cd b7       	in	r28, 0x3d	; 61
     ebe:	de b7       	in	r29, 0x3e	; 62
     ec0:	69 97       	sbiw	r28, 0x19	; 25
     ec2:	0f b6       	in	r0, 0x3f	; 63
     ec4:	f8 94       	cli
     ec6:	de bf       	out	0x3e, r29	; 62
     ec8:	0f be       	out	0x3f, r0	; 63
     eca:	cd bf       	out	0x3d, r28	; 61
     ecc:	14 2f       	mov	r17, r20
     ece:	42 2e       	mov	r4, r18
     ed0:	5e 2c       	mov	r5, r14
      char    fillch;
      ldiv_t  qr;

      qr.quot = l; // initialize the quotient 

      if (bSigned){
     ed2:	00 23       	and	r16, r16
     ed4:	79 f0       	breq	.+30     	; 0xef4 <lcd_int32+0x58>
        bSigned = (qr.quot<0);
     ed6:	6b 01       	movw	r12, r22
     ed8:	7c 01       	movw	r14, r24
     eda:	cc 24       	eor	r12, r12
     edc:	f7 fc       	sbrc	r15, 7
     ede:	c3 94       	inc	r12
     ee0:	dd 24       	eor	r13, r13
     ee2:	ee 24       	eor	r14, r14
     ee4:	ff 24       	eor	r15, r15
     ee6:	0c 2d       	mov	r16, r12
        qr.quot = labs(qr.quot);
     ee8:	6b 01       	movw	r12, r22
     eea:	7c 01       	movw	r14, r24
     eec:	97 fd       	sbrc	r25, 7
     eee:	a3 c0       	rjmp	.+326    	; 0x1036 <lcd_int32+0x19a>
     ef0:	c7 01       	movw	r24, r14
     ef2:	b6 01       	movw	r22, r12
      }

      // convert the digits to the right of the decimal point 
      if (decpos){
     ef4:	44 20       	and	r4, r4
     ef6:	09 f4       	brne	.+2      	; 0xefa <lcd_int32+0x5e>
     ef8:	96 c0       	rjmp	.+300    	; 0x1026 <lcd_int32+0x18a>
     efa:	9e 01       	movw	r18, r28
     efc:	2f 5f       	subi	r18, 0xFF	; 255
     efe:	3f 4f       	sbci	r19, 0xFF	; 255
     f00:	59 01       	movw	r10, r18
     f02:	49 01       	movw	r8, r18
     f04:	66 24       	eor	r6, r6
     f06:	6a 94       	dec	r6
     f08:	64 0c       	add	r6, r4
     f0a:	71 2c       	mov	r7, r1
     f0c:	3f ef       	ldi	r19, 0xFF	; 255
     f0e:	63 1a       	sub	r6, r19
     f10:	73 0a       	sbc	r7, r19
     f12:	6a 0c       	add	r6, r10
     f14:	7b 1c       	adc	r7, r11
        for (; decpos ; decpos--){
          qr = ldiv(qr.quot, 10);
     f16:	2a e0       	ldi	r18, 0x0A	; 10
     f18:	30 e0       	ldi	r19, 0x00	; 0
     f1a:	40 e0       	ldi	r20, 0x00	; 0
     f1c:	50 e0       	ldi	r21, 0x00	; 0
     f1e:	0e 94 8c 09 	call	0x1318	; 0x1318 <__divmodsi4>
     f22:	e6 2f       	mov	r30, r22
     f24:	2a 8b       	std	Y+18, r18	; 0x12
     f26:	3b 8b       	std	Y+19, r19	; 0x13
     f28:	4c 8b       	std	Y+20, r20	; 0x14
     f2a:	5d 8b       	std	Y+21, r21	; 0x15
     f2c:	6a 89       	ldd	r22, Y+18	; 0x12
     f2e:	7b 89       	ldd	r23, Y+19	; 0x13
     f30:	8c 89       	ldd	r24, Y+20	; 0x14
     f32:	9d 89       	ldd	r25, Y+21	; 0x15
          sline[i++] = qr.rem + '0';
     f34:	20 e3       	ldi	r18, 0x30	; 48
     f36:	2e 0f       	add	r18, r30
     f38:	f4 01       	movw	r30, r8
     f3a:	21 93       	st	Z+, r18
     f3c:	4f 01       	movw	r8, r30
        qr.quot = labs(qr.quot);
      }

      // convert the digits to the right of the decimal point 
      if (decpos){
        for (; decpos ; decpos--){
     f3e:	6e 16       	cp	r6, r30
     f40:	7f 06       	cpc	r7, r31
     f42:	49 f7       	brne	.-46     	; 0xf16 <lcd_int32+0x7a>
          qr = ldiv(qr.quot, 10);
          sline[i++] = qr.rem + '0';
        }
        sline[i++] = '.';
     f44:	99 24       	eor	r9, r9
     f46:	93 94       	inc	r9
     f48:	94 0c       	add	r9, r4
     f4a:	f5 01       	movw	r30, r10
     f4c:	e4 0d       	add	r30, r4
     f4e:	f1 1d       	adc	r31, r1
     f50:	2e e2       	ldi	r18, 0x2E	; 46
     f52:	20 83       	st	Z, r18
      }

      // convert the digits to the left of the decimal point 
      do{
          qr = ldiv(qr.quot, 10);
     f54:	2a e0       	ldi	r18, 0x0A	; 10
     f56:	30 e0       	ldi	r19, 0x00	; 0
     f58:	40 e0       	ldi	r20, 0x00	; 0
     f5a:	50 e0       	ldi	r21, 0x00	; 0
     f5c:	0e 94 8c 09 	call	0x1318	; 0x1318 <__divmodsi4>
     f60:	e6 2f       	mov	r30, r22
     f62:	2a 8b       	std	Y+18, r18	; 0x12
     f64:	3b 8b       	std	Y+19, r19	; 0x13
     f66:	4c 8b       	std	Y+20, r20	; 0x14
     f68:	5d 8b       	std	Y+21, r21	; 0x15
     f6a:	6e 8b       	std	Y+22, r22	; 0x16
     f6c:	7f 8b       	std	Y+23, r23	; 0x17
     f6e:	88 8f       	std	Y+24, r24	; 0x18
     f70:	99 8f       	std	Y+25, r25	; 0x19
     f72:	6a 89       	ldd	r22, Y+18	; 0x12
     f74:	7b 89       	ldd	r23, Y+19	; 0x13
     f76:	8c 89       	ldd	r24, Y+20	; 0x14
     f78:	9d 89       	ldd	r25, Y+21	; 0x15
          sline[i++] = qr.rem + '0';
     f7a:	31 e0       	ldi	r19, 0x01	; 1
     f7c:	39 0d       	add	r19, r9
     f7e:	d5 01       	movw	r26, r10
     f80:	a9 0d       	add	r26, r9
     f82:	b1 1d       	adc	r27, r1
     f84:	e0 5d       	subi	r30, 0xD0	; 208
     f86:	ec 93       	st	X, r30
     f88:	93 2e       	mov	r9, r19
        }while(qr.quot);
     f8a:	61 15       	cp	r22, r1
     f8c:	71 05       	cpc	r23, r1
     f8e:	81 05       	cpc	r24, r1
     f90:	91 05       	cpc	r25, r1
     f92:	01 f7       	brne	.-64     	; 0xf54 <lcd_int32+0xb8>

      // fill the whole field if a width was specified
      if (fieldwidth){
     f94:	11 23       	and	r17, r17
     f96:	61 f0       	breq	.+24     	; 0xfb0 <lcd_int32+0x114>
        fillch = bZeroFill? '0': ' '; // determine the fill character
     f98:	51 10       	cpse	r5, r1
     f9a:	4b c0       	rjmp	.+150    	; 0x1032 <lcd_int32+0x196>
     f9c:	90 e2       	ldi	r25, 0x20	; 32
        for (; i<fieldwidth ; ){sline[i++] = fillch;}
     f9e:	31 17       	cp	r19, r17
     fa0:	38 f4       	brcc	.+14     	; 0xfb0 <lcd_int32+0x114>
     fa2:	f5 01       	movw	r30, r10
     fa4:	e3 0f       	add	r30, r19
     fa6:	f1 1d       	adc	r31, r1
     fa8:	90 83       	st	Z, r25
     faa:	3f 5f       	subi	r19, 0xFF	; 255
     fac:	13 13       	cpse	r17, r19
     fae:	f9 cf       	rjmp	.-14     	; 0xfa2 <lcd_int32+0x106>
      }

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}
     fb0:	00 23       	and	r16, r16
     fb2:	31 f0       	breq	.+12     	; 0xfc0 <lcd_int32+0x124>
     fb4:	f5 01       	movw	r30, r10
     fb6:	e3 0f       	add	r30, r19
     fb8:	f1 1d       	adc	r31, r1
     fba:	9d e2       	ldi	r25, 0x2D	; 45
     fbc:	90 83       	st	Z, r25
     fbe:	3f 5f       	subi	r19, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     fc0:	21 e0       	ldi	r18, 0x01	; 1

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}

      // now output the formatted number
      do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
     fc2:	31 50       	subi	r19, 0x01	; 1
     fc4:	f5 01       	movw	r30, r10
     fc6:	e3 0f       	add	r30, r19
     fc8:	f1 1d       	adc	r31, r1
     fca:	90 81       	ld	r25, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     fcc:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     fce:	77 9b       	sbis	0x0e, 7	; 14
     fd0:	fe cf       	rjmp	.-4      	; 0xfce <lcd_int32+0x132>
  SPDR = byte;                        //send payload
     fd2:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     fd4:	77 9b       	sbis	0x0e, 7	; 14
     fd6:	fe cf       	rjmp	.-4      	; 0xfd4 <lcd_int32+0x138>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     fd8:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fdc:	98 60       	ori	r25, 0x08	; 8
     fde:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fe2:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fe6:	97 7f       	andi	r25, 0xF7	; 247
     fe8:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     fec:	85 ed       	ldi	r24, 0xD5	; 213
     fee:	8a 95       	dec	r24
     ff0:	f1 f7       	brne	.-4      	; 0xfee <lcd_int32+0x152>
     ff2:	00 00       	nop

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}

      // now output the formatted number
      do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
     ff4:	31 11       	cpse	r19, r1
     ff6:	e5 cf       	rjmp	.-54     	; 0xfc2 <lcd_int32+0x126>

}
     ff8:	69 96       	adiw	r28, 0x19	; 25
     ffa:	0f b6       	in	r0, 0x3f	; 63
     ffc:	f8 94       	cli
     ffe:	de bf       	out	0x3e, r29	; 62
    1000:	0f be       	out	0x3f, r0	; 63
    1002:	cd bf       	out	0x3d, r28	; 61
    1004:	df 91       	pop	r29
    1006:	cf 91       	pop	r28
    1008:	1f 91       	pop	r17
    100a:	0f 91       	pop	r16
    100c:	ff 90       	pop	r15
    100e:	ef 90       	pop	r14
    1010:	df 90       	pop	r13
    1012:	cf 90       	pop	r12
    1014:	bf 90       	pop	r11
    1016:	af 90       	pop	r10
    1018:	9f 90       	pop	r9
    101a:	8f 90       	pop	r8
    101c:	7f 90       	pop	r7
    101e:	6f 90       	pop	r6
    1020:	5f 90       	pop	r5
    1022:	4f 90       	pop	r4
    1024:	08 95       	ret
                uint8_t decpos,     //0 if no decimal point, otherwise
                uint8_t bSigned,    //non-zero if the number should be treated as signed 
                uint8_t bZeroFill)  //non-zero if a specified fieldwidth is to be zero filled
{
      char    sline[NUM_LCD_CHARS+1];
      uint8_t i=0;
    1026:	91 2c       	mov	r9, r1
    1028:	9e 01       	movw	r18, r28
    102a:	2f 5f       	subi	r18, 0xFF	; 255
    102c:	3f 4f       	sbci	r19, 0xFF	; 255
    102e:	59 01       	movw	r10, r18
    1030:	91 cf       	rjmp	.-222    	; 0xf54 <lcd_int32+0xb8>
          sline[i++] = qr.rem + '0';
        }while(qr.quot);

      // fill the whole field if a width was specified
      if (fieldwidth){
        fillch = bZeroFill? '0': ' '; // determine the fill character
    1032:	90 e3       	ldi	r25, 0x30	; 48
    1034:	b4 cf       	rjmp	.-152    	; 0xf9e <lcd_int32+0x102>

      qr.quot = l; // initialize the quotient 

      if (bSigned){
        bSigned = (qr.quot<0);
        qr.quot = labs(qr.quot);
    1036:	f0 94       	com	r15
    1038:	e0 94       	com	r14
    103a:	d0 94       	com	r13
    103c:	c0 94       	com	r12
    103e:	c1 1c       	adc	r12, r1
    1040:	d1 1c       	adc	r13, r1
    1042:	e1 1c       	adc	r14, r1
    1044:	f1 1c       	adc	r15, r1
    1046:	54 cf       	rjmp	.-344    	; 0xef0 <lcd_int32+0x54>

00001048 <lcd_int16>:
void    lcd_int16(int16_t l, 
                  uint8_t fieldwidth, 
                  uint8_t decpos, 
                  uint8_t bSigned,
                  uint8_t bZeroFill)
{
    1048:	5f 92       	push	r5
    104a:	6f 92       	push	r6
    104c:	7f 92       	push	r7
    104e:	8f 92       	push	r8
    1050:	9f 92       	push	r9
    1052:	af 92       	push	r10
    1054:	bf 92       	push	r11
    1056:	cf 92       	push	r12
    1058:	df 92       	push	r13
    105a:	ef 92       	push	r14
    105c:	ff 92       	push	r15
    105e:	0f 93       	push	r16
    1060:	1f 93       	push	r17
    1062:	cf 93       	push	r28
    1064:	df 93       	push	r29
    1066:	cd b7       	in	r28, 0x3d	; 61
    1068:	de b7       	in	r29, 0x3e	; 62
    106a:	61 97       	sbiw	r28, 0x11	; 17
    106c:	0f b6       	in	r0, 0x3f	; 63
    106e:	f8 94       	cli
    1070:	de bf       	out	0x3e, r29	; 62
    1072:	0f be       	out	0x3f, r0	; 63
    1074:	cd bf       	out	0x3d, r28	; 61
    1076:	5c 01       	movw	r10, r24
    1078:	16 2f       	mov	r17, r22
    107a:	74 2e       	mov	r7, r20
//        uint8_t bSigned;   Now an argument for signed or not

        // initialize the quotient 
        qr.quot = l;

        if ( (bSigned=(qr.quot<0)) )
    107c:	6b 2c       	mov	r6, r11
    107e:	66 1c       	adc	r6, r6
    1080:	66 24       	eor	r6, r6
    1082:	66 1c       	adc	r6, r6
    1084:	56 2c       	mov	r5, r6
    1086:	9c 01       	movw	r18, r24
    1088:	97 fd       	sbrc	r25, 7
    108a:	9b c0       	rjmp	.+310    	; 0x11c2 <__stack+0xc3>
                qr.quot = -qr.quot;

        // convert the digits to the right of the decimal point 
        if (decpos){
    108c:	77 20       	and	r7, r7
    108e:	09 f4       	brne	.+2      	; 0x1092 <lcd_int16+0x4a>
    1090:	8d c0       	rjmp	.+282    	; 0x11ac <__stack+0xad>
    1092:	ce 01       	movw	r24, r28
    1094:	01 96       	adiw	r24, 0x01	; 1
    1096:	7c 01       	movw	r14, r24
    1098:	6c 01       	movw	r12, r24
    109a:	88 24       	eor	r8, r8
    109c:	8a 94       	dec	r8
    109e:	87 0c       	add	r8, r7
    10a0:	91 2c       	mov	r9, r1
    10a2:	9f ef       	ldi	r25, 0xFF	; 255
    10a4:	89 1a       	sub	r8, r25
    10a6:	99 0a       	sbc	r9, r25
    10a8:	8e 0c       	add	r8, r14
    10aa:	9f 1c       	adc	r9, r15
          for (; decpos ; decpos--){
            qr = div(qr.quot, 10);
    10ac:	6a e0       	ldi	r22, 0x0A	; 10
    10ae:	70 e0       	ldi	r23, 0x00	; 0
    10b0:	c9 01       	movw	r24, r18
    10b2:	0e 94 78 09 	call	0x12f0	; 0x12f0 <__divmodhi4>
    10b6:	46 2f       	mov	r20, r22
    10b8:	24 2f       	mov	r18, r20
    10ba:	37 2f       	mov	r19, r23
            sline[i++] = qr.rem + '0';
    10bc:	80 5d       	subi	r24, 0xD0	; 208
    10be:	f6 01       	movw	r30, r12
    10c0:	81 93       	st	Z+, r24
    10c2:	6f 01       	movw	r12, r30
        if ( (bSigned=(qr.quot<0)) )
                qr.quot = -qr.quot;

        // convert the digits to the right of the decimal point 
        if (decpos){
          for (; decpos ; decpos--){
    10c4:	e8 15       	cp	r30, r8
    10c6:	f9 05       	cpc	r31, r9
    10c8:	89 f7       	brne	.-30     	; 0x10ac <lcd_int16+0x64>
            qr = div(qr.quot, 10);
            sline[i++] = qr.rem + '0';
          }
          sline[i++] = '.';
    10ca:	dd 24       	eor	r13, r13
    10cc:	d3 94       	inc	r13
    10ce:	d7 0c       	add	r13, r7
    10d0:	f7 01       	movw	r30, r14
    10d2:	e7 0d       	add	r30, r7
    10d4:	f1 1d       	adc	r31, r1
    10d6:	8e e2       	ldi	r24, 0x2E	; 46
    10d8:	80 83       	st	Z, r24
    10da:	01 c0       	rjmp	.+2      	; 0x10de <lcd_int16+0x96>

        // convert the digits to the left of the decimal point 
        do
        {
                qr = div(qr.quot, 10);
                sline[i++] = qr.rem + '0';
    10dc:	d9 2e       	mov	r13, r25
        }

        // convert the digits to the left of the decimal point 
        do
        {
                qr = div(qr.quot, 10);
    10de:	6a e0       	ldi	r22, 0x0A	; 10
    10e0:	70 e0       	ldi	r23, 0x00	; 0
    10e2:	c9 01       	movw	r24, r18
    10e4:	0e 94 78 09 	call	0x12f0	; 0x12f0 <__divmodhi4>
    10e8:	46 2f       	mov	r20, r22
    10ea:	24 2f       	mov	r18, r20
    10ec:	37 2f       	mov	r19, r23
                sline[i++] = qr.rem + '0';
    10ee:	91 e0       	ldi	r25, 0x01	; 1
    10f0:	9d 0d       	add	r25, r13
    10f2:	f7 01       	movw	r30, r14
    10f4:	ed 0d       	add	r30, r13
    10f6:	f1 1d       	adc	r31, r1
    10f8:	80 5d       	subi	r24, 0xD0	; 208
    10fa:	80 83       	st	Z, r24
        }
        while(qr.quot);
    10fc:	21 15       	cp	r18, r1
    10fe:	31 05       	cpc	r19, r1
    1100:	69 f7       	brne	.-38     	; 0x10dc <lcd_int16+0x94>

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
    1102:	01 11       	cpse	r16, r1
    1104:	58 c0       	rjmp	.+176    	; 0x11b6 <__stack+0xb7>
    1106:	b7 fc       	sbrc	r11, 7
    1108:	61 c0       	rjmp	.+194    	; 0x11cc <__stack+0xcd>
                sline[i++] = '-';
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    110a:	11 23       	and	r17, r17
    110c:	a9 f0       	breq	.+42     	; 0x1138 <__stack+0x39>
    110e:	71 2c       	mov	r7, r1
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    1110:	80 e2       	ldi	r24, 0x20	; 32
          for (; i<(fieldwidth-bSigned) ; ){ sline[i++] = fillch;}
    1112:	29 2f       	mov	r18, r25
    1114:	30 e0       	ldi	r19, 0x00	; 0
    1116:	41 2f       	mov	r20, r17
    1118:	50 e0       	ldi	r21, 0x00	; 0
    111a:	46 19       	sub	r20, r6
    111c:	57 09       	sbc	r21, r7
    111e:	24 17       	cp	r18, r20
    1120:	35 07       	cpc	r19, r21
    1122:	54 f4       	brge	.+20     	; 0x1138 <__stack+0x39>
    1124:	9f 5f       	subi	r25, 0xFF	; 255
    1126:	f7 01       	movw	r30, r14
    1128:	e2 0f       	add	r30, r18
    112a:	f3 1f       	adc	r31, r19
    112c:	80 83       	st	Z, r24
    112e:	29 2f       	mov	r18, r25
    1130:	30 e0       	ldi	r19, 0x00	; 0
    1132:	24 17       	cp	r18, r20
    1134:	35 07       	cpc	r19, r21
    1136:	b4 f3       	brlt	.-20     	; 0x1124 <__stack+0x25>
        }

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}
    1138:	55 20       	and	r5, r5
    113a:	31 f0       	breq	.+12     	; 0x1148 <__stack+0x49>
    113c:	f7 01       	movw	r30, r14
    113e:	e9 0f       	add	r30, r25
    1140:	f1 1d       	adc	r31, r1
    1142:	8d e2       	ldi	r24, 0x2D	; 45
    1144:	80 83       	st	Z, r24
    1146:	9f 5f       	subi	r25, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1148:	21 e0       	ldi	r18, 0x01	; 1

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}

        // now output the formatted number 
            do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    114a:	91 50       	subi	r25, 0x01	; 1
    114c:	f7 01       	movw	r30, r14
    114e:	e9 0f       	add	r30, r25
    1150:	f1 1d       	adc	r31, r1
    1152:	80 81       	ld	r24, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1154:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1156:	77 9b       	sbis	0x0e, 7	; 14
    1158:	fe cf       	rjmp	.-4      	; 0x1156 <__stack+0x57>
  SPDR = byte;                        //send payload
    115a:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    115c:	77 9b       	sbis	0x0e, 7	; 14
    115e:	fe cf       	rjmp	.-4      	; 0x115c <__stack+0x5d>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    1160:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1164:	88 60       	ori	r24, 0x08	; 8
    1166:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    116a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    116e:	87 7f       	andi	r24, 0xF7	; 247
    1170:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1174:	e5 ed       	ldi	r30, 0xD5	; 213
    1176:	ea 95       	dec	r30
    1178:	f1 f7       	brne	.-4      	; 0x1176 <__stack+0x77>
    117a:	00 00       	nop

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}

        // now output the formatted number 
            do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    117c:	91 11       	cpse	r25, r1
    117e:	e5 cf       	rjmp	.-54     	; 0x114a <__stack+0x4b>
}
    1180:	61 96       	adiw	r28, 0x11	; 17
    1182:	0f b6       	in	r0, 0x3f	; 63
    1184:	f8 94       	cli
    1186:	de bf       	out	0x3e, r29	; 62
    1188:	0f be       	out	0x3f, r0	; 63
    118a:	cd bf       	out	0x3d, r28	; 61
    118c:	df 91       	pop	r29
    118e:	cf 91       	pop	r28
    1190:	1f 91       	pop	r17
    1192:	0f 91       	pop	r16
    1194:	ff 90       	pop	r15
    1196:	ef 90       	pop	r14
    1198:	df 90       	pop	r13
    119a:	cf 90       	pop	r12
    119c:	bf 90       	pop	r11
    119e:	af 90       	pop	r10
    11a0:	9f 90       	pop	r9
    11a2:	8f 90       	pop	r8
    11a4:	7f 90       	pop	r7
    11a6:	6f 90       	pop	r6
    11a8:	5f 90       	pop	r5
    11aa:	08 95       	ret
                  uint8_t decpos, 
                  uint8_t bSigned,
                  uint8_t bZeroFill)
{
        char    sline[NUM_LCD_CHARS+1];
        uint8_t i=0;
    11ac:	d1 2c       	mov	r13, r1
    11ae:	ce 01       	movw	r24, r28
    11b0:	01 96       	adiw	r24, 0x01	; 1
    11b2:	7c 01       	movw	r14, r24
    11b4:	94 cf       	rjmp	.-216    	; 0x10de <lcd_int16+0x96>
                sline[i++] = '-';
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    11b6:	11 23       	and	r17, r17
    11b8:	09 f4       	brne	.+2      	; 0x11bc <__stack+0xbd>
    11ba:	be cf       	rjmp	.-132    	; 0x1138 <__stack+0x39>
    11bc:	71 2c       	mov	r7, r1
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    11be:	80 e3       	ldi	r24, 0x30	; 48
    11c0:	a8 cf       	rjmp	.-176    	; 0x1112 <__stack+0x13>
    11c2:	22 27       	eor	r18, r18
    11c4:	33 27       	eor	r19, r19
    11c6:	28 1b       	sub	r18, r24
    11c8:	39 0b       	sbc	r19, r25
    11ca:	60 cf       	rjmp	.-320    	; 0x108c <lcd_int16+0x44>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    11cc:	d3 94       	inc	r13
    11ce:	d3 94       	inc	r13
    11d0:	f7 01       	movw	r30, r14
    11d2:	e9 0f       	add	r30, r25
    11d4:	f1 1d       	adc	r31, r1
    11d6:	8d e2       	ldi	r24, 0x2D	; 45
    11d8:	80 83       	st	Z, r24
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    11da:	11 23       	and	r17, r17
    11dc:	59 f0       	breq	.+22     	; 0x11f4 <__stack+0xf5>
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
          for (; i<(fieldwidth-bSigned) ; ){ sline[i++] = fillch;}
    11de:	2d 2d       	mov	r18, r13
    11e0:	30 e0       	ldi	r19, 0x00	; 0
    11e2:	41 2f       	mov	r20, r17
    11e4:	50 e0       	ldi	r21, 0x00	; 0
    11e6:	24 17       	cp	r18, r20
    11e8:	35 07       	cpc	r19, r21
    11ea:	24 f4       	brge	.+8      	; 0x11f4 <__stack+0xf5>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    11ec:	9d 2d       	mov	r25, r13
                bSigned = 0;
    11ee:	51 2c       	mov	r5, r1
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    11f0:	80 e2       	ldi	r24, 0x20	; 32
    11f2:	98 cf       	rjmp	.-208    	; 0x1124 <__stack+0x25>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    11f4:	9d 2d       	mov	r25, r13
    11f6:	a8 cf       	rjmp	.-176    	; 0x1148 <__stack+0x49>

000011f8 <main>:
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
    11f8:	87 b3       	in	r24, 0x17	; 23
    11fa:	87 60       	ori	r24, 0x07	; 7
    11fc:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
    11fe:	8d b1       	in	r24, 0x0d	; 13
    1200:	8c 65       	ori	r24, 0x5C	; 92
    1202:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
    1204:	70 9a       	sbi	0x0e, 0	; 14
Function:
Description:
Parameters:
**********************************************************************/
void tcnt0_init(){
   ASSR |= (1<<AS0);
    1206:	80 b7       	in	r24, 0x30	; 48
    1208:	88 60       	ori	r24, 0x08	; 8
    120a:	80 bf       	out	0x30, r24	; 48
   TIMSK |= (1<<TOIE0);			//enable interrupts
    120c:	87 b7       	in	r24, 0x37	; 55
    120e:	81 60       	ori	r24, 0x01	; 1
    1210:	87 bf       	out	0x37, r24	; 55
   TCCR0 |= (1<<CS00);			//normal mode, no prescale
    1212:	83 b7       	in	r24, 0x33	; 51
    1214:	81 60       	ori	r24, 0x01	; 1
    1216:	83 bf       	out	0x33, r24	; 51
Function:
Description:
Parameters:
**********************************************************************/
void tcnt1_init(){
   TCCR1A |= 0x00;//(1<<COM1A0); //Toggle on OCR1A match
    1218:	8f b5       	in	r24, 0x2f	; 47
    121a:	8f bd       	out	0x2f, r24	; 47
   TCCR1B |= 0x00; //(1<<CS11) | (1<<CS10) | (1<<WGM12);		//CTC mode, 64bit prescaler
    121c:	8e b5       	in	r24, 0x2e	; 46
    121e:	8e bd       	out	0x2e, r24	; 46
   TCCR1C = 0x00;
    1220:	10 92 7a 00 	sts	0x007A, r1	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
   TIMSK  |= (1<<OCIE1A);// | (1<<TOIE1); 
    1224:	87 b7       	in	r24, 0x37	; 55
    1226:	80 61       	ori	r24, 0x10	; 16
    1228:	87 bf       	out	0x37, r24	; 55
   TIFR   |= (1<<OCF1A);// | (1<<TOV1);
    122a:	86 b7       	in	r24, 0x36	; 54
    122c:	80 61       	ori	r24, 0x10	; 16
    122e:	86 bf       	out	0x36, r24	; 54
   TCNT1 = 0x0000; 		//Initialize TNCT1 to 0
    1230:	1d bc       	out	0x2d, r1	; 45
    1232:	1c bc       	out	0x2c, r1	; 44
   OCR1A = 0x80;
    1234:	80 e8       	ldi	r24, 0x80	; 128
    1236:	90 e0       	ldi	r25, 0x00	; 0
    1238:	9b bd       	out	0x2b, r25	; 43
    123a:	8a bd       	out	0x2a, r24	; 42
Function:
Description:
Parameters:
**********************************************************************/
void tcnt2_init(){
   TCCR2 |= (1<<WGM21) | (1<<WGM20)| (1<<CS20) | (1<<COM21);			//normal mode, no prescale
    123c:	85 b5       	in	r24, 0x25	; 37
    123e:	89 66       	ori	r24, 0x69	; 105
    1240:	85 bd       	out	0x25, r24	; 37
int main() {
   spi_init();				//Initalize SPI
   tcnt0_init();
   tcnt1_init();
   tcnt2_init();
   tcnt3_init();
    1242:	0e 94 90 00 	call	0x120	; 0x120 <tcnt3_init>
   port_init();
    1246:	0e 94 83 03 	call	0x706	; 0x706 <port_init>
Description:
Parameters:
**********************************************************************/
void adc_init(){
//Initalize ADC and its ports
   DDRF  &= ~(_BV(DDF7)); //make port F bit 7 is ADC input  
    124a:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
    124e:	8f 77       	andi	r24, 0x7F	; 127
    1250:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
   PORTF &= ~(_BV(PF7));  //port F bit 7 pullups must be off
    1254:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1258:	8f 77       	andi	r24, 0x7F	; 127
    125a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
   ADMUX |= (1<<REFS0) | (1<<MUX2)| (1<<MUX1)| (1<<MUX0); //single-ended, input PORTF bit 7, right adjusted, 10 bits
    125e:	87 b1       	in	r24, 0x07	; 7
    1260:	87 64       	ori	r24, 0x47	; 71
    1262:	87 b9       	out	0x07, r24	; 7

   ADCSRA |= (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);//ADC enabled, don't start yet, single shot mode 
    1264:	86 b1       	in	r24, 0x06	; 6
    1266:	87 68       	ori	r24, 0x87	; 135
    1268:	86 b9       	out	0x06, r24	; 6
   tcnt2_init();
   tcnt3_init();
   port_init();
   adc_init();

   lcd_init();
    126a:	0e 94 8c 06 	call	0xd18	; 0xd18 <lcd_init>
   sei();				//Enable interrupts
    126e:	78 94       	sei
Description:
Parameters:
**********************************************************************/
void alarm_sound() {
   if(alarm && ((hour_count == a_hour_count) && (min_count == a_min_count))){
      OCR3A = 158;
    1270:	ce e9       	ldi	r28, 0x9E	; 158
    1272:	d0 e0       	ldi	r29, 0x00	; 0
	 }
	 PORTA = segment_data[j];	//Writes the segment data to PORTA aka the segments
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
				//the digit to be displayed is in pin 4, 5, and 6 
         _delay_us(200);		//delay so that the display does not flicker
         PORTA = 0xFF;
    1274:	1f ef       	ldi	r17, 0xFF	; 255
Function:
Description:
Parameters:
**********************************************************************/
void alarm_sound() {
   if(alarm && ((hour_count == a_hour_count) && (min_count == a_min_count))){
    1276:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <alarm>
    127a:	88 23       	and	r24, r24
    127c:	31 f0       	breq	.+12     	; 0x128a <main+0x92>
    127e:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <hour_count>
    1282:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <a_hour_count>
    1286:	98 17       	cp	r25, r24
    1288:	41 f1       	breq	.+80     	; 0x12da <main+0xe2>
      OCR3A = 158;
   }
   else {
      OCR3A = 0;
    128a:	10 92 87 00 	sts	0x0087, r1	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
    128e:	10 92 86 00 	sts	0x0086, r1	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>

   lcd_init();
   sei();				//Enable interrupts
   while(1){
      alarm_sound();
      fetch_adc();	//put this into an ISR
    1292:	0e 94 15 04 	call	0x82a	; 0x82a <fetch_adc>
      clock_time();
    1296:	0e 94 bb 02 	call	0x576	; 0x576 <clock_time>
      change_alarm_state();
    129a:	0e 94 92 03 	call	0x724	; 0x724 <change_alarm_state>
    129e:	ec e2       	ldi	r30, 0x2C	; 44
    12a0:	f1 e0       	ldi	r31, 0x01	; 1
    12a2:	80 e0       	ldi	r24, 0x00	; 0
      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
         if(alarm){
    12a4:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <alarm>
    12a8:	99 23       	and	r25, r25
    12aa:	29 f0       	breq	.+10     	; 0x12b6 <main+0xbe>
	    segment_data[2] &= 0b011;
    12ac:	90 91 2e 01 	lds	r25, 0x012E	; 0x80012e <__data_end+0x2>
    12b0:	93 70       	andi	r25, 0x03	; 3
    12b2:	90 93 2e 01 	sts	0x012E, r25	; 0x80012e <__data_end+0x2>
	 }
	 PORTA = segment_data[j];	//Writes the segment data to PORTA aka the segments
    12b6:	91 91       	ld	r25, Z+
    12b8:	9b bb       	out	0x1b, r25	; 27
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
    12ba:	98 2f       	mov	r25, r24
    12bc:	92 95       	swap	r25
    12be:	90 7f       	andi	r25, 0xF0	; 240
    12c0:	98 bb       	out	0x18, r25	; 24
    12c2:	af e1       	ldi	r26, 0x1F	; 31
    12c4:	b3 e0       	ldi	r27, 0x03	; 3
    12c6:	11 97       	sbiw	r26, 0x01	; 1
    12c8:	f1 f7       	brne	.-4      	; 0x12c6 <main+0xce>
    12ca:	00 c0       	rjmp	.+0      	; 0x12cc <main+0xd4>
    12cc:	00 00       	nop
				//the digit to be displayed is in pin 4, 5, and 6 
         _delay_us(200);		//delay so that the display does not flicker
         PORTA = 0xFF;
    12ce:	1b bb       	out	0x1b, r17	; 27
    12d0:	8f 5f       	subi	r24, 0xFF	; 255
   while(1){
      alarm_sound();
      fetch_adc();	//put this into an ISR
      clock_time();
      change_alarm_state();
      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
    12d2:	85 30       	cpi	r24, 0x05	; 5
    12d4:	39 f7       	brne	.-50     	; 0x12a4 <main+0xac>
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
				//the digit to be displayed is in pin 4, 5, and 6 
         _delay_us(200);		//delay so that the display does not flicker
         PORTA = 0xFF;
      }
	PORTB = 0x00;;
    12d6:	18 ba       	out	0x18, r1	; 24
   }
    12d8:	ce cf       	rjmp	.-100    	; 0x1276 <main+0x7e>
Function:
Description:
Parameters:
**********************************************************************/
void alarm_sound() {
   if(alarm && ((hour_count == a_hour_count) && (min_count == a_min_count))){
    12da:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <min_count>
    12de:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <a_min_count>
    12e2:	98 13       	cpse	r25, r24
    12e4:	d2 cf       	rjmp	.-92     	; 0x128a <main+0x92>
      OCR3A = 158;
    12e6:	d0 93 87 00 	sts	0x0087, r29	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
    12ea:	c0 93 86 00 	sts	0x0086, r28	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
    12ee:	d1 cf       	rjmp	.-94     	; 0x1292 <main+0x9a>

000012f0 <__divmodhi4>:
    12f0:	97 fb       	bst	r25, 7
    12f2:	07 2e       	mov	r0, r23
    12f4:	16 f4       	brtc	.+4      	; 0x12fa <__divmodhi4+0xa>
    12f6:	00 94       	com	r0
    12f8:	07 d0       	rcall	.+14     	; 0x1308 <__divmodhi4_neg1>
    12fa:	77 fd       	sbrc	r23, 7
    12fc:	09 d0       	rcall	.+18     	; 0x1310 <__divmodhi4_neg2>
    12fe:	0e 94 ab 09 	call	0x1356	; 0x1356 <__udivmodhi4>
    1302:	07 fc       	sbrc	r0, 7
    1304:	05 d0       	rcall	.+10     	; 0x1310 <__divmodhi4_neg2>
    1306:	3e f4       	brtc	.+14     	; 0x1316 <__divmodhi4_exit>

00001308 <__divmodhi4_neg1>:
    1308:	90 95       	com	r25
    130a:	81 95       	neg	r24
    130c:	9f 4f       	sbci	r25, 0xFF	; 255
    130e:	08 95       	ret

00001310 <__divmodhi4_neg2>:
    1310:	70 95       	com	r23
    1312:	61 95       	neg	r22
    1314:	7f 4f       	sbci	r23, 0xFF	; 255

00001316 <__divmodhi4_exit>:
    1316:	08 95       	ret

00001318 <__divmodsi4>:
    1318:	05 2e       	mov	r0, r21
    131a:	97 fb       	bst	r25, 7
    131c:	1e f4       	brtc	.+6      	; 0x1324 <__divmodsi4+0xc>
    131e:	00 94       	com	r0
    1320:	0e 94 a3 09 	call	0x1346	; 0x1346 <__negsi2>
    1324:	57 fd       	sbrc	r21, 7
    1326:	07 d0       	rcall	.+14     	; 0x1336 <__divmodsi4_neg2>
    1328:	0e 94 bf 09 	call	0x137e	; 0x137e <__udivmodsi4>
    132c:	07 fc       	sbrc	r0, 7
    132e:	03 d0       	rcall	.+6      	; 0x1336 <__divmodsi4_neg2>
    1330:	4e f4       	brtc	.+18     	; 0x1344 <__divmodsi4_exit>
    1332:	0c 94 a3 09 	jmp	0x1346	; 0x1346 <__negsi2>

00001336 <__divmodsi4_neg2>:
    1336:	50 95       	com	r21
    1338:	40 95       	com	r20
    133a:	30 95       	com	r19
    133c:	21 95       	neg	r18
    133e:	3f 4f       	sbci	r19, 0xFF	; 255
    1340:	4f 4f       	sbci	r20, 0xFF	; 255
    1342:	5f 4f       	sbci	r21, 0xFF	; 255

00001344 <__divmodsi4_exit>:
    1344:	08 95       	ret

00001346 <__negsi2>:
    1346:	90 95       	com	r25
    1348:	80 95       	com	r24
    134a:	70 95       	com	r23
    134c:	61 95       	neg	r22
    134e:	7f 4f       	sbci	r23, 0xFF	; 255
    1350:	8f 4f       	sbci	r24, 0xFF	; 255
    1352:	9f 4f       	sbci	r25, 0xFF	; 255
    1354:	08 95       	ret

00001356 <__udivmodhi4>:
    1356:	aa 1b       	sub	r26, r26
    1358:	bb 1b       	sub	r27, r27
    135a:	51 e1       	ldi	r21, 0x11	; 17
    135c:	07 c0       	rjmp	.+14     	; 0x136c <__udivmodhi4_ep>

0000135e <__udivmodhi4_loop>:
    135e:	aa 1f       	adc	r26, r26
    1360:	bb 1f       	adc	r27, r27
    1362:	a6 17       	cp	r26, r22
    1364:	b7 07       	cpc	r27, r23
    1366:	10 f0       	brcs	.+4      	; 0x136c <__udivmodhi4_ep>
    1368:	a6 1b       	sub	r26, r22
    136a:	b7 0b       	sbc	r27, r23

0000136c <__udivmodhi4_ep>:
    136c:	88 1f       	adc	r24, r24
    136e:	99 1f       	adc	r25, r25
    1370:	5a 95       	dec	r21
    1372:	a9 f7       	brne	.-22     	; 0x135e <__udivmodhi4_loop>
    1374:	80 95       	com	r24
    1376:	90 95       	com	r25
    1378:	bc 01       	movw	r22, r24
    137a:	cd 01       	movw	r24, r26
    137c:	08 95       	ret

0000137e <__udivmodsi4>:
    137e:	a1 e2       	ldi	r26, 0x21	; 33
    1380:	1a 2e       	mov	r1, r26
    1382:	aa 1b       	sub	r26, r26
    1384:	bb 1b       	sub	r27, r27
    1386:	fd 01       	movw	r30, r26
    1388:	0d c0       	rjmp	.+26     	; 0x13a4 <__udivmodsi4_ep>

0000138a <__udivmodsi4_loop>:
    138a:	aa 1f       	adc	r26, r26
    138c:	bb 1f       	adc	r27, r27
    138e:	ee 1f       	adc	r30, r30
    1390:	ff 1f       	adc	r31, r31
    1392:	a2 17       	cp	r26, r18
    1394:	b3 07       	cpc	r27, r19
    1396:	e4 07       	cpc	r30, r20
    1398:	f5 07       	cpc	r31, r21
    139a:	20 f0       	brcs	.+8      	; 0x13a4 <__udivmodsi4_ep>
    139c:	a2 1b       	sub	r26, r18
    139e:	b3 0b       	sbc	r27, r19
    13a0:	e4 0b       	sbc	r30, r20
    13a2:	f5 0b       	sbc	r31, r21

000013a4 <__udivmodsi4_ep>:
    13a4:	66 1f       	adc	r22, r22
    13a6:	77 1f       	adc	r23, r23
    13a8:	88 1f       	adc	r24, r24
    13aa:	99 1f       	adc	r25, r25
    13ac:	1a 94       	dec	r1
    13ae:	69 f7       	brne	.-38     	; 0x138a <__udivmodsi4_loop>
    13b0:	60 95       	com	r22
    13b2:	70 95       	com	r23
    13b4:	80 95       	com	r24
    13b6:	90 95       	com	r25
    13b8:	9b 01       	movw	r18, r22
    13ba:	ac 01       	movw	r20, r24
    13bc:	bd 01       	movw	r22, r26
    13be:	cf 01       	movw	r24, r30
    13c0:	08 95       	ret

000013c2 <_exit>:
    13c2:	f8 94       	cli

000013c4 <__stop_program>:
    13c4:	ff cf       	rjmp	.-2      	; 0x13c4 <__stop_program>
