
lab5.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000034  00800100  0000190a  0000199e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000190a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000ce  00800134  00800134  000019d2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000019d2  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001a04  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000a8  00000000  00000000  00001a40  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002c04  00000000  00000000  00001ae8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000010f5  00000000  00000000  000046ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000155c  00000000  00000000  000057e1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000578  00000000  00000000  00006d40  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000088e  00000000  00000000  000072b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001e62  00000000  00000000  00007b46  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000e0  00000000  00000000  000099a8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 97 00 	jmp	0x12e	; 0x12e <__ctors_end>
       4:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
       8:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
       c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      10:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      14:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      18:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      1c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      20:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      24:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      28:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      2c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      30:	0c 94 04 05 	jmp	0xa08	; 0xa08 <__vector_12>
      34:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      38:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      3c:	0c 94 ae 03 	jmp	0x75c	; 0x75c <__vector_15>
      40:	0c 94 78 03 	jmp	0x6f0	; 0x6f0 <__vector_16>
      44:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      48:	0c 94 43 05 	jmp	0xa86	; 0xa86 <__vector_18>
      4c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      50:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      54:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      58:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      5c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      60:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      64:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      68:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      6c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      70:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      74:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      78:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      7c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      80:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      84:	0c 94 27 0a 	jmp	0x144e	; 0x144e <__vector_33>
      88:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      8c:	68 0a       	sbc	r6, r24
      8e:	3f 0a       	sbc	r3, r31
      90:	3f 0a       	sbc	r3, r31
      92:	3f 0a       	sbc	r3, r31
      94:	3f 0a       	sbc	r3, r31
      96:	3f 0a       	sbc	r3, r31
      98:	3f 0a       	sbc	r3, r31
      9a:	3f 0a       	sbc	r3, r31
      9c:	68 0a       	sbc	r6, r24
      9e:	3f 0a       	sbc	r3, r31
      a0:	3f 0a       	sbc	r3, r31
      a2:	3f 0a       	sbc	r3, r31
      a4:	3f 0a       	sbc	r3, r31
      a6:	3f 0a       	sbc	r3, r31
      a8:	3f 0a       	sbc	r3, r31
      aa:	3f 0a       	sbc	r3, r31
      ac:	72 0a       	sbc	r7, r18
      ae:	3f 0a       	sbc	r3, r31
      b0:	3f 0a       	sbc	r3, r31
      b2:	3f 0a       	sbc	r3, r31
      b4:	3f 0a       	sbc	r3, r31
      b6:	3f 0a       	sbc	r3, r31
      b8:	3f 0a       	sbc	r3, r31
      ba:	3f 0a       	sbc	r3, r31
      bc:	3f 0a       	sbc	r3, r31
      be:	3f 0a       	sbc	r3, r31
      c0:	3f 0a       	sbc	r3, r31
      c2:	3f 0a       	sbc	r3, r31
      c4:	3f 0a       	sbc	r3, r31
      c6:	3f 0a       	sbc	r3, r31
      c8:	3f 0a       	sbc	r3, r31
      ca:	3f 0a       	sbc	r3, r31
      cc:	72 0a       	sbc	r7, r18
      ce:	3f 0a       	sbc	r3, r31
      d0:	3f 0a       	sbc	r3, r31
      d2:	3f 0a       	sbc	r3, r31
      d4:	3f 0a       	sbc	r3, r31
      d6:	3f 0a       	sbc	r3, r31
      d8:	3f 0a       	sbc	r3, r31
      da:	3f 0a       	sbc	r3, r31
      dc:	3f 0a       	sbc	r3, r31
      de:	3f 0a       	sbc	r3, r31
      e0:	3f 0a       	sbc	r3, r31
      e2:	3f 0a       	sbc	r3, r31
      e4:	3f 0a       	sbc	r3, r31
      e6:	3f 0a       	sbc	r3, r31
      e8:	3f 0a       	sbc	r3, r31
      ea:	3f 0a       	sbc	r3, r31
      ec:	89 0a       	sbc	r8, r25
      ee:	3f 0a       	sbc	r3, r31
      f0:	3f 0a       	sbc	r3, r31
      f2:	3f 0a       	sbc	r3, r31
      f4:	3f 0a       	sbc	r3, r31
      f6:	3f 0a       	sbc	r3, r31
      f8:	3f 0a       	sbc	r3, r31
      fa:	3f 0a       	sbc	r3, r31
      fc:	8d 0a       	sbc	r8, r29
      fe:	3f 0a       	sbc	r3, r31
     100:	3f 0a       	sbc	r3, r31
     102:	3f 0a       	sbc	r3, r31
     104:	3f 0a       	sbc	r3, r31
     106:	3f 0a       	sbc	r3, r31
     108:	3f 0a       	sbc	r3, r31
     10a:	3f 0a       	sbc	r3, r31
     10c:	3f 0a       	sbc	r3, r31
     10e:	3f 0a       	sbc	r3, r31
     110:	3f 0a       	sbc	r3, r31
     112:	3f 0a       	sbc	r3, r31
     114:	3f 0a       	sbc	r3, r31
     116:	3f 0a       	sbc	r3, r31
     118:	3f 0a       	sbc	r3, r31
     11a:	3f 0a       	sbc	r3, r31
     11c:	9b 0a       	sbc	r9, r27
     11e:	3f 0a       	sbc	r3, r31
     120:	3f 0a       	sbc	r3, r31
     122:	3f 0a       	sbc	r3, r31
     124:	3f 0a       	sbc	r3, r31
     126:	3f 0a       	sbc	r3, r31
     128:	3f 0a       	sbc	r3, r31
     12a:	3f 0a       	sbc	r3, r31
     12c:	59 0a       	sbc	r5, r25

0000012e <__ctors_end>:
     12e:	11 24       	eor	r1, r1
     130:	1f be       	out	0x3f, r1	; 63
     132:	cf ef       	ldi	r28, 0xFF	; 255
     134:	d0 e1       	ldi	r29, 0x10	; 16
     136:	de bf       	out	0x3e, r29	; 62
     138:	cd bf       	out	0x3d, r28	; 61

0000013a <__do_copy_data>:
     13a:	11 e0       	ldi	r17, 0x01	; 1
     13c:	a0 e0       	ldi	r26, 0x00	; 0
     13e:	b1 e0       	ldi	r27, 0x01	; 1
     140:	ea e0       	ldi	r30, 0x0A	; 10
     142:	f9 e1       	ldi	r31, 0x19	; 25
     144:	00 e0       	ldi	r16, 0x00	; 0
     146:	0b bf       	out	0x3b, r16	; 59
     148:	02 c0       	rjmp	.+4      	; 0x14e <__do_copy_data+0x14>
     14a:	07 90       	elpm	r0, Z+
     14c:	0d 92       	st	X+, r0
     14e:	a4 33       	cpi	r26, 0x34	; 52
     150:	b1 07       	cpc	r27, r17
     152:	d9 f7       	brne	.-10     	; 0x14a <__do_copy_data+0x10>

00000154 <__do_clear_bss>:
     154:	22 e0       	ldi	r18, 0x02	; 2
     156:	a4 e3       	ldi	r26, 0x34	; 52
     158:	b1 e0       	ldi	r27, 0x01	; 1
     15a:	01 c0       	rjmp	.+2      	; 0x15e <.do_clear_bss_start>

0000015c <.do_clear_bss_loop>:
     15c:	1d 92       	st	X+, r1

0000015e <.do_clear_bss_start>:
     15e:	a2 30       	cpi	r26, 0x02	; 2
     160:	b2 07       	cpc	r27, r18
     162:	e1 f7       	brne	.-8      	; 0x15c <.do_clear_bss_loop>
     164:	0e 94 26 0b 	call	0x164c	; 0x164c <main>
     168:	0c 94 83 0c 	jmp	0x1906	; 0x1906 <_exit>

0000016c <__bad_interrupt>:
     16c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000170 <snoozin.part.1>:
	seconds equals the normal seconds. 
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
      if(a_sec_count == sec_count)
     170:	90 91 45 01 	lds	r25, 0x0145	; 0x800145 <a_sec_count>
     174:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <sec_count>
     178:	98 17       	cp	r25, r24
     17a:	21 f0       	breq	.+8      	; 0x184 <snoozin.part.1+0x14>
         snooze = 0;
      else 
         snooze = 1;
     17c:	81 e0       	ldi	r24, 0x01	; 1
     17e:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <snooze>
     182:	08 95       	ret
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
      if(a_sec_count == sec_count)
         snooze = 0;
     184:	10 92 40 01 	sts	0x0140, r1	; 0x800140 <snooze>
     188:	08 95       	ret

0000018a <spi_init>:
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
     18a:	87 b3       	in	r24, 0x17	; 23
     18c:	87 60       	ori	r24, 0x07	; 7
     18e:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
     190:	8d b1       	in	r24, 0x0d	; 13
     192:	8c 65       	ori	r24, 0x5C	; 92
     194:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
     196:	70 9a       	sbi	0x0e, 0	; 14
     198:	08 95       	ret

0000019a <tcnt0_init>:
Description: Timer counter 0 is initialized in normal mode with no prescale
	and will be used as a seconds counter for the clock
Parameters: NA
**********************************************************************/
void tcnt0_init(){
   ASSR |= (1<<AS0);
     19a:	80 b7       	in	r24, 0x30	; 48
     19c:	88 60       	ori	r24, 0x08	; 8
     19e:	80 bf       	out	0x30, r24	; 48
   TIMSK |= (1<<OCIE0) | (1<<TOIE0);			//enable interrupts
     1a0:	87 b7       	in	r24, 0x37	; 55
     1a2:	83 60       	ori	r24, 0x03	; 3
     1a4:	87 bf       	out	0x37, r24	; 55
   TCCR0 |= (1<<CS00);			//normal mode, no prescale
     1a6:	83 b7       	in	r24, 0x33	; 51
     1a8:	81 60       	ori	r24, 0x01	; 1
     1aa:	83 bf       	out	0x33, r24	; 51
   OCR0 = 0xFF;
     1ac:	8f ef       	ldi	r24, 0xFF	; 255
     1ae:	81 bf       	out	0x31, r24	; 49
     1b0:	08 95       	ret

000001b2 <tcnt1_init>:
Description: Timer counter 1 is initialized in CTC mode, 64 bit prescaler
	so that it can be used to generate an alarm frequency
Parameters: NA
**********************************************************************/
void tcnt1_init(){
   TCCR1B |= (1<<CS11) | (1<<CS10) | (1<<WGM12);		//CTC mode, 64bit prescaler
     1b2:	8e b5       	in	r24, 0x2e	; 46
     1b4:	8b 60       	ori	r24, 0x0B	; 11
     1b6:	8e bd       	out	0x2e, r24	; 46
   TCCR1C = 0x00;
     1b8:	10 92 7a 00 	sts	0x007A, r1	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
   TIMSK  |= (1<<OCIE1A) | (1<<TOIE1);	//enable flag for interrupt 
     1bc:	87 b7       	in	r24, 0x37	; 55
     1be:	84 61       	ori	r24, 0x14	; 20
     1c0:	87 bf       	out	0x37, r24	; 55
   OCR1A = 0x0040;		//compare match at 64
     1c2:	80 e4       	ldi	r24, 0x40	; 64
     1c4:	90 e0       	ldi	r25, 0x00	; 0
     1c6:	9b bd       	out	0x2b, r25	; 43
     1c8:	8a bd       	out	0x2a, r24	; 42
     1ca:	08 95       	ret

000001cc <tcnt2_init>:
	normal mode with a 64 bit prescaler. OCRA2 is adjusted to change
	the pwn produced.
Parameters: NA
**********************************************************************/
void tcnt2_init(){
   TCCR2 |= (1<<WGM21) | (1<<WGM20)| (1<<CS20) | (1<<COM21);			
     1cc:	85 b5       	in	r24, 0x25	; 37
     1ce:	89 66       	ori	r24, 0x69	; 105
     1d0:	85 bd       	out	0x25, r24	; 37
     1d2:	08 95       	ret

000001d4 <tcnt3_init>:
Description: This timer is used as a volume control for the audio amp.
	I adjust the value of OCR3A to change the pwm.
Parameters: NA
**********************************************************************/
void tcnt3_init(){
   TCCR3A |= (1<<COM3A1) | (1<<WGM31);	 //Clear on OCR3A match
     1d4:	eb e8       	ldi	r30, 0x8B	; 139
     1d6:	f0 e0       	ldi	r31, 0x00	; 0
     1d8:	80 81       	ld	r24, Z
     1da:	82 68       	ori	r24, 0x82	; 130
     1dc:	80 83       	st	Z, r24
   TCCR3B |= (1<<CS30) | (1<<WGM32) | (1<<WGM33);		//Fast PWM mode, no prescaler
     1de:	ea e8       	ldi	r30, 0x8A	; 138
     1e0:	f0 e0       	ldi	r31, 0x00	; 0
     1e2:	80 81       	ld	r24, Z
     1e4:	89 61       	ori	r24, 0x19	; 25
     1e6:	80 83       	st	Z, r24
   TCCR3C = 0x00;
     1e8:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x7e008c>
   ICR3 = 0x9F;				//Setting the TOP value
     1ec:	8f e9       	ldi	r24, 0x9F	; 159
     1ee:	90 e0       	ldi	r25, 0x00	; 0
     1f0:	90 93 81 00 	sts	0x0081, r25	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
     1f4:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
   TCNT3 = 0x0000; 			//Initialize TNCT1 to 0
     1f8:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     1fc:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
   OCR3A = 0x9F;			//Volume Control 0x9F=Max 0x00=Min
     200:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     204:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
     208:	08 95       	ret

0000020a <spi_read>:
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
     20a:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
     20c:	77 9b       	sbis	0x0e, 7	; 14
     20e:	fe cf       	rjmp	.-4      	; 0x20c <spi_read+0x2>
   return SPDR;
     210:	8f b1       	in	r24, 0x0f	; 15
}
     212:	08 95       	ret

00000214 <chk_buttons>:
	be implemented at the same time. Adapted to check all buttons from 
	Ganssel's "Guide to Debouncing" Expects active low pushbuttons on PINA 
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
     214:	48 2f       	mov	r20, r24
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
     216:	e8 2f       	mov	r30, r24
     218:	f0 e0       	ldi	r31, 0x00	; 0
     21a:	99 b3       	in	r25, 0x19	; 25
     21c:	ee 0f       	add	r30, r30
     21e:	ff 1f       	adc	r31, r31
     220:	e2 5b       	subi	r30, 0xB2	; 178
     222:	fe 4f       	sbci	r31, 0xFE	; 254
     224:	20 81       	ld	r18, Z
     226:	31 81       	ldd	r19, Z+1	; 0x01
     228:	22 0f       	add	r18, r18
     22a:	33 1f       	adc	r19, r19
     22c:	30 6e       	ori	r19, 0xE0	; 224
     22e:	89 2f       	mov	r24, r25
     230:	90 e0       	ldi	r25, 0x00	; 0
     232:	02 c0       	rjmp	.+4      	; 0x238 <chk_buttons+0x24>
     234:	95 95       	asr	r25
     236:	87 95       	ror	r24
     238:	4a 95       	dec	r20
     23a:	e2 f7       	brpl	.-8      	; 0x234 <chk_buttons+0x20>
     23c:	81 70       	andi	r24, 0x01	; 1
     23e:	99 27       	eor	r25, r25
     240:	28 2b       	or	r18, r24
     242:	39 2b       	or	r19, r25
     244:	31 83       	std	Z+1, r19	; 0x01
     246:	20 83       	st	Z, r18
     248:	81 e0       	ldi	r24, 0x01	; 1
     24a:	21 15       	cp	r18, r1
     24c:	30 4f       	sbci	r19, 0xF0	; 240
     24e:	09 f0       	breq	.+2      	; 0x252 <chk_buttons+0x3e>
     250:	80 e0       	ldi	r24, 0x00	; 0
  if (state[button] == 0xF000)
    return 1;
return 0;
}
     252:	08 95       	ret

00000254 <bars>:
Description:This function reads in the button board and updates the 
	LEDs on the bargraph through the serial port.
Parameters: NA
**********************************************************************/
void bars() {
   DDRA = 0x00;				//Set all as inputs
     254:	1a ba       	out	0x1a, r1	; 26
   PORTA = 0xFF;			//Pull up resistors
     256:	8f ef       	ldi	r24, 0xFF	; 255
     258:	8b bb       	out	0x1b, r24	; 27
   PORTB |= PINB | 0x70;		//Enable tristate buffer
     25a:	86 b3       	in	r24, 0x16	; 22
     25c:	98 b3       	in	r25, 0x18	; 24
     25e:	80 67       	ori	r24, 0x70	; 112
     260:	89 2b       	or	r24, r25
     262:	88 bb       	out	0x18, r24	; 24
     264:	ee e4       	ldi	r30, 0x4E	; 78
     266:	f1 e0       	ldi	r31, 0x01	; 1

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     268:	20 e0       	ldi	r18, 0x00	; 0
     26a:	30 e0       	ldi	r19, 0x00	; 0
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
     26c:	61 e0       	ldi	r22, 0x01	; 1
     26e:	70 e0       	ldi	r23, 0x00	; 0
     270:	05 c0       	rjmp	.+10     	; 0x27c <bars+0x28>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     272:	2f 5f       	subi	r18, 0xFF	; 255
     274:	3f 4f       	sbci	r19, 0xFF	; 255
     276:	28 30       	cpi	r18, 0x08	; 8
     278:	31 05       	cpc	r19, r1
     27a:	39 f1       	breq	.+78     	; 0x2ca <bars+0x76>
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
     27c:	99 b3       	in	r25, 0x19	; 25
     27e:	40 81       	ld	r20, Z
     280:	51 81       	ldd	r21, Z+1	; 0x01
     282:	44 0f       	add	r20, r20
     284:	55 1f       	adc	r21, r21
     286:	89 2f       	mov	r24, r25
     288:	90 e0       	ldi	r25, 0x00	; 0
     28a:	02 2e       	mov	r0, r18
     28c:	02 c0       	rjmp	.+4      	; 0x292 <bars+0x3e>
     28e:	95 95       	asr	r25
     290:	87 95       	ror	r24
     292:	0a 94       	dec	r0
     294:	e2 f7       	brpl	.-8      	; 0x28e <bars+0x3a>
     296:	81 70       	andi	r24, 0x01	; 1
     298:	99 27       	eor	r25, r25
     29a:	84 2b       	or	r24, r20
     29c:	95 2b       	or	r25, r21
     29e:	90 6e       	ori	r25, 0xE0	; 224
     2a0:	81 93       	st	Z+, r24
     2a2:	91 93       	st	Z+, r25
  if (state[button] == 0xF000)
     2a4:	81 15       	cp	r24, r1
     2a6:	90 4f       	sbci	r25, 0xF0	; 240
     2a8:	21 f7       	brne	.-56     	; 0x272 <bars+0x1e>
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
     2aa:	cb 01       	movw	r24, r22
     2ac:	02 2e       	mov	r0, r18
     2ae:	02 c0       	rjmp	.+4      	; 0x2b4 <bars+0x60>
     2b0:	88 0f       	add	r24, r24
     2b2:	99 1f       	adc	r25, r25
     2b4:	0a 94       	dec	r0
     2b6:	e2 f7       	brpl	.-8      	; 0x2b0 <bars+0x5c>
     2b8:	90 93 3e 01 	sts	0x013E, r25	; 0x80013e <mult+0x1>
     2bc:	80 93 3d 01 	sts	0x013D, r24	; 0x80013d <mult>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     2c0:	2f 5f       	subi	r18, 0xFF	; 255
     2c2:	3f 4f       	sbci	r19, 0xFF	; 255
     2c4:	28 30       	cpi	r18, 0x08	; 8
     2c6:	31 05       	cpc	r19, r1
     2c8:	c9 f6       	brne	.-78     	; 0x27c <bars+0x28>
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
     2ca:	88 b3       	in	r24, 0x18	; 24
     2cc:	18 ba       	out	0x18, r1	; 24
   if(mult == 128){			//Button 8 toggles base 10 and 16
     2ce:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <mult>
     2d2:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <mult+0x1>
     2d6:	80 38       	cpi	r24, 0x80	; 128
     2d8:	91 05       	cpc	r25, r1
     2da:	09 f4       	brne	.+2      	; 0x2de <bars+0x8a>
     2dc:	79 c0       	rjmp	.+242    	; 0x3d0 <bars+0x17c>
      alarm = !(alarm);			//on the LED display
   }
   if(mult == 64){		//Button 7 toggles snooze
     2de:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <mult>
     2e2:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <mult+0x1>
     2e6:	80 34       	cpi	r24, 0x40	; 64
     2e8:	91 05       	cpc	r25, r1
     2ea:	c9 f1       	breq	.+114    	; 0x35e <bars+0x10a>
	       a_hour_count = 0;
	    }
	 }  
      }
   }
   if(mult > 4) {			//I only want values from the
     2ec:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <mult>
     2f0:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <mult+0x1>
     2f4:	05 97       	sbiw	r24, 0x05	; 5
     2f6:	20 f0       	brcs	.+8      	; 0x300 <bars+0xac>
      mult = 0;				//first three buttons
     2f8:	10 92 3e 01 	sts	0x013E, r1	; 0x80013e <mult+0x1>
     2fc:	10 92 3d 01 	sts	0x013D, r1	; 0x80013d <mult>
   }
   //This switch statement is used to enable a 'toggle' functionality
   //so that modes can be selected an deselected
   switch(mult) {
     300:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <mult>
     304:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <mult+0x1>
     308:	81 30       	cpi	r24, 0x01	; 1
     30a:	91 05       	cpc	r25, r1
     30c:	19 f0       	breq	.+6      	; 0x314 <bars+0xc0>
     30e:	82 30       	cpi	r24, 0x02	; 2
     310:	91 05       	cpc	r25, r1
     312:	01 f5       	brne	.+64     	; 0x354 <bars+0x100>
	 }
	 else
	    mode_sel = 1;		//If not, then change mode
         break;
      case 2:
	 if((mode_sel ^ mult) == 0 ){//if((mode_sel ^ mult) && (mode_sel == 4)){//if cur &prev are diff
     314:	40 91 39 01 	lds	r20, 0x0139	; 0x800139 <mode_sel>
     318:	50 91 3a 01 	lds	r21, 0x013A	; 0x80013a <mode_sel+0x1>
     31c:	20 91 3d 01 	lds	r18, 0x013D	; 0x80013d <mult>
     320:	30 91 3e 01 	lds	r19, 0x013E	; 0x80013e <mult+0x1>
     324:	42 17       	cp	r20, r18
     326:	53 07       	cpc	r21, r19
     328:	09 f4       	brne	.+2      	; 0x32c <bars+0xd8>
     32a:	5a c0       	rjmp	.+180    	; 0x3e0 <bars+0x18c>
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
         break;*/
      default:
	 mode_sel = mode_sel;		//no/invalid button press
     32c:	90 93 3a 01 	sts	0x013A, r25	; 0x80013a <mode_sel+0x1>
     330:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <mode_sel>
   }   
   mult = 0;				//clear mult for next pass
     334:	10 92 3e 01 	sts	0x013E, r1	; 0x80013e <mult+0x1>
     338:	10 92 3d 01 	sts	0x013D, r1	; 0x80013d <mult>

   DDRA = 0xFF;				//Set A to alloutputs
     33c:	8f ef       	ldi	r24, 0xFF	; 255
     33e:	8a bb       	out	0x1a, r24	; 26
   SPDR = mode_sel;			//Write mode to the Bargraph
     340:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <mode_sel>
     344:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <mode_sel+0x1>
     348:	8f b9       	out	0x0f, r24	; 15
   while(bit_is_clear(SPSR, SPIF)){}	
     34a:	77 9b       	sbis	0x0e, 7	; 14
     34c:	fe cf       	rjmp	.-4      	; 0x34a <bars+0xf6>
   PORTB |= (1<<PB0);			//Rgclk high on bargraph
     34e:	c0 9a       	sbi	0x18, 0	; 24
   PORTB &= 0xFE;			//Rgclk low on bargraph
     350:	c0 98       	cbi	0x18, 0	; 24
   
return ;
     352:	08 95       	ret
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
         break;*/
      default:
	 mode_sel = mode_sel;		//no/invalid button press
     354:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <mode_sel>
     358:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <mode_sel+0x1>
     35c:	e7 cf       	rjmp	.-50     	; 0x32c <bars+0xd8>
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
   }
   if(mult == 64){		//Button 7 toggles snooze
      snooze = !(snooze);		//10 second snooze functionality
     35e:	90 91 40 01 	lds	r25, 0x0140	; 0x800140 <snooze>
     362:	81 e0       	ldi	r24, 0x01	; 1
     364:	91 11       	cpse	r25, r1
     366:	45 c0       	rjmp	.+138    	; 0x3f2 <bars+0x19e>
     368:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <snooze>
      a_sec_count = sec_count + 10;
     36c:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <sec_count>
     370:	86 5f       	subi	r24, 0xF6	; 246
     372:	80 93 45 01 	sts	0x0145, r24	; 0x800145 <a_sec_count>
      if(a_sec_count > 60){
     376:	80 91 45 01 	lds	r24, 0x0145	; 0x800145 <a_sec_count>
     37a:	8d 33       	cpi	r24, 0x3D	; 61
     37c:	08 f4       	brcc	.+2      	; 0x380 <bars+0x12c>
     37e:	b6 cf       	rjmp	.-148    	; 0x2ec <bars+0x98>
         a_sec_count = a_sec_count % 60;
     380:	90 91 45 01 	lds	r25, 0x0145	; 0x800145 <a_sec_count>
     384:	89 e8       	ldi	r24, 0x89	; 137
     386:	98 9f       	mul	r25, r24
     388:	81 2d       	mov	r24, r1
     38a:	11 24       	eor	r1, r1
     38c:	82 95       	swap	r24
     38e:	86 95       	lsr	r24
     390:	87 70       	andi	r24, 0x07	; 7
     392:	2c e3       	ldi	r18, 0x3C	; 60
     394:	82 9f       	mul	r24, r18
     396:	90 19       	sub	r25, r0
     398:	11 24       	eor	r1, r1
     39a:	90 93 45 01 	sts	0x0145, r25	; 0x800145 <a_sec_count>
	 a_min_count++;
     39e:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <a_min_count>
     3a2:	8f 5f       	subi	r24, 0xFF	; 255
     3a4:	80 93 44 01 	sts	0x0144, r24	; 0x800144 <a_min_count>
	 if(a_min_count == 60){
     3a8:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <a_min_count>
     3ac:	8c 33       	cpi	r24, 0x3C	; 60
     3ae:	09 f0       	breq	.+2      	; 0x3b2 <bars+0x15e>
     3b0:	9d cf       	rjmp	.-198    	; 0x2ec <bars+0x98>
	    a_hour_count++;
     3b2:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <a_hour_count>
     3b6:	8f 5f       	subi	r24, 0xFF	; 255
     3b8:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <a_hour_count>
	    a_min_count = 0;
     3bc:	10 92 44 01 	sts	0x0144, r1	; 0x800144 <a_min_count>
	    if(a_hour_count == 24){
     3c0:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <a_hour_count>
     3c4:	88 31       	cpi	r24, 0x18	; 24
     3c6:	09 f0       	breq	.+2      	; 0x3ca <bars+0x176>
     3c8:	91 cf       	rjmp	.-222    	; 0x2ec <bars+0x98>
	       a_hour_count = 0;
     3ca:	10 92 43 01 	sts	0x0143, r1	; 0x800143 <a_hour_count>
     3ce:	8e cf       	rjmp	.-228    	; 0x2ec <bars+0x98>
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
     3d0:	90 91 41 01 	lds	r25, 0x0141	; 0x800141 <alarm>
     3d4:	81 e0       	ldi	r24, 0x01	; 1
     3d6:	91 11       	cpse	r25, r1
     3d8:	08 c0       	rjmp	.+16     	; 0x3ea <bars+0x196>
     3da:	80 93 41 01 	sts	0x0141, r24	; 0x800141 <alarm>
     3de:	7f cf       	rjmp	.-258    	; 0x2de <bars+0x8a>
	 else
	    mode_sel = 1;		//If not, then change mode
         break;
      case 2:
	 if((mode_sel ^ mult) == 0 ){//if((mode_sel ^ mult) && (mode_sel == 4)){//if cur &prev are diff
	    mode_sel = 0;//and prev isn't = 1 then two modes are selected
     3e0:	10 92 3a 01 	sts	0x013A, r1	; 0x80013a <mode_sel+0x1>
     3e4:	10 92 39 01 	sts	0x0139, r1	; 0x800139 <mode_sel>
     3e8:	a5 cf       	rjmp	.-182    	; 0x334 <bars+0xe0>
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
     3ea:	80 e0       	ldi	r24, 0x00	; 0
     3ec:	80 93 41 01 	sts	0x0141, r24	; 0x800141 <alarm>
     3f0:	76 cf       	rjmp	.-276    	; 0x2de <bars+0x8a>
   }
   if(mult == 64){		//Button 7 toggles snooze
      snooze = !(snooze);		//10 second snooze functionality
     3f2:	80 e0       	ldi	r24, 0x00	; 0
     3f4:	b9 cf       	rjmp	.-142    	; 0x368 <bars+0x114>

000003f6 <read_encoder>:
   int8_t value = 0x00;
   uint8_t ec_a;
   uint8_t ec_b;

   //Shift_LD_N low
   PORTE &= 0x00;	//Begining of SHIFT_LD_N pulse. It is low here
     3f6:	83 b1       	in	r24, 0x03	; 3
     3f8:	13 b8       	out	0x03, r1	; 3
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     3fa:	87 ec       	ldi	r24, 0xC7	; 199
     3fc:	90 e0       	ldi	r25, 0x00	; 0
     3fe:	01 97       	sbiw	r24, 0x01	; 1
     400:	f1 f7       	brne	.-4      	; 0x3fe <read_encoder+0x8>
     402:	00 c0       	rjmp	.+0      	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
     404:	00 00       	nop
   _delay_us(50);
   PORTE |= 0xFF;	//End of SHIFT_LD_N pulse. back to high
     406:	83 b1       	in	r24, 0x03	; 3
     408:	8f ef       	ldi	r24, 0xFF	; 255
     40a:	83 b9       	out	0x03, r24	; 3
   PORTD &= 0x0F;	//CLK_INH low
     40c:	82 b3       	in	r24, 0x12	; 18
     40e:	8f 70       	andi	r24, 0x0F	; 15
     410:	82 bb       	out	0x12, r24	; 18
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
     412:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
     414:	77 9b       	sbis	0x0e, 7	; 14
     416:	fe cf       	rjmp	.-4      	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
   return SPDR;
     418:	9f b1       	in	r25, 0x0f	; 15
   _delay_us(50);
   PORTE |= 0xFF;	//End of SHIFT_LD_N pulse. back to high
   PORTD &= 0x0F;	//CLK_INH low

   encoder_value = spi_read();
   PORTD |= 0xF0;	//CLK_INH high
     41a:	82 b3       	in	r24, 0x12	; 18
     41c:	80 6f       	ori	r24, 0xF0	; 240
     41e:	82 bb       	out	0x12, r24	; 18
   value = mode_sel;
     420:	20 91 39 01 	lds	r18, 0x0139	; 0x800139 <mode_sel>
     424:	30 91 3a 01 	lds	r19, 0x013A	; 0x80013a <mode_sel+0x1>
     428:	82 2f       	mov	r24, r18
   ec_a = encoder_value & 0x03;  //Only grabs these bits 0000_0011
     42a:	69 2f       	mov	r22, r25
     42c:	63 70       	andi	r22, 0x03	; 3
   ec_b = encoder_value & 0x0C;  //Only grabs these bits 0000_1100 
     42e:	9c 70       	andi	r25, 0x0C	; 12
   ec_b = (ec_b >> 2);
     430:	96 95       	lsr	r25
     432:	96 95       	lsr	r25

//mode_sel == 0 means that no mode has been selected and the speaker volume can be adjusted
   if(mode_sel == 0){
     434:	20 91 39 01 	lds	r18, 0x0139	; 0x800139 <mode_sel>
     438:	30 91 3a 01 	lds	r19, 0x013A	; 0x80013a <mode_sel+0x1>
     43c:	23 2b       	or	r18, r19
     43e:	09 f5       	brne	.+66     	; 0x482 <__LOCK_REGION_LENGTH__+0x82>
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     440:	20 91 78 01 	lds	r18, 0x0178	; 0x800178 <EC_a_prev>
     444:	46 2f       	mov	r20, r22
     446:	50 e0       	ldi	r21, 0x00	; 0
     448:	02 2e       	mov	r0, r18
     44a:	00 0c       	add	r0, r0
     44c:	33 0b       	sbc	r19, r19
     44e:	42 17       	cp	r20, r18
     450:	53 07       	cpc	r21, r19
     452:	b9 f0       	breq	.+46     	; 0x482 <__LOCK_REGION_LENGTH__+0x82>
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     454:	20 91 78 01 	lds	r18, 0x0178	; 0x800178 <EC_a_prev>
     458:	21 11       	cpse	r18, r1
     45a:	26 c0       	rjmp	.+76     	; 0x4a8 <__LOCK_REGION_LENGTH__+0xa8>
     45c:	61 30       	cpi	r22, 0x01	; 1
     45e:	21 f5       	brne	.+72     	; 0x4a8 <__LOCK_REGION_LENGTH__+0xa8>
            volume += 10;	//increment volume
     460:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     464:	26 5f       	subi	r18, 0xF6	; 246
     466:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <volume>
	    if(volume <= 0x9F){
     46a:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     46e:	20 3a       	cpi	r18, 0xA0	; 160
     470:	08 f0       	brcs	.+2      	; 0x474 <__LOCK_REGION_LENGTH__+0x74>
     472:	e5 c0       	rjmp	.+458    	; 0x63e <__LOCK_REGION_LENGTH__+0x23e>
	    }
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
	    volume -= 10;	//decrement volume 
	    if(volume >= 0x00){
		OCR3A = volume;	//minimum volume
     474:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     478:	30 e0       	ldi	r19, 0x00	; 0
     47a:	30 93 87 00 	sts	0x0087, r19	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     47e:	20 93 86 00 	sts	0x0086, r18	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
	    value = 0;
      }*/
   }

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
     482:	20 91 39 01 	lds	r18, 0x0139	; 0x800139 <mode_sel>
     486:	30 91 3a 01 	lds	r19, 0x013A	; 0x80013a <mode_sel+0x1>
     48a:	21 30       	cpi	r18, 0x01	; 1
     48c:	31 05       	cpc	r19, r1
     48e:	f1 f0       	breq	.+60     	; 0x4cc <__LOCK_REGION_LENGTH__+0xcc>
         else
	    value = 0;
      }
   }
//mode_sel == 2 means that the user has selected the "alarm time change" mode
   if(mode_sel == 2){
     490:	20 91 39 01 	lds	r18, 0x0139	; 0x800139 <mode_sel>
     494:	30 91 3a 01 	lds	r19, 0x013A	; 0x80013a <mode_sel+0x1>
     498:	22 30       	cpi	r18, 0x02	; 2
     49a:	31 05       	cpc	r19, r1
     49c:	b1 f1       	breq	.+108    	; 0x50a <__LOCK_REGION_LENGTH__+0x10a>
         else
	    value = 0;
      }
   }
//Saves previous values into volatile variables
EC_a_prev = ec_a;
     49e:	60 93 78 01 	sts	0x0178, r22	; 0x800178 <EC_a_prev>
EC_b_prev = ec_b;
     4a2:	90 93 66 01 	sts	0x0166, r25	; 0x800166 <EC_b_prev>

return value;
}
     4a6:	08 95       	ret
	    else {
		volume = 0x9F;
		OCR3A = 0x9F;
	    }
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     4a8:	20 91 78 01 	lds	r18, 0x0178	; 0x800178 <EC_a_prev>
     4ac:	21 11       	cpse	r18, r1
     4ae:	03 c0       	rjmp	.+6      	; 0x4b6 <__LOCK_REGION_LENGTH__+0xb6>
     4b0:	62 30       	cpi	r22, 0x02	; 2
     4b2:	09 f4       	brne	.+2      	; 0x4b6 <__LOCK_REGION_LENGTH__+0xb6>
     4b4:	af c0       	rjmp	.+350    	; 0x614 <__LOCK_REGION_LENGTH__+0x214>
		volume = 0x00;
		OCR3A = 0x00;
	    }
         }
         else	//If not one of the state changes above, do nothing
	 volume = volume;
     4b6:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     4ba:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <volume>
	    value = 0;
      }*/
   }

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
     4be:	20 91 39 01 	lds	r18, 0x0139	; 0x800139 <mode_sel>
     4c2:	30 91 3a 01 	lds	r19, 0x013A	; 0x80013a <mode_sel+0x1>
     4c6:	21 30       	cpi	r18, 0x01	; 1
     4c8:	31 05       	cpc	r19, r1
     4ca:	11 f7       	brne	.-60     	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     4cc:	20 91 78 01 	lds	r18, 0x0178	; 0x800178 <EC_a_prev>
     4d0:	46 2f       	mov	r20, r22
     4d2:	50 e0       	ldi	r21, 0x00	; 0
     4d4:	02 2e       	mov	r0, r18
     4d6:	00 0c       	add	r0, r0
     4d8:	33 0b       	sbc	r19, r19
     4da:	42 17       	cp	r20, r18
     4dc:	53 07       	cpc	r21, r19
     4de:	09 f4       	brne	.+2      	; 0x4e2 <__LOCK_REGION_LENGTH__+0xe2>
     4e0:	5a c0       	rjmp	.+180    	; 0x596 <__LOCK_REGION_LENGTH__+0x196>
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     4e2:	20 91 78 01 	lds	r18, 0x0178	; 0x800178 <EC_a_prev>
     4e6:	22 23       	and	r18, r18
     4e8:	09 f4       	brne	.+2      	; 0x4ec <__LOCK_REGION_LENGTH__+0xec>
     4ea:	47 c0       	rjmp	.+142    	; 0x57a <__LOCK_REGION_LENGTH__+0x17a>
            hour_count = hour_count + 1;//value = value;
	    if(hour_count == 24)
	       hour_count = 0;
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     4ec:	20 91 78 01 	lds	r18, 0x0178	; 0x800178 <EC_a_prev>
     4f0:	21 11       	cpse	r18, r1
     4f2:	03 c0       	rjmp	.+6      	; 0x4fa <__LOCK_REGION_LENGTH__+0xfa>
     4f4:	62 30       	cpi	r22, 0x02	; 2
     4f6:	09 f4       	brne	.+2      	; 0x4fa <__LOCK_REGION_LENGTH__+0xfa>
     4f8:	80 c0       	rjmp	.+256    	; 0x5fa <__LOCK_REGION_LENGTH__+0x1fa>
	    hour_count = hour_count - 1;//value = -(value);
	    if(hour_count < 0)
	       hour_count = 23; 
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
     4fa:	80 e0       	ldi	r24, 0x00	; 0
         else
	    value = 0;
      }
   }
//mode_sel == 2 means that the user has selected the "alarm time change" mode
   if(mode_sel == 2){
     4fc:	20 91 39 01 	lds	r18, 0x0139	; 0x800139 <mode_sel>
     500:	30 91 3a 01 	lds	r19, 0x013A	; 0x80013a <mode_sel+0x1>
     504:	22 30       	cpi	r18, 0x02	; 2
     506:	31 05       	cpc	r19, r1
     508:	51 f6       	brne	.-108    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     50a:	20 91 78 01 	lds	r18, 0x0178	; 0x800178 <EC_a_prev>
     50e:	46 2f       	mov	r20, r22
     510:	50 e0       	ldi	r21, 0x00	; 0
     512:	02 2e       	mov	r0, r18
     514:	00 0c       	add	r0, r0
     516:	33 0b       	sbc	r19, r19
     518:	42 17       	cp	r20, r18
     51a:	53 07       	cpc	r21, r19
     51c:	d1 f0       	breq	.+52     	; 0x552 <__LOCK_REGION_LENGTH__+0x152>
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     51e:	20 91 78 01 	lds	r18, 0x0178	; 0x800178 <EC_a_prev>
     522:	21 11       	cpse	r18, r1
     524:	03 c0       	rjmp	.+6      	; 0x52c <__LOCK_REGION_LENGTH__+0x12c>
     526:	61 30       	cpi	r22, 0x01	; 1
     528:	09 f4       	brne	.+2      	; 0x52c <__LOCK_REGION_LENGTH__+0x12c>
     52a:	7c c0       	rjmp	.+248    	; 0x624 <__LOCK_REGION_LENGTH__+0x224>
            a_hour_count = a_hour_count + 1;//value = value;
	    if(a_hour_count == 24)
	       a_hour_count = 0;
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     52c:	20 91 78 01 	lds	r18, 0x0178	; 0x800178 <EC_a_prev>
     530:	21 11       	cpse	r18, r1
     532:	1d c0       	rjmp	.+58     	; 0x56e <__LOCK_REGION_LENGTH__+0x16e>
     534:	62 30       	cpi	r22, 0x02	; 2
     536:	d9 f4       	brne	.+54     	; 0x56e <__LOCK_REGION_LENGTH__+0x16e>
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
	    a_min_count = a_min_count - 1; //value = -(value);
	    if(a_min_count < 0){
	       a_min_count = 59;
	       a_hour_count--;
     538:	20 91 43 01 	lds	r18, 0x0143	; 0x800143 <a_hour_count>
     53c:	21 50       	subi	r18, 0x01	; 1
     53e:	20 93 43 01 	sts	0x0143, r18	; 0x800143 <a_hour_count>
	       if(a_hour_count < 0){
     542:	20 91 43 01 	lds	r18, 0x0143	; 0x800143 <a_hour_count>
     546:	27 ff       	sbrs	r18, 7
     548:	aa cf       	rjmp	.-172    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
	          a_hour_count = 23;
     54a:	27 e1       	ldi	r18, 0x17	; 23
     54c:	20 93 43 01 	sts	0x0143, r18	; 0x800143 <a_hour_count>
     550:	a6 cf       	rjmp	.-180    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
     552:	20 91 66 01 	lds	r18, 0x0166	; 0x800166 <EC_b_prev>
     556:	21 11       	cpse	r18, r1
     558:	03 c0       	rjmp	.+6      	; 0x560 <__LOCK_REGION_LENGTH__+0x160>
     55a:	91 30       	cpi	r25, 0x01	; 1
     55c:	09 f4       	brne	.+2      	; 0x560 <__LOCK_REGION_LENGTH__+0x160>
     55e:	86 c0       	rjmp	.+268    	; 0x66c <__LOCK_REGION_LENGTH__+0x26c>
	       a_hour_count++;
	       if(a_hour_count > 23)
	          a_hour_count = 0;
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
     560:	20 91 66 01 	lds	r18, 0x0166	; 0x800166 <EC_b_prev>
     564:	21 11       	cpse	r18, r1
     566:	03 c0       	rjmp	.+6      	; 0x56e <__LOCK_REGION_LENGTH__+0x16e>
     568:	92 30       	cpi	r25, 0x02	; 2
     56a:	09 f4       	brne	.+2      	; 0x56e <__LOCK_REGION_LENGTH__+0x16e>
     56c:	72 c0       	rjmp	.+228    	; 0x652 <__LOCK_REGION_LENGTH__+0x252>
	    a_hour_count = a_hour_count - 1;//value = -(value);
	    if(a_hour_count < 0)
	       a_hour_count = 23; 
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
     56e:	80 e0       	ldi	r24, 0x00	; 0
         else
	    value = 0;
      }
   }
//Saves previous values into volatile variables
EC_a_prev = ec_a;
     570:	60 93 78 01 	sts	0x0178, r22	; 0x800178 <EC_a_prev>
EC_b_prev = ec_b;
     574:	90 93 66 01 	sts	0x0166, r25	; 0x800166 <EC_b_prev>

return value;
}
     578:	08 95       	ret
   }

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     57a:	61 30       	cpi	r22, 0x01	; 1
     57c:	09 f0       	breq	.+2      	; 0x580 <__LOCK_REGION_LENGTH__+0x180>
     57e:	b6 cf       	rjmp	.-148    	; 0x4ec <__LOCK_REGION_LENGTH__+0xec>
            hour_count = hour_count + 1;//value = value;
     580:	20 91 46 01 	lds	r18, 0x0146	; 0x800146 <hour_count>
     584:	2f 5f       	subi	r18, 0xFF	; 255
     586:	20 93 46 01 	sts	0x0146, r18	; 0x800146 <hour_count>
	    if(hour_count == 24)
     58a:	20 91 46 01 	lds	r18, 0x0146	; 0x800146 <hour_count>
     58e:	28 31       	cpi	r18, 0x18	; 24
     590:	09 f0       	breq	.+2      	; 0x594 <__LOCK_REGION_LENGTH__+0x194>
     592:	7e cf       	rjmp	.-260    	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
     594:	1c c0       	rjmp	.+56     	; 0x5ce <__LOCK_REGION_LENGTH__+0x1ce>
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
     596:	20 91 66 01 	lds	r18, 0x0166	; 0x800166 <EC_b_prev>
     59a:	21 11       	cpse	r18, r1
     59c:	1b c0       	rjmp	.+54     	; 0x5d4 <__LOCK_REGION_LENGTH__+0x1d4>
     59e:	91 30       	cpi	r25, 0x01	; 1
     5a0:	c9 f4       	brne	.+50     	; 0x5d4 <__LOCK_REGION_LENGTH__+0x1d4>
            min_count = min_count + 1;//value = value;
     5a2:	20 91 47 01 	lds	r18, 0x0147	; 0x800147 <min_count>
     5a6:	2f 5f       	subi	r18, 0xFF	; 255
     5a8:	20 93 47 01 	sts	0x0147, r18	; 0x800147 <min_count>
	    if(min_count == 60){
     5ac:	20 91 47 01 	lds	r18, 0x0147	; 0x800147 <min_count>
     5b0:	2c 33       	cpi	r18, 0x3C	; 60
     5b2:	09 f0       	breq	.+2      	; 0x5b6 <__LOCK_REGION_LENGTH__+0x1b6>
     5b4:	6d cf       	rjmp	.-294    	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
	       min_count = 0; 
     5b6:	10 92 47 01 	sts	0x0147, r1	; 0x800147 <min_count>
	       hour_count++;
     5ba:	20 91 46 01 	lds	r18, 0x0146	; 0x800146 <hour_count>
     5be:	2f 5f       	subi	r18, 0xFF	; 255
     5c0:	20 93 46 01 	sts	0x0146, r18	; 0x800146 <hour_count>
	       if(hour_count > 23)
     5c4:	20 91 46 01 	lds	r18, 0x0146	; 0x800146 <hour_count>
     5c8:	28 31       	cpi	r18, 0x18	; 24
     5ca:	0c f4       	brge	.+2      	; 0x5ce <__LOCK_REGION_LENGTH__+0x1ce>
     5cc:	61 cf       	rjmp	.-318    	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
	          hour_count = 0;
     5ce:	10 92 46 01 	sts	0x0146, r1	; 0x800146 <hour_count>
     5d2:	5e cf       	rjmp	.-324    	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
     5d4:	20 91 66 01 	lds	r18, 0x0166	; 0x800166 <EC_b_prev>
     5d8:	21 11       	cpse	r18, r1
     5da:	8f cf       	rjmp	.-226    	; 0x4fa <__LOCK_REGION_LENGTH__+0xfa>
     5dc:	92 30       	cpi	r25, 0x02	; 2
     5de:	09 f0       	breq	.+2      	; 0x5e2 <__LOCK_REGION_LENGTH__+0x1e2>
     5e0:	8c cf       	rjmp	.-232    	; 0x4fa <__LOCK_REGION_LENGTH__+0xfa>
	    min_count = min_count - 1; //value = -(value);
     5e2:	20 91 47 01 	lds	r18, 0x0147	; 0x800147 <min_count>
     5e6:	21 50       	subi	r18, 0x01	; 1
     5e8:	20 93 47 01 	sts	0x0147, r18	; 0x800147 <min_count>
	    if(min_count < 0){
     5ec:	20 91 47 01 	lds	r18, 0x0147	; 0x800147 <min_count>
     5f0:	27 ff       	sbrs	r18, 7
     5f2:	4e cf       	rjmp	.-356    	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
	       min_count = 59;
     5f4:	2b e3       	ldi	r18, 0x3B	; 59
     5f6:	20 93 47 01 	sts	0x0147, r18	; 0x800147 <min_count>
	       hour_count--;
     5fa:	20 91 46 01 	lds	r18, 0x0146	; 0x800146 <hour_count>
     5fe:	21 50       	subi	r18, 0x01	; 1
     600:	20 93 46 01 	sts	0x0146, r18	; 0x800146 <hour_count>
	       if(hour_count < 0){
     604:	20 91 46 01 	lds	r18, 0x0146	; 0x800146 <hour_count>
     608:	27 ff       	sbrs	r18, 7
     60a:	42 cf       	rjmp	.-380    	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
	          hour_count = 23;
     60c:	27 e1       	ldi	r18, 0x17	; 23
     60e:	20 93 46 01 	sts	0x0146, r18	; 0x800146 <hour_count>
     612:	3e cf       	rjmp	.-388    	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
		volume = 0x9F;
		OCR3A = 0x9F;
	    }
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
	    volume -= 10;	//decrement volume 
     614:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     618:	2a 50       	subi	r18, 0x0A	; 10
     61a:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <volume>
	    if(volume >= 0x00){
     61e:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     622:	28 cf       	rjmp	.-432    	; 0x474 <__LOCK_REGION_LENGTH__+0x74>
   }
//mode_sel == 2 means that the user has selected the "alarm time change" mode
   if(mode_sel == 2){
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
            a_hour_count = a_hour_count + 1;//value = value;
     624:	20 91 43 01 	lds	r18, 0x0143	; 0x800143 <a_hour_count>
     628:	2f 5f       	subi	r18, 0xFF	; 255
     62a:	20 93 43 01 	sts	0x0143, r18	; 0x800143 <a_hour_count>
	    if(a_hour_count == 24)
     62e:	20 91 43 01 	lds	r18, 0x0143	; 0x800143 <a_hour_count>
     632:	28 31       	cpi	r18, 0x18	; 24
     634:	09 f0       	breq	.+2      	; 0x638 <__LOCK_REGION_LENGTH__+0x238>
     636:	33 cf       	rjmp	.-410    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
            a_min_count = a_min_count + 1;//value = value;
	    if(a_min_count == 60){
	       a_min_count = 0; 
	       a_hour_count++;
	       if(a_hour_count > 23)
	          a_hour_count = 0;
     638:	10 92 43 01 	sts	0x0143, r1	; 0x800143 <a_hour_count>
     63c:	30 cf       	rjmp	.-416    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
            volume += 10;	//increment volume
	    if(volume <= 0x9F){
		OCR3A = volume;	//maximum volume
	    }
	    else {
		volume = 0x9F;
     63e:	2f e9       	ldi	r18, 0x9F	; 159
     640:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <volume>
		OCR3A = 0x9F;
     644:	2f e9       	ldi	r18, 0x9F	; 159
     646:	30 e0       	ldi	r19, 0x00	; 0
     648:	30 93 87 00 	sts	0x0087, r19	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     64c:	20 93 86 00 	sts	0x0086, r18	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
     650:	18 cf       	rjmp	.-464    	; 0x482 <__LOCK_REGION_LENGTH__+0x82>
	       if(a_hour_count > 23)
	          a_hour_count = 0;
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
	    a_min_count = a_min_count - 1; //value = -(value);
     652:	20 91 44 01 	lds	r18, 0x0144	; 0x800144 <a_min_count>
     656:	21 50       	subi	r18, 0x01	; 1
     658:	20 93 44 01 	sts	0x0144, r18	; 0x800144 <a_min_count>
	    if(a_min_count < 0){
     65c:	20 91 44 01 	lds	r18, 0x0144	; 0x800144 <a_min_count>
     660:	27 ff       	sbrs	r18, 7
     662:	1d cf       	rjmp	.-454    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
	       a_min_count = 59;
     664:	2b e3       	ldi	r18, 0x3B	; 59
     666:	20 93 44 01 	sts	0x0144, r18	; 0x800144 <a_min_count>
     66a:	66 cf       	rjmp	.-308    	; 0x538 <__LOCK_REGION_LENGTH__+0x138>
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
            a_min_count = a_min_count + 1;//value = value;
     66c:	20 91 44 01 	lds	r18, 0x0144	; 0x800144 <a_min_count>
     670:	2f 5f       	subi	r18, 0xFF	; 255
     672:	20 93 44 01 	sts	0x0144, r18	; 0x800144 <a_min_count>
	    if(a_min_count == 60){
     676:	20 91 44 01 	lds	r18, 0x0144	; 0x800144 <a_min_count>
     67a:	2c 33       	cpi	r18, 0x3C	; 60
     67c:	09 f0       	breq	.+2      	; 0x680 <__LOCK_REGION_LENGTH__+0x280>
     67e:	0f cf       	rjmp	.-482    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
	       a_min_count = 0; 
     680:	10 92 44 01 	sts	0x0144, r1	; 0x800144 <a_min_count>
	       a_hour_count++;
     684:	20 91 43 01 	lds	r18, 0x0143	; 0x800143 <a_hour_count>
     688:	2f 5f       	subi	r18, 0xFF	; 255
     68a:	20 93 43 01 	sts	0x0143, r18	; 0x800143 <a_hour_count>
	       if(a_hour_count > 23)
     68e:	20 91 43 01 	lds	r18, 0x0143	; 0x800143 <a_hour_count>
     692:	28 31       	cpi	r18, 0x18	; 24
     694:	0c f4       	brge	.+2      	; 0x698 <__LOCK_REGION_LENGTH__+0x298>
     696:	03 cf       	rjmp	.-506    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
     698:	cf cf       	rjmp	.-98     	; 0x638 <__LOCK_REGION_LENGTH__+0x238>

0000069a <get_local_temp>:
**********************************************************************/
void get_local_temp(){
uint16_t lm73_temp;

  //_delay_ms(65); //tenth second wait
  twi_start_rd(LM73_ADDRESS, lm73_rd_buf, 2); //read temperature data from LM73 (2 bytes) 
     69a:	42 e0       	ldi	r20, 0x02	; 2
     69c:	60 eb       	ldi	r22, 0xB0	; 176
     69e:	71 e0       	ldi	r23, 0x01	; 1
     6a0:	80 e9       	ldi	r24, 0x90	; 144
     6a2:	0e 94 cb 0a 	call	0x1596	; 0x1596 <twi_start_rd>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     6a6:	8f e9       	ldi	r24, 0x9F	; 159
     6a8:	9f e0       	ldi	r25, 0x0F	; 15
     6aa:	01 97       	sbiw	r24, 0x01	; 1
     6ac:	f1 f7       	brne	.-4      	; 0x6aa <get_local_temp+0x10>
     6ae:	00 c0       	rjmp	.+0      	; 0x6b0 <get_local_temp+0x16>
     6b0:	00 00       	nop
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
     6b2:	80 91 b0 01 	lds	r24, 0x01B0	; 0x8001b0 <lm73_rd_buf>
     6b6:	90 91 b1 01 	lds	r25, 0x01B1	; 0x8001b1 <lm73_rd_buf+0x1>
     6ba:	98 27       	eor	r25, r24
     6bc:	89 27       	eor	r24, r25
     6be:	98 27       	eor	r25, r24
     6c0:	4a e0       	ldi	r20, 0x0A	; 10
     6c2:	69 e7       	ldi	r22, 0x79	; 121
     6c4:	71 e0       	ldi	r23, 0x01	; 1
     6c6:	88 0f       	add	r24, r24
     6c8:	89 2f       	mov	r24, r25
     6ca:	88 1f       	adc	r24, r24
     6cc:	99 0b       	sbc	r25, r25
     6ce:	91 95       	neg	r25
     6d0:	0e 94 4e 0c 	call	0x189c	; 0x189c <__itoa_ncheck>
  lm73_temp = lm73_rd_buf[0]; //save high temperature byte into lm73_temp
  lm73_temp = lm73_temp << 8; //shift it into upper byte 
  lm73_temp |= lm73_rd_buf[1]; //"OR" in the low temp byte to lm73_temp 
  itoa(lm73_temp >> 7, lcd_string_array, 10); //convert to string in array with itoa() from avr-libc                           

  line2_col1();
     6d4:	0e 94 32 07 	call	0xe64	; 0xe64 <line2_col1>
  lcd_array[2] = lcd_string_array[0];
     6d8:	e6 e1       	ldi	r30, 0x16	; 22
     6da:	f1 e0       	ldi	r31, 0x01	; 1
     6dc:	a9 e7       	ldi	r26, 0x79	; 121
     6de:	b1 e0       	ldi	r27, 0x01	; 1
     6e0:	8c 91       	ld	r24, X
     6e2:	82 83       	std	Z+2, r24	; 0x02
  lcd_array[3] = lcd_string_array[1];
     6e4:	11 96       	adiw	r26, 0x01	; 1
     6e6:	8c 91       	ld	r24, X
     6e8:	83 83       	std	Z+3, r24	; 0x03
  string2lcd(lcd_array);
     6ea:	cf 01       	movw	r24, r30
     6ec:	0c 94 8a 07 	jmp	0xf14	; 0xf14 <string2lcd>

000006f0 <__vector_16>:
	update the mode and bargraph. Then I change the sum based on	
	the value returned from the encoder reading. Sum is then bounded
	from 0-1023. 1023+1=1 and 0-any number > 0 = 1023.
Parameters: NA
**********************************************************************/
ISR(TIMER0_OVF_vect) { 
     6f0:	1f 92       	push	r1
     6f2:	0f 92       	push	r0
     6f4:	0f b6       	in	r0, 0x3f	; 63
     6f6:	0f 92       	push	r0
     6f8:	11 24       	eor	r1, r1
     6fa:	0b b6       	in	r0, 0x3b	; 59
     6fc:	0f 92       	push	r0
     6fe:	2f 93       	push	r18
     700:	3f 93       	push	r19
     702:	4f 93       	push	r20
     704:	5f 93       	push	r21
     706:	6f 93       	push	r22
     708:	7f 93       	push	r23
     70a:	8f 93       	push	r24
     70c:	9f 93       	push	r25
     70e:	af 93       	push	r26
     710:	bf 93       	push	r27
     712:	ef 93       	push	r30
     714:	ff 93       	push	r31
   static uint8_t count_7_8125ms = 0;

   count_7_8125ms++;
     716:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <count_7_8125ms.2191>
     71a:	8f 5f       	subi	r24, 0xFF	; 255
     71c:	80 93 4d 01 	sts	0x014D, r24	; 0x80014d <count_7_8125ms.2191>
   if((count_7_8125ms % 128) == 0) { //interrupts every 1 second
     720:	8f 77       	andi	r24, 0x7F	; 127
     722:	29 f4       	brne	.+10     	; 0x72e <__vector_16+0x3e>
      sec_count++;
     724:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <sec_count>
     728:	8f 5f       	subi	r24, 0xFF	; 255
     72a:	80 93 48 01 	sts	0x0148, r24	; 0x800148 <sec_count>
   }
   bars();  
     72e:	0e 94 2a 01 	call	0x254	; 0x254 <bars>
   read_encoder();      
     732:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <read_encoder>

}
     736:	ff 91       	pop	r31
     738:	ef 91       	pop	r30
     73a:	bf 91       	pop	r27
     73c:	af 91       	pop	r26
     73e:	9f 91       	pop	r25
     740:	8f 91       	pop	r24
     742:	7f 91       	pop	r23
     744:	6f 91       	pop	r22
     746:	5f 91       	pop	r21
     748:	4f 91       	pop	r20
     74a:	3f 91       	pop	r19
     74c:	2f 91       	pop	r18
     74e:	0f 90       	pop	r0
     750:	0b be       	out	0x3b, r0	; 59
     752:	0f 90       	pop	r0
     754:	0f be       	out	0x3f, r0	; 63
     756:	0f 90       	pop	r0
     758:	1f 90       	pop	r1
     75a:	18 95       	reti

0000075c <__vector_15>:

ISR(TIMER0_COMP_vect) {
     75c:	1f 92       	push	r1
     75e:	0f 92       	push	r0
     760:	0f b6       	in	r0, 0x3f	; 63
     762:	0f 92       	push	r0
     764:	11 24       	eor	r1, r1
     766:	0b b6       	in	r0, 0x3b	; 59
     768:	0f 92       	push	r0
     76a:	2f 93       	push	r18
     76c:	3f 93       	push	r19
     76e:	4f 93       	push	r20
     770:	5f 93       	push	r21
     772:	6f 93       	push	r22
     774:	7f 93       	push	r23
     776:	8f 93       	push	r24
     778:	9f 93       	push	r25
     77a:	af 93       	push	r26
     77c:	bf 93       	push	r27
     77e:	ef 93       	push	r30
     780:	ff 93       	push	r31
   static uint8_t count7_8125ms = 0;

   count7_8125ms++;
     782:	80 91 4c 01 	lds	r24, 0x014C	; 0x80014c <count7_8125ms.2197>
     786:	8f 5f       	subi	r24, 0xFF	; 255
     788:	80 93 4c 01 	sts	0x014C, r24	; 0x80014c <count7_8125ms.2197>
   if((count7_8125ms % 128) == 0) { //interrupts every 1 second
     78c:	8f 77       	andi	r24, 0x7F	; 127
     78e:	11 f4       	brne	.+4      	; 0x794 <__vector_15+0x38>
      get_local_temp();
     790:	0e 94 4d 03 	call	0x69a	; 0x69a <get_local_temp>
      itoa(send_seq,lcd_string,10);
      uart_puts(lcd_string);
      uart_putc('\0'); */
   }

}
     794:	ff 91       	pop	r31
     796:	ef 91       	pop	r30
     798:	bf 91       	pop	r27
     79a:	af 91       	pop	r26
     79c:	9f 91       	pop	r25
     79e:	8f 91       	pop	r24
     7a0:	7f 91       	pop	r23
     7a2:	6f 91       	pop	r22
     7a4:	5f 91       	pop	r21
     7a6:	4f 91       	pop	r20
     7a8:	3f 91       	pop	r19
     7aa:	2f 91       	pop	r18
     7ac:	0f 90       	pop	r0
     7ae:	0b be       	out	0x3b, r0	; 59
     7b0:	0f 90       	pop	r0
     7b2:	0f be       	out	0x3f, r0	; 63
     7b4:	0f 90       	pop	r0
     7b6:	1f 90       	pop	r1
     7b8:	18 95       	reti

000007ba <clock_time>:
	selected alarm time or normal time is displayed.
Parameters: NA
**********************************************************************/
void clock_time(){ //by default we use military time
//This block is used to increment the time based on an increasing seconds count   
   if(sec_count == 60){
     7ba:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <sec_count>
     7be:	8c 33       	cpi	r24, 0x3C	; 60
     7c0:	09 f4       	brne	.+2      	; 0x7c4 <clock_time+0xa>
     7c2:	a4 c0       	rjmp	.+328    	; 0x90c <clock_time+0x152>
	 }//hours	
      }//mins
   }//secs

//This is where the digits are written to the data array
      if(mode_sel == 2){	//display alarm time
     7c4:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <mode_sel>
     7c8:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <mode_sel+0x1>
     7cc:	02 97       	sbiw	r24, 0x02	; 2
     7ce:	09 f4       	brne	.+2      	; 0x7d2 <clock_time+0x18>
     7d0:	5a c0       	rjmp	.+180    	; 0x886 <clock_time+0xcc>
         else {segment_data[2] = 0b111;}		//Turn colon off
         segment_data[1] = dec_to_7seg[a_min_count/10];
         segment_data[0] = dec_to_7seg[a_min_count%10];
      }
      else{			//display military time
         segment_data[4] = dec_to_7seg[hour_count/10];
     7d2:	90 91 46 01 	lds	r25, 0x0146	; 0x800146 <hour_count>
     7d6:	87 e6       	ldi	r24, 0x67	; 103
     7d8:	98 02       	muls	r25, r24
     7da:	e1 2d       	mov	r30, r1
     7dc:	11 24       	eor	r1, r1
     7de:	e5 95       	asr	r30
     7e0:	e5 95       	asr	r30
     7e2:	97 fd       	sbrc	r25, 7
     7e4:	e3 95       	inc	r30
     7e6:	0e 2e       	mov	r0, r30
     7e8:	00 0c       	add	r0, r0
     7ea:	ff 0b       	sbc	r31, r31
     7ec:	e0 50       	subi	r30, 0x00	; 0
     7ee:	ff 4f       	sbci	r31, 0xFF	; 255
     7f0:	90 81       	ld	r25, Z
     7f2:	90 93 38 01 	sts	0x0138, r25	; 0x800138 <__data_end+0x4>
         segment_data[3] = dec_to_7seg[hour_count%10];
     7f6:	e0 91 46 01 	lds	r30, 0x0146	; 0x800146 <hour_count>
     7fa:	e8 02       	muls	r30, r24
     7fc:	81 2d       	mov	r24, r1
     7fe:	11 24       	eor	r1, r1
     800:	85 95       	asr	r24
     802:	85 95       	asr	r24
     804:	e7 fd       	sbrc	r30, 7
     806:	83 95       	inc	r24
     808:	9a e0       	ldi	r25, 0x0A	; 10
     80a:	89 9f       	mul	r24, r25
     80c:	e0 19       	sub	r30, r0
     80e:	11 24       	eor	r1, r1
     810:	0e 2e       	mov	r0, r30
     812:	00 0c       	add	r0, r0
     814:	ff 0b       	sbc	r31, r31
     816:	e0 50       	subi	r30, 0x00	; 0
     818:	ff 4f       	sbci	r31, 0xFF	; 255
     81a:	80 81       	ld	r24, Z
     81c:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <__data_end+0x3>
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     820:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <sec_count>
     824:	80 fd       	sbrc	r24, 0
     826:	2b c0       	rjmp	.+86     	; 0x87e <clock_time+0xc4>
         else {segment_data[2] = 0b111;}		//Turn colon off
     828:	87 e0       	ldi	r24, 0x07	; 7
     82a:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__data_end+0x2>
         segment_data[1] = dec_to_7seg[min_count/10];
     82e:	90 91 47 01 	lds	r25, 0x0147	; 0x800147 <min_count>
     832:	87 e6       	ldi	r24, 0x67	; 103
     834:	98 02       	muls	r25, r24
     836:	e1 2d       	mov	r30, r1
     838:	11 24       	eor	r1, r1
     83a:	e5 95       	asr	r30
     83c:	e5 95       	asr	r30
     83e:	97 fd       	sbrc	r25, 7
     840:	e3 95       	inc	r30
     842:	0e 2e       	mov	r0, r30
     844:	00 0c       	add	r0, r0
     846:	ff 0b       	sbc	r31, r31
     848:	e0 50       	subi	r30, 0x00	; 0
     84a:	ff 4f       	sbci	r31, 0xFF	; 255
     84c:	90 81       	ld	r25, Z
     84e:	90 93 35 01 	sts	0x0135, r25	; 0x800135 <__data_end+0x1>
         segment_data[0] = dec_to_7seg[min_count%10];
     852:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <min_count>
     856:	e8 02       	muls	r30, r24
     858:	81 2d       	mov	r24, r1
     85a:	11 24       	eor	r1, r1
     85c:	85 95       	asr	r24
     85e:	85 95       	asr	r24
     860:	e7 fd       	sbrc	r30, 7
     862:	83 95       	inc	r24
     864:	9a e0       	ldi	r25, 0x0A	; 10
     866:	89 9f       	mul	r24, r25
     868:	e0 19       	sub	r30, r0
     86a:	11 24       	eor	r1, r1
     86c:	0e 2e       	mov	r0, r30
     86e:	00 0c       	add	r0, r0
     870:	ff 0b       	sbc	r31, r31
     872:	e0 50       	subi	r30, 0x00	; 0
     874:	ff 4f       	sbci	r31, 0xFF	; 255
     876:	80 81       	ld	r24, Z
     878:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <__data_end>
     87c:	08 95       	ret
         segment_data[0] = dec_to_7seg[a_min_count%10];
      }
      else{			//display military time
         segment_data[4] = dec_to_7seg[hour_count/10];
         segment_data[3] = dec_to_7seg[hour_count%10];
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     87e:	84 e0       	ldi	r24, 0x04	; 4
     880:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__data_end+0x2>
     884:	d4 cf       	rjmp	.-88     	; 0x82e <clock_time+0x74>
      }//mins
   }//secs

//This is where the digits are written to the data array
      if(mode_sel == 2){	//display alarm time
         segment_data[4] = dec_to_7seg[a_hour_count/10];
     886:	90 91 43 01 	lds	r25, 0x0143	; 0x800143 <a_hour_count>
     88a:	87 e6       	ldi	r24, 0x67	; 103
     88c:	98 02       	muls	r25, r24
     88e:	e1 2d       	mov	r30, r1
     890:	11 24       	eor	r1, r1
     892:	e5 95       	asr	r30
     894:	e5 95       	asr	r30
     896:	97 fd       	sbrc	r25, 7
     898:	e3 95       	inc	r30
     89a:	0e 2e       	mov	r0, r30
     89c:	00 0c       	add	r0, r0
     89e:	ff 0b       	sbc	r31, r31
     8a0:	e0 50       	subi	r30, 0x00	; 0
     8a2:	ff 4f       	sbci	r31, 0xFF	; 255
     8a4:	90 81       	ld	r25, Z
     8a6:	90 93 38 01 	sts	0x0138, r25	; 0x800138 <__data_end+0x4>
         segment_data[3] = dec_to_7seg[a_hour_count%10];
     8aa:	e0 91 43 01 	lds	r30, 0x0143	; 0x800143 <a_hour_count>
     8ae:	e8 02       	muls	r30, r24
     8b0:	81 2d       	mov	r24, r1
     8b2:	11 24       	eor	r1, r1
     8b4:	85 95       	asr	r24
     8b6:	85 95       	asr	r24
     8b8:	e7 fd       	sbrc	r30, 7
     8ba:	83 95       	inc	r24
     8bc:	9a e0       	ldi	r25, 0x0A	; 10
     8be:	89 9f       	mul	r24, r25
     8c0:	e0 19       	sub	r30, r0
     8c2:	11 24       	eor	r1, r1
     8c4:	0e 2e       	mov	r0, r30
     8c6:	00 0c       	add	r0, r0
     8c8:	ff 0b       	sbc	r31, r31
     8ca:	e0 50       	subi	r30, 0x00	; 0
     8cc:	ff 4f       	sbci	r31, 0xFF	; 255
     8ce:	80 81       	ld	r24, Z
     8d0:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <__data_end+0x3>
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     8d4:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <sec_count>
     8d8:	80 fd       	sbrc	r24, 0
     8da:	33 c0       	rjmp	.+102    	; 0x942 <clock_time+0x188>
         else {segment_data[2] = 0b111;}		//Turn colon off
     8dc:	87 e0       	ldi	r24, 0x07	; 7
     8de:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__data_end+0x2>
         segment_data[1] = dec_to_7seg[a_min_count/10];
     8e2:	90 91 44 01 	lds	r25, 0x0144	; 0x800144 <a_min_count>
     8e6:	87 e6       	ldi	r24, 0x67	; 103
     8e8:	98 02       	muls	r25, r24
     8ea:	e1 2d       	mov	r30, r1
     8ec:	11 24       	eor	r1, r1
     8ee:	e5 95       	asr	r30
     8f0:	e5 95       	asr	r30
     8f2:	97 fd       	sbrc	r25, 7
     8f4:	e3 95       	inc	r30
     8f6:	0e 2e       	mov	r0, r30
     8f8:	00 0c       	add	r0, r0
     8fa:	ff 0b       	sbc	r31, r31
     8fc:	e0 50       	subi	r30, 0x00	; 0
     8fe:	ff 4f       	sbci	r31, 0xFF	; 255
     900:	90 81       	ld	r25, Z
     902:	90 93 35 01 	sts	0x0135, r25	; 0x800135 <__data_end+0x1>
         segment_data[0] = dec_to_7seg[a_min_count%10];
     906:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <a_min_count>
     90a:	a5 cf       	rjmp	.-182    	; 0x856 <clock_time+0x9c>
Parameters: NA
**********************************************************************/
void clock_time(){ //by default we use military time
//This block is used to increment the time based on an increasing seconds count   
   if(sec_count == 60){
      min_count++;
     90c:	80 91 47 01 	lds	r24, 0x0147	; 0x800147 <min_count>
     910:	8f 5f       	subi	r24, 0xFF	; 255
     912:	80 93 47 01 	sts	0x0147, r24	; 0x800147 <min_count>
      sec_count = 0;
     916:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <sec_count>
      if(min_count == 60){
     91a:	80 91 47 01 	lds	r24, 0x0147	; 0x800147 <min_count>
     91e:	8c 33       	cpi	r24, 0x3C	; 60
     920:	09 f0       	breq	.+2      	; 0x924 <clock_time+0x16a>
     922:	50 cf       	rjmp	.-352    	; 0x7c4 <clock_time+0xa>
	 hour_count++;
     924:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <hour_count>
     928:	8f 5f       	subi	r24, 0xFF	; 255
     92a:	80 93 46 01 	sts	0x0146, r24	; 0x800146 <hour_count>
	 min_count = 0;
     92e:	10 92 47 01 	sts	0x0147, r1	; 0x800147 <min_count>
	 if(hour_count == 24){
     932:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <hour_count>
     936:	88 31       	cpi	r24, 0x18	; 24
     938:	09 f0       	breq	.+2      	; 0x93c <clock_time+0x182>
     93a:	44 cf       	rjmp	.-376    	; 0x7c4 <clock_time+0xa>
	    hour_count = 0;
     93c:	10 92 46 01 	sts	0x0146, r1	; 0x800146 <hour_count>
     940:	41 cf       	rjmp	.-382    	; 0x7c4 <clock_time+0xa>

//This is where the digits are written to the data array
      if(mode_sel == 2){	//display alarm time
         segment_data[4] = dec_to_7seg[a_hour_count/10];
         segment_data[3] = dec_to_7seg[a_hour_count%10];
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     942:	84 e0       	ldi	r24, 0x04	; 4
     944:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__data_end+0x2>
     948:	cc cf       	rjmp	.-104    	; 0x8e2 <clock_time+0x128>

0000094a <port_init>:
Function: port_init
Description: General port initialization and setting pull up resistors
Parameters: NA
**********************************************************************/
void port_init(){
   DDRC |= 0xFF; 
     94a:	84 b3       	in	r24, 0x14	; 20
     94c:	8f ef       	ldi	r24, 0xFF	; 255
     94e:	84 bb       	out	0x14, r24	; 20
   DDRB |= 0xF0;				//PB4-6 is SEL0-2, PB7 is PWM
     950:	97 b3       	in	r25, 0x17	; 23
     952:	90 6f       	ori	r25, 0xF0	; 240
     954:	97 bb       	out	0x17, r25	; 23
   DDRE |= 0x4F;				//PE6 is SHIFT_LD_N
     956:	92 b1       	in	r25, 0x02	; 2
     958:	9f 64       	ori	r25, 0x4F	; 79
     95a:	92 b9       	out	0x02, r25	; 2
   DDRD |= 0xFF;				//PE1 is CLK_INH and PE2 is SRCLK
     95c:	91 b3       	in	r25, 0x11	; 17
     95e:	81 bb       	out	0x11, r24	; 17
   DDRF |= 0x08;
     960:	e1 e6       	ldi	r30, 0x61	; 97
     962:	f0 e0       	ldi	r31, 0x00	; 0
     964:	90 81       	ld	r25, Z
     966:	98 60       	ori	r25, 0x08	; 8
     968:	90 83       	st	Z, r25
   PORTC |= 0x01;
     96a:	a8 9a       	sbi	0x15, 0	; 21
   PORTD |= 0xFF;
     96c:	92 b3       	in	r25, 0x12	; 18
     96e:	82 bb       	out	0x12, r24	; 18
   PORTE |= 0xFF;
     970:	93 b1       	in	r25, 0x03	; 3
     972:	83 b9       	out	0x03, r24	; 3
     974:	08 95       	ret

00000976 <change_alarm_state>:
	and what time it is set for on the LCD.
Parameters: NA
**********************************************************************/
void change_alarm_state(){
   static uint8_t curr = 0;
   if(alarm && (curr ==0)){
     976:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <alarm>
     97a:	88 23       	and	r24, r24
     97c:	21 f0       	breq	.+8      	; 0x986 <change_alarm_state+0x10>
     97e:	80 91 4b 01 	lds	r24, 0x014B	; 0x80014b <curr.2204>
     982:	88 23       	and	r24, r24
     984:	89 f0       	breq	.+34     	; 0x9a8 <change_alarm_state+0x32>
      //lcd_array[2] = 'a';
      //lcd_array[3] = 'r';
      //lcd_array[4] = 'm';
      curr = 1;
   }
   else if((!alarm) && (curr == 1)){
     986:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <alarm>
     98a:	81 11       	cpse	r24, r1
     98c:	04 c0       	rjmp	.+8      	; 0x996 <change_alarm_state+0x20>
     98e:	80 91 4b 01 	lds	r24, 0x014B	; 0x80014b <curr.2204>
     992:	81 30       	cpi	r24, 0x01	; 1
     994:	09 f0       	breq	.+2      	; 0x998 <change_alarm_state+0x22>
     996:	08 95       	ret
      curr = 0;
     998:	10 92 4b 01 	sts	0x014B, r1	; 0x80014b <curr.2204>
      line1_col1();
     99c:	0e 94 48 07 	call	0xe90	; 0xe90 <line1_col1>
      string2lcd("     ");
     9a0:	8c e2       	ldi	r24, 0x2C	; 44
     9a2:	91 e0       	ldi	r25, 0x01	; 1
     9a4:	0c 94 8a 07 	jmp	0xf14	; 0xf14 <string2lcd>
Parameters: NA
**********************************************************************/
void change_alarm_state(){
   static uint8_t curr = 0;
   if(alarm && (curr ==0)){
      line1_col1();
     9a8:	0e 94 48 07 	call	0xe90	; 0xe90 <line1_col1>
      string2lcd("Alarm");
     9ac:	86 e2       	ldi	r24, 0x26	; 38
     9ae:	91 e0       	ldi	r25, 0x01	; 1
     9b0:	0e 94 8a 07 	call	0xf14	; 0xf14 <string2lcd>
      //lcd_array[0] = 'A';
      //lcd_array[1] = 'l';
      //lcd_array[2] = 'a';
      //lcd_array[3] = 'r';
      //lcd_array[4] = 'm';
      curr = 1;
     9b4:	81 e0       	ldi	r24, 0x01	; 1
     9b6:	80 93 4b 01 	sts	0x014B, r24	; 0x80014b <curr.2204>
     9ba:	08 95       	ret

000009bc <adc_init>:
Description: Basic adc initialization used for single shot adc readings
Parameters: NA
**********************************************************************/
void adc_init(){
//Initalize ADC and its ports
   DDRF  &= ~(_BV(DDF7)); //make port F bit 7 is ADC input  
     9bc:	e1 e6       	ldi	r30, 0x61	; 97
     9be:	f0 e0       	ldi	r31, 0x00	; 0
     9c0:	80 81       	ld	r24, Z
     9c2:	8f 77       	andi	r24, 0x7F	; 127
     9c4:	80 83       	st	Z, r24
   PORTF &= ~(_BV(PF7));  //port F bit 7 pullups must be off
     9c6:	e2 e6       	ldi	r30, 0x62	; 98
     9c8:	f0 e0       	ldi	r31, 0x00	; 0
     9ca:	80 81       	ld	r24, Z
     9cc:	8f 77       	andi	r24, 0x7F	; 127
     9ce:	80 83       	st	Z, r24
   ADMUX |= (1<<REFS0) | (1<<MUX2)| (1<<MUX1)| (1<<MUX0); //single-ended, input PORTF bit 7, right adjusted, 10 bits
     9d0:	87 b1       	in	r24, 0x07	; 7
     9d2:	87 64       	ori	r24, 0x47	; 71
     9d4:	87 b9       	out	0x07, r24	; 7

   ADCSRA |= (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);//ADC enabled, don't start yet, single shot mode 
     9d6:	86 b1       	in	r24, 0x06	; 6
     9d8:	87 68       	ori	r24, 0x87	; 135
     9da:	86 b9       	out	0x06, r24	; 6
     9dc:	08 95       	ret

000009de <fetch_adc>:
void fetch_adc(){
   uint16_t adc_result;
   uint16_t step;   
   uint16_t step2;   

   ADCSRA |= (1<<ADSC); //poke ADSC and start conversion
     9de:	36 9a       	sbi	0x06, 6	; 6
   while(bit_is_clear(ADCSRA, ADIF)){} //spin while interrupt flag not set
     9e0:	34 9b       	sbis	0x06, 4	; 6
     9e2:	fe cf       	rjmp	.-4      	; 0x9e0 <fetch_adc+0x2>
   ACSR |= (1<<ACI); //its done, clear flag by writing a one 
     9e4:	44 9a       	sbi	0x08, 4	; 8
   adc_result = ADC;                      //read the ADC output as 16 bits
     9e6:	24 b1       	in	r18, 0x04	; 4
     9e8:	35 b1       	in	r19, 0x05	; 5

   step = adc_result/4;//scales the adc result from 0-255
   step2 =  255 - step;//I need the complement to the adc result
     9ea:	36 95       	lsr	r19
     9ec:	27 95       	ror	r18
     9ee:	36 95       	lsr	r19
     9f0:	27 95       	ror	r18
   if(step2 > 235){	//this is a minimum brightness level
      step2 = 235;
   }

   OCR2 = step2;	//Write brightness level to tnct2 compare match register
     9f2:	8f ef       	ldi	r24, 0xFF	; 255
     9f4:	90 e0       	ldi	r25, 0x00	; 0
     9f6:	82 1b       	sub	r24, r18
     9f8:	93 0b       	sbc	r25, r19
     9fa:	8c 3e       	cpi	r24, 0xEC	; 236
     9fc:	91 05       	cpc	r25, r1
     9fe:	10 f0       	brcs	.+4      	; 0xa04 <fetch_adc+0x26>
     a00:	8b ee       	ldi	r24, 0xEB	; 235
     a02:	90 e0       	ldi	r25, 0x00	; 0
     a04:	83 bd       	out	0x23, r24	; 35
     a06:	08 95       	ret

00000a08 <__vector_12>:
Function: TIMER!_COMPA_vect
Description: This ISR creates the alarm frequency on PORTD but 3 the is used
	for the alarm tone.
Parameters: NA
**********************************************************************/
ISR(TIMER1_COMPA_vect){
     a08:	1f 92       	push	r1
     a0a:	0f 92       	push	r0
     a0c:	0f b6       	in	r0, 0x3f	; 63
     a0e:	0f 92       	push	r0
     a10:	11 24       	eor	r1, r1
     a12:	8f 93       	push	r24
     a14:	9f 93       	push	r25
   //static uint8_t seconds = 0;
   //bars();  //displays the mode on the bargraph
   //read_encoder();     //reads the encoder values
if(!snooze){ //alarm has not been snoozed
     a16:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <snooze>
     a1a:	81 11       	cpse	r24, r1
     a1c:	0a c0       	rjmp	.+20     	; 0xa32 <__vector_12+0x2a>
//checks to see alarm is on and the alarm time matches clock time
   if(alarm && ((hour_count == a_hour_count) && (min_count == a_min_count))){
     a1e:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <alarm>
     a22:	88 23       	and	r24, r24
     a24:	31 f0       	breq	.+12     	; 0xa32 <__vector_12+0x2a>
     a26:	90 91 46 01 	lds	r25, 0x0146	; 0x800146 <hour_count>
     a2a:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <a_hour_count>
     a2e:	98 17       	cp	r25, r24
     a30:	39 f0       	breq	.+14     	; 0xa40 <__vector_12+0x38>
      PORTD = PIND ^ 0b00000100;//toggles PD3 to create frequency
   }
}
}
     a32:	9f 91       	pop	r25
     a34:	8f 91       	pop	r24
     a36:	0f 90       	pop	r0
     a38:	0f be       	out	0x3f, r0	; 63
     a3a:	0f 90       	pop	r0
     a3c:	1f 90       	pop	r1
     a3e:	18 95       	reti
   //static uint8_t seconds = 0;
   //bars();  //displays the mode on the bargraph
   //read_encoder();     //reads the encoder values
if(!snooze){ //alarm has not been snoozed
//checks to see alarm is on and the alarm time matches clock time
   if(alarm && ((hour_count == a_hour_count) && (min_count == a_min_count))){
     a40:	90 91 47 01 	lds	r25, 0x0147	; 0x800147 <min_count>
     a44:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <a_min_count>
     a48:	98 13       	cpse	r25, r24
     a4a:	f3 cf       	rjmp	.-26     	; 0xa32 <__vector_12+0x2a>
      PORTD = PIND ^ 0b00000100;//toggles PD3 to create frequency
     a4c:	90 b3       	in	r25, 0x10	; 16
     a4e:	84 e0       	ldi	r24, 0x04	; 4
     a50:	89 27       	eor	r24, r25
     a52:	82 bb       	out	0x12, r24	; 18
   }
}
}
     a54:	ee cf       	rjmp	.-36     	; 0xa32 <__vector_12+0x2a>

00000a56 <snoozin>:
Description: This function disables the snooze variable once the alarm
	seconds equals the normal seconds. 
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
     a56:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <snooze>
     a5a:	81 11       	cpse	r24, r1
     a5c:	0c 94 b8 00 	jmp	0x170	; 0x170 <snoozin.part.1>
     a60:	08 95       	ret

00000a62 <local_temp_init>:
Description: 
Parameters: NA
**********************************************************************/
void local_temp_init(){

lm73_wr_buf[0] = 0x00; //load lm73_wr_buf[0] with temperature pointer address
     a62:	10 92 ae 01 	sts	0x01AE, r1	; 0x8001ae <lm73_wr_buf>
twi_start_wr(LM73_ADDRESS, lm73_rd_buf, 1); //start the TWI write process
     a66:	41 e0       	ldi	r20, 0x01	; 1
     a68:	60 eb       	ldi	r22, 0xB0	; 176
     a6a:	71 e0       	ldi	r23, 0x01	; 1
     a6c:	80 e9       	ldi	r24, 0x90	; 144
     a6e:	0e 94 ba 0a 	call	0x1574	; 0x1574 <twi_start_wr>
     a72:	2f ef       	ldi	r18, 0xFF	; 255
     a74:	81 ee       	ldi	r24, 0xE1	; 225
     a76:	94 e0       	ldi	r25, 0x04	; 4
     a78:	21 50       	subi	r18, 0x01	; 1
     a7a:	80 40       	sbci	r24, 0x00	; 0
     a7c:	90 40       	sbci	r25, 0x00	; 0
     a7e:	e1 f7       	brne	.-8      	; 0xa78 <local_temp_init+0x16>
     a80:	00 c0       	rjmp	.+0      	; 0xa82 <local_temp_init+0x20>
     a82:	00 00       	nop
     a84:	08 95       	ret

00000a86 <__vector_18>:
/**********************************************************************
Function: ()
Description: 
Parameters: NA
**********************************************************************/
ISR(USART0_RX_vect){
     a86:	1f 92       	push	r1
     a88:	0f 92       	push	r0
     a8a:	0f b6       	in	r0, 0x3f	; 63
     a8c:	0f 92       	push	r0
     a8e:	11 24       	eor	r1, r1
     a90:	0b b6       	in	r0, 0x3b	; 59
     a92:	0f 92       	push	r0
     a94:	8f 93       	push	r24
     a96:	9f 93       	push	r25
     a98:	ef 93       	push	r30
     a9a:	ff 93       	push	r31
static  uint8_t  i;
  rx_char = UDR0;              //get character
     a9c:	8c b1       	in	r24, 0x0c	; 12
     a9e:	80 93 77 01 	sts	0x0177, r24	; 0x800177 <rx_char>
  lcd_str_array[i++]=rx_char;  //store in array 
     aa2:	e0 91 4a 01 	lds	r30, 0x014A	; 0x80014a <i.2229>
     aa6:	91 e0       	ldi	r25, 0x01	; 1
     aa8:	9e 0f       	add	r25, r30
     aaa:	90 93 4a 01 	sts	0x014A, r25	; 0x80014a <i.2229>
     aae:	f0 e0       	ldi	r31, 0x00	; 0
     ab0:	e9 59       	subi	r30, 0x99	; 153
     ab2:	fe 4f       	sbci	r31, 0xFE	; 254
     ab4:	80 83       	st	Z, r24
 //if entire string has arrived, set flag, reset index
  if(rx_char == '\0'){
     ab6:	81 11       	cpse	r24, r1
     ab8:	09 c0       	rjmp	.+18     	; 0xacc <__vector_18+0x46>
    rcv_rdy=1; 
     aba:	81 e0       	ldi	r24, 0x01	; 1
     abc:	80 93 60 01 	sts	0x0160, r24	; 0x800160 <rcv_rdy>
    lcd_str_array[--i]  = (' ');     //clear the count field
     ac0:	80 e2       	ldi	r24, 0x20	; 32
     ac2:	80 83       	st	Z, r24
    lcd_str_array[i+1]  = (' ');
     ac4:	81 83       	std	Z+1, r24	; 0x01
    lcd_str_array[i+2]  = (' ');
     ac6:	82 83       	std	Z+2, r24	; 0x02
    i=0;  
     ac8:	10 92 4a 01 	sts	0x014A, r1	; 0x80014a <i.2229>
  }
}
     acc:	ff 91       	pop	r31
     ace:	ef 91       	pop	r30
     ad0:	9f 91       	pop	r25
     ad2:	8f 91       	pop	r24
     ad4:	0f 90       	pop	r0
     ad6:	0b be       	out	0x3b, r0	; 59
     ad8:	0f 90       	pop	r0
     ada:	0f be       	out	0x3f, r0	; 63
     adc:	0f 90       	pop	r0
     ade:	1f 90       	pop	r1
     ae0:	18 95       	reti

00000ae2 <send_lcd>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ae2:	91 e0       	ldi	r25, 0x01	; 1
     ae4:	81 11       	cpse	r24, r1
     ae6:	01 c0       	rjmp	.+2      	; 0xaea <send_lcd+0x8>
     ae8:	90 e0       	ldi	r25, 0x00	; 0
     aea:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     aec:	77 9b       	sbis	0x0e, 7	; 14
     aee:	fe cf       	rjmp	.-4      	; 0xaec <send_lcd+0xa>
  SPDR = byte;                        //send payload
     af0:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     af2:	77 9b       	sbis	0x0e, 7	; 14
     af4:	fe cf       	rjmp	.-4      	; 0xaf2 <send_lcd+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     af6:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     afa:	88 60       	ori	r24, 0x08	; 8
     afc:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b00:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b04:	87 7f       	andi	r24, 0xF7	; 247
     b06:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b0a:	08 95       	ret

00000b0c <refresh_lcd>:
//
void refresh_lcd(char lcd_string_array[]) {

  static uint8_t i=0;           // index into string array 

 send_lcd(CHAR_BYTE,lcd_string_array[i]);
     b0c:	20 91 5e 01 	lds	r18, 0x015E	; 0x80015e <i.2095>
     b10:	82 0f       	add	r24, r18
     b12:	91 1d       	adc	r25, r1
     b14:	fc 01       	movw	r30, r24
     b16:	80 81       	ld	r24, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b18:	91 e0       	ldi	r25, 0x01	; 1
     b1a:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b1c:	77 9b       	sbis	0x0e, 7	; 14
     b1e:	fe cf       	rjmp	.-4      	; 0xb1c <refresh_lcd+0x10>
  SPDR = byte;                        //send payload
     b20:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b22:	77 9b       	sbis	0x0e, 7	; 14
     b24:	fe cf       	rjmp	.-4      	; 0xb22 <refresh_lcd+0x16>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b26:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b2a:	88 60       	ori	r24, 0x08	; 8
     b2c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b30:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b34:	87 7f       	andi	r24, 0xF7	; 247
     b36:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
void refresh_lcd(char lcd_string_array[]) {

  static uint8_t i=0;           // index into string array 

 send_lcd(CHAR_BYTE,lcd_string_array[i]);
 i++;   //increment to next character
     b3a:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <i.2095>
     b3e:	8f 5f       	subi	r24, 0xFF	; 255
     b40:	80 93 5e 01 	sts	0x015E, r24	; 0x80015e <i.2095>
 //delays are inserted to allow character to be written before moving
 //the cursor to the next line.
 if(i == 16){_delay_us(40); line2_col1();      } //goto line 2, 1st char 
     b44:	80 31       	cpi	r24, 0x10	; 16
     b46:	f9 f0       	breq	.+62     	; 0xb86 <refresh_lcd+0x7a>
 if(i == 32){_delay_us(40); line1_col1(); i=0; } //goto line 1, 1st char 
     b48:	80 32       	cpi	r24, 0x20	; 32
     b4a:	09 f0       	breq	.+2      	; 0xb4e <refresh_lcd+0x42>
     b4c:	08 95       	ret
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     b4e:	e5 ed       	ldi	r30, 0xD5	; 213
     b50:	ea 95       	dec	r30
     b52:	f1 f7       	brne	.-4      	; 0xb50 <refresh_lcd+0x44>
     b54:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b56:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b58:	77 9b       	sbis	0x0e, 7	; 14
     b5a:	fe cf       	rjmp	.-4      	; 0xb58 <refresh_lcd+0x4c>
  SPDR = byte;                        //send payload
     b5c:	80 e8       	ldi	r24, 0x80	; 128
     b5e:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b60:	77 9b       	sbis	0x0e, 7	; 14
     b62:	fe cf       	rjmp	.-4      	; 0xb60 <refresh_lcd+0x54>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b64:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b68:	88 60       	ori	r24, 0x08	; 8
     b6a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b6e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b72:	87 7f       	andi	r24, 0xF7	; 247
     b74:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b78:	f5 ed       	ldi	r31, 0xD5	; 213
     b7a:	fa 95       	dec	r31
     b7c:	f1 f7       	brne	.-4      	; 0xb7a <refresh_lcd+0x6e>
     b7e:	00 00       	nop
 send_lcd(CHAR_BYTE,lcd_string_array[i]);
 i++;   //increment to next character
 //delays are inserted to allow character to be written before moving
 //the cursor to the next line.
 if(i == 16){_delay_us(40); line2_col1();      } //goto line 2, 1st char 
 if(i == 32){_delay_us(40); line1_col1(); i=0; } //goto line 1, 1st char 
     b80:	10 92 5e 01 	sts	0x015E, r1	; 0x80015e <i.2095>
     b84:	08 95       	ret
     b86:	f5 ed       	ldi	r31, 0xD5	; 213
     b88:	fa 95       	dec	r31
     b8a:	f1 f7       	brne	.-4      	; 0xb88 <refresh_lcd+0x7c>
     b8c:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b8e:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b90:	77 9b       	sbis	0x0e, 7	; 14
     b92:	fe cf       	rjmp	.-4      	; 0xb90 <refresh_lcd+0x84>
  SPDR = byte;                        //send payload
     b94:	80 ec       	ldi	r24, 0xC0	; 192
     b96:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b98:	77 9b       	sbis	0x0e, 7	; 14
     b9a:	fe cf       	rjmp	.-4      	; 0xb98 <refresh_lcd+0x8c>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b9c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ba0:	88 60       	ori	r24, 0x08	; 8
     ba2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ba6:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     baa:	87 7f       	andi	r24, 0xF7	; 247
     bac:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bb0:	85 ed       	ldi	r24, 0xD5	; 213
     bb2:	8a 95       	dec	r24
     bb4:	f1 f7       	brne	.-4      	; 0xbb2 <refresh_lcd+0xa6>
     bb6:	00 00       	nop
     bb8:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <i.2095>
     bbc:	c5 cf       	rjmp	.-118    	; 0xb48 <refresh_lcd+0x3c>

00000bbe <set_custom_character>:
//address, such as send_lcd(CHAR_BYTE, 0x01, 1) or it can be insteretd into a string 
//via a forward slash escape as in string2lcd("this is my music note \1")

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
     bbe:	66 0f       	add	r22, r22
     bc0:	66 0f       	add	r22, r22
     bc2:	66 0f       	add	r22, r22
     bc4:	60 5c       	subi	r22, 0xC0	; 192
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     bc6:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     bc8:	77 9b       	sbis	0x0e, 7	; 14
     bca:	fe cf       	rjmp	.-4      	; 0xbc8 <set_custom_character+0xa>
  SPDR = byte;                        //send payload
     bcc:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     bce:	77 9b       	sbis	0x0e, 7	; 14
     bd0:	fe cf       	rjmp	.-4      	; 0xbce <set_custom_character+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     bd2:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bd6:	28 60       	ori	r18, 0x08	; 8
     bd8:	20 93 62 00 	sts	0x0062, r18	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bdc:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     be0:	27 7f       	andi	r18, 0xF7	; 247
     be2:	20 93 62 00 	sts	0x0062, r18	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     be6:	25 ed       	ldi	r18, 0xD5	; 213
     be8:	2a 95       	dec	r18
     bea:	f1 f7       	brne	.-4      	; 0xbe8 <set_custom_character+0x2a>
     bec:	00 00       	nop
     bee:	fc 01       	movw	r30, r24
     bf0:	9c 01       	movw	r18, r24
     bf2:	28 5f       	subi	r18, 0xF8	; 248
     bf4:	3f 4f       	sbci	r19, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     bf6:	91 e0       	ldi	r25, 0x01	; 1

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
    for(i=0; i<8; i++){
      send_lcd(CHAR_BYTE, data[i]); _delay_us(40); //each char byte takes 37us to execute
     bf8:	81 91       	ld	r24, Z+
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     bfa:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     bfc:	77 9b       	sbis	0x0e, 7	; 14
     bfe:	fe cf       	rjmp	.-4      	; 0xbfc <set_custom_character+0x3e>
  SPDR = byte;                        //send payload
     c00:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c02:	77 9b       	sbis	0x0e, 7	; 14
     c04:	fe cf       	rjmp	.-4      	; 0xc02 <set_custom_character+0x44>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     c06:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c0a:	88 60       	ori	r24, 0x08	; 8
     c0c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c10:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c14:	87 7f       	andi	r24, 0xF7	; 247
     c16:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c1a:	85 ed       	ldi	r24, 0xD5	; 213
     c1c:	8a 95       	dec	r24
     c1e:	f1 f7       	brne	.-4      	; 0xc1c <set_custom_character+0x5e>
     c20:	00 00       	nop
//via a forward slash escape as in string2lcd("this is my music note \1")

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
    for(i=0; i<8; i++){
     c22:	e2 17       	cp	r30, r18
     c24:	f3 07       	cpc	r31, r19
     c26:	41 f7       	brne	.-48     	; 0xbf8 <set_custom_character+0x3a>
      send_lcd(CHAR_BYTE, data[i]); _delay_us(40); //each char byte takes 37us to execute
    }
}
     c28:	08 95       	ret

00000c2a <set_cursor>:
//                          set_cursor 
//
//Sets the cursor to an arbitrary potition on the screen, row is either 1 or 2
//col is a number form 0-15, counting from left to right
void set_cursor(uint8_t row, uint8_t col){
    send_lcd(CMD_BYTE, 0x80 + col + ((row-1)*0x40));
     c2a:	90 e4       	ldi	r25, 0x40	; 64
     c2c:	89 9f       	mul	r24, r25
     c2e:	60 0d       	add	r22, r0
     c30:	11 24       	eor	r1, r1
     c32:	60 5c       	subi	r22, 0xC0	; 192
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c34:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c36:	77 9b       	sbis	0x0e, 7	; 14
     c38:	fe cf       	rjmp	.-4      	; 0xc36 <set_cursor+0xc>
  SPDR = byte;                        //send payload
     c3a:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c3c:	77 9b       	sbis	0x0e, 7	; 14
     c3e:	fe cf       	rjmp	.-4      	; 0xc3c <set_cursor+0x12>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     c40:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c44:	88 60       	ori	r24, 0x08	; 8
     c46:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c4a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c4e:	87 7f       	andi	r24, 0xF7	; 247
     c50:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c54:	08 95       	ret

00000c56 <uint2lcd>:
//not displayed.  
//TODO: optimize by removing the mod operators
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
     c56:	81 11       	cpse	r24, r1
     c58:	13 c0       	rjmp	.+38     	; 0xc80 <uint2lcd+0x2a>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c5a:	81 e0       	ldi	r24, 0x01	; 1
     c5c:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c5e:	77 9b       	sbis	0x0e, 7	; 14
     c60:	fe cf       	rjmp	.-4      	; 0xc5e <uint2lcd+0x8>
  SPDR = byte;                        //send payload
     c62:	80 e3       	ldi	r24, 0x30	; 48
     c64:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c66:	77 9b       	sbis	0x0e, 7	; 14
     c68:	fe cf       	rjmp	.-4      	; 0xc66 <uint2lcd+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     c6a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c6e:	88 60       	ori	r24, 0x08	; 8
     c70:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c74:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c78:	87 7f       	andi	r24, 0xF7	; 247
     c7a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c7e:	08 95       	ret
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
     c80:	84 36       	cpi	r24, 0x64	; 100
     c82:	b0 f4       	brcc	.+44     	; 0xcb0 <uint2lcd+0x5a>
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
     c84:	8a 30       	cpi	r24, 0x0A	; 10
     c86:	60 f5       	brcc	.+88     	; 0xce0 <uint2lcd+0x8a>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c88:	91 e0       	ldi	r25, 0x01	; 1
     c8a:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c8c:	77 9b       	sbis	0x0e, 7	; 14
     c8e:	fe cf       	rjmp	.-4      	; 0xc8c <uint2lcd+0x36>
void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
      if(number >= 1)  {send_lcd(CHAR_BYTE, 0x30+(number%10)    ); }
     c90:	9d ec       	ldi	r25, 0xCD	; 205
     c92:	89 9f       	mul	r24, r25
     c94:	91 2d       	mov	r25, r1
     c96:	11 24       	eor	r1, r1
     c98:	96 95       	lsr	r25
     c9a:	96 95       	lsr	r25
     c9c:	96 95       	lsr	r25
     c9e:	2a e0       	ldi	r18, 0x0A	; 10
     ca0:	92 9f       	mul	r25, r18
     ca2:	80 19       	sub	r24, r0
     ca4:	11 24       	eor	r1, r1
     ca6:	80 5d       	subi	r24, 0xD0	; 208
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
  SPDR = byte;                        //send payload
     ca8:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     caa:	77 9b       	sbis	0x0e, 7	; 14
     cac:	fe cf       	rjmp	.-4      	; 0xcaa <uint2lcd+0x54>
     cae:	dd cf       	rjmp	.-70     	; 0xc6a <uint2lcd+0x14>
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
     cb0:	99 e2       	ldi	r25, 0x29	; 41
     cb2:	89 9f       	mul	r24, r25
     cb4:	91 2d       	mov	r25, r1
     cb6:	11 24       	eor	r1, r1
     cb8:	92 95       	swap	r25
     cba:	9f 70       	andi	r25, 0x0F	; 15
     cbc:	90 5d       	subi	r25, 0xD0	; 208
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     cbe:	21 e0       	ldi	r18, 0x01	; 1
     cc0:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     cc2:	77 9b       	sbis	0x0e, 7	; 14
     cc4:	fe cf       	rjmp	.-4      	; 0xcc2 <uint2lcd+0x6c>
  SPDR = byte;                        //send payload
     cc6:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     cc8:	77 9b       	sbis	0x0e, 7	; 14
     cca:	fe cf       	rjmp	.-4      	; 0xcc8 <uint2lcd+0x72>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     ccc:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cd0:	98 60       	ori	r25, 0x08	; 8
     cd2:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cd6:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cda:	97 7f       	andi	r25, 0xF7	; 247
     cdc:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
     ce0:	99 e2       	ldi	r25, 0x29	; 41
     ce2:	89 9f       	mul	r24, r25
     ce4:	91 2d       	mov	r25, r1
     ce6:	11 24       	eor	r1, r1
     ce8:	92 95       	swap	r25
     cea:	9f 70       	andi	r25, 0x0F	; 15
     cec:	38 2f       	mov	r19, r24
     cee:	24 e6       	ldi	r18, 0x64	; 100
     cf0:	92 9f       	mul	r25, r18
     cf2:	30 19       	sub	r19, r0
     cf4:	11 24       	eor	r1, r1
     cf6:	2d ec       	ldi	r18, 0xCD	; 205
     cf8:	32 9f       	mul	r19, r18
     cfa:	91 2d       	mov	r25, r1
     cfc:	11 24       	eor	r1, r1
     cfe:	96 95       	lsr	r25
     d00:	96 95       	lsr	r25
     d02:	96 95       	lsr	r25
     d04:	90 5d       	subi	r25, 0xD0	; 208
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d06:	21 e0       	ldi	r18, 0x01	; 1
     d08:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d0a:	77 9b       	sbis	0x0e, 7	; 14
     d0c:	fe cf       	rjmp	.-4      	; 0xd0a <uint2lcd+0xb4>
  SPDR = byte;                        //send payload
     d0e:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d10:	77 9b       	sbis	0x0e, 7	; 14
     d12:	fe cf       	rjmp	.-4      	; 0xd10 <uint2lcd+0xba>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d14:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d18:	98 60       	ori	r25, 0x08	; 8
     d1a:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d1e:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d22:	97 7f       	andi	r25, 0xF7	; 247
     d24:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d28:	af cf       	rjmp	.-162    	; 0xc88 <uint2lcd+0x32>

00000d2a <int2lcd>:
//Takes a 8bit signed and displays it in base ten on the LCD. Leading 0's are 
//not displayed.
//
void int2lcd(int8_t number){
    //if < 0, print minus sign, then take 2's complement of number and display
    if(number < 0){send_lcd(CHAR_BYTE, '-'); _delay_us(40); uint2lcd(~number+1);}  
     d2a:	87 ff       	sbrs	r24, 7
    else          {uint2lcd(number);                                            }
     d2c:	0c 94 2b 06 	jmp	0xc56	; 0xc56 <uint2lcd>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d30:	91 e0       	ldi	r25, 0x01	; 1
     d32:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d34:	77 9b       	sbis	0x0e, 7	; 14
     d36:	fe cf       	rjmp	.-4      	; 0xd34 <int2lcd+0xa>
  SPDR = byte;                        //send payload
     d38:	9d e2       	ldi	r25, 0x2D	; 45
     d3a:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d3c:	77 9b       	sbis	0x0e, 7	; 14
     d3e:	fe cf       	rjmp	.-4      	; 0xd3c <int2lcd+0x12>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d40:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d44:	98 60       	ori	r25, 0x08	; 8
     d46:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d4a:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d4e:	97 7f       	andi	r25, 0xF7	; 247
     d50:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d54:	95 ed       	ldi	r25, 0xD5	; 213
     d56:	9a 95       	dec	r25
     d58:	f1 f7       	brne	.-4      	; 0xd56 <int2lcd+0x2c>
     d5a:	00 00       	nop
//Takes a 8bit signed and displays it in base ten on the LCD. Leading 0's are 
//not displayed.
//
void int2lcd(int8_t number){
    //if < 0, print minus sign, then take 2's complement of number and display
    if(number < 0){send_lcd(CHAR_BYTE, '-'); _delay_us(40); uint2lcd(~number+1);}  
     d5c:	81 95       	neg	r24
     d5e:	0c 94 2b 06 	jmp	0xc56	; 0xc56 <uint2lcd>

00000d62 <cursor_on>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d62:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d64:	77 9b       	sbis	0x0e, 7	; 14
     d66:	fe cf       	rjmp	.-4      	; 0xd64 <cursor_on+0x2>
  SPDR = byte;                        //send payload
     d68:	8e e0       	ldi	r24, 0x0E	; 14
     d6a:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d6c:	77 9b       	sbis	0x0e, 7	; 14
     d6e:	fe cf       	rjmp	.-4      	; 0xd6c <cursor_on+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d70:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d74:	88 60       	ori	r24, 0x08	; 8
     d76:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d7a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d7e:	87 7f       	andi	r24, 0xF7	; 247
     d80:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d84:	08 95       	ret

00000d86 <cursor_off>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d86:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d88:	77 9b       	sbis	0x0e, 7	; 14
     d8a:	fe cf       	rjmp	.-4      	; 0xd88 <cursor_off+0x2>
  SPDR = byte;                        //send payload
     d8c:	8c e0       	ldi	r24, 0x0C	; 12
     d8e:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d90:	77 9b       	sbis	0x0e, 7	; 14
     d92:	fe cf       	rjmp	.-4      	; 0xd90 <cursor_off+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d94:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d98:	88 60       	ori	r24, 0x08	; 8
     d9a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d9e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     da2:	87 7f       	andi	r24, 0xF7	; 247
     da4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     da8:	08 95       	ret

00000daa <shift_right>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     daa:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     dac:	77 9b       	sbis	0x0e, 7	; 14
     dae:	fe cf       	rjmp	.-4      	; 0xdac <shift_right+0x2>
  SPDR = byte;                        //send payload
     db0:	8e e1       	ldi	r24, 0x1E	; 30
     db2:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     db4:	77 9b       	sbis	0x0e, 7	; 14
     db6:	fe cf       	rjmp	.-4      	; 0xdb4 <shift_right+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     db8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dbc:	88 60       	ori	r24, 0x08	; 8
     dbe:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dc2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dc6:	87 7f       	andi	r24, 0xF7	; 247
     dc8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dcc:	08 95       	ret

00000dce <shift_left>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     dce:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     dd0:	77 9b       	sbis	0x0e, 7	; 14
     dd2:	fe cf       	rjmp	.-4      	; 0xdd0 <shift_left+0x2>
  SPDR = byte;                        //send payload
     dd4:	88 e1       	ldi	r24, 0x18	; 24
     dd6:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     dd8:	77 9b       	sbis	0x0e, 7	; 14
     dda:	fe cf       	rjmp	.-4      	; 0xdd8 <shift_left+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     ddc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     de0:	88 60       	ori	r24, 0x08	; 8
     de2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     de6:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dea:	87 7f       	andi	r24, 0xF7	; 247
     dec:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     df0:	08 95       	ret

00000df2 <strobe_lcd>:
     df2:	e2 e6       	ldi	r30, 0x62	; 98
     df4:	f0 e0       	ldi	r31, 0x00	; 0
     df6:	80 81       	ld	r24, Z
     df8:	88 60       	ori	r24, 0x08	; 8
     dfa:	80 83       	st	Z, r24
     dfc:	80 81       	ld	r24, Z
     dfe:	87 7f       	andi	r24, 0xF7	; 247
     e00:	80 83       	st	Z, r24
     e02:	08 95       	ret

00000e04 <clear_display>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e04:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e06:	77 9b       	sbis	0x0e, 7	; 14
     e08:	fe cf       	rjmp	.-4      	; 0xe06 <clear_display+0x2>
  SPDR = byte;                        //send payload
     e0a:	81 e0       	ldi	r24, 0x01	; 1
     e0c:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e0e:	77 9b       	sbis	0x0e, 7	; 14
     e10:	fe cf       	rjmp	.-4      	; 0xe0e <clear_display+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     e12:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e16:	88 60       	ori	r24, 0x08	; 8
     e18:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e1c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e20:	87 7f       	andi	r24, 0xF7	; 247
     e22:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e26:	8f e1       	ldi	r24, 0x1F	; 31
     e28:	9c e1       	ldi	r25, 0x1C	; 28
     e2a:	01 97       	sbiw	r24, 0x01	; 1
     e2c:	f1 f7       	brne	.-4      	; 0xe2a <clear_display+0x26>
     e2e:	00 c0       	rjmp	.+0      	; 0xe30 <clear_display+0x2c>
     e30:	00 00       	nop
     e32:	08 95       	ret

00000e34 <cursor_home>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e34:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e36:	77 9b       	sbis	0x0e, 7	; 14
     e38:	fe cf       	rjmp	.-4      	; 0xe36 <cursor_home+0x2>
  SPDR = byte;                        //send payload
     e3a:	82 e0       	ldi	r24, 0x02	; 2
     e3c:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e3e:	77 9b       	sbis	0x0e, 7	; 14
     e40:	fe cf       	rjmp	.-4      	; 0xe3e <cursor_home+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     e42:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e46:	88 60       	ori	r24, 0x08	; 8
     e48:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e4c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e50:	87 7f       	andi	r24, 0xF7	; 247
     e52:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e56:	8f e6       	ldi	r24, 0x6F	; 111
     e58:	97 e1       	ldi	r25, 0x17	; 23
     e5a:	01 97       	sbiw	r24, 0x01	; 1
     e5c:	f1 f7       	brne	.-4      	; 0xe5a <cursor_home+0x26>
     e5e:	00 c0       	rjmp	.+0      	; 0xe60 <cursor_home+0x2c>
     e60:	00 00       	nop
     e62:	08 95       	ret

00000e64 <line2_col1>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e64:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e66:	77 9b       	sbis	0x0e, 7	; 14
     e68:	fe cf       	rjmp	.-4      	; 0xe66 <line2_col1+0x2>
  SPDR = byte;                        //send payload
     e6a:	80 ec       	ldi	r24, 0xC0	; 192
     e6c:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e6e:	77 9b       	sbis	0x0e, 7	; 14
     e70:	fe cf       	rjmp	.-4      	; 0xe6e <line2_col1+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     e72:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e76:	88 60       	ori	r24, 0x08	; 8
     e78:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e7c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e80:	87 7f       	andi	r24, 0xF7	; 247
     e82:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e86:	85 ed       	ldi	r24, 0xD5	; 213
     e88:	8a 95       	dec	r24
     e8a:	f1 f7       	brne	.-4      	; 0xe88 <line2_col1+0x24>
     e8c:	00 00       	nop
     e8e:	08 95       	ret

00000e90 <line1_col1>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e90:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e92:	77 9b       	sbis	0x0e, 7	; 14
     e94:	fe cf       	rjmp	.-4      	; 0xe92 <line1_col1+0x2>
  SPDR = byte;                        //send payload
     e96:	80 e8       	ldi	r24, 0x80	; 128
     e98:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e9a:	77 9b       	sbis	0x0e, 7	; 14
     e9c:	fe cf       	rjmp	.-4      	; 0xe9a <line1_col1+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     e9e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ea2:	88 60       	ori	r24, 0x08	; 8
     ea4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ea8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     eac:	87 7f       	andi	r24, 0xF7	; 247
     eae:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     eb2:	85 ed       	ldi	r24, 0xD5	; 213
     eb4:	8a 95       	dec	r24
     eb6:	f1 f7       	brne	.-4      	; 0xeb4 <line1_col1+0x24>
     eb8:	00 00       	nop
     eba:	08 95       	ret

00000ebc <fill_spaces>:

//-----------------------------------------------------------------------------
//                          fill_spaces   
//
//Fill an entire line with spaces.
void fill_spaces(void){
     ebc:	90 e1       	ldi	r25, 0x10	; 16
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ebe:	31 e0       	ldi	r19, 0x01	; 1
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
  SPDR = byte;                        //send payload
     ec0:	20 e2       	ldi	r18, 0x20	; 32
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ec2:	3f b9       	out	0x0f, r19	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ec4:	77 9b       	sbis	0x0e, 7	; 14
     ec6:	fe cf       	rjmp	.-4      	; 0xec4 <fill_spaces+0x8>
  SPDR = byte;                        //send payload
     ec8:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     eca:	77 9b       	sbis	0x0e, 7	; 14
     ecc:	fe cf       	rjmp	.-4      	; 0xeca <fill_spaces+0xe>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     ece:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ed2:	88 60       	ori	r24, 0x08	; 8
     ed4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ed8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     edc:	87 7f       	andi	r24, 0xF7	; 247
     ede:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ee2:	85 ed       	ldi	r24, 0xD5	; 213
     ee4:	8a 95       	dec	r24
     ee6:	f1 f7       	brne	.-4      	; 0xee4 <fill_spaces+0x28>
     ee8:	00 00       	nop
     eea:	91 50       	subi	r25, 0x01	; 1
//                          fill_spaces   
//
//Fill an entire line with spaces.
void fill_spaces(void){
	uint8_t i;
	for (i=0; i<=(NUM_LCD_CHARS-1); i++){
     eec:	51 f7       	brne	.-44     	; 0xec2 <fill_spaces+0x6>
		send_lcd(CHAR_BYTE, ' '); 
                _delay_us(40);  //40us wait between characters
	}
}  
     eee:	08 95       	ret

00000ef0 <char2lcd>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ef0:	91 e0       	ldi	r25, 0x01	; 1
     ef2:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ef4:	77 9b       	sbis	0x0e, 7	; 14
     ef6:	fe cf       	rjmp	.-4      	; 0xef4 <char2lcd+0x4>
  SPDR = byte;                        //send payload
     ef8:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     efa:	77 9b       	sbis	0x0e, 7	; 14
     efc:	fe cf       	rjmp	.-4      	; 0xefa <char2lcd+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     efe:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f02:	88 60       	ori	r24, 0x08	; 8
     f04:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f08:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f0c:	87 7f       	andi	r24, 0xF7	; 247
     f0e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f12:	08 95       	ret

00000f14 <string2lcd>:

//----------------------------------------------------------------------------
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
     f14:	fc 01       	movw	r30, r24
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     f16:	40 e0       	ldi	r20, 0x00	; 0
     f18:	50 e0       	ldi	r21, 0x00	; 0
     f1a:	60 e0       	ldi	r22, 0x00	; 0
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     f1c:	71 e0       	ldi	r23, 0x01	; 1
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     f1e:	df 01       	movw	r26, r30
     f20:	a4 0f       	add	r26, r20
     f22:	b5 1f       	adc	r27, r21
     f24:	8c 91       	ld	r24, X
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     f26:	7f b9       	out	0x0f, r23	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f28:	77 9b       	sbis	0x0e, 7	; 14
     f2a:	fe cf       	rjmp	.-4      	; 0xf28 <string2lcd+0x14>
  SPDR = byte;                        //send payload
     f2c:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f2e:	77 9b       	sbis	0x0e, 7	; 14
     f30:	fe cf       	rjmp	.-4      	; 0xf2e <string2lcd+0x1a>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     f32:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f36:	98 60       	ori	r25, 0x08	; 8
     f38:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f3c:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f40:	97 7f       	andi	r25, 0xF7	; 247
     f42:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f46:	85 ed       	ldi	r24, 0xD5	; 213
     f48:	8a 95       	dec	r24
     f4a:	f1 f7       	brne	.-4      	; 0xf48 <string2lcd+0x34>
     f4c:	00 00       	nop
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     f4e:	6f 5f       	subi	r22, 0xFF	; 255
     f50:	46 2f       	mov	r20, r22
     f52:	50 e0       	ldi	r21, 0x00	; 0
     f54:	df 01       	movw	r26, r30
     f56:	0d 90       	ld	r0, X+
     f58:	00 20       	and	r0, r0
     f5a:	e9 f7       	brne	.-6      	; 0xf56 <string2lcd+0x42>
     f5c:	9d 01       	movw	r18, r26
     f5e:	2e 1b       	sub	r18, r30
     f60:	3f 0b       	sbc	r19, r31
     f62:	22 50       	subi	r18, 0x02	; 2
     f64:	31 09       	sbc	r19, r1
     f66:	24 17       	cp	r18, r20
     f68:	35 07       	cpc	r19, r21
     f6a:	c8 f6       	brcc	.-78     	; 0xf1e <string2lcd+0xa>
  _delay_us(40);  //execution takes 37us per character
  }                  
} 
     f6c:	08 95       	ret

00000f6e <lcd_init>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     f6e:	8f ef       	ldi	r24, 0xFF	; 255
     f70:	99 ef       	ldi	r25, 0xF9	; 249
     f72:	01 97       	sbiw	r24, 0x01	; 1
     f74:	f1 f7       	brne	.-4      	; 0xf72 <lcd_init+0x4>
     f76:	00 c0       	rjmp	.+0      	; 0xf78 <lcd_init+0xa>
     f78:	00 00       	nop
//
void lcd_init(void){
  _delay_ms(16);      //power up delay
#if SPI_MODE==1       //assumption is that the SPI port is intialized
  //TODO: kludge alert! setting of DDRF should not be here, but is probably harmless.
  DDRF=0x08;          //port F bit 3 is enable for LCD in SPI mode
     f7a:	88 e0       	ldi	r24, 0x08	; 8
     f7c:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     f80:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f82:	77 9b       	sbis	0x0e, 7	; 14
     f84:	fe cf       	rjmp	.-4      	; 0xf82 <lcd_init+0x14>
  SPDR = byte;                        //send payload
     f86:	80 e3       	ldi	r24, 0x30	; 48
     f88:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f8a:	77 9b       	sbis	0x0e, 7	; 14
     f8c:	fe cf       	rjmp	.-4      	; 0xf8a <lcd_init+0x1c>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     f8e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f92:	88 60       	ori	r24, 0x08	; 8
     f94:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f98:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f9c:	87 7f       	andi	r24, 0xF7	; 247
     f9e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fa2:	8f e5       	ldi	r24, 0x5F	; 95
     fa4:	9d e6       	ldi	r25, 0x6D	; 109
     fa6:	01 97       	sbiw	r24, 0x01	; 1
     fa8:	f1 f7       	brne	.-4      	; 0xfa6 <lcd_init+0x38>
     faa:	00 c0       	rjmp	.+0      	; 0xfac <lcd_init+0x3e>
     fac:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     fae:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     fb0:	77 9b       	sbis	0x0e, 7	; 14
     fb2:	fe cf       	rjmp	.-4      	; 0xfb0 <lcd_init+0x42>
  SPDR = byte;                        //send payload
     fb4:	80 e3       	ldi	r24, 0x30	; 48
     fb6:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     fb8:	77 9b       	sbis	0x0e, 7	; 14
     fba:	fe cf       	rjmp	.-4      	; 0xfb8 <lcd_init+0x4a>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     fbc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fc0:	88 60       	ori	r24, 0x08	; 8
     fc2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fc6:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fca:	87 7f       	andi	r24, 0xF7	; 247
     fcc:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fd0:	8f e5       	ldi	r24, 0x5F	; 95
     fd2:	9d e6       	ldi	r25, 0x6D	; 109
     fd4:	01 97       	sbiw	r24, 0x01	; 1
     fd6:	f1 f7       	brne	.-4      	; 0xfd4 <lcd_init+0x66>
     fd8:	00 c0       	rjmp	.+0      	; 0xfda <lcd_init+0x6c>
     fda:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     fdc:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     fde:	77 9b       	sbis	0x0e, 7	; 14
     fe0:	fe cf       	rjmp	.-4      	; 0xfde <lcd_init+0x70>
  SPDR = byte;                        //send payload
     fe2:	80 e3       	ldi	r24, 0x30	; 48
     fe4:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     fe6:	77 9b       	sbis	0x0e, 7	; 14
     fe8:	fe cf       	rjmp	.-4      	; 0xfe6 <lcd_init+0x78>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     fea:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fee:	88 60       	ori	r24, 0x08	; 8
     ff0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ff4:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ff8:	87 7f       	andi	r24, 0xF7	; 247
     ffa:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ffe:	8f e5       	ldi	r24, 0x5F	; 95
    1000:	9d e6       	ldi	r25, 0x6D	; 109
    1002:	01 97       	sbiw	r24, 0x01	; 1
    1004:	f1 f7       	brne	.-4      	; 0x1002 <lcd_init+0x94>
    1006:	00 c0       	rjmp	.+0      	; 0x1008 <lcd_init+0x9a>
    1008:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    100a:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    100c:	77 9b       	sbis	0x0e, 7	; 14
    100e:	fe cf       	rjmp	.-4      	; 0x100c <lcd_init+0x9e>
  SPDR = byte;                        //send payload
    1010:	88 e3       	ldi	r24, 0x38	; 56
    1012:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1014:	77 9b       	sbis	0x0e, 7	; 14
    1016:	fe cf       	rjmp	.-4      	; 0x1014 <lcd_init+0xa6>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    1018:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    101c:	88 60       	ori	r24, 0x08	; 8
    101e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1022:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1026:	87 7f       	andi	r24, 0xF7	; 247
    1028:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    102c:	8f e1       	ldi	r24, 0x1F	; 31
    102e:	9e e4       	ldi	r25, 0x4E	; 78
    1030:	01 97       	sbiw	r24, 0x01	; 1
    1032:	f1 f7       	brne	.-4      	; 0x1030 <lcd_init+0xc2>
    1034:	00 c0       	rjmp	.+0      	; 0x1036 <lcd_init+0xc8>
    1036:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1038:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    103a:	77 9b       	sbis	0x0e, 7	; 14
    103c:	fe cf       	rjmp	.-4      	; 0x103a <lcd_init+0xcc>
  SPDR = byte;                        //send payload
    103e:	88 e0       	ldi	r24, 0x08	; 8
    1040:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1042:	77 9b       	sbis	0x0e, 7	; 14
    1044:	fe cf       	rjmp	.-4      	; 0x1042 <lcd_init+0xd4>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    1046:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    104a:	88 60       	ori	r24, 0x08	; 8
    104c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1050:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1054:	87 7f       	andi	r24, 0xF7	; 247
    1056:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    105a:	8f e1       	ldi	r24, 0x1F	; 31
    105c:	9e e4       	ldi	r25, 0x4E	; 78
    105e:	01 97       	sbiw	r24, 0x01	; 1
    1060:	f1 f7       	brne	.-4      	; 0x105e <lcd_init+0xf0>
    1062:	00 c0       	rjmp	.+0      	; 0x1064 <lcd_init+0xf6>
    1064:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1066:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1068:	77 9b       	sbis	0x0e, 7	; 14
    106a:	fe cf       	rjmp	.-4      	; 0x1068 <lcd_init+0xfa>
  SPDR = byte;                        //send payload
    106c:	81 e0       	ldi	r24, 0x01	; 1
    106e:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1070:	77 9b       	sbis	0x0e, 7	; 14
    1072:	fe cf       	rjmp	.-4      	; 0x1070 <lcd_init+0x102>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    1074:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1078:	88 60       	ori	r24, 0x08	; 8
    107a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    107e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1082:	87 7f       	andi	r24, 0xF7	; 247
    1084:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1088:	8f e1       	ldi	r24, 0x1F	; 31
    108a:	9e e4       	ldi	r25, 0x4E	; 78
    108c:	01 97       	sbiw	r24, 0x01	; 1
    108e:	f1 f7       	brne	.-4      	; 0x108c <lcd_init+0x11e>
    1090:	00 c0       	rjmp	.+0      	; 0x1092 <lcd_init+0x124>
    1092:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1094:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1096:	77 9b       	sbis	0x0e, 7	; 14
    1098:	fe cf       	rjmp	.-4      	; 0x1096 <lcd_init+0x128>
  SPDR = byte;                        //send payload
    109a:	86 e0       	ldi	r24, 0x06	; 6
    109c:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    109e:	77 9b       	sbis	0x0e, 7	; 14
    10a0:	fe cf       	rjmp	.-4      	; 0x109e <lcd_init+0x130>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    10a2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10a6:	88 60       	ori	r24, 0x08	; 8
    10a8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10ac:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10b0:	87 7f       	andi	r24, 0xF7	; 247
    10b2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10b6:	8f e1       	ldi	r24, 0x1F	; 31
    10b8:	9e e4       	ldi	r25, 0x4E	; 78
    10ba:	01 97       	sbiw	r24, 0x01	; 1
    10bc:	f1 f7       	brne	.-4      	; 0x10ba <lcd_init+0x14c>
    10be:	00 c0       	rjmp	.+0      	; 0x10c0 <lcd_init+0x152>
    10c0:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    10c2:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    10c4:	77 9b       	sbis	0x0e, 7	; 14
    10c6:	fe cf       	rjmp	.-4      	; 0x10c4 <lcd_init+0x156>
  SPDR = byte;                        //send payload
    10c8:	8c e0       	ldi	r24, 0x0C	; 12
    10ca:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    10cc:	77 9b       	sbis	0x0e, 7	; 14
    10ce:	fe cf       	rjmp	.-4      	; 0x10cc <lcd_init+0x15e>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    10d0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10d4:	88 60       	ori	r24, 0x08	; 8
    10d6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10da:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10de:	87 7f       	andi	r24, 0xF7	; 247
    10e0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10e4:	8f e1       	ldi	r24, 0x1F	; 31
    10e6:	9e e4       	ldi	r25, 0x4E	; 78
    10e8:	01 97       	sbiw	r24, 0x01	; 1
    10ea:	f1 f7       	brne	.-4      	; 0x10e8 <lcd_init+0x17a>
    10ec:	00 c0       	rjmp	.+0      	; 0x10ee <lcd_init+0x180>
    10ee:	00 00       	nop
    10f0:	08 95       	ret

000010f2 <lcd_int32>:
void  lcd_int32(int32_t l,          //number to display
                uint8_t fieldwidth, //width of the field for display
                uint8_t decpos,     //0 if no decimal point, otherwise
                uint8_t bSigned,    //non-zero if the number should be treated as signed 
                uint8_t bZeroFill)  //non-zero if a specified fieldwidth is to be zero filled
{
    10f2:	4f 92       	push	r4
    10f4:	5f 92       	push	r5
    10f6:	6f 92       	push	r6
    10f8:	7f 92       	push	r7
    10fa:	8f 92       	push	r8
    10fc:	9f 92       	push	r9
    10fe:	af 92       	push	r10
    1100:	bf 92       	push	r11
    1102:	cf 92       	push	r12
    1104:	df 92       	push	r13
    1106:	ef 92       	push	r14
    1108:	ff 92       	push	r15
    110a:	0f 93       	push	r16
    110c:	1f 93       	push	r17
    110e:	cf 93       	push	r28
    1110:	df 93       	push	r29
    1112:	cd b7       	in	r28, 0x3d	; 61
    1114:	de b7       	in	r29, 0x3e	; 62
    1116:	69 97       	sbiw	r28, 0x19	; 25
    1118:	0f b6       	in	r0, 0x3f	; 63
    111a:	f8 94       	cli
    111c:	de bf       	out	0x3e, r29	; 62
    111e:	0f be       	out	0x3f, r0	; 63
    1120:	cd bf       	out	0x3d, r28	; 61
    1122:	14 2f       	mov	r17, r20
    1124:	42 2e       	mov	r4, r18
    1126:	5e 2c       	mov	r5, r14
      char    fillch;
      ldiv_t  qr;

      qr.quot = l; // initialize the quotient 

      if (bSigned){
    1128:	00 23       	and	r16, r16
    112a:	79 f0       	breq	.+30     	; 0x114a <__stack+0x4b>
        bSigned = (qr.quot<0);
    112c:	6b 01       	movw	r12, r22
    112e:	7c 01       	movw	r14, r24
    1130:	cc 24       	eor	r12, r12
    1132:	f7 fc       	sbrc	r15, 7
    1134:	c3 94       	inc	r12
    1136:	dd 24       	eor	r13, r13
    1138:	ee 24       	eor	r14, r14
    113a:	ff 24       	eor	r15, r15
    113c:	0c 2d       	mov	r16, r12
        qr.quot = labs(qr.quot);
    113e:	6b 01       	movw	r12, r22
    1140:	7c 01       	movw	r14, r24
    1142:	97 fd       	sbrc	r25, 7
    1144:	a3 c0       	rjmp	.+326    	; 0x128c <__stack+0x18d>
    1146:	c7 01       	movw	r24, r14
    1148:	b6 01       	movw	r22, r12
      }

      // convert the digits to the right of the decimal point 
      if (decpos){
    114a:	44 20       	and	r4, r4
    114c:	09 f4       	brne	.+2      	; 0x1150 <__stack+0x51>
    114e:	96 c0       	rjmp	.+300    	; 0x127c <__stack+0x17d>
    1150:	9e 01       	movw	r18, r28
    1152:	2f 5f       	subi	r18, 0xFF	; 255
    1154:	3f 4f       	sbci	r19, 0xFF	; 255
    1156:	59 01       	movw	r10, r18
    1158:	49 01       	movw	r8, r18
    115a:	66 24       	eor	r6, r6
    115c:	6a 94       	dec	r6
    115e:	64 0c       	add	r6, r4
    1160:	71 2c       	mov	r7, r1
    1162:	3f ef       	ldi	r19, 0xFF	; 255
    1164:	63 1a       	sub	r6, r19
    1166:	73 0a       	sbc	r7, r19
    1168:	6a 0c       	add	r6, r10
    116a:	7b 1c       	adc	r7, r11
        for (; decpos ; decpos--){
          qr = ldiv(qr.quot, 10);
    116c:	2a e0       	ldi	r18, 0x0A	; 10
    116e:	30 e0       	ldi	r19, 0x00	; 0
    1170:	40 e0       	ldi	r20, 0x00	; 0
    1172:	50 e0       	ldi	r21, 0x00	; 0
    1174:	0e 94 f0 0b 	call	0x17e0	; 0x17e0 <__divmodsi4>
    1178:	e6 2f       	mov	r30, r22
    117a:	2a 8b       	std	Y+18, r18	; 0x12
    117c:	3b 8b       	std	Y+19, r19	; 0x13
    117e:	4c 8b       	std	Y+20, r20	; 0x14
    1180:	5d 8b       	std	Y+21, r21	; 0x15
    1182:	6a 89       	ldd	r22, Y+18	; 0x12
    1184:	7b 89       	ldd	r23, Y+19	; 0x13
    1186:	8c 89       	ldd	r24, Y+20	; 0x14
    1188:	9d 89       	ldd	r25, Y+21	; 0x15
          sline[i++] = qr.rem + '0';
    118a:	20 e3       	ldi	r18, 0x30	; 48
    118c:	2e 0f       	add	r18, r30
    118e:	f4 01       	movw	r30, r8
    1190:	21 93       	st	Z+, r18
    1192:	4f 01       	movw	r8, r30
        qr.quot = labs(qr.quot);
      }

      // convert the digits to the right of the decimal point 
      if (decpos){
        for (; decpos ; decpos--){
    1194:	6e 16       	cp	r6, r30
    1196:	7f 06       	cpc	r7, r31
    1198:	49 f7       	brne	.-46     	; 0x116c <__stack+0x6d>
          qr = ldiv(qr.quot, 10);
          sline[i++] = qr.rem + '0';
        }
        sline[i++] = '.';
    119a:	99 24       	eor	r9, r9
    119c:	93 94       	inc	r9
    119e:	94 0c       	add	r9, r4
    11a0:	f5 01       	movw	r30, r10
    11a2:	e4 0d       	add	r30, r4
    11a4:	f1 1d       	adc	r31, r1
    11a6:	2e e2       	ldi	r18, 0x2E	; 46
    11a8:	20 83       	st	Z, r18
      }

      // convert the digits to the left of the decimal point 
      do{
          qr = ldiv(qr.quot, 10);
    11aa:	2a e0       	ldi	r18, 0x0A	; 10
    11ac:	30 e0       	ldi	r19, 0x00	; 0
    11ae:	40 e0       	ldi	r20, 0x00	; 0
    11b0:	50 e0       	ldi	r21, 0x00	; 0
    11b2:	0e 94 f0 0b 	call	0x17e0	; 0x17e0 <__divmodsi4>
    11b6:	e6 2f       	mov	r30, r22
    11b8:	2a 8b       	std	Y+18, r18	; 0x12
    11ba:	3b 8b       	std	Y+19, r19	; 0x13
    11bc:	4c 8b       	std	Y+20, r20	; 0x14
    11be:	5d 8b       	std	Y+21, r21	; 0x15
    11c0:	6e 8b       	std	Y+22, r22	; 0x16
    11c2:	7f 8b       	std	Y+23, r23	; 0x17
    11c4:	88 8f       	std	Y+24, r24	; 0x18
    11c6:	99 8f       	std	Y+25, r25	; 0x19
    11c8:	6a 89       	ldd	r22, Y+18	; 0x12
    11ca:	7b 89       	ldd	r23, Y+19	; 0x13
    11cc:	8c 89       	ldd	r24, Y+20	; 0x14
    11ce:	9d 89       	ldd	r25, Y+21	; 0x15
          sline[i++] = qr.rem + '0';
    11d0:	31 e0       	ldi	r19, 0x01	; 1
    11d2:	39 0d       	add	r19, r9
    11d4:	d5 01       	movw	r26, r10
    11d6:	a9 0d       	add	r26, r9
    11d8:	b1 1d       	adc	r27, r1
    11da:	e0 5d       	subi	r30, 0xD0	; 208
    11dc:	ec 93       	st	X, r30
    11de:	93 2e       	mov	r9, r19
        }while(qr.quot);
    11e0:	61 15       	cp	r22, r1
    11e2:	71 05       	cpc	r23, r1
    11e4:	81 05       	cpc	r24, r1
    11e6:	91 05       	cpc	r25, r1
    11e8:	01 f7       	brne	.-64     	; 0x11aa <__stack+0xab>

      // fill the whole field if a width was specified
      if (fieldwidth){
    11ea:	11 23       	and	r17, r17
    11ec:	61 f0       	breq	.+24     	; 0x1206 <__stack+0x107>
        fillch = bZeroFill? '0': ' '; // determine the fill character
    11ee:	51 10       	cpse	r5, r1
    11f0:	4b c0       	rjmp	.+150    	; 0x1288 <__stack+0x189>
    11f2:	90 e2       	ldi	r25, 0x20	; 32
        for (; i<fieldwidth ; ){sline[i++] = fillch;}
    11f4:	31 17       	cp	r19, r17
    11f6:	38 f4       	brcc	.+14     	; 0x1206 <__stack+0x107>
    11f8:	f5 01       	movw	r30, r10
    11fa:	e3 0f       	add	r30, r19
    11fc:	f1 1d       	adc	r31, r1
    11fe:	90 83       	st	Z, r25
    1200:	3f 5f       	subi	r19, 0xFF	; 255
    1202:	13 13       	cpse	r17, r19
    1204:	f9 cf       	rjmp	.-14     	; 0x11f8 <__stack+0xf9>
      }

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}
    1206:	00 23       	and	r16, r16
    1208:	31 f0       	breq	.+12     	; 0x1216 <__stack+0x117>
    120a:	f5 01       	movw	r30, r10
    120c:	e3 0f       	add	r30, r19
    120e:	f1 1d       	adc	r31, r1
    1210:	9d e2       	ldi	r25, 0x2D	; 45
    1212:	90 83       	st	Z, r25
    1214:	3f 5f       	subi	r19, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1216:	21 e0       	ldi	r18, 0x01	; 1

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}

      // now output the formatted number
      do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    1218:	31 50       	subi	r19, 0x01	; 1
    121a:	f5 01       	movw	r30, r10
    121c:	e3 0f       	add	r30, r19
    121e:	f1 1d       	adc	r31, r1
    1220:	90 81       	ld	r25, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1222:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1224:	77 9b       	sbis	0x0e, 7	; 14
    1226:	fe cf       	rjmp	.-4      	; 0x1224 <__stack+0x125>
  SPDR = byte;                        //send payload
    1228:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    122a:	77 9b       	sbis	0x0e, 7	; 14
    122c:	fe cf       	rjmp	.-4      	; 0x122a <__stack+0x12b>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    122e:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1232:	98 60       	ori	r25, 0x08	; 8
    1234:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1238:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    123c:	97 7f       	andi	r25, 0xF7	; 247
    123e:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1242:	85 ed       	ldi	r24, 0xD5	; 213
    1244:	8a 95       	dec	r24
    1246:	f1 f7       	brne	.-4      	; 0x1244 <__stack+0x145>
    1248:	00 00       	nop

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}

      // now output the formatted number
      do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    124a:	31 11       	cpse	r19, r1
    124c:	e5 cf       	rjmp	.-54     	; 0x1218 <__stack+0x119>

}
    124e:	69 96       	adiw	r28, 0x19	; 25
    1250:	0f b6       	in	r0, 0x3f	; 63
    1252:	f8 94       	cli
    1254:	de bf       	out	0x3e, r29	; 62
    1256:	0f be       	out	0x3f, r0	; 63
    1258:	cd bf       	out	0x3d, r28	; 61
    125a:	df 91       	pop	r29
    125c:	cf 91       	pop	r28
    125e:	1f 91       	pop	r17
    1260:	0f 91       	pop	r16
    1262:	ff 90       	pop	r15
    1264:	ef 90       	pop	r14
    1266:	df 90       	pop	r13
    1268:	cf 90       	pop	r12
    126a:	bf 90       	pop	r11
    126c:	af 90       	pop	r10
    126e:	9f 90       	pop	r9
    1270:	8f 90       	pop	r8
    1272:	7f 90       	pop	r7
    1274:	6f 90       	pop	r6
    1276:	5f 90       	pop	r5
    1278:	4f 90       	pop	r4
    127a:	08 95       	ret
                uint8_t decpos,     //0 if no decimal point, otherwise
                uint8_t bSigned,    //non-zero if the number should be treated as signed 
                uint8_t bZeroFill)  //non-zero if a specified fieldwidth is to be zero filled
{
      char    sline[NUM_LCD_CHARS+1];
      uint8_t i=0;
    127c:	91 2c       	mov	r9, r1
    127e:	9e 01       	movw	r18, r28
    1280:	2f 5f       	subi	r18, 0xFF	; 255
    1282:	3f 4f       	sbci	r19, 0xFF	; 255
    1284:	59 01       	movw	r10, r18
    1286:	91 cf       	rjmp	.-222    	; 0x11aa <__stack+0xab>
          sline[i++] = qr.rem + '0';
        }while(qr.quot);

      // fill the whole field if a width was specified
      if (fieldwidth){
        fillch = bZeroFill? '0': ' '; // determine the fill character
    1288:	90 e3       	ldi	r25, 0x30	; 48
    128a:	b4 cf       	rjmp	.-152    	; 0x11f4 <__stack+0xf5>

      qr.quot = l; // initialize the quotient 

      if (bSigned){
        bSigned = (qr.quot<0);
        qr.quot = labs(qr.quot);
    128c:	f0 94       	com	r15
    128e:	e0 94       	com	r14
    1290:	d0 94       	com	r13
    1292:	c0 94       	com	r12
    1294:	c1 1c       	adc	r12, r1
    1296:	d1 1c       	adc	r13, r1
    1298:	e1 1c       	adc	r14, r1
    129a:	f1 1c       	adc	r15, r1
    129c:	54 cf       	rjmp	.-344    	; 0x1146 <__stack+0x47>

0000129e <lcd_int16>:
void    lcd_int16(int16_t l, 
                  uint8_t fieldwidth, 
                  uint8_t decpos, 
                  uint8_t bSigned,
                  uint8_t bZeroFill)
{
    129e:	5f 92       	push	r5
    12a0:	6f 92       	push	r6
    12a2:	7f 92       	push	r7
    12a4:	8f 92       	push	r8
    12a6:	9f 92       	push	r9
    12a8:	af 92       	push	r10
    12aa:	bf 92       	push	r11
    12ac:	cf 92       	push	r12
    12ae:	df 92       	push	r13
    12b0:	ef 92       	push	r14
    12b2:	ff 92       	push	r15
    12b4:	0f 93       	push	r16
    12b6:	1f 93       	push	r17
    12b8:	cf 93       	push	r28
    12ba:	df 93       	push	r29
    12bc:	cd b7       	in	r28, 0x3d	; 61
    12be:	de b7       	in	r29, 0x3e	; 62
    12c0:	61 97       	sbiw	r28, 0x11	; 17
    12c2:	0f b6       	in	r0, 0x3f	; 63
    12c4:	f8 94       	cli
    12c6:	de bf       	out	0x3e, r29	; 62
    12c8:	0f be       	out	0x3f, r0	; 63
    12ca:	cd bf       	out	0x3d, r28	; 61
    12cc:	5c 01       	movw	r10, r24
    12ce:	16 2f       	mov	r17, r22
    12d0:	74 2e       	mov	r7, r20
//        uint8_t bSigned;   Now an argument for signed or not

        // initialize the quotient 
        qr.quot = l;

        if ( (bSigned=(qr.quot<0)) )
    12d2:	6b 2c       	mov	r6, r11
    12d4:	66 1c       	adc	r6, r6
    12d6:	66 24       	eor	r6, r6
    12d8:	66 1c       	adc	r6, r6
    12da:	56 2c       	mov	r5, r6
    12dc:	9c 01       	movw	r18, r24
    12de:	97 fd       	sbrc	r25, 7
    12e0:	9b c0       	rjmp	.+310    	; 0x1418 <lcd_int16+0x17a>
                qr.quot = -qr.quot;

        // convert the digits to the right of the decimal point 
        if (decpos){
    12e2:	77 20       	and	r7, r7
    12e4:	09 f4       	brne	.+2      	; 0x12e8 <lcd_int16+0x4a>
    12e6:	8d c0       	rjmp	.+282    	; 0x1402 <lcd_int16+0x164>
    12e8:	ce 01       	movw	r24, r28
    12ea:	01 96       	adiw	r24, 0x01	; 1
    12ec:	7c 01       	movw	r14, r24
    12ee:	6c 01       	movw	r12, r24
    12f0:	88 24       	eor	r8, r8
    12f2:	8a 94       	dec	r8
    12f4:	87 0c       	add	r8, r7
    12f6:	91 2c       	mov	r9, r1
    12f8:	9f ef       	ldi	r25, 0xFF	; 255
    12fa:	89 1a       	sub	r8, r25
    12fc:	99 0a       	sbc	r9, r25
    12fe:	8e 0c       	add	r8, r14
    1300:	9f 1c       	adc	r9, r15
          for (; decpos ; decpos--){
            qr = div(qr.quot, 10);
    1302:	6a e0       	ldi	r22, 0x0A	; 10
    1304:	70 e0       	ldi	r23, 0x00	; 0
    1306:	c9 01       	movw	r24, r18
    1308:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <__divmodhi4>
    130c:	46 2f       	mov	r20, r22
    130e:	24 2f       	mov	r18, r20
    1310:	37 2f       	mov	r19, r23
            sline[i++] = qr.rem + '0';
    1312:	80 5d       	subi	r24, 0xD0	; 208
    1314:	f6 01       	movw	r30, r12
    1316:	81 93       	st	Z+, r24
    1318:	6f 01       	movw	r12, r30
        if ( (bSigned=(qr.quot<0)) )
                qr.quot = -qr.quot;

        // convert the digits to the right of the decimal point 
        if (decpos){
          for (; decpos ; decpos--){
    131a:	e8 15       	cp	r30, r8
    131c:	f9 05       	cpc	r31, r9
    131e:	89 f7       	brne	.-30     	; 0x1302 <lcd_int16+0x64>
            qr = div(qr.quot, 10);
            sline[i++] = qr.rem + '0';
          }
          sline[i++] = '.';
    1320:	dd 24       	eor	r13, r13
    1322:	d3 94       	inc	r13
    1324:	d7 0c       	add	r13, r7
    1326:	f7 01       	movw	r30, r14
    1328:	e7 0d       	add	r30, r7
    132a:	f1 1d       	adc	r31, r1
    132c:	8e e2       	ldi	r24, 0x2E	; 46
    132e:	80 83       	st	Z, r24
    1330:	01 c0       	rjmp	.+2      	; 0x1334 <lcd_int16+0x96>

        // convert the digits to the left of the decimal point 
        do
        {
                qr = div(qr.quot, 10);
                sline[i++] = qr.rem + '0';
    1332:	d9 2e       	mov	r13, r25
        }

        // convert the digits to the left of the decimal point 
        do
        {
                qr = div(qr.quot, 10);
    1334:	6a e0       	ldi	r22, 0x0A	; 10
    1336:	70 e0       	ldi	r23, 0x00	; 0
    1338:	c9 01       	movw	r24, r18
    133a:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <__divmodhi4>
    133e:	46 2f       	mov	r20, r22
    1340:	24 2f       	mov	r18, r20
    1342:	37 2f       	mov	r19, r23
                sline[i++] = qr.rem + '0';
    1344:	91 e0       	ldi	r25, 0x01	; 1
    1346:	9d 0d       	add	r25, r13
    1348:	f7 01       	movw	r30, r14
    134a:	ed 0d       	add	r30, r13
    134c:	f1 1d       	adc	r31, r1
    134e:	80 5d       	subi	r24, 0xD0	; 208
    1350:	80 83       	st	Z, r24
        }
        while(qr.quot);
    1352:	21 15       	cp	r18, r1
    1354:	31 05       	cpc	r19, r1
    1356:	69 f7       	brne	.-38     	; 0x1332 <lcd_int16+0x94>

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
    1358:	01 11       	cpse	r16, r1
    135a:	58 c0       	rjmp	.+176    	; 0x140c <lcd_int16+0x16e>
    135c:	b7 fc       	sbrc	r11, 7
    135e:	61 c0       	rjmp	.+194    	; 0x1422 <lcd_int16+0x184>
                sline[i++] = '-';
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    1360:	11 23       	and	r17, r17
    1362:	a9 f0       	breq	.+42     	; 0x138e <lcd_int16+0xf0>
    1364:	71 2c       	mov	r7, r1
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    1366:	80 e2       	ldi	r24, 0x20	; 32
          for (; i<(fieldwidth-bSigned) ; ){ sline[i++] = fillch;}
    1368:	29 2f       	mov	r18, r25
    136a:	30 e0       	ldi	r19, 0x00	; 0
    136c:	41 2f       	mov	r20, r17
    136e:	50 e0       	ldi	r21, 0x00	; 0
    1370:	46 19       	sub	r20, r6
    1372:	57 09       	sbc	r21, r7
    1374:	24 17       	cp	r18, r20
    1376:	35 07       	cpc	r19, r21
    1378:	54 f4       	brge	.+20     	; 0x138e <lcd_int16+0xf0>
    137a:	9f 5f       	subi	r25, 0xFF	; 255
    137c:	f7 01       	movw	r30, r14
    137e:	e2 0f       	add	r30, r18
    1380:	f3 1f       	adc	r31, r19
    1382:	80 83       	st	Z, r24
    1384:	29 2f       	mov	r18, r25
    1386:	30 e0       	ldi	r19, 0x00	; 0
    1388:	24 17       	cp	r18, r20
    138a:	35 07       	cpc	r19, r21
    138c:	b4 f3       	brlt	.-20     	; 0x137a <lcd_int16+0xdc>
        }

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}
    138e:	55 20       	and	r5, r5
    1390:	31 f0       	breq	.+12     	; 0x139e <lcd_int16+0x100>
    1392:	f7 01       	movw	r30, r14
    1394:	e9 0f       	add	r30, r25
    1396:	f1 1d       	adc	r31, r1
    1398:	8d e2       	ldi	r24, 0x2D	; 45
    139a:	80 83       	st	Z, r24
    139c:	9f 5f       	subi	r25, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    139e:	21 e0       	ldi	r18, 0x01	; 1

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}

        // now output the formatted number 
            do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    13a0:	91 50       	subi	r25, 0x01	; 1
    13a2:	f7 01       	movw	r30, r14
    13a4:	e9 0f       	add	r30, r25
    13a6:	f1 1d       	adc	r31, r1
    13a8:	80 81       	ld	r24, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    13aa:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    13ac:	77 9b       	sbis	0x0e, 7	; 14
    13ae:	fe cf       	rjmp	.-4      	; 0x13ac <lcd_int16+0x10e>
  SPDR = byte;                        //send payload
    13b0:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    13b2:	77 9b       	sbis	0x0e, 7	; 14
    13b4:	fe cf       	rjmp	.-4      	; 0x13b2 <lcd_int16+0x114>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    13b6:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    13ba:	88 60       	ori	r24, 0x08	; 8
    13bc:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    13c0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    13c4:	87 7f       	andi	r24, 0xF7	; 247
    13c6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    13ca:	e5 ed       	ldi	r30, 0xD5	; 213
    13cc:	ea 95       	dec	r30
    13ce:	f1 f7       	brne	.-4      	; 0x13cc <lcd_int16+0x12e>
    13d0:	00 00       	nop

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}

        // now output the formatted number 
            do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    13d2:	91 11       	cpse	r25, r1
    13d4:	e5 cf       	rjmp	.-54     	; 0x13a0 <lcd_int16+0x102>
}
    13d6:	61 96       	adiw	r28, 0x11	; 17
    13d8:	0f b6       	in	r0, 0x3f	; 63
    13da:	f8 94       	cli
    13dc:	de bf       	out	0x3e, r29	; 62
    13de:	0f be       	out	0x3f, r0	; 63
    13e0:	cd bf       	out	0x3d, r28	; 61
    13e2:	df 91       	pop	r29
    13e4:	cf 91       	pop	r28
    13e6:	1f 91       	pop	r17
    13e8:	0f 91       	pop	r16
    13ea:	ff 90       	pop	r15
    13ec:	ef 90       	pop	r14
    13ee:	df 90       	pop	r13
    13f0:	cf 90       	pop	r12
    13f2:	bf 90       	pop	r11
    13f4:	af 90       	pop	r10
    13f6:	9f 90       	pop	r9
    13f8:	8f 90       	pop	r8
    13fa:	7f 90       	pop	r7
    13fc:	6f 90       	pop	r6
    13fe:	5f 90       	pop	r5
    1400:	08 95       	ret
                  uint8_t decpos, 
                  uint8_t bSigned,
                  uint8_t bZeroFill)
{
        char    sline[NUM_LCD_CHARS+1];
        uint8_t i=0;
    1402:	d1 2c       	mov	r13, r1
    1404:	ce 01       	movw	r24, r28
    1406:	01 96       	adiw	r24, 0x01	; 1
    1408:	7c 01       	movw	r14, r24
    140a:	94 cf       	rjmp	.-216    	; 0x1334 <lcd_int16+0x96>
                sline[i++] = '-';
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    140c:	11 23       	and	r17, r17
    140e:	09 f4       	brne	.+2      	; 0x1412 <lcd_int16+0x174>
    1410:	be cf       	rjmp	.-132    	; 0x138e <lcd_int16+0xf0>
    1412:	71 2c       	mov	r7, r1
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    1414:	80 e3       	ldi	r24, 0x30	; 48
    1416:	a8 cf       	rjmp	.-176    	; 0x1368 <lcd_int16+0xca>
    1418:	22 27       	eor	r18, r18
    141a:	33 27       	eor	r19, r19
    141c:	28 1b       	sub	r18, r24
    141e:	39 0b       	sbc	r19, r25
    1420:	60 cf       	rjmp	.-320    	; 0x12e2 <lcd_int16+0x44>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    1422:	d3 94       	inc	r13
    1424:	d3 94       	inc	r13
    1426:	f7 01       	movw	r30, r14
    1428:	e9 0f       	add	r30, r25
    142a:	f1 1d       	adc	r31, r1
    142c:	8d e2       	ldi	r24, 0x2D	; 45
    142e:	80 83       	st	Z, r24
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    1430:	11 23       	and	r17, r17
    1432:	59 f0       	breq	.+22     	; 0x144a <lcd_int16+0x1ac>
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
          for (; i<(fieldwidth-bSigned) ; ){ sline[i++] = fillch;}
    1434:	2d 2d       	mov	r18, r13
    1436:	30 e0       	ldi	r19, 0x00	; 0
    1438:	41 2f       	mov	r20, r17
    143a:	50 e0       	ldi	r21, 0x00	; 0
    143c:	24 17       	cp	r18, r20
    143e:	35 07       	cpc	r19, r21
    1440:	24 f4       	brge	.+8      	; 0x144a <lcd_int16+0x1ac>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    1442:	9d 2d       	mov	r25, r13
                bSigned = 0;
    1444:	51 2c       	mov	r5, r1
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    1446:	80 e2       	ldi	r24, 0x20	; 32
    1448:	98 cf       	rjmp	.-208    	; 0x137a <lcd_int16+0xdc>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    144a:	9d 2d       	mov	r25, r13
    144c:	a8 cf       	rjmp	.-176    	; 0x139e <lcd_int16+0x100>

0000144e <__vector_33>:

//****************************************************************************
//This is the TWI ISR. Different actions are taken depending upon the value
//of the TWI status register TWSR.
//****************************************************************************/
ISR(TWI_vect){
    144e:	1f 92       	push	r1
    1450:	0f 92       	push	r0
    1452:	0f b6       	in	r0, 0x3f	; 63
    1454:	0f 92       	push	r0
    1456:	11 24       	eor	r1, r1
    1458:	0b b6       	in	r0, 0x3b	; 59
    145a:	0f 92       	push	r0
    145c:	2f 93       	push	r18
    145e:	3f 93       	push	r19
    1460:	8f 93       	push	r24
    1462:	9f 93       	push	r25
    1464:	af 93       	push	r26
    1466:	bf 93       	push	r27
    1468:	ef 93       	push	r30
    146a:	ff 93       	push	r31
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    146c:	e0 91 71 00 	lds	r30, 0x0071	; 0x800071 <__TEXT_REGION_LENGTH__+0x7e0071>
    1470:	8e 2f       	mov	r24, r30
    1472:	90 e0       	ldi	r25, 0x00	; 0
    1474:	fc 01       	movw	r30, r24
    1476:	38 97       	sbiw	r30, 0x08	; 8
    1478:	e1 35       	cpi	r30, 0x51	; 81
    147a:	f1 05       	cpc	r31, r1
    147c:	b0 f0       	brcs	.+44     	; 0x14aa <__vector_33+0x5c>
      break;      
    case TW_MT_ARB_LOST:                //Arbitration lost 
      TWCR = TWCR_START;                //initiate RESTART 
      break;
    default:                            //Error occured, save TWSR 
      twi_state = TWSR;         
    147e:	80 91 71 00 	lds	r24, 0x0071	; 0x800071 <__TEXT_REGION_LENGTH__+0x7e0071>
    1482:	80 93 a9 01 	sts	0x01A9, r24	; 0x8001a9 <twi_state>
      TWCR = TWCR_RST;                  //Reset TWI, disable interupts 
    1486:	84 e0       	ldi	r24, 0x04	; 4
    1488:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
  }//switch
}//TWI_isr
    148c:	ff 91       	pop	r31
    148e:	ef 91       	pop	r30
    1490:	bf 91       	pop	r27
    1492:	af 91       	pop	r26
    1494:	9f 91       	pop	r25
    1496:	8f 91       	pop	r24
    1498:	3f 91       	pop	r19
    149a:	2f 91       	pop	r18
    149c:	0f 90       	pop	r0
    149e:	0b be       	out	0x3b, r0	; 59
    14a0:	0f 90       	pop	r0
    14a2:	0f be       	out	0x3f, r0	; 63
    14a4:	0f 90       	pop	r0
    14a6:	1f 90       	pop	r1
    14a8:	18 95       	reti
//of the TWI status register TWSR.
//****************************************************************************/
ISR(TWI_vect){
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    14aa:	ea 5b       	subi	r30, 0xBA	; 186
    14ac:	ff 4f       	sbci	r31, 0xFF	; 255
    14ae:	0c 94 0f 0c 	jmp	0x181e	; 0x181e <__tablejump2__>
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
      else                               {TWCR = TWCR_RNACK;} //NACK last byte 
      break; 
    case TW_MR_DATA_NACK: //Data byte was rcvd and NACK xmitted
      twi_buf[twi_buf_ptr] = TWDR;      //save last byte to buffer
    14b2:	80 91 5f 01 	lds	r24, 0x015F	; 0x80015f <twi_buf_ptr.1780>
    14b6:	e0 91 aa 01 	lds	r30, 0x01AA	; 0x8001aa <twi_buf>
    14ba:	f0 91 ab 01 	lds	r31, 0x01AB	; 0x8001ab <twi_buf+0x1>
    14be:	e8 0f       	add	r30, r24
    14c0:	f1 1d       	adc	r31, r1
    14c2:	80 91 73 00 	lds	r24, 0x0073	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
    14c6:	80 83       	st	Z, r24
      TWCR = TWCR_STOP;                 //initiate a STOP
    14c8:	84 e9       	ldi	r24, 0x94	; 148
    14ca:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
      break;      
    14ce:	de cf       	rjmp	.-68     	; 0x148c <__vector_33+0x3e>
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    case TW_START:          //START has been xmitted, fall thorough
    case TW_REP_START:      //Repeated START was xmitted
      TWDR = twi_bus_addr;  //load up the twi bus address
    14d0:	80 91 ac 01 	lds	r24, 0x01AC	; 0x8001ac <twi_bus_addr>
    14d4:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
      twi_buf_ptr = 0;      //initalize buffer pointer 
    14d8:	10 92 5f 01 	sts	0x015F, r1	; 0x80015f <twi_buf_ptr.1780>
      TWCR = TWCR_SEND;     //send SLA+RW
    14dc:	85 e8       	ldi	r24, 0x85	; 133
    14de:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
      break;
    14e2:	d4 cf       	rjmp	.-88     	; 0x148c <__vector_33+0x3e>
    case TW_MT_SLA_ACK:     //SLA+W was xmitted and ACK rcvd, fall through 
    case TW_MT_DATA_ACK:                //Data byte was xmitted and ACK rcvd
      if (twi_buf_ptr < twi_msg_size){  //send data till done
    14e4:	80 91 5f 01 	lds	r24, 0x015F	; 0x80015f <twi_buf_ptr.1780>
    14e8:	90 91 ad 01 	lds	r25, 0x01AD	; 0x8001ad <twi_msg_size>
    14ec:	89 17       	cp	r24, r25
    14ee:	60 f7       	brcc	.-40     	; 0x14c8 <__vector_33+0x7a>
        TWDR = twi_buf[twi_buf_ptr++];  //load next and postincrement index
    14f0:	e0 91 aa 01 	lds	r30, 0x01AA	; 0x8001aa <twi_buf>
    14f4:	f0 91 ab 01 	lds	r31, 0x01AB	; 0x8001ab <twi_buf+0x1>
    14f8:	91 e0       	ldi	r25, 0x01	; 1
    14fa:	98 0f       	add	r25, r24
    14fc:	90 93 5f 01 	sts	0x015F, r25	; 0x80015f <twi_buf_ptr.1780>
    1500:	e8 0f       	add	r30, r24
    1502:	f1 1d       	adc	r31, r1
    1504:	80 81       	ld	r24, Z
    1506:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
        TWCR = TWCR_SEND;               //send next byte 
    150a:	85 e8       	ldi	r24, 0x85	; 133
    150c:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
    1510:	bd cf       	rjmp	.-134    	; 0x148c <__vector_33+0x3e>
    case TW_MR_DATA_NACK: //Data byte was rcvd and NACK xmitted
      twi_buf[twi_buf_ptr] = TWDR;      //save last byte to buffer
      TWCR = TWCR_STOP;                 //initiate a STOP
      break;      
    case TW_MT_ARB_LOST:                //Arbitration lost 
      TWCR = TWCR_START;                //initiate RESTART 
    1512:	85 ea       	ldi	r24, 0xA5	; 165
    1514:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
      break;
    1518:	b9 cf       	rjmp	.-142    	; 0x148c <__vector_33+0x3e>
    151a:	20 91 5f 01 	lds	r18, 0x015F	; 0x80015f <twi_buf_ptr.1780>
      else{TWCR = TWCR_STOP;}           //last byte sent, send STOP 
      break;
    case TW_MR_DATA_ACK:                //Data byte has been rcvd, ACK xmitted, fall through
      twi_buf[twi_buf_ptr++] = TWDR;    //fill buffer with rcvd data
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
    151e:	80 91 ad 01 	lds	r24, 0x01AD	; 0x8001ad <twi_msg_size>
    1522:	30 e0       	ldi	r19, 0x00	; 0
    1524:	90 e0       	ldi	r25, 0x00	; 0
    1526:	01 97       	sbiw	r24, 0x01	; 1
    1528:	28 17       	cp	r18, r24
    152a:	39 07       	cpc	r19, r25
    152c:	dc f4       	brge	.+54     	; 0x1564 <__vector_33+0x116>
    152e:	85 ec       	ldi	r24, 0xC5	; 197
    1530:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
    1534:	ab cf       	rjmp	.-170    	; 0x148c <__vector_33+0x3e>
        TWCR = TWCR_SEND;               //send next byte 
      }
      else{TWCR = TWCR_STOP;}           //last byte sent, send STOP 
      break;
    case TW_MR_DATA_ACK:                //Data byte has been rcvd, ACK xmitted, fall through
      twi_buf[twi_buf_ptr++] = TWDR;    //fill buffer with rcvd data
    1536:	e0 91 aa 01 	lds	r30, 0x01AA	; 0x8001aa <twi_buf>
    153a:	f0 91 ab 01 	lds	r31, 0x01AB	; 0x8001ab <twi_buf+0x1>
    153e:	80 91 5f 01 	lds	r24, 0x015F	; 0x80015f <twi_buf_ptr.1780>
    1542:	21 e0       	ldi	r18, 0x01	; 1
    1544:	28 0f       	add	r18, r24
    1546:	20 93 5f 01 	sts	0x015F, r18	; 0x80015f <twi_buf_ptr.1780>
    154a:	e8 0f       	add	r30, r24
    154c:	f1 1d       	adc	r31, r1
    154e:	80 91 73 00 	lds	r24, 0x0073	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
    1552:	80 83       	st	Z, r24
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
    1554:	80 91 ad 01 	lds	r24, 0x01AD	; 0x8001ad <twi_msg_size>
    1558:	30 e0       	ldi	r19, 0x00	; 0
    155a:	90 e0       	ldi	r25, 0x00	; 0
    155c:	01 97       	sbiw	r24, 0x01	; 1
    155e:	28 17       	cp	r18, r24
    1560:	39 07       	cpc	r19, r25
    1562:	2c f3       	brlt	.-54     	; 0x152e <__vector_33+0xe0>
      else                               {TWCR = TWCR_RNACK;} //NACK last byte 
    1564:	85 e8       	ldi	r24, 0x85	; 133
    1566:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
    156a:	90 cf       	rjmp	.-224    	; 0x148c <__vector_33+0x3e>

0000156c <twi_busy>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    156c:	80 91 74 00 	lds	r24, 0x0074	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
}
    1570:	81 70       	andi	r24, 0x01	; 1
    1572:	08 95       	ret

00001574 <twi_start_wr>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    1574:	90 91 74 00 	lds	r25, 0x0074	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
//Initiates a write transfer. Loads global variables. Sends START. ISR handles
//the rest.
//****************************************************************************
void twi_start_wr(uint8_t twi_addr, uint8_t *twi_data, uint8_t byte_cnt){

  while(twi_busy());                    //wait till TWI rdy for next xfer
    1578:	90 fd       	sbrc	r25, 0
    157a:	fc cf       	rjmp	.-8      	; 0x1574 <twi_start_wr>
  twi_bus_addr = (twi_addr & ~TW_READ); //set twi bus address, mark as write 
    157c:	8e 7f       	andi	r24, 0xFE	; 254
    157e:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <twi_bus_addr>
  twi_buf = twi_data;                   //load pointer to write buffer
    1582:	70 93 ab 01 	sts	0x01AB, r23	; 0x8001ab <twi_buf+0x1>
    1586:	60 93 aa 01 	sts	0x01AA, r22	; 0x8001aa <twi_buf>
  twi_msg_size = byte_cnt;              //load size of xfer 
    158a:	40 93 ad 01 	sts	0x01AD, r20	; 0x8001ad <twi_msg_size>
  TWCR = TWCR_START;                    //initiate START
    158e:	85 ea       	ldi	r24, 0xA5	; 165
    1590:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
    1594:	08 95       	ret

00001596 <twi_start_rd>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    1596:	90 91 74 00 	lds	r25, 0x0074	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
//Initiates a read transfer. Loads global variables. Sends START. ISR handles
//the rest.
//****************************************************************************
void twi_start_rd(uint8_t twi_addr, uint8_t *twi_data, uint8_t byte_cnt){

  while(twi_busy());                   //wait till TWI rdy for next xfer
    159a:	90 fd       	sbrc	r25, 0
    159c:	fc cf       	rjmp	.-8      	; 0x1596 <twi_start_rd>
  twi_bus_addr = (twi_addr | TW_READ); //set twi bus address, mark as read  
    159e:	81 60       	ori	r24, 0x01	; 1
    15a0:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <twi_bus_addr>
  twi_buf = twi_data;                  //load pointer to write buffer
    15a4:	70 93 ab 01 	sts	0x01AB, r23	; 0x8001ab <twi_buf+0x1>
    15a8:	60 93 aa 01 	sts	0x01AA, r22	; 0x8001aa <twi_buf>
  twi_msg_size = byte_cnt;             //load size of xfer 
    15ac:	40 93 ad 01 	sts	0x01AD, r20	; 0x8001ad <twi_msg_size>
  TWCR = TWCR_START;                   //initiate START
    15b0:	85 ea       	ldi	r24, 0xA5	; 165
    15b2:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
    15b6:	08 95       	ret

000015b8 <init_twi>:
//10K pullups are present on the board
//for alarm clock an additional 4.7K resistor is also there for pullup
//******************************************************************************

void init_twi(){
  TWDR = 0xFF;     //release SDA, default contents
    15b8:	8f ef       	ldi	r24, 0xFF	; 255
    15ba:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
  TWSR = 0x00;     //prescaler value = 1
    15be:	10 92 71 00 	sts	0x0071, r1	; 0x800071 <__TEXT_REGION_LENGTH__+0x7e0071>
  TWBR = TWI_TWBR; //defined in twi_master.h 
    15c2:	8c e0       	ldi	r24, 0x0C	; 12
    15c4:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x7e0070>
    15c8:	08 95       	ret

000015ca <lm73_temp_convert>:
   else{ //deg C

   }
//Yeah, this is for you to do! ;^)
return 0b11111111;
}//lm73_temp_convert
    15ca:	8f ef       	ldi	r24, 0xFF	; 255
    15cc:	08 95       	ret

000015ce <uart_putc>:
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    15ce:	5d 9b       	sbis	0x0b, 5	; 11
    15d0:	fe cf       	rjmp	.-4      	; 0x15ce <uart_putc>
    UDR0 = data;    // Send data byte
    15d2:	8c b9       	out	0x0c, r24	; 12
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    15d4:	5d 9b       	sbis	0x0b, 5	; 11
    15d6:	fe cf       	rjmp	.-4      	; 0x15d4 <uart_putc+0x6>
}
    15d8:	08 95       	ret

000015da <uart_puts>:

//******************************************************************
//                        uart_puts
// Takes a string and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts(char *str) {
    15da:	fc 01       	movw	r30, r24
    int i = 0;
    while(str[i] != '\0') { // Loop through string, sending each character
    15dc:	90 81       	ld	r25, Z
    15de:	99 23       	and	r25, r25
    15e0:	49 f0       	breq	.+18     	; 0x15f4 <uart_puts+0x1a>
    15e2:	31 96       	adiw	r30, 0x01	; 1
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    15e4:	5d 9b       	sbis	0x0b, 5	; 11
    15e6:	fe cf       	rjmp	.-4      	; 0x15e4 <uart_puts+0xa>
    UDR0 = data;    // Send data byte
    15e8:	9c b9       	out	0x0c, r25	; 12
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    15ea:	5d 9b       	sbis	0x0b, 5	; 11
    15ec:	fe cf       	rjmp	.-4      	; 0x15ea <uart_puts+0x10>
//                        uart_puts
// Takes a string and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts(char *str) {
    int i = 0;
    while(str[i] != '\0') { // Loop through string, sending each character
    15ee:	91 91       	ld	r25, Z+
    15f0:	91 11       	cpse	r25, r1
    15f2:	f8 cf       	rjmp	.-16     	; 0x15e4 <uart_puts+0xa>
    15f4:	08 95       	ret

000015f6 <uart_puts_p>:
//******************************************************************
//                        uart_puts_p
// Takes a string in flash memory and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts_p(const char *str) {
    while(pgm_read_byte(str) != 0x00) { // Loop through string, sending each character
    15f6:	9c 01       	movw	r18, r24
    15f8:	fc 01       	movw	r30, r24
    15fa:	44 91       	lpm	r20, Z
    15fc:	44 23       	and	r20, r20
    15fe:	69 f0       	breq	.+26     	; 0x161a <uart_puts_p+0x24>
        uart_putc(pgm_read_byte(str++));
    1600:	01 96       	adiw	r24, 0x01	; 1
    1602:	f9 01       	movw	r30, r18
    1604:	24 91       	lpm	r18, Z
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    1606:	5d 9b       	sbis	0x0b, 5	; 11
    1608:	fe cf       	rjmp	.-4      	; 0x1606 <uart_puts_p+0x10>
    UDR0 = data;    // Send data byte
    160a:	2c b9       	out	0x0c, r18	; 12
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    160c:	5d 9b       	sbis	0x0b, 5	; 11
    160e:	fe cf       	rjmp	.-4      	; 0x160c <uart_puts_p+0x16>
//******************************************************************
//                        uart_puts_p
// Takes a string in flash memory and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts_p(const char *str) {
    while(pgm_read_byte(str) != 0x00) { // Loop through string, sending each character
    1610:	9c 01       	movw	r18, r24
    1612:	fc 01       	movw	r30, r24
    1614:	44 91       	lpm	r20, Z
    1616:	41 11       	cpse	r20, r1
    1618:	f3 cf       	rjmp	.-26     	; 0x1600 <uart_puts_p+0xa>
        uart_putc(pgm_read_byte(str++));
    }
}
    161a:	08 95       	ret

0000161c <uart_init>:
//Jumpers J14 and J16 (mega128.1) or Jumpers J7 and J9 (mega128.2)
//must be in place for the MAX232 chip to get data.

void uart_init(){
//rx and tx enable, receive interrupt enabled, 8 bit characters
  UCSR0B |= (1<<RXEN0) | (1<<TXEN0) | (1<<RXCIE0);
    161c:	8a b1       	in	r24, 0x0a	; 10
    161e:	88 69       	ori	r24, 0x98	; 152
    1620:	8a b9       	out	0x0a, r24	; 10
//  UCSR0B |= (1<<RXEN0) | (1<<TXEN0);  //INTERRUPS DISABLED!!!

//  UCSR0B |= (1<<RXEN0) | (1<<TXEN0) ;
//async operation, no parity,  one stop bit, 8-bit characters
UCSR0C |= (1<<UCSZ01) | (1<<UCSZ00);
    1622:	e5 e9       	ldi	r30, 0x95	; 149
    1624:	f0 e0       	ldi	r31, 0x00	; 0
    1626:	80 81       	ld	r24, Z
    1628:	86 60       	ori	r24, 0x06	; 6
    162a:	80 83       	st	Z, r24
UBRR0H = (BAUDVALUE >>8 ); //load upper byte of the baud rate into UBRR 
    162c:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
UBRR0L =  BAUDVALUE;       //load lower byte of the baud rate into UBRR 
    1630:	87 e6       	ldi	r24, 0x67	; 103
    1632:	89 b9       	out	0x09, r24	; 9
    1634:	08 95       	ret

00001636 <uart_getc>:
//Modified to not block indefinately in the case of a lost byte
//
char uart_getc(void) {
  uint16_t timer = 0;

  while (!(UCSR0A & (1<<RXC0))) {
    1636:	80 e8       	ldi	r24, 0x80	; 128
    1638:	9e e3       	ldi	r25, 0x3E	; 62
    163a:	02 c0       	rjmp	.+4      	; 0x1640 <uart_getc+0xa>
    163c:	01 97       	sbiw	r24, 0x01	; 1
  timer++;
  if(timer >= 16000){ return(0);}
    163e:	21 f0       	breq	.+8      	; 0x1648 <uart_getc+0x12>
//Modified to not block indefinately in the case of a lost byte
//
char uart_getc(void) {
  uint16_t timer = 0;

  while (!(UCSR0A & (1<<RXC0))) {
    1640:	5f 9b       	sbis	0x0b, 7	; 11
    1642:	fc cf       	rjmp	.-8      	; 0x163c <uart_getc+0x6>
  //what should we return if nothing comes in?
  //return the data into a global variable
  //give uart_getc the address of the variable
  //return a -1 if no data comes back.
  } // Wait for byte to arrive
  return(UDR0); //return the received data
    1644:	8c b1       	in	r24, 0x0c	; 12
    1646:	08 95       	ret
char uart_getc(void) {
  uint16_t timer = 0;

  while (!(UCSR0A & (1<<RXC0))) {
  timer++;
  if(timer >= 16000){ return(0);}
    1648:	80 e0       	ldi	r24, 0x00	; 0
  //return the data into a global variable
  //give uart_getc the address of the variable
  //return a -1 if no data comes back.
  } // Wait for byte to arrive
  return(UDR0); //return the received data
}
    164a:	08 95       	ret

0000164c <main>:
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
    164c:	87 b3       	in	r24, 0x17	; 23
    164e:	87 60       	ori	r24, 0x07	; 7
    1650:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
    1652:	8d b1       	in	r24, 0x0d	; 13
    1654:	8c 65       	ori	r24, 0x5C	; 92
    1656:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
    1658:	70 9a       	sbi	0x0e, 0	; 14
Description: Timer counter 0 is initialized in normal mode with no prescale
	and will be used as a seconds counter for the clock
Parameters: NA
**********************************************************************/
void tcnt0_init(){
   ASSR |= (1<<AS0);
    165a:	80 b7       	in	r24, 0x30	; 48
    165c:	88 60       	ori	r24, 0x08	; 8
    165e:	80 bf       	out	0x30, r24	; 48
   TIMSK |= (1<<OCIE0) | (1<<TOIE0);			//enable interrupts
    1660:	87 b7       	in	r24, 0x37	; 55
    1662:	83 60       	ori	r24, 0x03	; 3
    1664:	87 bf       	out	0x37, r24	; 55
   TCCR0 |= (1<<CS00);			//normal mode, no prescale
    1666:	83 b7       	in	r24, 0x33	; 51
    1668:	81 60       	ori	r24, 0x01	; 1
    166a:	83 bf       	out	0x33, r24	; 51
   OCR0 = 0xFF;
    166c:	8f ef       	ldi	r24, 0xFF	; 255
    166e:	81 bf       	out	0x31, r24	; 49
Description: Timer counter 1 is initialized in CTC mode, 64 bit prescaler
	so that it can be used to generate an alarm frequency
Parameters: NA
**********************************************************************/
void tcnt1_init(){
   TCCR1B |= (1<<CS11) | (1<<CS10) | (1<<WGM12);		//CTC mode, 64bit prescaler
    1670:	8e b5       	in	r24, 0x2e	; 46
    1672:	8b 60       	ori	r24, 0x0B	; 11
    1674:	8e bd       	out	0x2e, r24	; 46
   TCCR1C = 0x00;
    1676:	10 92 7a 00 	sts	0x007A, r1	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
   TIMSK  |= (1<<OCIE1A) | (1<<TOIE1);	//enable flag for interrupt 
    167a:	87 b7       	in	r24, 0x37	; 55
    167c:	84 61       	ori	r24, 0x14	; 20
    167e:	87 bf       	out	0x37, r24	; 55
   OCR1A = 0x0040;		//compare match at 64
    1680:	80 e4       	ldi	r24, 0x40	; 64
    1682:	90 e0       	ldi	r25, 0x00	; 0
    1684:	9b bd       	out	0x2b, r25	; 43
    1686:	8a bd       	out	0x2a, r24	; 42
	normal mode with a 64 bit prescaler. OCRA2 is adjusted to change
	the pwn produced.
Parameters: NA
**********************************************************************/
void tcnt2_init(){
   TCCR2 |= (1<<WGM21) | (1<<WGM20)| (1<<CS20) | (1<<COM21);			
    1688:	85 b5       	in	r24, 0x25	; 37
    168a:	89 66       	ori	r24, 0x69	; 105
    168c:	85 bd       	out	0x25, r24	; 37
Description: This timer is used as a volume control for the audio amp.
	I adjust the value of OCR3A to change the pwm.
Parameters: NA
**********************************************************************/
void tcnt3_init(){
   TCCR3A |= (1<<COM3A1) | (1<<WGM31);	 //Clear on OCR3A match
    168e:	80 91 8b 00 	lds	r24, 0x008B	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
    1692:	82 68       	ori	r24, 0x82	; 130
    1694:	80 93 8b 00 	sts	0x008B, r24	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
   TCCR3B |= (1<<CS30) | (1<<WGM32) | (1<<WGM33);		//Fast PWM mode, no prescaler
    1698:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
    169c:	89 61       	ori	r24, 0x19	; 25
    169e:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
   TCCR3C = 0x00;
    16a2:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x7e008c>
   ICR3 = 0x9F;				//Setting the TOP value
    16a6:	8f e9       	ldi	r24, 0x9F	; 159
    16a8:	90 e0       	ldi	r25, 0x00	; 0
    16aa:	90 93 81 00 	sts	0x0081, r25	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
    16ae:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
   TCNT3 = 0x0000; 			//Initialize TNCT1 to 0
    16b2:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    16b6:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
   OCR3A = 0x9F;			//Volume Control 0x9F=Max 0x00=Min
    16ba:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
    16be:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
Description: Basic adc initialization used for single shot adc readings
Parameters: NA
**********************************************************************/
void adc_init(){
//Initalize ADC and its ports
   DDRF  &= ~(_BV(DDF7)); //make port F bit 7 is ADC input  
    16c2:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
    16c6:	8f 77       	andi	r24, 0x7F	; 127
    16c8:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
   PORTF &= ~(_BV(PF7));  //port F bit 7 pullups must be off
    16cc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    16d0:	8f 77       	andi	r24, 0x7F	; 127
    16d2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
   ADMUX |= (1<<REFS0) | (1<<MUX2)| (1<<MUX1)| (1<<MUX0); //single-ended, input PORTF bit 7, right adjusted, 10 bits
    16d6:	87 b1       	in	r24, 0x07	; 7
    16d8:	87 64       	ori	r24, 0x47	; 71
    16da:	87 b9       	out	0x07, r24	; 7

   ADCSRA |= (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);//ADC enabled, don't start yet, single shot mode 
    16dc:	86 b1       	in	r24, 0x06	; 6
    16de:	87 68       	ori	r24, 0x87	; 135
    16e0:	86 b9       	out	0x06, r24	; 6
   tcnt0_init();
   tcnt1_init();
   tcnt2_init();
   tcnt3_init();
   adc_init();
   port_init();
    16e2:	0e 94 a5 04 	call	0x94a	; 0x94a <port_init>
   init_twi();
    16e6:	0e 94 dc 0a 	call	0x15b8	; 0x15b8 <init_twi>
Description: 
Parameters: NA
**********************************************************************/
void local_temp_init(){

lm73_wr_buf[0] = 0x00; //load lm73_wr_buf[0] with temperature pointer address
    16ea:	10 92 ae 01 	sts	0x01AE, r1	; 0x8001ae <lm73_wr_buf>
twi_start_wr(LM73_ADDRESS, lm73_rd_buf, 1); //start the TWI write process
    16ee:	41 e0       	ldi	r20, 0x01	; 1
    16f0:	60 eb       	ldi	r22, 0xB0	; 176
    16f2:	71 e0       	ldi	r23, 0x01	; 1
    16f4:	80 e9       	ldi	r24, 0x90	; 144
    16f6:	0e 94 ba 0a 	call	0x1574	; 0x1574 <twi_start_wr>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    16fa:	2f ef       	ldi	r18, 0xFF	; 255
    16fc:	81 ee       	ldi	r24, 0xE1	; 225
    16fe:	94 e0       	ldi	r25, 0x04	; 4
    1700:	21 50       	subi	r18, 0x01	; 1
    1702:	80 40       	sbci	r24, 0x00	; 0
    1704:	90 40       	sbci	r25, 0x00	; 0
    1706:	e1 f7       	brne	.-8      	; 0x1700 <main+0xb4>
    1708:	00 c0       	rjmp	.+0      	; 0x170a <main+0xbe>
    170a:	00 00       	nop
   adc_init();
   port_init();
   init_twi();
   local_temp_init();   

   uart_init();
    170c:	0e 94 0e 0b 	call	0x161c	; 0x161c <uart_init>
   lcd_init();
    1710:	0e 94 b7 07 	call	0xf6e	; 0xf6e <lcd_init>
   sei();				//Enable interrupts
    1714:	78 94       	sei
	 }
	 PORTA = segment_data[j];	//Writes the segment data to PORTA aka the segments
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
				//the digit to be displayed is in pin 4, 5, and 6 
         _delay_us(150);		//delay so that the display does not flicker
         PORTA = 0xFF;
    1716:	cf ef       	ldi	r28, 0xFF	; 255
   lcd_init();
   sei();				//Enable interrupts
   while(1){

//***************  start rcv portion ***************
    if(rcv_rdy==1){
    1718:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <rcv_rdy>
    171c:	81 30       	cpi	r24, 0x01	; 1
    171e:	f1 f1       	breq	.+124    	; 0x179c <main+0x150>
  	lcd_array[8] = lcd_str_array[0];
  	lcd_array[9] = lcd_str_array[1];
	rcv_rdy=0;
    }//if 
//**************  end rcv portion ***************
   uart_puts("A");
    1720:	82 e3       	ldi	r24, 0x32	; 50
    1722:	91 e0       	ldi	r25, 0x01	; 1
    1724:	0e 94 ed 0a 	call	0x15da	; 0x15da <uart_puts>
    1728:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <send_seq>
    172c:	4a e0       	ldi	r20, 0x0A	; 10
    172e:	63 e6       	ldi	r22, 0x63	; 99
    1730:	71 e0       	ldi	r23, 0x01	; 1
    1732:	90 e0       	ldi	r25, 0x00	; 0
    1734:	0e 94 4e 0c 	call	0x189c	; 0x189c <__itoa_ncheck>
   itoa(send_seq,lcd_string,10);
   uart_puts(lcd_string);
    1738:	83 e6       	ldi	r24, 0x63	; 99
    173a:	91 e0       	ldi	r25, 0x01	; 1
    173c:	0e 94 ed 0a 	call	0x15da	; 0x15da <uart_puts>
   uart_putc('\0'); 
    1740:	80 e0       	ldi	r24, 0x00	; 0
    1742:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <uart_putc>
Description: This function disables the snooze variable once the alarm
	seconds equals the normal seconds. 
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
    1746:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <snooze>
    174a:	81 11       	cpse	r24, r1
    174c:	32 c0       	rjmp	.+100    	; 0x17b2 <main+0x166>
   itoa(send_seq,lcd_string,10);
   uart_puts(lcd_string);
   uart_putc('\0'); 
//      refresh_lcd(lcd_array);
      snoozin();
      fetch_adc();
    174e:	0e 94 ef 04 	call	0x9de	; 0x9de <fetch_adc>
      clock_time();
    1752:	0e 94 dd 03 	call	0x7ba	; 0x7ba <clock_time>
      change_alarm_state();
    1756:	0e 94 bb 04 	call	0x976	; 0x976 <change_alarm_state>
    175a:	e4 e3       	ldi	r30, 0x34	; 52
    175c:	f1 e0       	ldi	r31, 0x01	; 1
    175e:	80 e0       	ldi	r24, 0x00	; 0
      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
         if(alarm){
    1760:	90 91 41 01 	lds	r25, 0x0141	; 0x800141 <alarm>
    1764:	99 23       	and	r25, r25
    1766:	29 f0       	breq	.+10     	; 0x1772 <main+0x126>
	    segment_data[2] &= 0b011;
    1768:	90 91 36 01 	lds	r25, 0x0136	; 0x800136 <__data_end+0x2>
    176c:	93 70       	andi	r25, 0x03	; 3
    176e:	90 93 36 01 	sts	0x0136, r25	; 0x800136 <__data_end+0x2>
	 }
	 PORTA = segment_data[j];	//Writes the segment data to PORTA aka the segments
    1772:	91 91       	ld	r25, Z+
    1774:	9b bb       	out	0x1b, r25	; 27
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
    1776:	98 2f       	mov	r25, r24
    1778:	92 95       	swap	r25
    177a:	90 7f       	andi	r25, 0xF0	; 240
    177c:	98 bb       	out	0x18, r25	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    177e:	a7 e5       	ldi	r26, 0x57	; 87
    1780:	b2 e0       	ldi	r27, 0x02	; 2
    1782:	11 97       	sbiw	r26, 0x01	; 1
    1784:	f1 f7       	brne	.-4      	; 0x1782 <main+0x136>
    1786:	00 c0       	rjmp	.+0      	; 0x1788 <main+0x13c>
    1788:	00 00       	nop
				//the digit to be displayed is in pin 4, 5, and 6 
         _delay_us(150);		//delay so that the display does not flicker
         PORTA = 0xFF;
    178a:	cb bb       	out	0x1b, r28	; 27
    178c:	8f 5f       	subi	r24, 0xFF	; 255
//      refresh_lcd(lcd_array);
      snoozin();
      fetch_adc();
      clock_time();
      change_alarm_state();
      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
    178e:	85 30       	cpi	r24, 0x05	; 5
    1790:	39 f7       	brne	.-50     	; 0x1760 <main+0x114>
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
				//the digit to be displayed is in pin 4, 5, and 6 
         _delay_us(150);		//delay so that the display does not flicker
         PORTA = 0xFF;
      }
	PORTB = 0x00;;
    1792:	18 ba       	out	0x18, r1	; 24
   lcd_init();
   sei();				//Enable interrupts
   while(1){

//***************  start rcv portion ***************
    if(rcv_rdy==1){
    1794:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <rcv_rdy>
    1798:	81 30       	cpi	r24, 0x01	; 1
    179a:	11 f6       	brne	.-124    	; 0x1720 <main+0xd4>
	//line1_col1();
    	//string2lcd(lcd_str_array);    
  	lcd_array[8] = lcd_str_array[0];
    179c:	80 91 67 01 	lds	r24, 0x0167	; 0x800167 <lcd_str_array>
    17a0:	80 93 1e 01 	sts	0x011E, r24	; 0x80011e <lcd_array+0x8>
  	lcd_array[9] = lcd_str_array[1];
    17a4:	80 91 68 01 	lds	r24, 0x0168	; 0x800168 <lcd_str_array+0x1>
    17a8:	80 93 1f 01 	sts	0x011F, r24	; 0x80011f <lcd_array+0x9>
	rcv_rdy=0;
    17ac:	10 92 60 01 	sts	0x0160, r1	; 0x800160 <rcv_rdy>
    17b0:	b7 cf       	rjmp	.-146    	; 0x1720 <main+0xd4>
    17b2:	0e 94 b8 00 	call	0x170	; 0x170 <snoozin.part.1>
    17b6:	cb cf       	rjmp	.-106    	; 0x174e <main+0x102>

000017b8 <__divmodhi4>:
    17b8:	97 fb       	bst	r25, 7
    17ba:	07 2e       	mov	r0, r23
    17bc:	16 f4       	brtc	.+4      	; 0x17c2 <__divmodhi4+0xa>
    17be:	00 94       	com	r0
    17c0:	07 d0       	rcall	.+14     	; 0x17d0 <__divmodhi4_neg1>
    17c2:	77 fd       	sbrc	r23, 7
    17c4:	09 d0       	rcall	.+18     	; 0x17d8 <__divmodhi4_neg2>
    17c6:	0e 94 18 0c 	call	0x1830	; 0x1830 <__udivmodhi4>
    17ca:	07 fc       	sbrc	r0, 7
    17cc:	05 d0       	rcall	.+10     	; 0x17d8 <__divmodhi4_neg2>
    17ce:	3e f4       	brtc	.+14     	; 0x17de <__divmodhi4_exit>

000017d0 <__divmodhi4_neg1>:
    17d0:	90 95       	com	r25
    17d2:	81 95       	neg	r24
    17d4:	9f 4f       	sbci	r25, 0xFF	; 255
    17d6:	08 95       	ret

000017d8 <__divmodhi4_neg2>:
    17d8:	70 95       	com	r23
    17da:	61 95       	neg	r22
    17dc:	7f 4f       	sbci	r23, 0xFF	; 255

000017de <__divmodhi4_exit>:
    17de:	08 95       	ret

000017e0 <__divmodsi4>:
    17e0:	05 2e       	mov	r0, r21
    17e2:	97 fb       	bst	r25, 7
    17e4:	1e f4       	brtc	.+6      	; 0x17ec <__divmodsi4+0xc>
    17e6:	00 94       	com	r0
    17e8:	0e 94 07 0c 	call	0x180e	; 0x180e <__negsi2>
    17ec:	57 fd       	sbrc	r21, 7
    17ee:	07 d0       	rcall	.+14     	; 0x17fe <__divmodsi4_neg2>
    17f0:	0e 94 2c 0c 	call	0x1858	; 0x1858 <__udivmodsi4>
    17f4:	07 fc       	sbrc	r0, 7
    17f6:	03 d0       	rcall	.+6      	; 0x17fe <__divmodsi4_neg2>
    17f8:	4e f4       	brtc	.+18     	; 0x180c <__divmodsi4_exit>
    17fa:	0c 94 07 0c 	jmp	0x180e	; 0x180e <__negsi2>

000017fe <__divmodsi4_neg2>:
    17fe:	50 95       	com	r21
    1800:	40 95       	com	r20
    1802:	30 95       	com	r19
    1804:	21 95       	neg	r18
    1806:	3f 4f       	sbci	r19, 0xFF	; 255
    1808:	4f 4f       	sbci	r20, 0xFF	; 255
    180a:	5f 4f       	sbci	r21, 0xFF	; 255

0000180c <__divmodsi4_exit>:
    180c:	08 95       	ret

0000180e <__negsi2>:
    180e:	90 95       	com	r25
    1810:	80 95       	com	r24
    1812:	70 95       	com	r23
    1814:	61 95       	neg	r22
    1816:	7f 4f       	sbci	r23, 0xFF	; 255
    1818:	8f 4f       	sbci	r24, 0xFF	; 255
    181a:	9f 4f       	sbci	r25, 0xFF	; 255
    181c:	08 95       	ret

0000181e <__tablejump2__>:
    181e:	ee 0f       	add	r30, r30
    1820:	ff 1f       	adc	r31, r31
    1822:	00 24       	eor	r0, r0
    1824:	00 1c       	adc	r0, r0
    1826:	0b be       	out	0x3b, r0	; 59
    1828:	07 90       	elpm	r0, Z+
    182a:	f6 91       	elpm	r31, Z
    182c:	e0 2d       	mov	r30, r0
    182e:	09 94       	ijmp

00001830 <__udivmodhi4>:
    1830:	aa 1b       	sub	r26, r26
    1832:	bb 1b       	sub	r27, r27
    1834:	51 e1       	ldi	r21, 0x11	; 17
    1836:	07 c0       	rjmp	.+14     	; 0x1846 <__udivmodhi4_ep>

00001838 <__udivmodhi4_loop>:
    1838:	aa 1f       	adc	r26, r26
    183a:	bb 1f       	adc	r27, r27
    183c:	a6 17       	cp	r26, r22
    183e:	b7 07       	cpc	r27, r23
    1840:	10 f0       	brcs	.+4      	; 0x1846 <__udivmodhi4_ep>
    1842:	a6 1b       	sub	r26, r22
    1844:	b7 0b       	sbc	r27, r23

00001846 <__udivmodhi4_ep>:
    1846:	88 1f       	adc	r24, r24
    1848:	99 1f       	adc	r25, r25
    184a:	5a 95       	dec	r21
    184c:	a9 f7       	brne	.-22     	; 0x1838 <__udivmodhi4_loop>
    184e:	80 95       	com	r24
    1850:	90 95       	com	r25
    1852:	bc 01       	movw	r22, r24
    1854:	cd 01       	movw	r24, r26
    1856:	08 95       	ret

00001858 <__udivmodsi4>:
    1858:	a1 e2       	ldi	r26, 0x21	; 33
    185a:	1a 2e       	mov	r1, r26
    185c:	aa 1b       	sub	r26, r26
    185e:	bb 1b       	sub	r27, r27
    1860:	fd 01       	movw	r30, r26
    1862:	0d c0       	rjmp	.+26     	; 0x187e <__udivmodsi4_ep>

00001864 <__udivmodsi4_loop>:
    1864:	aa 1f       	adc	r26, r26
    1866:	bb 1f       	adc	r27, r27
    1868:	ee 1f       	adc	r30, r30
    186a:	ff 1f       	adc	r31, r31
    186c:	a2 17       	cp	r26, r18
    186e:	b3 07       	cpc	r27, r19
    1870:	e4 07       	cpc	r30, r20
    1872:	f5 07       	cpc	r31, r21
    1874:	20 f0       	brcs	.+8      	; 0x187e <__udivmodsi4_ep>
    1876:	a2 1b       	sub	r26, r18
    1878:	b3 0b       	sbc	r27, r19
    187a:	e4 0b       	sbc	r30, r20
    187c:	f5 0b       	sbc	r31, r21

0000187e <__udivmodsi4_ep>:
    187e:	66 1f       	adc	r22, r22
    1880:	77 1f       	adc	r23, r23
    1882:	88 1f       	adc	r24, r24
    1884:	99 1f       	adc	r25, r25
    1886:	1a 94       	dec	r1
    1888:	69 f7       	brne	.-38     	; 0x1864 <__udivmodsi4_loop>
    188a:	60 95       	com	r22
    188c:	70 95       	com	r23
    188e:	80 95       	com	r24
    1890:	90 95       	com	r25
    1892:	9b 01       	movw	r18, r22
    1894:	ac 01       	movw	r20, r24
    1896:	bd 01       	movw	r22, r26
    1898:	cf 01       	movw	r24, r30
    189a:	08 95       	ret

0000189c <__itoa_ncheck>:
    189c:	bb 27       	eor	r27, r27
    189e:	4a 30       	cpi	r20, 0x0A	; 10
    18a0:	31 f4       	brne	.+12     	; 0x18ae <__itoa_ncheck+0x12>
    18a2:	99 23       	and	r25, r25
    18a4:	22 f4       	brpl	.+8      	; 0x18ae <__itoa_ncheck+0x12>
    18a6:	bd e2       	ldi	r27, 0x2D	; 45
    18a8:	90 95       	com	r25
    18aa:	81 95       	neg	r24
    18ac:	9f 4f       	sbci	r25, 0xFF	; 255
    18ae:	0c 94 5a 0c 	jmp	0x18b4	; 0x18b4 <__utoa_common>

000018b2 <__utoa_ncheck>:
    18b2:	bb 27       	eor	r27, r27

000018b4 <__utoa_common>:
    18b4:	fb 01       	movw	r30, r22
    18b6:	55 27       	eor	r21, r21
    18b8:	aa 27       	eor	r26, r26
    18ba:	88 0f       	add	r24, r24
    18bc:	99 1f       	adc	r25, r25
    18be:	aa 1f       	adc	r26, r26
    18c0:	a4 17       	cp	r26, r20
    18c2:	10 f0       	brcs	.+4      	; 0x18c8 <__utoa_common+0x14>
    18c4:	a4 1b       	sub	r26, r20
    18c6:	83 95       	inc	r24
    18c8:	50 51       	subi	r21, 0x10	; 16
    18ca:	b9 f7       	brne	.-18     	; 0x18ba <__utoa_common+0x6>
    18cc:	a0 5d       	subi	r26, 0xD0	; 208
    18ce:	aa 33       	cpi	r26, 0x3A	; 58
    18d0:	08 f0       	brcs	.+2      	; 0x18d4 <__utoa_common+0x20>
    18d2:	a9 5d       	subi	r26, 0xD9	; 217
    18d4:	a1 93       	st	Z+, r26
    18d6:	00 97       	sbiw	r24, 0x00	; 0
    18d8:	79 f7       	brne	.-34     	; 0x18b8 <__utoa_common+0x4>
    18da:	b1 11       	cpse	r27, r1
    18dc:	b1 93       	st	Z+, r27
    18de:	11 92       	st	Z+, r1
    18e0:	cb 01       	movw	r24, r22
    18e2:	0c 94 73 0c 	jmp	0x18e6	; 0x18e6 <strrev>

000018e6 <strrev>:
    18e6:	dc 01       	movw	r26, r24
    18e8:	fc 01       	movw	r30, r24
    18ea:	67 2f       	mov	r22, r23
    18ec:	71 91       	ld	r23, Z+
    18ee:	77 23       	and	r23, r23
    18f0:	e1 f7       	brne	.-8      	; 0x18ea <strrev+0x4>
    18f2:	32 97       	sbiw	r30, 0x02	; 2
    18f4:	04 c0       	rjmp	.+8      	; 0x18fe <strrev+0x18>
    18f6:	7c 91       	ld	r23, X
    18f8:	6d 93       	st	X+, r22
    18fa:	70 83       	st	Z, r23
    18fc:	62 91       	ld	r22, -Z
    18fe:	ae 17       	cp	r26, r30
    1900:	bf 07       	cpc	r27, r31
    1902:	c8 f3       	brcs	.-14     	; 0x18f6 <strrev+0x10>
    1904:	08 95       	ret

00001906 <_exit>:
    1906:	f8 94       	cli

00001908 <__stop_program>:
    1908:	ff cf       	rjmp	.-2      	; 0x1908 <__stop_program>
