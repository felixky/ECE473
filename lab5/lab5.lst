
lab5.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000036  00800100  00001806  0000189a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001806  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000067  00800136  00800136  000018d0  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000018d0  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001900  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000088  00000000  00000000  0000193c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002851  00000000  00000000  000019c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000f60  00000000  00000000  00004215  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000013d0  00000000  00000000  00005175  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000004e4  00000000  00000000  00006548  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000007e0  00000000  00000000  00006a2c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001c5a  00000000  00000000  0000720c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000d8  00000000  00000000  00008e66  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 97 00 	jmp	0x12e	; 0x12e <__ctors_end>
       4:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
       8:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
       c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      10:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      14:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      18:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      1c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      20:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      24:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      28:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      2c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      30:	0c 94 12 05 	jmp	0xa24	; 0xa24 <__vector_12>
      34:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      38:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      3c:	0c 94 b2 03 	jmp	0x764	; 0x764 <__vector_15>
      40:	0c 94 7c 03 	jmp	0x6f8	; 0x6f8 <__vector_16>
      44:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      48:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      4c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      50:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      54:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      58:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      5c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      60:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      64:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      68:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      6c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      70:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      74:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      78:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      7c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      80:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      84:	0c 94 04 0a 	jmp	0x1408	; 0x1408 <__vector_33>
      88:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      8c:	45 0a       	sbc	r4, r21
      8e:	1c 0a       	sbc	r1, r28
      90:	1c 0a       	sbc	r1, r28
      92:	1c 0a       	sbc	r1, r28
      94:	1c 0a       	sbc	r1, r28
      96:	1c 0a       	sbc	r1, r28
      98:	1c 0a       	sbc	r1, r28
      9a:	1c 0a       	sbc	r1, r28
      9c:	45 0a       	sbc	r4, r21
      9e:	1c 0a       	sbc	r1, r28
      a0:	1c 0a       	sbc	r1, r28
      a2:	1c 0a       	sbc	r1, r28
      a4:	1c 0a       	sbc	r1, r28
      a6:	1c 0a       	sbc	r1, r28
      a8:	1c 0a       	sbc	r1, r28
      aa:	1c 0a       	sbc	r1, r28
      ac:	4f 0a       	sbc	r4, r31
      ae:	1c 0a       	sbc	r1, r28
      b0:	1c 0a       	sbc	r1, r28
      b2:	1c 0a       	sbc	r1, r28
      b4:	1c 0a       	sbc	r1, r28
      b6:	1c 0a       	sbc	r1, r28
      b8:	1c 0a       	sbc	r1, r28
      ba:	1c 0a       	sbc	r1, r28
      bc:	1c 0a       	sbc	r1, r28
      be:	1c 0a       	sbc	r1, r28
      c0:	1c 0a       	sbc	r1, r28
      c2:	1c 0a       	sbc	r1, r28
      c4:	1c 0a       	sbc	r1, r28
      c6:	1c 0a       	sbc	r1, r28
      c8:	1c 0a       	sbc	r1, r28
      ca:	1c 0a       	sbc	r1, r28
      cc:	4f 0a       	sbc	r4, r31
      ce:	1c 0a       	sbc	r1, r28
      d0:	1c 0a       	sbc	r1, r28
      d2:	1c 0a       	sbc	r1, r28
      d4:	1c 0a       	sbc	r1, r28
      d6:	1c 0a       	sbc	r1, r28
      d8:	1c 0a       	sbc	r1, r28
      da:	1c 0a       	sbc	r1, r28
      dc:	1c 0a       	sbc	r1, r28
      de:	1c 0a       	sbc	r1, r28
      e0:	1c 0a       	sbc	r1, r28
      e2:	1c 0a       	sbc	r1, r28
      e4:	1c 0a       	sbc	r1, r28
      e6:	1c 0a       	sbc	r1, r28
      e8:	1c 0a       	sbc	r1, r28
      ea:	1c 0a       	sbc	r1, r28
      ec:	66 0a       	sbc	r6, r22
      ee:	1c 0a       	sbc	r1, r28
      f0:	1c 0a       	sbc	r1, r28
      f2:	1c 0a       	sbc	r1, r28
      f4:	1c 0a       	sbc	r1, r28
      f6:	1c 0a       	sbc	r1, r28
      f8:	1c 0a       	sbc	r1, r28
      fa:	1c 0a       	sbc	r1, r28
      fc:	6a 0a       	sbc	r6, r26
      fe:	1c 0a       	sbc	r1, r28
     100:	1c 0a       	sbc	r1, r28
     102:	1c 0a       	sbc	r1, r28
     104:	1c 0a       	sbc	r1, r28
     106:	1c 0a       	sbc	r1, r28
     108:	1c 0a       	sbc	r1, r28
     10a:	1c 0a       	sbc	r1, r28
     10c:	1c 0a       	sbc	r1, r28
     10e:	1c 0a       	sbc	r1, r28
     110:	1c 0a       	sbc	r1, r28
     112:	1c 0a       	sbc	r1, r28
     114:	1c 0a       	sbc	r1, r28
     116:	1c 0a       	sbc	r1, r28
     118:	1c 0a       	sbc	r1, r28
     11a:	1c 0a       	sbc	r1, r28
     11c:	78 0a       	sbc	r7, r24
     11e:	1c 0a       	sbc	r1, r28
     120:	1c 0a       	sbc	r1, r28
     122:	1c 0a       	sbc	r1, r28
     124:	1c 0a       	sbc	r1, r28
     126:	1c 0a       	sbc	r1, r28
     128:	1c 0a       	sbc	r1, r28
     12a:	1c 0a       	sbc	r1, r28
     12c:	36 0a       	sbc	r3, r22

0000012e <__ctors_end>:
     12e:	11 24       	eor	r1, r1
     130:	1f be       	out	0x3f, r1	; 63
     132:	cf ef       	ldi	r28, 0xFF	; 255
     134:	d0 e1       	ldi	r29, 0x10	; 16
     136:	de bf       	out	0x3e, r29	; 62
     138:	cd bf       	out	0x3d, r28	; 61

0000013a <__do_copy_data>:
     13a:	11 e0       	ldi	r17, 0x01	; 1
     13c:	a0 e0       	ldi	r26, 0x00	; 0
     13e:	b1 e0       	ldi	r27, 0x01	; 1
     140:	e6 e0       	ldi	r30, 0x06	; 6
     142:	f8 e1       	ldi	r31, 0x18	; 24
     144:	00 e0       	ldi	r16, 0x00	; 0
     146:	0b bf       	out	0x3b, r16	; 59
     148:	02 c0       	rjmp	.+4      	; 0x14e <__do_copy_data+0x14>
     14a:	07 90       	elpm	r0, Z+
     14c:	0d 92       	st	X+, r0
     14e:	a6 33       	cpi	r26, 0x36	; 54
     150:	b1 07       	cpc	r27, r17
     152:	d9 f7       	brne	.-10     	; 0x14a <__do_copy_data+0x10>

00000154 <__do_clear_bss>:
     154:	21 e0       	ldi	r18, 0x01	; 1
     156:	a6 e3       	ldi	r26, 0x36	; 54
     158:	b1 e0       	ldi	r27, 0x01	; 1
     15a:	01 c0       	rjmp	.+2      	; 0x15e <.do_clear_bss_start>

0000015c <.do_clear_bss_loop>:
     15c:	1d 92       	st	X+, r1

0000015e <.do_clear_bss_start>:
     15e:	ad 39       	cpi	r26, 0x9D	; 157
     160:	b2 07       	cpc	r27, r18
     162:	e1 f7       	brne	.-8      	; 0x15c <.do_clear_bss_loop>
     164:	0e 94 c3 0a 	call	0x1586	; 0x1586 <main>
     168:	0c 94 01 0c 	jmp	0x1802	; 0x1802 <_exit>

0000016c <__bad_interrupt>:
     16c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000170 <snoozin.part.1>:
	seconds equals the normal seconds. 
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
      if(a_sec_count == sec_count)
     170:	90 91 47 01 	lds	r25, 0x0147	; 0x800147 <a_sec_count>
     174:	80 91 4a 01 	lds	r24, 0x014A	; 0x80014a <sec_count>
     178:	98 17       	cp	r25, r24
     17a:	21 f0       	breq	.+8      	; 0x184 <snoozin.part.1+0x14>
         snooze = 0;
      else 
         snooze = 1;
     17c:	81 e0       	ldi	r24, 0x01	; 1
     17e:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <snooze>
     182:	08 95       	ret
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
      if(a_sec_count == sec_count)
         snooze = 0;
     184:	10 92 42 01 	sts	0x0142, r1	; 0x800142 <snooze>
     188:	08 95       	ret

0000018a <spi_init>:
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
     18a:	87 b3       	in	r24, 0x17	; 23
     18c:	87 60       	ori	r24, 0x07	; 7
     18e:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
     190:	8d b1       	in	r24, 0x0d	; 13
     192:	8c 65       	ori	r24, 0x5C	; 92
     194:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
     196:	70 9a       	sbi	0x0e, 0	; 14
     198:	08 95       	ret

0000019a <tcnt0_init>:
Description: Timer counter 0 is initialized in normal mode with no prescale
	and will be used as a seconds counter for the clock
Parameters: NA
**********************************************************************/
void tcnt0_init(){
   ASSR |= (1<<AS0);
     19a:	80 b7       	in	r24, 0x30	; 48
     19c:	88 60       	ori	r24, 0x08	; 8
     19e:	80 bf       	out	0x30, r24	; 48
   TIMSK |= (1<<OCIE0) | (1<<TOIE0);			//enable interrupts
     1a0:	87 b7       	in	r24, 0x37	; 55
     1a2:	83 60       	ori	r24, 0x03	; 3
     1a4:	87 bf       	out	0x37, r24	; 55
   TCCR0 |= (1<<CS00);			//normal mode, no prescale
     1a6:	83 b7       	in	r24, 0x33	; 51
     1a8:	81 60       	ori	r24, 0x01	; 1
     1aa:	83 bf       	out	0x33, r24	; 51
   OCR0 = 0xFF;
     1ac:	8f ef       	ldi	r24, 0xFF	; 255
     1ae:	81 bf       	out	0x31, r24	; 49
     1b0:	08 95       	ret

000001b2 <tcnt1_init>:
Description: Timer counter 1 is initialized in CTC mode, 64 bit prescaler
	so that it can be used to generate an alarm frequency
Parameters: NA
**********************************************************************/
void tcnt1_init(){
   TCCR1B |= (1<<CS11) | (1<<CS10) | (1<<WGM12);		//CTC mode, 64bit prescaler
     1b2:	8e b5       	in	r24, 0x2e	; 46
     1b4:	8b 60       	ori	r24, 0x0B	; 11
     1b6:	8e bd       	out	0x2e, r24	; 46
   TCCR1C = 0x00;
     1b8:	10 92 7a 00 	sts	0x007A, r1	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
   TIMSK  |= (1<<OCIE1A);	//enable flag for interrupt 
     1bc:	87 b7       	in	r24, 0x37	; 55
     1be:	80 61       	ori	r24, 0x10	; 16
     1c0:	87 bf       	out	0x37, r24	; 55
   OCR1A = 0x0040;		//compare match at 64
     1c2:	80 e4       	ldi	r24, 0x40	; 64
     1c4:	90 e0       	ldi	r25, 0x00	; 0
     1c6:	9b bd       	out	0x2b, r25	; 43
     1c8:	8a bd       	out	0x2a, r24	; 42
     1ca:	08 95       	ret

000001cc <tcnt2_init>:
	normal mode with a 64 bit prescaler. OCRA2 is adjusted to change
	the pwn produced.
Parameters: NA
**********************************************************************/
void tcnt2_init(){
   TCCR2 |= (1<<WGM21) | (1<<WGM20)| (1<<CS20) | (1<<COM21);			
     1cc:	85 b5       	in	r24, 0x25	; 37
     1ce:	89 66       	ori	r24, 0x69	; 105
     1d0:	85 bd       	out	0x25, r24	; 37
     1d2:	08 95       	ret

000001d4 <tcnt3_init>:
Description: This timer is used as a volume control for the audio amp.
	I adjust the value of OCR3A to change the pwm.
Parameters: NA
**********************************************************************/
void tcnt3_init(){
   TCCR3A |= (1<<COM3A1) | (1<<WGM31);	 //Clear on OCR3A match
     1d4:	eb e8       	ldi	r30, 0x8B	; 139
     1d6:	f0 e0       	ldi	r31, 0x00	; 0
     1d8:	80 81       	ld	r24, Z
     1da:	82 68       	ori	r24, 0x82	; 130
     1dc:	80 83       	st	Z, r24
   TCCR3B |= (1<<CS30) | (1<<WGM32) | (1<<WGM33);		//Fast PWM mode, no prescaler
     1de:	ea e8       	ldi	r30, 0x8A	; 138
     1e0:	f0 e0       	ldi	r31, 0x00	; 0
     1e2:	80 81       	ld	r24, Z
     1e4:	89 61       	ori	r24, 0x19	; 25
     1e6:	80 83       	st	Z, r24
   TCCR3C = 0x00;
     1e8:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x7e008c>
   ICR3 = 0x9F;				//Setting the TOP value
     1ec:	8f e9       	ldi	r24, 0x9F	; 159
     1ee:	90 e0       	ldi	r25, 0x00	; 0
     1f0:	90 93 81 00 	sts	0x0081, r25	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
     1f4:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
   TCNT3 = 0x0000; 			//Initialize TNCT1 to 0
     1f8:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     1fc:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
   OCR3A = 0x9F;			//Volume Control 0x9F=Max 0x00=Min
     200:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     204:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
     208:	08 95       	ret

0000020a <spi_read>:
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
     20a:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
     20c:	77 9b       	sbis	0x0e, 7	; 14
     20e:	fe cf       	rjmp	.-4      	; 0x20c <spi_read+0x2>
   return SPDR;
     210:	8f b1       	in	r24, 0x0f	; 15
}
     212:	08 95       	ret

00000214 <chk_buttons>:
	be implemented at the same time. Adapted to check all buttons from 
	Ganssel's "Guide to Debouncing" Expects active low pushbuttons on PINA 
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
     214:	48 2f       	mov	r20, r24
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
     216:	e8 2f       	mov	r30, r24
     218:	f0 e0       	ldi	r31, 0x00	; 0
     21a:	99 b3       	in	r25, 0x19	; 25
     21c:	ee 0f       	add	r30, r30
     21e:	ff 1f       	adc	r31, r31
     220:	e2 5b       	subi	r30, 0xB2	; 178
     222:	fe 4f       	sbci	r31, 0xFE	; 254
     224:	20 81       	ld	r18, Z
     226:	31 81       	ldd	r19, Z+1	; 0x01
     228:	22 0f       	add	r18, r18
     22a:	33 1f       	adc	r19, r19
     22c:	30 6e       	ori	r19, 0xE0	; 224
     22e:	89 2f       	mov	r24, r25
     230:	90 e0       	ldi	r25, 0x00	; 0
     232:	02 c0       	rjmp	.+4      	; 0x238 <chk_buttons+0x24>
     234:	95 95       	asr	r25
     236:	87 95       	ror	r24
     238:	4a 95       	dec	r20
     23a:	e2 f7       	brpl	.-8      	; 0x234 <chk_buttons+0x20>
     23c:	81 70       	andi	r24, 0x01	; 1
     23e:	99 27       	eor	r25, r25
     240:	28 2b       	or	r18, r24
     242:	39 2b       	or	r19, r25
     244:	31 83       	std	Z+1, r19	; 0x01
     246:	20 83       	st	Z, r18
     248:	81 e0       	ldi	r24, 0x01	; 1
     24a:	21 15       	cp	r18, r1
     24c:	30 4f       	sbci	r19, 0xF0	; 240
     24e:	09 f0       	breq	.+2      	; 0x252 <chk_buttons+0x3e>
     250:	80 e0       	ldi	r24, 0x00	; 0
  if (state[button] == 0xF000)
    return 1;
return 0;
}
     252:	08 95       	ret

00000254 <bars>:
Description:This function reads in the button board and updates the 
	LEDs on the bargraph through the serial port.
Parameters: NA
**********************************************************************/
void bars() {
   DDRA = 0x00;				//Set all as inputs
     254:	1a ba       	out	0x1a, r1	; 26
   PORTA = 0xFF;			//Pull up resistors
     256:	8f ef       	ldi	r24, 0xFF	; 255
     258:	8b bb       	out	0x1b, r24	; 27
   PORTB |= PINB | 0x70;		//Enable tristate buffer
     25a:	86 b3       	in	r24, 0x16	; 22
     25c:	98 b3       	in	r25, 0x18	; 24
     25e:	80 67       	ori	r24, 0x70	; 112
     260:	89 2b       	or	r24, r25
     262:	88 bb       	out	0x18, r24	; 24
     264:	ee e4       	ldi	r30, 0x4E	; 78
     266:	f1 e0       	ldi	r31, 0x01	; 1

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     268:	20 e0       	ldi	r18, 0x00	; 0
     26a:	30 e0       	ldi	r19, 0x00	; 0
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
     26c:	61 e0       	ldi	r22, 0x01	; 1
     26e:	70 e0       	ldi	r23, 0x00	; 0
     270:	05 c0       	rjmp	.+10     	; 0x27c <bars+0x28>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     272:	2f 5f       	subi	r18, 0xFF	; 255
     274:	3f 4f       	sbci	r19, 0xFF	; 255
     276:	28 30       	cpi	r18, 0x08	; 8
     278:	31 05       	cpc	r19, r1
     27a:	39 f1       	breq	.+78     	; 0x2ca <bars+0x76>
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
     27c:	99 b3       	in	r25, 0x19	; 25
     27e:	40 81       	ld	r20, Z
     280:	51 81       	ldd	r21, Z+1	; 0x01
     282:	44 0f       	add	r20, r20
     284:	55 1f       	adc	r21, r21
     286:	89 2f       	mov	r24, r25
     288:	90 e0       	ldi	r25, 0x00	; 0
     28a:	02 2e       	mov	r0, r18
     28c:	02 c0       	rjmp	.+4      	; 0x292 <bars+0x3e>
     28e:	95 95       	asr	r25
     290:	87 95       	ror	r24
     292:	0a 94       	dec	r0
     294:	e2 f7       	brpl	.-8      	; 0x28e <bars+0x3a>
     296:	81 70       	andi	r24, 0x01	; 1
     298:	99 27       	eor	r25, r25
     29a:	84 2b       	or	r24, r20
     29c:	95 2b       	or	r25, r21
     29e:	90 6e       	ori	r25, 0xE0	; 224
     2a0:	81 93       	st	Z+, r24
     2a2:	91 93       	st	Z+, r25
  if (state[button] == 0xF000)
     2a4:	81 15       	cp	r24, r1
     2a6:	90 4f       	sbci	r25, 0xF0	; 240
     2a8:	21 f7       	brne	.-56     	; 0x272 <bars+0x1e>
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
     2aa:	cb 01       	movw	r24, r22
     2ac:	02 2e       	mov	r0, r18
     2ae:	02 c0       	rjmp	.+4      	; 0x2b4 <bars+0x60>
     2b0:	88 0f       	add	r24, r24
     2b2:	99 1f       	adc	r25, r25
     2b4:	0a 94       	dec	r0
     2b6:	e2 f7       	brpl	.-8      	; 0x2b0 <bars+0x5c>
     2b8:	90 93 40 01 	sts	0x0140, r25	; 0x800140 <mult+0x1>
     2bc:	80 93 3f 01 	sts	0x013F, r24	; 0x80013f <mult>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     2c0:	2f 5f       	subi	r18, 0xFF	; 255
     2c2:	3f 4f       	sbci	r19, 0xFF	; 255
     2c4:	28 30       	cpi	r18, 0x08	; 8
     2c6:	31 05       	cpc	r19, r1
     2c8:	c9 f6       	brne	.-78     	; 0x27c <bars+0x28>
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
     2ca:	88 b3       	in	r24, 0x18	; 24
     2cc:	18 ba       	out	0x18, r1	; 24
   if(mult == 128){			//Button 8 toggles base 10 and 16
     2ce:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <mult>
     2d2:	90 91 40 01 	lds	r25, 0x0140	; 0x800140 <mult+0x1>
     2d6:	80 38       	cpi	r24, 0x80	; 128
     2d8:	91 05       	cpc	r25, r1
     2da:	09 f4       	brne	.+2      	; 0x2de <bars+0x8a>
     2dc:	79 c0       	rjmp	.+242    	; 0x3d0 <bars+0x17c>
      alarm = !(alarm);			//on the LED display
   }
   if(mult == 64){		//Button 7 toggles snooze
     2de:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <mult>
     2e2:	90 91 40 01 	lds	r25, 0x0140	; 0x800140 <mult+0x1>
     2e6:	80 34       	cpi	r24, 0x40	; 64
     2e8:	91 05       	cpc	r25, r1
     2ea:	c9 f1       	breq	.+114    	; 0x35e <bars+0x10a>
	       a_hour_count = 0;
	    }
	 }  
      }
   }
   if(mult > 4) {			//I only want values from the
     2ec:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <mult>
     2f0:	90 91 40 01 	lds	r25, 0x0140	; 0x800140 <mult+0x1>
     2f4:	05 97       	sbiw	r24, 0x05	; 5
     2f6:	20 f0       	brcs	.+8      	; 0x300 <bars+0xac>
      mult = 0;				//first three buttons
     2f8:	10 92 40 01 	sts	0x0140, r1	; 0x800140 <mult+0x1>
     2fc:	10 92 3f 01 	sts	0x013F, r1	; 0x80013f <mult>
   }
   //This switch statement is used to enable a 'toggle' functionality
   //so that modes can be selected an deselected
   switch(mult) {
     300:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <mult>
     304:	90 91 40 01 	lds	r25, 0x0140	; 0x800140 <mult+0x1>
     308:	81 30       	cpi	r24, 0x01	; 1
     30a:	91 05       	cpc	r25, r1
     30c:	19 f0       	breq	.+6      	; 0x314 <bars+0xc0>
     30e:	82 30       	cpi	r24, 0x02	; 2
     310:	91 05       	cpc	r25, r1
     312:	01 f5       	brne	.+64     	; 0x354 <bars+0x100>
	 }
	 else
	    mode_sel = 1;		//If not, then change mode
         break;
      case 2:
	 if((mode_sel ^ mult) == 0 ){//if((mode_sel ^ mult) && (mode_sel == 4)){//if cur &prev are diff
     314:	40 91 3b 01 	lds	r20, 0x013B	; 0x80013b <mode_sel>
     318:	50 91 3c 01 	lds	r21, 0x013C	; 0x80013c <mode_sel+0x1>
     31c:	20 91 3f 01 	lds	r18, 0x013F	; 0x80013f <mult>
     320:	30 91 40 01 	lds	r19, 0x0140	; 0x800140 <mult+0x1>
     324:	42 17       	cp	r20, r18
     326:	53 07       	cpc	r21, r19
     328:	09 f4       	brne	.+2      	; 0x32c <bars+0xd8>
     32a:	5a c0       	rjmp	.+180    	; 0x3e0 <bars+0x18c>
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
         break;*/
      default:
	 mode_sel = mode_sel;		//no/invalid button press
     32c:	90 93 3c 01 	sts	0x013C, r25	; 0x80013c <mode_sel+0x1>
     330:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <mode_sel>
   }   
   mult = 0;				//clear mult for next pass
     334:	10 92 40 01 	sts	0x0140, r1	; 0x800140 <mult+0x1>
     338:	10 92 3f 01 	sts	0x013F, r1	; 0x80013f <mult>

   DDRA = 0xFF;				//Set A to alloutputs
     33c:	8f ef       	ldi	r24, 0xFF	; 255
     33e:	8a bb       	out	0x1a, r24	; 26
   SPDR = mode_sel;			//Write mode to the Bargraph
     340:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <mode_sel>
     344:	90 91 3c 01 	lds	r25, 0x013C	; 0x80013c <mode_sel+0x1>
     348:	8f b9       	out	0x0f, r24	; 15
   while(bit_is_clear(SPSR, SPIF)){}	
     34a:	77 9b       	sbis	0x0e, 7	; 14
     34c:	fe cf       	rjmp	.-4      	; 0x34a <bars+0xf6>
   PORTB |= (1<<PB0);			//Rgclk high on bargraph
     34e:	c0 9a       	sbi	0x18, 0	; 24
   PORTB &= 0xFE;			//Rgclk low on bargraph
     350:	c0 98       	cbi	0x18, 0	; 24
   
return ;
     352:	08 95       	ret
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
         break;*/
      default:
	 mode_sel = mode_sel;		//no/invalid button press
     354:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <mode_sel>
     358:	90 91 3c 01 	lds	r25, 0x013C	; 0x80013c <mode_sel+0x1>
     35c:	e7 cf       	rjmp	.-50     	; 0x32c <bars+0xd8>
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
   }
   if(mult == 64){		//Button 7 toggles snooze
      snooze = !(snooze);		//10 second snooze functionality
     35e:	90 91 42 01 	lds	r25, 0x0142	; 0x800142 <snooze>
     362:	81 e0       	ldi	r24, 0x01	; 1
     364:	91 11       	cpse	r25, r1
     366:	45 c0       	rjmp	.+138    	; 0x3f2 <bars+0x19e>
     368:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <snooze>
      a_sec_count = sec_count + 10;
     36c:	80 91 4a 01 	lds	r24, 0x014A	; 0x80014a <sec_count>
     370:	86 5f       	subi	r24, 0xF6	; 246
     372:	80 93 47 01 	sts	0x0147, r24	; 0x800147 <a_sec_count>
      if(a_sec_count > 60){
     376:	80 91 47 01 	lds	r24, 0x0147	; 0x800147 <a_sec_count>
     37a:	8d 33       	cpi	r24, 0x3D	; 61
     37c:	08 f4       	brcc	.+2      	; 0x380 <bars+0x12c>
     37e:	b6 cf       	rjmp	.-148    	; 0x2ec <bars+0x98>
         a_sec_count = a_sec_count % 60;
     380:	90 91 47 01 	lds	r25, 0x0147	; 0x800147 <a_sec_count>
     384:	89 e8       	ldi	r24, 0x89	; 137
     386:	98 9f       	mul	r25, r24
     388:	81 2d       	mov	r24, r1
     38a:	11 24       	eor	r1, r1
     38c:	82 95       	swap	r24
     38e:	86 95       	lsr	r24
     390:	87 70       	andi	r24, 0x07	; 7
     392:	2c e3       	ldi	r18, 0x3C	; 60
     394:	82 9f       	mul	r24, r18
     396:	90 19       	sub	r25, r0
     398:	11 24       	eor	r1, r1
     39a:	90 93 47 01 	sts	0x0147, r25	; 0x800147 <a_sec_count>
	 a_min_count++;
     39e:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <a_min_count>
     3a2:	8f 5f       	subi	r24, 0xFF	; 255
     3a4:	80 93 46 01 	sts	0x0146, r24	; 0x800146 <a_min_count>
	 if(a_min_count == 60){
     3a8:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <a_min_count>
     3ac:	8c 33       	cpi	r24, 0x3C	; 60
     3ae:	09 f0       	breq	.+2      	; 0x3b2 <bars+0x15e>
     3b0:	9d cf       	rjmp	.-198    	; 0x2ec <bars+0x98>
	    a_hour_count++;
     3b2:	80 91 45 01 	lds	r24, 0x0145	; 0x800145 <a_hour_count>
     3b6:	8f 5f       	subi	r24, 0xFF	; 255
     3b8:	80 93 45 01 	sts	0x0145, r24	; 0x800145 <a_hour_count>
	    a_min_count = 0;
     3bc:	10 92 46 01 	sts	0x0146, r1	; 0x800146 <a_min_count>
	    if(a_hour_count == 24){
     3c0:	80 91 45 01 	lds	r24, 0x0145	; 0x800145 <a_hour_count>
     3c4:	88 31       	cpi	r24, 0x18	; 24
     3c6:	09 f0       	breq	.+2      	; 0x3ca <bars+0x176>
     3c8:	91 cf       	rjmp	.-222    	; 0x2ec <bars+0x98>
	       a_hour_count = 0;
     3ca:	10 92 45 01 	sts	0x0145, r1	; 0x800145 <a_hour_count>
     3ce:	8e cf       	rjmp	.-228    	; 0x2ec <bars+0x98>
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
     3d0:	90 91 43 01 	lds	r25, 0x0143	; 0x800143 <alarm>
     3d4:	81 e0       	ldi	r24, 0x01	; 1
     3d6:	91 11       	cpse	r25, r1
     3d8:	08 c0       	rjmp	.+16     	; 0x3ea <bars+0x196>
     3da:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <alarm>
     3de:	7f cf       	rjmp	.-258    	; 0x2de <bars+0x8a>
	 else
	    mode_sel = 1;		//If not, then change mode
         break;
      case 2:
	 if((mode_sel ^ mult) == 0 ){//if((mode_sel ^ mult) && (mode_sel == 4)){//if cur &prev are diff
	    mode_sel = 0;//and prev isn't = 1 then two modes are selected
     3e0:	10 92 3c 01 	sts	0x013C, r1	; 0x80013c <mode_sel+0x1>
     3e4:	10 92 3b 01 	sts	0x013B, r1	; 0x80013b <mode_sel>
     3e8:	a5 cf       	rjmp	.-182    	; 0x334 <bars+0xe0>
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
     3ea:	80 e0       	ldi	r24, 0x00	; 0
     3ec:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <alarm>
     3f0:	76 cf       	rjmp	.-276    	; 0x2de <bars+0x8a>
   }
   if(mult == 64){		//Button 7 toggles snooze
      snooze = !(snooze);		//10 second snooze functionality
     3f2:	80 e0       	ldi	r24, 0x00	; 0
     3f4:	b9 cf       	rjmp	.-142    	; 0x368 <bars+0x114>

000003f6 <read_encoder>:
   int8_t value = 0x00;
   uint8_t ec_a;
   uint8_t ec_b;

   //Shift_LD_N low
   PORTE &= 0x00;	//Begining of SHIFT_LD_N pulse. It is low here
     3f6:	83 b1       	in	r24, 0x03	; 3
     3f8:	13 b8       	out	0x03, r1	; 3
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     3fa:	87 ec       	ldi	r24, 0xC7	; 199
     3fc:	90 e0       	ldi	r25, 0x00	; 0
     3fe:	01 97       	sbiw	r24, 0x01	; 1
     400:	f1 f7       	brne	.-4      	; 0x3fe <read_encoder+0x8>
     402:	00 c0       	rjmp	.+0      	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
     404:	00 00       	nop
   _delay_us(50);
   PORTE |= 0xFF;	//End of SHIFT_LD_N pulse. back to high
     406:	83 b1       	in	r24, 0x03	; 3
     408:	8f ef       	ldi	r24, 0xFF	; 255
     40a:	83 b9       	out	0x03, r24	; 3
   PORTD &= 0x0F;	//CLK_INH low
     40c:	82 b3       	in	r24, 0x12	; 18
     40e:	8f 70       	andi	r24, 0x0F	; 15
     410:	82 bb       	out	0x12, r24	; 18
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
     412:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
     414:	77 9b       	sbis	0x0e, 7	; 14
     416:	fe cf       	rjmp	.-4      	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
   return SPDR;
     418:	9f b1       	in	r25, 0x0f	; 15
   _delay_us(50);
   PORTE |= 0xFF;	//End of SHIFT_LD_N pulse. back to high
   PORTD &= 0x0F;	//CLK_INH low

   encoder_value = spi_read();
   PORTD |= 0xF0;	//CLK_INH high
     41a:	82 b3       	in	r24, 0x12	; 18
     41c:	80 6f       	ori	r24, 0xF0	; 240
     41e:	82 bb       	out	0x12, r24	; 18
   value = mode_sel;
     420:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <mode_sel>
     424:	30 91 3c 01 	lds	r19, 0x013C	; 0x80013c <mode_sel+0x1>
     428:	82 2f       	mov	r24, r18
   ec_a = encoder_value & 0x03;  //Only grabs these bits 0000_0011
     42a:	69 2f       	mov	r22, r25
     42c:	63 70       	andi	r22, 0x03	; 3
   ec_b = encoder_value & 0x0C;  //Only grabs these bits 0000_1100 
     42e:	9c 70       	andi	r25, 0x0C	; 12
   ec_b = (ec_b >> 2);
     430:	96 95       	lsr	r25
     432:	96 95       	lsr	r25

//mode_sel == 0 means that no mode has been selected and the speaker volume can be adjusted
   if(mode_sel == 0){
     434:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <mode_sel>
     438:	30 91 3c 01 	lds	r19, 0x013C	; 0x80013c <mode_sel+0x1>
     43c:	23 2b       	or	r18, r19
     43e:	09 f5       	brne	.+66     	; 0x482 <__LOCK_REGION_LENGTH__+0x82>
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     440:	20 91 63 01 	lds	r18, 0x0163	; 0x800163 <EC_a_prev>
     444:	46 2f       	mov	r20, r22
     446:	50 e0       	ldi	r21, 0x00	; 0
     448:	02 2e       	mov	r0, r18
     44a:	00 0c       	add	r0, r0
     44c:	33 0b       	sbc	r19, r19
     44e:	42 17       	cp	r20, r18
     450:	53 07       	cpc	r21, r19
     452:	b9 f0       	breq	.+46     	; 0x482 <__LOCK_REGION_LENGTH__+0x82>
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     454:	20 91 63 01 	lds	r18, 0x0163	; 0x800163 <EC_a_prev>
     458:	21 11       	cpse	r18, r1
     45a:	26 c0       	rjmp	.+76     	; 0x4a8 <__LOCK_REGION_LENGTH__+0xa8>
     45c:	61 30       	cpi	r22, 0x01	; 1
     45e:	21 f5       	brne	.+72     	; 0x4a8 <__LOCK_REGION_LENGTH__+0xa8>
            volume += 10;	//increment volume
     460:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     464:	26 5f       	subi	r18, 0xF6	; 246
     466:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <volume>
	    if(volume <= 0x9F){
     46a:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     46e:	20 3a       	cpi	r18, 0xA0	; 160
     470:	08 f0       	brcs	.+2      	; 0x474 <__LOCK_REGION_LENGTH__+0x74>
     472:	e5 c0       	rjmp	.+458    	; 0x63e <__LOCK_REGION_LENGTH__+0x23e>
	    }
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
	    volume -= 10;	//decrement volume 
	    if(volume >= 0x00){
		OCR3A = volume;	//minimum volume
     474:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     478:	30 e0       	ldi	r19, 0x00	; 0
     47a:	30 93 87 00 	sts	0x0087, r19	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     47e:	20 93 86 00 	sts	0x0086, r18	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
	    value = 0;
      }*/
   }

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
     482:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <mode_sel>
     486:	30 91 3c 01 	lds	r19, 0x013C	; 0x80013c <mode_sel+0x1>
     48a:	21 30       	cpi	r18, 0x01	; 1
     48c:	31 05       	cpc	r19, r1
     48e:	f1 f0       	breq	.+60     	; 0x4cc <__LOCK_REGION_LENGTH__+0xcc>
         else
	    value = 0;
      }
   }
//mode_sel == 2 means that the user has selected the "alarm time change" mode
   if(mode_sel == 2){
     490:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <mode_sel>
     494:	30 91 3c 01 	lds	r19, 0x013C	; 0x80013c <mode_sel+0x1>
     498:	22 30       	cpi	r18, 0x02	; 2
     49a:	31 05       	cpc	r19, r1
     49c:	b1 f1       	breq	.+108    	; 0x50a <__LOCK_REGION_LENGTH__+0x10a>
         else
	    value = 0;
      }
   }
//Saves previous values into volatile variables
EC_a_prev = ec_a;
     49e:	60 93 63 01 	sts	0x0163, r22	; 0x800163 <EC_a_prev>
EC_b_prev = ec_b;
     4a2:	90 93 62 01 	sts	0x0162, r25	; 0x800162 <EC_b_prev>

return value;
}
     4a6:	08 95       	ret
	    else {
		volume = 0x9F;
		OCR3A = 0x9F;
	    }
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     4a8:	20 91 63 01 	lds	r18, 0x0163	; 0x800163 <EC_a_prev>
     4ac:	21 11       	cpse	r18, r1
     4ae:	03 c0       	rjmp	.+6      	; 0x4b6 <__LOCK_REGION_LENGTH__+0xb6>
     4b0:	62 30       	cpi	r22, 0x02	; 2
     4b2:	09 f4       	brne	.+2      	; 0x4b6 <__LOCK_REGION_LENGTH__+0xb6>
     4b4:	af c0       	rjmp	.+350    	; 0x614 <__LOCK_REGION_LENGTH__+0x214>
		volume = 0x00;
		OCR3A = 0x00;
	    }
         }
         else	//If not one of the state changes above, do nothing
	 volume = volume;
     4b6:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     4ba:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <volume>
	    value = 0;
      }*/
   }

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
     4be:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <mode_sel>
     4c2:	30 91 3c 01 	lds	r19, 0x013C	; 0x80013c <mode_sel+0x1>
     4c6:	21 30       	cpi	r18, 0x01	; 1
     4c8:	31 05       	cpc	r19, r1
     4ca:	11 f7       	brne	.-60     	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     4cc:	20 91 63 01 	lds	r18, 0x0163	; 0x800163 <EC_a_prev>
     4d0:	46 2f       	mov	r20, r22
     4d2:	50 e0       	ldi	r21, 0x00	; 0
     4d4:	02 2e       	mov	r0, r18
     4d6:	00 0c       	add	r0, r0
     4d8:	33 0b       	sbc	r19, r19
     4da:	42 17       	cp	r20, r18
     4dc:	53 07       	cpc	r21, r19
     4de:	09 f4       	brne	.+2      	; 0x4e2 <__LOCK_REGION_LENGTH__+0xe2>
     4e0:	5a c0       	rjmp	.+180    	; 0x596 <__LOCK_REGION_LENGTH__+0x196>
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     4e2:	20 91 63 01 	lds	r18, 0x0163	; 0x800163 <EC_a_prev>
     4e6:	22 23       	and	r18, r18
     4e8:	09 f4       	brne	.+2      	; 0x4ec <__LOCK_REGION_LENGTH__+0xec>
     4ea:	47 c0       	rjmp	.+142    	; 0x57a <__LOCK_REGION_LENGTH__+0x17a>
            hour_count = hour_count + 1;//value = value;
	    if(hour_count == 24)
	       hour_count = 0;
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     4ec:	20 91 63 01 	lds	r18, 0x0163	; 0x800163 <EC_a_prev>
     4f0:	21 11       	cpse	r18, r1
     4f2:	03 c0       	rjmp	.+6      	; 0x4fa <__LOCK_REGION_LENGTH__+0xfa>
     4f4:	62 30       	cpi	r22, 0x02	; 2
     4f6:	09 f4       	brne	.+2      	; 0x4fa <__LOCK_REGION_LENGTH__+0xfa>
     4f8:	80 c0       	rjmp	.+256    	; 0x5fa <__LOCK_REGION_LENGTH__+0x1fa>
	    hour_count = hour_count - 1;//value = -(value);
	    if(hour_count < 0)
	       hour_count = 23; 
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
     4fa:	80 e0       	ldi	r24, 0x00	; 0
         else
	    value = 0;
      }
   }
//mode_sel == 2 means that the user has selected the "alarm time change" mode
   if(mode_sel == 2){
     4fc:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <mode_sel>
     500:	30 91 3c 01 	lds	r19, 0x013C	; 0x80013c <mode_sel+0x1>
     504:	22 30       	cpi	r18, 0x02	; 2
     506:	31 05       	cpc	r19, r1
     508:	51 f6       	brne	.-108    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     50a:	20 91 63 01 	lds	r18, 0x0163	; 0x800163 <EC_a_prev>
     50e:	46 2f       	mov	r20, r22
     510:	50 e0       	ldi	r21, 0x00	; 0
     512:	02 2e       	mov	r0, r18
     514:	00 0c       	add	r0, r0
     516:	33 0b       	sbc	r19, r19
     518:	42 17       	cp	r20, r18
     51a:	53 07       	cpc	r21, r19
     51c:	d1 f0       	breq	.+52     	; 0x552 <__LOCK_REGION_LENGTH__+0x152>
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     51e:	20 91 63 01 	lds	r18, 0x0163	; 0x800163 <EC_a_prev>
     522:	21 11       	cpse	r18, r1
     524:	03 c0       	rjmp	.+6      	; 0x52c <__LOCK_REGION_LENGTH__+0x12c>
     526:	61 30       	cpi	r22, 0x01	; 1
     528:	09 f4       	brne	.+2      	; 0x52c <__LOCK_REGION_LENGTH__+0x12c>
     52a:	7c c0       	rjmp	.+248    	; 0x624 <__LOCK_REGION_LENGTH__+0x224>
            a_hour_count = a_hour_count + 1;//value = value;
	    if(a_hour_count == 24)
	       a_hour_count = 0;
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     52c:	20 91 63 01 	lds	r18, 0x0163	; 0x800163 <EC_a_prev>
     530:	21 11       	cpse	r18, r1
     532:	1d c0       	rjmp	.+58     	; 0x56e <__LOCK_REGION_LENGTH__+0x16e>
     534:	62 30       	cpi	r22, 0x02	; 2
     536:	d9 f4       	brne	.+54     	; 0x56e <__LOCK_REGION_LENGTH__+0x16e>
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
	    a_min_count = a_min_count - 1; //value = -(value);
	    if(a_min_count < 0){
	       a_min_count = 59;
	       a_hour_count--;
     538:	20 91 45 01 	lds	r18, 0x0145	; 0x800145 <a_hour_count>
     53c:	21 50       	subi	r18, 0x01	; 1
     53e:	20 93 45 01 	sts	0x0145, r18	; 0x800145 <a_hour_count>
	       if(a_hour_count < 0){
     542:	20 91 45 01 	lds	r18, 0x0145	; 0x800145 <a_hour_count>
     546:	27 ff       	sbrs	r18, 7
     548:	aa cf       	rjmp	.-172    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
	          a_hour_count = 23;
     54a:	27 e1       	ldi	r18, 0x17	; 23
     54c:	20 93 45 01 	sts	0x0145, r18	; 0x800145 <a_hour_count>
     550:	a6 cf       	rjmp	.-180    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
     552:	20 91 62 01 	lds	r18, 0x0162	; 0x800162 <EC_b_prev>
     556:	21 11       	cpse	r18, r1
     558:	03 c0       	rjmp	.+6      	; 0x560 <__LOCK_REGION_LENGTH__+0x160>
     55a:	91 30       	cpi	r25, 0x01	; 1
     55c:	09 f4       	brne	.+2      	; 0x560 <__LOCK_REGION_LENGTH__+0x160>
     55e:	86 c0       	rjmp	.+268    	; 0x66c <__LOCK_REGION_LENGTH__+0x26c>
	       a_hour_count++;
	       if(a_hour_count > 23)
	          a_hour_count = 0;
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
     560:	20 91 62 01 	lds	r18, 0x0162	; 0x800162 <EC_b_prev>
     564:	21 11       	cpse	r18, r1
     566:	03 c0       	rjmp	.+6      	; 0x56e <__LOCK_REGION_LENGTH__+0x16e>
     568:	92 30       	cpi	r25, 0x02	; 2
     56a:	09 f4       	brne	.+2      	; 0x56e <__LOCK_REGION_LENGTH__+0x16e>
     56c:	72 c0       	rjmp	.+228    	; 0x652 <__LOCK_REGION_LENGTH__+0x252>
	    a_hour_count = a_hour_count - 1;//value = -(value);
	    if(a_hour_count < 0)
	       a_hour_count = 23; 
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
     56e:	80 e0       	ldi	r24, 0x00	; 0
         else
	    value = 0;
      }
   }
//Saves previous values into volatile variables
EC_a_prev = ec_a;
     570:	60 93 63 01 	sts	0x0163, r22	; 0x800163 <EC_a_prev>
EC_b_prev = ec_b;
     574:	90 93 62 01 	sts	0x0162, r25	; 0x800162 <EC_b_prev>

return value;
}
     578:	08 95       	ret
   }

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     57a:	61 30       	cpi	r22, 0x01	; 1
     57c:	09 f0       	breq	.+2      	; 0x580 <__LOCK_REGION_LENGTH__+0x180>
     57e:	b6 cf       	rjmp	.-148    	; 0x4ec <__LOCK_REGION_LENGTH__+0xec>
            hour_count = hour_count + 1;//value = value;
     580:	20 91 48 01 	lds	r18, 0x0148	; 0x800148 <hour_count>
     584:	2f 5f       	subi	r18, 0xFF	; 255
     586:	20 93 48 01 	sts	0x0148, r18	; 0x800148 <hour_count>
	    if(hour_count == 24)
     58a:	20 91 48 01 	lds	r18, 0x0148	; 0x800148 <hour_count>
     58e:	28 31       	cpi	r18, 0x18	; 24
     590:	09 f0       	breq	.+2      	; 0x594 <__LOCK_REGION_LENGTH__+0x194>
     592:	7e cf       	rjmp	.-260    	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
     594:	1c c0       	rjmp	.+56     	; 0x5ce <__LOCK_REGION_LENGTH__+0x1ce>
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
     596:	20 91 62 01 	lds	r18, 0x0162	; 0x800162 <EC_b_prev>
     59a:	21 11       	cpse	r18, r1
     59c:	1b c0       	rjmp	.+54     	; 0x5d4 <__LOCK_REGION_LENGTH__+0x1d4>
     59e:	91 30       	cpi	r25, 0x01	; 1
     5a0:	c9 f4       	brne	.+50     	; 0x5d4 <__LOCK_REGION_LENGTH__+0x1d4>
            min_count = min_count + 1;//value = value;
     5a2:	20 91 49 01 	lds	r18, 0x0149	; 0x800149 <min_count>
     5a6:	2f 5f       	subi	r18, 0xFF	; 255
     5a8:	20 93 49 01 	sts	0x0149, r18	; 0x800149 <min_count>
	    if(min_count == 60){
     5ac:	20 91 49 01 	lds	r18, 0x0149	; 0x800149 <min_count>
     5b0:	2c 33       	cpi	r18, 0x3C	; 60
     5b2:	09 f0       	breq	.+2      	; 0x5b6 <__LOCK_REGION_LENGTH__+0x1b6>
     5b4:	6d cf       	rjmp	.-294    	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
	       min_count = 0; 
     5b6:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <min_count>
	       hour_count++;
     5ba:	20 91 48 01 	lds	r18, 0x0148	; 0x800148 <hour_count>
     5be:	2f 5f       	subi	r18, 0xFF	; 255
     5c0:	20 93 48 01 	sts	0x0148, r18	; 0x800148 <hour_count>
	       if(hour_count > 23)
     5c4:	20 91 48 01 	lds	r18, 0x0148	; 0x800148 <hour_count>
     5c8:	28 31       	cpi	r18, 0x18	; 24
     5ca:	0c f4       	brge	.+2      	; 0x5ce <__LOCK_REGION_LENGTH__+0x1ce>
     5cc:	61 cf       	rjmp	.-318    	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
	          hour_count = 0;
     5ce:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <hour_count>
     5d2:	5e cf       	rjmp	.-324    	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
     5d4:	20 91 62 01 	lds	r18, 0x0162	; 0x800162 <EC_b_prev>
     5d8:	21 11       	cpse	r18, r1
     5da:	8f cf       	rjmp	.-226    	; 0x4fa <__LOCK_REGION_LENGTH__+0xfa>
     5dc:	92 30       	cpi	r25, 0x02	; 2
     5de:	09 f0       	breq	.+2      	; 0x5e2 <__LOCK_REGION_LENGTH__+0x1e2>
     5e0:	8c cf       	rjmp	.-232    	; 0x4fa <__LOCK_REGION_LENGTH__+0xfa>
	    min_count = min_count - 1; //value = -(value);
     5e2:	20 91 49 01 	lds	r18, 0x0149	; 0x800149 <min_count>
     5e6:	21 50       	subi	r18, 0x01	; 1
     5e8:	20 93 49 01 	sts	0x0149, r18	; 0x800149 <min_count>
	    if(min_count < 0){
     5ec:	20 91 49 01 	lds	r18, 0x0149	; 0x800149 <min_count>
     5f0:	27 ff       	sbrs	r18, 7
     5f2:	4e cf       	rjmp	.-356    	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
	       min_count = 59;
     5f4:	2b e3       	ldi	r18, 0x3B	; 59
     5f6:	20 93 49 01 	sts	0x0149, r18	; 0x800149 <min_count>
	       hour_count--;
     5fa:	20 91 48 01 	lds	r18, 0x0148	; 0x800148 <hour_count>
     5fe:	21 50       	subi	r18, 0x01	; 1
     600:	20 93 48 01 	sts	0x0148, r18	; 0x800148 <hour_count>
	       if(hour_count < 0){
     604:	20 91 48 01 	lds	r18, 0x0148	; 0x800148 <hour_count>
     608:	27 ff       	sbrs	r18, 7
     60a:	42 cf       	rjmp	.-380    	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
	          hour_count = 23;
     60c:	27 e1       	ldi	r18, 0x17	; 23
     60e:	20 93 48 01 	sts	0x0148, r18	; 0x800148 <hour_count>
     612:	3e cf       	rjmp	.-388    	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
		volume = 0x9F;
		OCR3A = 0x9F;
	    }
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
	    volume -= 10;	//decrement volume 
     614:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     618:	2a 50       	subi	r18, 0x0A	; 10
     61a:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <volume>
	    if(volume >= 0x00){
     61e:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     622:	28 cf       	rjmp	.-432    	; 0x474 <__LOCK_REGION_LENGTH__+0x74>
   }
//mode_sel == 2 means that the user has selected the "alarm time change" mode
   if(mode_sel == 2){
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
            a_hour_count = a_hour_count + 1;//value = value;
     624:	20 91 45 01 	lds	r18, 0x0145	; 0x800145 <a_hour_count>
     628:	2f 5f       	subi	r18, 0xFF	; 255
     62a:	20 93 45 01 	sts	0x0145, r18	; 0x800145 <a_hour_count>
	    if(a_hour_count == 24)
     62e:	20 91 45 01 	lds	r18, 0x0145	; 0x800145 <a_hour_count>
     632:	28 31       	cpi	r18, 0x18	; 24
     634:	09 f0       	breq	.+2      	; 0x638 <__LOCK_REGION_LENGTH__+0x238>
     636:	33 cf       	rjmp	.-410    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
            a_min_count = a_min_count + 1;//value = value;
	    if(a_min_count == 60){
	       a_min_count = 0; 
	       a_hour_count++;
	       if(a_hour_count > 23)
	          a_hour_count = 0;
     638:	10 92 45 01 	sts	0x0145, r1	; 0x800145 <a_hour_count>
     63c:	30 cf       	rjmp	.-416    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
            volume += 10;	//increment volume
	    if(volume <= 0x9F){
		OCR3A = volume;	//maximum volume
	    }
	    else {
		volume = 0x9F;
     63e:	2f e9       	ldi	r18, 0x9F	; 159
     640:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <volume>
		OCR3A = 0x9F;
     644:	2f e9       	ldi	r18, 0x9F	; 159
     646:	30 e0       	ldi	r19, 0x00	; 0
     648:	30 93 87 00 	sts	0x0087, r19	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     64c:	20 93 86 00 	sts	0x0086, r18	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
     650:	18 cf       	rjmp	.-464    	; 0x482 <__LOCK_REGION_LENGTH__+0x82>
	       if(a_hour_count > 23)
	          a_hour_count = 0;
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
	    a_min_count = a_min_count - 1; //value = -(value);
     652:	20 91 46 01 	lds	r18, 0x0146	; 0x800146 <a_min_count>
     656:	21 50       	subi	r18, 0x01	; 1
     658:	20 93 46 01 	sts	0x0146, r18	; 0x800146 <a_min_count>
	    if(a_min_count < 0){
     65c:	20 91 46 01 	lds	r18, 0x0146	; 0x800146 <a_min_count>
     660:	27 ff       	sbrs	r18, 7
     662:	1d cf       	rjmp	.-454    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
	       a_min_count = 59;
     664:	2b e3       	ldi	r18, 0x3B	; 59
     666:	20 93 46 01 	sts	0x0146, r18	; 0x800146 <a_min_count>
     66a:	66 cf       	rjmp	.-308    	; 0x538 <__LOCK_REGION_LENGTH__+0x138>
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
            a_min_count = a_min_count + 1;//value = value;
     66c:	20 91 46 01 	lds	r18, 0x0146	; 0x800146 <a_min_count>
     670:	2f 5f       	subi	r18, 0xFF	; 255
     672:	20 93 46 01 	sts	0x0146, r18	; 0x800146 <a_min_count>
	    if(a_min_count == 60){
     676:	20 91 46 01 	lds	r18, 0x0146	; 0x800146 <a_min_count>
     67a:	2c 33       	cpi	r18, 0x3C	; 60
     67c:	09 f0       	breq	.+2      	; 0x680 <__LOCK_REGION_LENGTH__+0x280>
     67e:	0f cf       	rjmp	.-482    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
	       a_min_count = 0; 
     680:	10 92 46 01 	sts	0x0146, r1	; 0x800146 <a_min_count>
	       a_hour_count++;
     684:	20 91 45 01 	lds	r18, 0x0145	; 0x800145 <a_hour_count>
     688:	2f 5f       	subi	r18, 0xFF	; 255
     68a:	20 93 45 01 	sts	0x0145, r18	; 0x800145 <a_hour_count>
	       if(a_hour_count > 23)
     68e:	20 91 45 01 	lds	r18, 0x0145	; 0x800145 <a_hour_count>
     692:	28 31       	cpi	r18, 0x18	; 24
     694:	0c f4       	brge	.+2      	; 0x698 <__LOCK_REGION_LENGTH__+0x298>
     696:	03 cf       	rjmp	.-506    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
     698:	cf cf       	rjmp	.-98     	; 0x638 <__LOCK_REGION_LENGTH__+0x238>

0000069a <get_local_temp>:
**********************************************************************/
void get_local_temp(){
uint16_t lm73_temp;

  //_delay_ms(65); //tenth second wait
  clear_display();                  //wipe the display
     69a:	0e 94 df 06 	call	0xdbe	; 0xdbe <clear_display>
  twi_start_rd(LM73_ADDRESS, lm73_rd_buf, 2); //read temperature data from LM73 (2 bytes) 
     69e:	42 e0       	ldi	r20, 0x02	; 2
     6a0:	6b e9       	ldi	r22, 0x9B	; 155
     6a2:	71 e0       	ldi	r23, 0x01	; 1
     6a4:	80 e9       	ldi	r24, 0x90	; 144
     6a6:	0e 94 a8 0a 	call	0x1550	; 0x1550 <twi_start_rd>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     6aa:	8f e9       	ldi	r24, 0x9F	; 159
     6ac:	9f e0       	ldi	r25, 0x0F	; 15
     6ae:	01 97       	sbiw	r24, 0x01	; 1
     6b0:	f1 f7       	brne	.-4      	; 0x6ae <get_local_temp+0x14>
     6b2:	00 c0       	rjmp	.+0      	; 0x6b4 <get_local_temp+0x1a>
     6b4:	00 00       	nop
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
     6b6:	80 91 9b 01 	lds	r24, 0x019B	; 0x80019b <lm73_rd_buf>
     6ba:	90 91 9c 01 	lds	r25, 0x019C	; 0x80019c <lm73_rd_buf+0x1>
     6be:	98 27       	eor	r25, r24
     6c0:	89 27       	eor	r24, r25
     6c2:	98 27       	eor	r25, r24
     6c4:	4a e0       	ldi	r20, 0x0A	; 10
     6c6:	64 e6       	ldi	r22, 0x64	; 100
     6c8:	71 e0       	ldi	r23, 0x01	; 1
     6ca:	88 0f       	add	r24, r24
     6cc:	89 2f       	mov	r24, r25
     6ce:	88 1f       	adc	r24, r24
     6d0:	99 0b       	sbc	r25, r25
     6d2:	91 95       	neg	r25
     6d4:	0e 94 cc 0b 	call	0x1798	; 0x1798 <__itoa_ncheck>
  lm73_temp = lm73_rd_buf[0]; //save high temperature byte into lm73_temp
  lm73_temp = lm73_temp << 8; //shift it into upper byte 
  lm73_temp |= lm73_rd_buf[1]; //"OR" in the low temp byte to lm73_temp 
  itoa(lm73_temp >> 7, lcd_string_array, 10); //convert to string in array with itoa() from avr-libc                           

  lcd_array[16] = 'L';
     6d8:	e6 e1       	ldi	r30, 0x16	; 22
     6da:	f1 e0       	ldi	r31, 0x01	; 1
     6dc:	8c e4       	ldi	r24, 0x4C	; 76
     6de:	80 8b       	std	Z+16, r24	; 0x10
  lcd_array[17] = ':';  
     6e0:	8a e3       	ldi	r24, 0x3A	; 58
     6e2:	81 8b       	std	Z+17, r24	; 0x11
  lcd_array[18] = lcd_string_array[0];  
     6e4:	a4 e6       	ldi	r26, 0x64	; 100
     6e6:	b1 e0       	ldi	r27, 0x01	; 1
     6e8:	8c 91       	ld	r24, X
     6ea:	82 8b       	std	Z+18, r24	; 0x12
  lcd_array[19] = lcd_string_array[1];  
     6ec:	11 96       	adiw	r26, 0x01	; 1
     6ee:	8c 91       	ld	r24, X
     6f0:	83 8b       	std	Z+19, r24	; 0x13
  lcd_array[20] = 'C';  
     6f2:	83 e4       	ldi	r24, 0x43	; 67
     6f4:	84 8b       	std	Z+20, r24	; 0x14
     6f6:	08 95       	ret

000006f8 <__vector_16>:
	update the mode and bargraph. Then I change the sum based on	
	the value returned from the encoder reading. Sum is then bounded
	from 0-1023. 1023+1=1 and 0-any number > 0 = 1023.
Parameters: NA
**********************************************************************/
ISR(TIMER0_OVF_vect) { 
     6f8:	1f 92       	push	r1
     6fa:	0f 92       	push	r0
     6fc:	0f b6       	in	r0, 0x3f	; 63
     6fe:	0f 92       	push	r0
     700:	11 24       	eor	r1, r1
     702:	0b b6       	in	r0, 0x3b	; 59
     704:	0f 92       	push	r0
     706:	2f 93       	push	r18
     708:	3f 93       	push	r19
     70a:	4f 93       	push	r20
     70c:	5f 93       	push	r21
     70e:	6f 93       	push	r22
     710:	7f 93       	push	r23
     712:	8f 93       	push	r24
     714:	9f 93       	push	r25
     716:	af 93       	push	r26
     718:	bf 93       	push	r27
     71a:	ef 93       	push	r30
     71c:	ff 93       	push	r31
   static uint8_t count_7_8125ms = 0;

   count_7_8125ms++;
     71e:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <count_7_8125ms.2045>
     722:	8f 5f       	subi	r24, 0xFF	; 255
     724:	80 93 4d 01 	sts	0x014D, r24	; 0x80014d <count_7_8125ms.2045>
   if((count_7_8125ms % 128) == 0) { //interrupts every 1 second
     728:	8f 77       	andi	r24, 0x7F	; 127
     72a:	29 f4       	brne	.+10     	; 0x736 <__vector_16+0x3e>
      sec_count++;
     72c:	80 91 4a 01 	lds	r24, 0x014A	; 0x80014a <sec_count>
     730:	8f 5f       	subi	r24, 0xFF	; 255
     732:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <sec_count>
   }
   bars();  
     736:	0e 94 2a 01 	call	0x254	; 0x254 <bars>
   read_encoder();      
     73a:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <read_encoder>

}
     73e:	ff 91       	pop	r31
     740:	ef 91       	pop	r30
     742:	bf 91       	pop	r27
     744:	af 91       	pop	r26
     746:	9f 91       	pop	r25
     748:	8f 91       	pop	r24
     74a:	7f 91       	pop	r23
     74c:	6f 91       	pop	r22
     74e:	5f 91       	pop	r21
     750:	4f 91       	pop	r20
     752:	3f 91       	pop	r19
     754:	2f 91       	pop	r18
     756:	0f 90       	pop	r0
     758:	0b be       	out	0x3b, r0	; 59
     75a:	0f 90       	pop	r0
     75c:	0f be       	out	0x3f, r0	; 63
     75e:	0f 90       	pop	r0
     760:	1f 90       	pop	r1
     762:	18 95       	reti

00000764 <__vector_15>:

ISR(TIMER0_COMP_vect) {
     764:	1f 92       	push	r1
     766:	0f 92       	push	r0
     768:	0f b6       	in	r0, 0x3f	; 63
     76a:	0f 92       	push	r0
     76c:	11 24       	eor	r1, r1
     76e:	0b b6       	in	r0, 0x3b	; 59
     770:	0f 92       	push	r0
     772:	2f 93       	push	r18
     774:	3f 93       	push	r19
     776:	4f 93       	push	r20
     778:	5f 93       	push	r21
     77a:	6f 93       	push	r22
     77c:	7f 93       	push	r23
     77e:	8f 93       	push	r24
     780:	9f 93       	push	r25
     782:	af 93       	push	r26
     784:	bf 93       	push	r27
     786:	ef 93       	push	r30
     788:	ff 93       	push	r31
   static uint8_t count7_8125ms = 0;

   count7_8125ms++;
     78a:	80 91 4c 01 	lds	r24, 0x014C	; 0x80014c <count7_8125ms.2051>
     78e:	8f 5f       	subi	r24, 0xFF	; 255
     790:	80 93 4c 01 	sts	0x014C, r24	; 0x80014c <count7_8125ms.2051>
   if((count7_8125ms % 128) == 0) { //interrupts every 1 second
     794:	8f 77       	andi	r24, 0x7F	; 127
     796:	11 f4       	brne	.+4      	; 0x79c <__vector_15+0x38>
      get_local_temp();
     798:	0e 94 4d 03 	call	0x69a	; 0x69a <get_local_temp>
   }

}
     79c:	ff 91       	pop	r31
     79e:	ef 91       	pop	r30
     7a0:	bf 91       	pop	r27
     7a2:	af 91       	pop	r26
     7a4:	9f 91       	pop	r25
     7a6:	8f 91       	pop	r24
     7a8:	7f 91       	pop	r23
     7aa:	6f 91       	pop	r22
     7ac:	5f 91       	pop	r21
     7ae:	4f 91       	pop	r20
     7b0:	3f 91       	pop	r19
     7b2:	2f 91       	pop	r18
     7b4:	0f 90       	pop	r0
     7b6:	0b be       	out	0x3b, r0	; 59
     7b8:	0f 90       	pop	r0
     7ba:	0f be       	out	0x3f, r0	; 63
     7bc:	0f 90       	pop	r0
     7be:	1f 90       	pop	r1
     7c0:	18 95       	reti

000007c2 <clock_time>:
	selected alarm time or normal time is displayed.
Parameters: NA
**********************************************************************/
void clock_time(){ //by default we use military time
//This block is used to increment the time based on an increasing seconds count   
   if(sec_count == 60){
     7c2:	80 91 4a 01 	lds	r24, 0x014A	; 0x80014a <sec_count>
     7c6:	8c 33       	cpi	r24, 0x3C	; 60
     7c8:	09 f4       	brne	.+2      	; 0x7cc <clock_time+0xa>
     7ca:	a4 c0       	rjmp	.+328    	; 0x914 <clock_time+0x152>
	 }//hours	
      }//mins
   }//secs

//This is where the digits are written to the data array
      if(mode_sel == 2){	//display alarm time
     7cc:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <mode_sel>
     7d0:	90 91 3c 01 	lds	r25, 0x013C	; 0x80013c <mode_sel+0x1>
     7d4:	02 97       	sbiw	r24, 0x02	; 2
     7d6:	09 f4       	brne	.+2      	; 0x7da <clock_time+0x18>
     7d8:	5a c0       	rjmp	.+180    	; 0x88e <clock_time+0xcc>
         else {segment_data[2] = 0b111;}		//Turn colon off
         segment_data[1] = dec_to_7seg[a_min_count/10];
         segment_data[0] = dec_to_7seg[a_min_count%10];
      }
      else{			//display military time
         segment_data[4] = dec_to_7seg[hour_count/10];
     7da:	90 91 48 01 	lds	r25, 0x0148	; 0x800148 <hour_count>
     7de:	87 e6       	ldi	r24, 0x67	; 103
     7e0:	98 02       	muls	r25, r24
     7e2:	e1 2d       	mov	r30, r1
     7e4:	11 24       	eor	r1, r1
     7e6:	e5 95       	asr	r30
     7e8:	e5 95       	asr	r30
     7ea:	97 fd       	sbrc	r25, 7
     7ec:	e3 95       	inc	r30
     7ee:	0e 2e       	mov	r0, r30
     7f0:	00 0c       	add	r0, r0
     7f2:	ff 0b       	sbc	r31, r31
     7f4:	e0 50       	subi	r30, 0x00	; 0
     7f6:	ff 4f       	sbci	r31, 0xFF	; 255
     7f8:	90 81       	ld	r25, Z
     7fa:	90 93 3a 01 	sts	0x013A, r25	; 0x80013a <__data_end+0x4>
         segment_data[3] = dec_to_7seg[hour_count%10];
     7fe:	e0 91 48 01 	lds	r30, 0x0148	; 0x800148 <hour_count>
     802:	e8 02       	muls	r30, r24
     804:	81 2d       	mov	r24, r1
     806:	11 24       	eor	r1, r1
     808:	85 95       	asr	r24
     80a:	85 95       	asr	r24
     80c:	e7 fd       	sbrc	r30, 7
     80e:	83 95       	inc	r24
     810:	9a e0       	ldi	r25, 0x0A	; 10
     812:	89 9f       	mul	r24, r25
     814:	e0 19       	sub	r30, r0
     816:	11 24       	eor	r1, r1
     818:	0e 2e       	mov	r0, r30
     81a:	00 0c       	add	r0, r0
     81c:	ff 0b       	sbc	r31, r31
     81e:	e0 50       	subi	r30, 0x00	; 0
     820:	ff 4f       	sbci	r31, 0xFF	; 255
     822:	80 81       	ld	r24, Z
     824:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <__data_end+0x3>
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     828:	80 91 4a 01 	lds	r24, 0x014A	; 0x80014a <sec_count>
     82c:	80 fd       	sbrc	r24, 0
     82e:	2b c0       	rjmp	.+86     	; 0x886 <clock_time+0xc4>
         else {segment_data[2] = 0b111;}		//Turn colon off
     830:	87 e0       	ldi	r24, 0x07	; 7
     832:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <__data_end+0x2>
         segment_data[1] = dec_to_7seg[min_count/10];
     836:	90 91 49 01 	lds	r25, 0x0149	; 0x800149 <min_count>
     83a:	87 e6       	ldi	r24, 0x67	; 103
     83c:	98 02       	muls	r25, r24
     83e:	e1 2d       	mov	r30, r1
     840:	11 24       	eor	r1, r1
     842:	e5 95       	asr	r30
     844:	e5 95       	asr	r30
     846:	97 fd       	sbrc	r25, 7
     848:	e3 95       	inc	r30
     84a:	0e 2e       	mov	r0, r30
     84c:	00 0c       	add	r0, r0
     84e:	ff 0b       	sbc	r31, r31
     850:	e0 50       	subi	r30, 0x00	; 0
     852:	ff 4f       	sbci	r31, 0xFF	; 255
     854:	90 81       	ld	r25, Z
     856:	90 93 37 01 	sts	0x0137, r25	; 0x800137 <__data_end+0x1>
         segment_data[0] = dec_to_7seg[min_count%10];
     85a:	e0 91 49 01 	lds	r30, 0x0149	; 0x800149 <min_count>
     85e:	e8 02       	muls	r30, r24
     860:	81 2d       	mov	r24, r1
     862:	11 24       	eor	r1, r1
     864:	85 95       	asr	r24
     866:	85 95       	asr	r24
     868:	e7 fd       	sbrc	r30, 7
     86a:	83 95       	inc	r24
     86c:	9a e0       	ldi	r25, 0x0A	; 10
     86e:	89 9f       	mul	r24, r25
     870:	e0 19       	sub	r30, r0
     872:	11 24       	eor	r1, r1
     874:	0e 2e       	mov	r0, r30
     876:	00 0c       	add	r0, r0
     878:	ff 0b       	sbc	r31, r31
     87a:	e0 50       	subi	r30, 0x00	; 0
     87c:	ff 4f       	sbci	r31, 0xFF	; 255
     87e:	80 81       	ld	r24, Z
     880:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__data_end>
     884:	08 95       	ret
         segment_data[0] = dec_to_7seg[a_min_count%10];
      }
      else{			//display military time
         segment_data[4] = dec_to_7seg[hour_count/10];
         segment_data[3] = dec_to_7seg[hour_count%10];
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     886:	84 e0       	ldi	r24, 0x04	; 4
     888:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <__data_end+0x2>
     88c:	d4 cf       	rjmp	.-88     	; 0x836 <clock_time+0x74>
      }//mins
   }//secs

//This is where the digits are written to the data array
      if(mode_sel == 2){	//display alarm time
         segment_data[4] = dec_to_7seg[a_hour_count/10];
     88e:	90 91 45 01 	lds	r25, 0x0145	; 0x800145 <a_hour_count>
     892:	87 e6       	ldi	r24, 0x67	; 103
     894:	98 02       	muls	r25, r24
     896:	e1 2d       	mov	r30, r1
     898:	11 24       	eor	r1, r1
     89a:	e5 95       	asr	r30
     89c:	e5 95       	asr	r30
     89e:	97 fd       	sbrc	r25, 7
     8a0:	e3 95       	inc	r30
     8a2:	0e 2e       	mov	r0, r30
     8a4:	00 0c       	add	r0, r0
     8a6:	ff 0b       	sbc	r31, r31
     8a8:	e0 50       	subi	r30, 0x00	; 0
     8aa:	ff 4f       	sbci	r31, 0xFF	; 255
     8ac:	90 81       	ld	r25, Z
     8ae:	90 93 3a 01 	sts	0x013A, r25	; 0x80013a <__data_end+0x4>
         segment_data[3] = dec_to_7seg[a_hour_count%10];
     8b2:	e0 91 45 01 	lds	r30, 0x0145	; 0x800145 <a_hour_count>
     8b6:	e8 02       	muls	r30, r24
     8b8:	81 2d       	mov	r24, r1
     8ba:	11 24       	eor	r1, r1
     8bc:	85 95       	asr	r24
     8be:	85 95       	asr	r24
     8c0:	e7 fd       	sbrc	r30, 7
     8c2:	83 95       	inc	r24
     8c4:	9a e0       	ldi	r25, 0x0A	; 10
     8c6:	89 9f       	mul	r24, r25
     8c8:	e0 19       	sub	r30, r0
     8ca:	11 24       	eor	r1, r1
     8cc:	0e 2e       	mov	r0, r30
     8ce:	00 0c       	add	r0, r0
     8d0:	ff 0b       	sbc	r31, r31
     8d2:	e0 50       	subi	r30, 0x00	; 0
     8d4:	ff 4f       	sbci	r31, 0xFF	; 255
     8d6:	80 81       	ld	r24, Z
     8d8:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <__data_end+0x3>
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     8dc:	80 91 4a 01 	lds	r24, 0x014A	; 0x80014a <sec_count>
     8e0:	80 fd       	sbrc	r24, 0
     8e2:	33 c0       	rjmp	.+102    	; 0x94a <clock_time+0x188>
         else {segment_data[2] = 0b111;}		//Turn colon off
     8e4:	87 e0       	ldi	r24, 0x07	; 7
     8e6:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <__data_end+0x2>
         segment_data[1] = dec_to_7seg[a_min_count/10];
     8ea:	90 91 46 01 	lds	r25, 0x0146	; 0x800146 <a_min_count>
     8ee:	87 e6       	ldi	r24, 0x67	; 103
     8f0:	98 02       	muls	r25, r24
     8f2:	e1 2d       	mov	r30, r1
     8f4:	11 24       	eor	r1, r1
     8f6:	e5 95       	asr	r30
     8f8:	e5 95       	asr	r30
     8fa:	97 fd       	sbrc	r25, 7
     8fc:	e3 95       	inc	r30
     8fe:	0e 2e       	mov	r0, r30
     900:	00 0c       	add	r0, r0
     902:	ff 0b       	sbc	r31, r31
     904:	e0 50       	subi	r30, 0x00	; 0
     906:	ff 4f       	sbci	r31, 0xFF	; 255
     908:	90 81       	ld	r25, Z
     90a:	90 93 37 01 	sts	0x0137, r25	; 0x800137 <__data_end+0x1>
         segment_data[0] = dec_to_7seg[a_min_count%10];
     90e:	e0 91 46 01 	lds	r30, 0x0146	; 0x800146 <a_min_count>
     912:	a5 cf       	rjmp	.-182    	; 0x85e <clock_time+0x9c>
Parameters: NA
**********************************************************************/
void clock_time(){ //by default we use military time
//This block is used to increment the time based on an increasing seconds count   
   if(sec_count == 60){
      min_count++;
     914:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <min_count>
     918:	8f 5f       	subi	r24, 0xFF	; 255
     91a:	80 93 49 01 	sts	0x0149, r24	; 0x800149 <min_count>
      sec_count = 0;
     91e:	10 92 4a 01 	sts	0x014A, r1	; 0x80014a <sec_count>
      if(min_count == 60){
     922:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <min_count>
     926:	8c 33       	cpi	r24, 0x3C	; 60
     928:	09 f0       	breq	.+2      	; 0x92c <clock_time+0x16a>
     92a:	50 cf       	rjmp	.-352    	; 0x7cc <clock_time+0xa>
	 hour_count++;
     92c:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <hour_count>
     930:	8f 5f       	subi	r24, 0xFF	; 255
     932:	80 93 48 01 	sts	0x0148, r24	; 0x800148 <hour_count>
	 min_count = 0;
     936:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <min_count>
	 if(hour_count == 24){
     93a:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <hour_count>
     93e:	88 31       	cpi	r24, 0x18	; 24
     940:	09 f0       	breq	.+2      	; 0x944 <clock_time+0x182>
     942:	44 cf       	rjmp	.-376    	; 0x7cc <clock_time+0xa>
	    hour_count = 0;
     944:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <hour_count>
     948:	41 cf       	rjmp	.-382    	; 0x7cc <clock_time+0xa>

//This is where the digits are written to the data array
      if(mode_sel == 2){	//display alarm time
         segment_data[4] = dec_to_7seg[a_hour_count/10];
         segment_data[3] = dec_to_7seg[a_hour_count%10];
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     94a:	84 e0       	ldi	r24, 0x04	; 4
     94c:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <__data_end+0x2>
     950:	cc cf       	rjmp	.-104    	; 0x8ea <clock_time+0x128>

00000952 <port_init>:
Function: port_init
Description: General port initialization and setting pull up resistors
Parameters: NA
**********************************************************************/
void port_init(){
   DDRC |= 0xFF; 
     952:	84 b3       	in	r24, 0x14	; 20
     954:	8f ef       	ldi	r24, 0xFF	; 255
     956:	84 bb       	out	0x14, r24	; 20
   DDRB |= 0xF0;				//PB4-6 is SEL0-2, PB7 is PWM
     958:	97 b3       	in	r25, 0x17	; 23
     95a:	90 6f       	ori	r25, 0xF0	; 240
     95c:	97 bb       	out	0x17, r25	; 23
   DDRE |= 0x4F;				//PE6 is SHIFT_LD_N
     95e:	92 b1       	in	r25, 0x02	; 2
     960:	9f 64       	ori	r25, 0x4F	; 79
     962:	92 b9       	out	0x02, r25	; 2
   DDRD |= 0xFF;				//PE1 is CLK_INH and PE2 is SRCLK
     964:	91 b3       	in	r25, 0x11	; 17
     966:	81 bb       	out	0x11, r24	; 17
   PORTC |= 0x01;
     968:	a8 9a       	sbi	0x15, 0	; 21
   PORTD |= 0xFF;
     96a:	92 b3       	in	r25, 0x12	; 18
     96c:	82 bb       	out	0x12, r24	; 18
   PORTE |= 0xFF;
     96e:	93 b1       	in	r25, 0x03	; 3
     970:	83 b9       	out	0x03, r24	; 3
     972:	08 95       	ret

00000974 <change_alarm_state>:
      }
      curr = 1;	//indicated that alarm has been written to the display next time
	//through the function
   }
	//clears display when the alarm is turned off*/
   if(alarm && (curr ==0)){
     974:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <alarm>
     978:	88 23       	and	r24, r24
     97a:	21 f0       	breq	.+8      	; 0x984 <change_alarm_state+0x10>
     97c:	80 91 4b 01 	lds	r24, 0x014B	; 0x80014b <curr.2058>
     980:	88 23       	and	r24, r24
     982:	49 f0       	breq	.+18     	; 0x996 <change_alarm_state+0x22>
      lcd_array[2] = 'a';
      lcd_array[3] = 'r';
      lcd_array[4] = 'm';
      curr = 1;
   }
   else if((!alarm) && (curr == 1)){
     984:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <alarm>
     988:	81 11       	cpse	r24, r1
     98a:	04 c0       	rjmp	.+8      	; 0x994 <change_alarm_state+0x20>
     98c:	80 91 4b 01 	lds	r24, 0x014B	; 0x80014b <curr.2058>
     990:	81 30       	cpi	r24, 0x01	; 1
     992:	a1 f0       	breq	.+40     	; 0x9bc <change_alarm_state+0x48>
     994:	08 95       	ret
	//through the function
   }
	//clears display when the alarm is turned off*/
   if(alarm && (curr ==0)){
      //string2lcd("Alarm");
      lcd_array[0] = 'A';
     996:	81 e4       	ldi	r24, 0x41	; 65
     998:	80 93 16 01 	sts	0x0116, r24	; 0x800116 <lcd_array>
      lcd_array[1] = 'l';
     99c:	8c e6       	ldi	r24, 0x6C	; 108
     99e:	80 93 17 01 	sts	0x0117, r24	; 0x800117 <lcd_array+0x1>
      lcd_array[2] = 'a';
     9a2:	81 e6       	ldi	r24, 0x61	; 97
     9a4:	80 93 18 01 	sts	0x0118, r24	; 0x800118 <lcd_array+0x2>
      lcd_array[3] = 'r';
     9a8:	82 e7       	ldi	r24, 0x72	; 114
     9aa:	80 93 19 01 	sts	0x0119, r24	; 0x800119 <lcd_array+0x3>
      lcd_array[4] = 'm';
     9ae:	8d e6       	ldi	r24, 0x6D	; 109
     9b0:	80 93 1a 01 	sts	0x011A, r24	; 0x80011a <lcd_array+0x4>
      curr = 1;
     9b4:	81 e0       	ldi	r24, 0x01	; 1
     9b6:	80 93 4b 01 	sts	0x014B, r24	; 0x80014b <curr.2058>
     9ba:	08 95       	ret
   }
   else if((!alarm) && (curr == 1)){
      curr = 0;
     9bc:	10 92 4b 01 	sts	0x014B, r1	; 0x80014b <curr.2058>
      lcd_array[0] = ' ';
     9c0:	80 e2       	ldi	r24, 0x20	; 32
     9c2:	80 93 16 01 	sts	0x0116, r24	; 0x800116 <lcd_array>
      lcd_array[1] = ' ';
     9c6:	80 93 17 01 	sts	0x0117, r24	; 0x800117 <lcd_array+0x1>
      lcd_array[2] = ' ';
     9ca:	80 93 18 01 	sts	0x0118, r24	; 0x800118 <lcd_array+0x2>
      lcd_array[3] = ' ';
     9ce:	80 93 19 01 	sts	0x0119, r24	; 0x800119 <lcd_array+0x3>
      lcd_array[4] = ' ';
     9d2:	80 93 1a 01 	sts	0x011A, r24	; 0x80011a <lcd_array+0x4>
     9d6:	08 95       	ret

000009d8 <adc_init>:
Description: Basic adc initialization used for single shot adc readings
Parameters: NA
**********************************************************************/
void adc_init(){
//Initalize ADC and its ports
   DDRF  &= ~(_BV(DDF7)); //make port F bit 7 is ADC input  
     9d8:	e1 e6       	ldi	r30, 0x61	; 97
     9da:	f0 e0       	ldi	r31, 0x00	; 0
     9dc:	80 81       	ld	r24, Z
     9de:	8f 77       	andi	r24, 0x7F	; 127
     9e0:	80 83       	st	Z, r24
   PORTF &= ~(_BV(PF7));  //port F bit 7 pullups must be off
     9e2:	e2 e6       	ldi	r30, 0x62	; 98
     9e4:	f0 e0       	ldi	r31, 0x00	; 0
     9e6:	80 81       	ld	r24, Z
     9e8:	8f 77       	andi	r24, 0x7F	; 127
     9ea:	80 83       	st	Z, r24
   ADMUX |= (1<<REFS0) | (1<<MUX2)| (1<<MUX1)| (1<<MUX0); //single-ended, input PORTF bit 7, right adjusted, 10 bits
     9ec:	87 b1       	in	r24, 0x07	; 7
     9ee:	87 64       	ori	r24, 0x47	; 71
     9f0:	87 b9       	out	0x07, r24	; 7

   ADCSRA |= (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);//ADC enabled, don't start yet, single shot mode 
     9f2:	86 b1       	in	r24, 0x06	; 6
     9f4:	87 68       	ori	r24, 0x87	; 135
     9f6:	86 b9       	out	0x06, r24	; 6
     9f8:	08 95       	ret

000009fa <fetch_adc>:
void fetch_adc(){
   uint16_t adc_result;
   uint16_t step;   
   uint16_t step2;   

   ADCSRA |= (1<<ADSC); //poke ADSC and start conversion
     9fa:	36 9a       	sbi	0x06, 6	; 6
   while(bit_is_clear(ADCSRA, ADIF)){} //spin while interrupt flag not set
     9fc:	34 9b       	sbis	0x06, 4	; 6
     9fe:	fe cf       	rjmp	.-4      	; 0x9fc <fetch_adc+0x2>
   ACSR |= (1<<ACI); //its done, clear flag by writing a one 
     a00:	44 9a       	sbi	0x08, 4	; 8
   adc_result = ADC;                      //read the ADC output as 16 bits
     a02:	24 b1       	in	r18, 0x04	; 4
     a04:	35 b1       	in	r19, 0x05	; 5

   step = adc_result/4;//scales the adc result from 0-255
   step2 =  255 - step;//I need the complement to the adc result
     a06:	36 95       	lsr	r19
     a08:	27 95       	ror	r18
     a0a:	36 95       	lsr	r19
     a0c:	27 95       	ror	r18
   if(step2 > 235){	//this is a minimum brightness level
      step2 = 235;
   }

   OCR2 = step2;	//Write brightness level to tnct2 compare match register
     a0e:	8f ef       	ldi	r24, 0xFF	; 255
     a10:	90 e0       	ldi	r25, 0x00	; 0
     a12:	82 1b       	sub	r24, r18
     a14:	93 0b       	sbc	r25, r19
     a16:	8c 3e       	cpi	r24, 0xEC	; 236
     a18:	91 05       	cpc	r25, r1
     a1a:	10 f0       	brcs	.+4      	; 0xa20 <fetch_adc+0x26>
     a1c:	8b ee       	ldi	r24, 0xEB	; 235
     a1e:	90 e0       	ldi	r25, 0x00	; 0
     a20:	83 bd       	out	0x23, r24	; 35
     a22:	08 95       	ret

00000a24 <__vector_12>:
Function: TIMER!_COMPA_vect
Description: This ISR creates the alarm frequency on PORTD but 3 the is used
	for the alarm tone.
Parameters: NA
**********************************************************************/
ISR(TIMER1_COMPA_vect){
     a24:	1f 92       	push	r1
     a26:	0f 92       	push	r0
     a28:	0f b6       	in	r0, 0x3f	; 63
     a2a:	0f 92       	push	r0
     a2c:	11 24       	eor	r1, r1
     a2e:	8f 93       	push	r24
     a30:	9f 93       	push	r25
   //static uint8_t seconds = 0;
   //bars();  //displays the mode on the bargraph
   //read_encoder();     //reads the encoder values
if(!snooze){ //alarm has not been snoozed
     a32:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <snooze>
     a36:	81 11       	cpse	r24, r1
     a38:	0a c0       	rjmp	.+20     	; 0xa4e <__vector_12+0x2a>
//checks to see alarm is on and the alarm time matches clock time
   if(alarm && ((hour_count == a_hour_count) && (min_count == a_min_count))){
     a3a:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <alarm>
     a3e:	88 23       	and	r24, r24
     a40:	31 f0       	breq	.+12     	; 0xa4e <__vector_12+0x2a>
     a42:	90 91 48 01 	lds	r25, 0x0148	; 0x800148 <hour_count>
     a46:	80 91 45 01 	lds	r24, 0x0145	; 0x800145 <a_hour_count>
     a4a:	98 17       	cp	r25, r24
     a4c:	39 f0       	breq	.+14     	; 0xa5c <__vector_12+0x38>
      PORTD = PIND ^ 0b00000100;//toggles PD3 to create frequency
   }
}
}
     a4e:	9f 91       	pop	r25
     a50:	8f 91       	pop	r24
     a52:	0f 90       	pop	r0
     a54:	0f be       	out	0x3f, r0	; 63
     a56:	0f 90       	pop	r0
     a58:	1f 90       	pop	r1
     a5a:	18 95       	reti
   //static uint8_t seconds = 0;
   //bars();  //displays the mode on the bargraph
   //read_encoder();     //reads the encoder values
if(!snooze){ //alarm has not been snoozed
//checks to see alarm is on and the alarm time matches clock time
   if(alarm && ((hour_count == a_hour_count) && (min_count == a_min_count))){
     a5c:	90 91 49 01 	lds	r25, 0x0149	; 0x800149 <min_count>
     a60:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <a_min_count>
     a64:	98 13       	cpse	r25, r24
     a66:	f3 cf       	rjmp	.-26     	; 0xa4e <__vector_12+0x2a>
      PORTD = PIND ^ 0b00000100;//toggles PD3 to create frequency
     a68:	90 b3       	in	r25, 0x10	; 16
     a6a:	84 e0       	ldi	r24, 0x04	; 4
     a6c:	89 27       	eor	r24, r25
     a6e:	82 bb       	out	0x12, r24	; 18
   }
}
}
     a70:	ee cf       	rjmp	.-36     	; 0xa4e <__vector_12+0x2a>

00000a72 <snoozin>:
Description: This function disables the snooze variable once the alarm
	seconds equals the normal seconds. 
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
     a72:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <snooze>
     a76:	81 11       	cpse	r24, r1
     a78:	0c 94 b8 00 	jmp	0x170	; 0x170 <snoozin.part.1>
     a7c:	08 95       	ret

00000a7e <local_temp_init>:
Description: 
Parameters: NA
**********************************************************************/
void local_temp_init(){

lm73_wr_buf[0] = 0x00; //load lm73_wr_buf[0] with temperature pointer address
     a7e:	10 92 99 01 	sts	0x0199, r1	; 0x800199 <lm73_wr_buf>
twi_start_wr(LM73_ADDRESS, lm73_rd_buf, 1); //start the TWI write process
     a82:	41 e0       	ldi	r20, 0x01	; 1
     a84:	6b e9       	ldi	r22, 0x9B	; 155
     a86:	71 e0       	ldi	r23, 0x01	; 1
     a88:	80 e9       	ldi	r24, 0x90	; 144
     a8a:	0e 94 97 0a 	call	0x152e	; 0x152e <twi_start_wr>
     a8e:	8f e3       	ldi	r24, 0x3F	; 63
     a90:	9f e1       	ldi	r25, 0x1F	; 31
     a92:	01 97       	sbiw	r24, 0x01	; 1
     a94:	f1 f7       	brne	.-4      	; 0xa92 <local_temp_init+0x14>
     a96:	00 c0       	rjmp	.+0      	; 0xa98 <local_temp_init+0x1a>
     a98:	00 00       	nop
     a9a:	08 95       	ret

00000a9c <send_lcd>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     a9c:	91 e0       	ldi	r25, 0x01	; 1
     a9e:	81 11       	cpse	r24, r1
     aa0:	01 c0       	rjmp	.+2      	; 0xaa4 <send_lcd+0x8>
     aa2:	90 e0       	ldi	r25, 0x00	; 0
     aa4:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     aa6:	77 9b       	sbis	0x0e, 7	; 14
     aa8:	fe cf       	rjmp	.-4      	; 0xaa6 <send_lcd+0xa>
  SPDR = byte;                        //send payload
     aaa:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     aac:	77 9b       	sbis	0x0e, 7	; 14
     aae:	fe cf       	rjmp	.-4      	; 0xaac <send_lcd+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     ab0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ab4:	88 60       	ori	r24, 0x08	; 8
     ab6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     aba:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     abe:	87 7f       	andi	r24, 0xF7	; 247
     ac0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ac4:	08 95       	ret

00000ac6 <refresh_lcd>:
//
void refresh_lcd(char lcd_string_array[]) {

  static uint8_t i=0;           // index into string array 

 send_lcd(CHAR_BYTE,lcd_string_array[i]);
     ac6:	20 91 5e 01 	lds	r18, 0x015E	; 0x80015e <i.2095>
     aca:	82 0f       	add	r24, r18
     acc:	91 1d       	adc	r25, r1
     ace:	fc 01       	movw	r30, r24
     ad0:	80 81       	ld	r24, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ad2:	91 e0       	ldi	r25, 0x01	; 1
     ad4:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ad6:	77 9b       	sbis	0x0e, 7	; 14
     ad8:	fe cf       	rjmp	.-4      	; 0xad6 <refresh_lcd+0x10>
  SPDR = byte;                        //send payload
     ada:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     adc:	77 9b       	sbis	0x0e, 7	; 14
     ade:	fe cf       	rjmp	.-4      	; 0xadc <refresh_lcd+0x16>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     ae0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ae4:	88 60       	ori	r24, 0x08	; 8
     ae6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     aea:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     aee:	87 7f       	andi	r24, 0xF7	; 247
     af0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
void refresh_lcd(char lcd_string_array[]) {

  static uint8_t i=0;           // index into string array 

 send_lcd(CHAR_BYTE,lcd_string_array[i]);
 i++;   //increment to next character
     af4:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <i.2095>
     af8:	8f 5f       	subi	r24, 0xFF	; 255
     afa:	80 93 5e 01 	sts	0x015E, r24	; 0x80015e <i.2095>
 //delays are inserted to allow character to be written before moving
 //the cursor to the next line.
 if(i == 16){_delay_us(40); line2_col1();      } //goto line 2, 1st char 
     afe:	80 31       	cpi	r24, 0x10	; 16
     b00:	f9 f0       	breq	.+62     	; 0xb40 <refresh_lcd+0x7a>
 if(i == 32){_delay_us(40); line1_col1(); i=0; } //goto line 1, 1st char 
     b02:	80 32       	cpi	r24, 0x20	; 32
     b04:	09 f0       	breq	.+2      	; 0xb08 <refresh_lcd+0x42>
     b06:	08 95       	ret
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     b08:	e5 ed       	ldi	r30, 0xD5	; 213
     b0a:	ea 95       	dec	r30
     b0c:	f1 f7       	brne	.-4      	; 0xb0a <refresh_lcd+0x44>
     b0e:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b10:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b12:	77 9b       	sbis	0x0e, 7	; 14
     b14:	fe cf       	rjmp	.-4      	; 0xb12 <refresh_lcd+0x4c>
  SPDR = byte;                        //send payload
     b16:	80 e8       	ldi	r24, 0x80	; 128
     b18:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b1a:	77 9b       	sbis	0x0e, 7	; 14
     b1c:	fe cf       	rjmp	.-4      	; 0xb1a <refresh_lcd+0x54>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b1e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b22:	88 60       	ori	r24, 0x08	; 8
     b24:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b28:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b2c:	87 7f       	andi	r24, 0xF7	; 247
     b2e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b32:	f5 ed       	ldi	r31, 0xD5	; 213
     b34:	fa 95       	dec	r31
     b36:	f1 f7       	brne	.-4      	; 0xb34 <refresh_lcd+0x6e>
     b38:	00 00       	nop
 send_lcd(CHAR_BYTE,lcd_string_array[i]);
 i++;   //increment to next character
 //delays are inserted to allow character to be written before moving
 //the cursor to the next line.
 if(i == 16){_delay_us(40); line2_col1();      } //goto line 2, 1st char 
 if(i == 32){_delay_us(40); line1_col1(); i=0; } //goto line 1, 1st char 
     b3a:	10 92 5e 01 	sts	0x015E, r1	; 0x80015e <i.2095>
     b3e:	08 95       	ret
     b40:	f5 ed       	ldi	r31, 0xD5	; 213
     b42:	fa 95       	dec	r31
     b44:	f1 f7       	brne	.-4      	; 0xb42 <refresh_lcd+0x7c>
     b46:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b48:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b4a:	77 9b       	sbis	0x0e, 7	; 14
     b4c:	fe cf       	rjmp	.-4      	; 0xb4a <refresh_lcd+0x84>
  SPDR = byte;                        //send payload
     b4e:	80 ec       	ldi	r24, 0xC0	; 192
     b50:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b52:	77 9b       	sbis	0x0e, 7	; 14
     b54:	fe cf       	rjmp	.-4      	; 0xb52 <refresh_lcd+0x8c>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b56:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b5a:	88 60       	ori	r24, 0x08	; 8
     b5c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b60:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b64:	87 7f       	andi	r24, 0xF7	; 247
     b66:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b6a:	85 ed       	ldi	r24, 0xD5	; 213
     b6c:	8a 95       	dec	r24
     b6e:	f1 f7       	brne	.-4      	; 0xb6c <refresh_lcd+0xa6>
     b70:	00 00       	nop
     b72:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <i.2095>
     b76:	c5 cf       	rjmp	.-118    	; 0xb02 <refresh_lcd+0x3c>

00000b78 <set_custom_character>:
//address, such as send_lcd(CHAR_BYTE, 0x01, 1) or it can be insteretd into a string 
//via a forward slash escape as in string2lcd("this is my music note \1")

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
     b78:	66 0f       	add	r22, r22
     b7a:	66 0f       	add	r22, r22
     b7c:	66 0f       	add	r22, r22
     b7e:	60 5c       	subi	r22, 0xC0	; 192
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b80:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b82:	77 9b       	sbis	0x0e, 7	; 14
     b84:	fe cf       	rjmp	.-4      	; 0xb82 <set_custom_character+0xa>
  SPDR = byte;                        //send payload
     b86:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b88:	77 9b       	sbis	0x0e, 7	; 14
     b8a:	fe cf       	rjmp	.-4      	; 0xb88 <set_custom_character+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b8c:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b90:	28 60       	ori	r18, 0x08	; 8
     b92:	20 93 62 00 	sts	0x0062, r18	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b96:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b9a:	27 7f       	andi	r18, 0xF7	; 247
     b9c:	20 93 62 00 	sts	0x0062, r18	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ba0:	25 ed       	ldi	r18, 0xD5	; 213
     ba2:	2a 95       	dec	r18
     ba4:	f1 f7       	brne	.-4      	; 0xba2 <set_custom_character+0x2a>
     ba6:	00 00       	nop
     ba8:	fc 01       	movw	r30, r24
     baa:	9c 01       	movw	r18, r24
     bac:	28 5f       	subi	r18, 0xF8	; 248
     bae:	3f 4f       	sbci	r19, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     bb0:	91 e0       	ldi	r25, 0x01	; 1

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
    for(i=0; i<8; i++){
      send_lcd(CHAR_BYTE, data[i]); _delay_us(40); //each char byte takes 37us to execute
     bb2:	81 91       	ld	r24, Z+
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     bb4:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     bb6:	77 9b       	sbis	0x0e, 7	; 14
     bb8:	fe cf       	rjmp	.-4      	; 0xbb6 <set_custom_character+0x3e>
  SPDR = byte;                        //send payload
     bba:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     bbc:	77 9b       	sbis	0x0e, 7	; 14
     bbe:	fe cf       	rjmp	.-4      	; 0xbbc <set_custom_character+0x44>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     bc0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bc4:	88 60       	ori	r24, 0x08	; 8
     bc6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bca:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bce:	87 7f       	andi	r24, 0xF7	; 247
     bd0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bd4:	85 ed       	ldi	r24, 0xD5	; 213
     bd6:	8a 95       	dec	r24
     bd8:	f1 f7       	brne	.-4      	; 0xbd6 <set_custom_character+0x5e>
     bda:	00 00       	nop
//via a forward slash escape as in string2lcd("this is my music note \1")

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
    for(i=0; i<8; i++){
     bdc:	e2 17       	cp	r30, r18
     bde:	f3 07       	cpc	r31, r19
     be0:	41 f7       	brne	.-48     	; 0xbb2 <set_custom_character+0x3a>
      send_lcd(CHAR_BYTE, data[i]); _delay_us(40); //each char byte takes 37us to execute
    }
}
     be2:	08 95       	ret

00000be4 <set_cursor>:
//                          set_cursor 
//
//Sets the cursor to an arbitrary potition on the screen, row is either 1 or 2
//col is a number form 0-15, counting from left to right
void set_cursor(uint8_t row, uint8_t col){
    send_lcd(CMD_BYTE, 0x80 + col + ((row-1)*0x40));
     be4:	90 e4       	ldi	r25, 0x40	; 64
     be6:	89 9f       	mul	r24, r25
     be8:	60 0d       	add	r22, r0
     bea:	11 24       	eor	r1, r1
     bec:	60 5c       	subi	r22, 0xC0	; 192
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     bee:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     bf0:	77 9b       	sbis	0x0e, 7	; 14
     bf2:	fe cf       	rjmp	.-4      	; 0xbf0 <set_cursor+0xc>
  SPDR = byte;                        //send payload
     bf4:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     bf6:	77 9b       	sbis	0x0e, 7	; 14
     bf8:	fe cf       	rjmp	.-4      	; 0xbf6 <set_cursor+0x12>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     bfa:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bfe:	88 60       	ori	r24, 0x08	; 8
     c00:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c04:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c08:	87 7f       	andi	r24, 0xF7	; 247
     c0a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c0e:	08 95       	ret

00000c10 <uint2lcd>:
//not displayed.  
//TODO: optimize by removing the mod operators
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
     c10:	81 11       	cpse	r24, r1
     c12:	13 c0       	rjmp	.+38     	; 0xc3a <uint2lcd+0x2a>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c14:	81 e0       	ldi	r24, 0x01	; 1
     c16:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c18:	77 9b       	sbis	0x0e, 7	; 14
     c1a:	fe cf       	rjmp	.-4      	; 0xc18 <uint2lcd+0x8>
  SPDR = byte;                        //send payload
     c1c:	80 e3       	ldi	r24, 0x30	; 48
     c1e:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c20:	77 9b       	sbis	0x0e, 7	; 14
     c22:	fe cf       	rjmp	.-4      	; 0xc20 <uint2lcd+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     c24:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c28:	88 60       	ori	r24, 0x08	; 8
     c2a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c2e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c32:	87 7f       	andi	r24, 0xF7	; 247
     c34:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c38:	08 95       	ret
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
     c3a:	84 36       	cpi	r24, 0x64	; 100
     c3c:	b0 f4       	brcc	.+44     	; 0xc6a <uint2lcd+0x5a>
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
     c3e:	8a 30       	cpi	r24, 0x0A	; 10
     c40:	60 f5       	brcc	.+88     	; 0xc9a <uint2lcd+0x8a>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c42:	91 e0       	ldi	r25, 0x01	; 1
     c44:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c46:	77 9b       	sbis	0x0e, 7	; 14
     c48:	fe cf       	rjmp	.-4      	; 0xc46 <uint2lcd+0x36>
void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
      if(number >= 1)  {send_lcd(CHAR_BYTE, 0x30+(number%10)    ); }
     c4a:	9d ec       	ldi	r25, 0xCD	; 205
     c4c:	89 9f       	mul	r24, r25
     c4e:	91 2d       	mov	r25, r1
     c50:	11 24       	eor	r1, r1
     c52:	96 95       	lsr	r25
     c54:	96 95       	lsr	r25
     c56:	96 95       	lsr	r25
     c58:	2a e0       	ldi	r18, 0x0A	; 10
     c5a:	92 9f       	mul	r25, r18
     c5c:	80 19       	sub	r24, r0
     c5e:	11 24       	eor	r1, r1
     c60:	80 5d       	subi	r24, 0xD0	; 208
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
  SPDR = byte;                        //send payload
     c62:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c64:	77 9b       	sbis	0x0e, 7	; 14
     c66:	fe cf       	rjmp	.-4      	; 0xc64 <uint2lcd+0x54>
     c68:	dd cf       	rjmp	.-70     	; 0xc24 <uint2lcd+0x14>
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
     c6a:	99 e2       	ldi	r25, 0x29	; 41
     c6c:	89 9f       	mul	r24, r25
     c6e:	91 2d       	mov	r25, r1
     c70:	11 24       	eor	r1, r1
     c72:	92 95       	swap	r25
     c74:	9f 70       	andi	r25, 0x0F	; 15
     c76:	90 5d       	subi	r25, 0xD0	; 208
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c78:	21 e0       	ldi	r18, 0x01	; 1
     c7a:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c7c:	77 9b       	sbis	0x0e, 7	; 14
     c7e:	fe cf       	rjmp	.-4      	; 0xc7c <uint2lcd+0x6c>
  SPDR = byte;                        //send payload
     c80:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c82:	77 9b       	sbis	0x0e, 7	; 14
     c84:	fe cf       	rjmp	.-4      	; 0xc82 <uint2lcd+0x72>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     c86:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c8a:	98 60       	ori	r25, 0x08	; 8
     c8c:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c90:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c94:	97 7f       	andi	r25, 0xF7	; 247
     c96:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
     c9a:	99 e2       	ldi	r25, 0x29	; 41
     c9c:	89 9f       	mul	r24, r25
     c9e:	91 2d       	mov	r25, r1
     ca0:	11 24       	eor	r1, r1
     ca2:	92 95       	swap	r25
     ca4:	9f 70       	andi	r25, 0x0F	; 15
     ca6:	38 2f       	mov	r19, r24
     ca8:	24 e6       	ldi	r18, 0x64	; 100
     caa:	92 9f       	mul	r25, r18
     cac:	30 19       	sub	r19, r0
     cae:	11 24       	eor	r1, r1
     cb0:	2d ec       	ldi	r18, 0xCD	; 205
     cb2:	32 9f       	mul	r19, r18
     cb4:	91 2d       	mov	r25, r1
     cb6:	11 24       	eor	r1, r1
     cb8:	96 95       	lsr	r25
     cba:	96 95       	lsr	r25
     cbc:	96 95       	lsr	r25
     cbe:	90 5d       	subi	r25, 0xD0	; 208
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     cc0:	21 e0       	ldi	r18, 0x01	; 1
     cc2:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     cc4:	77 9b       	sbis	0x0e, 7	; 14
     cc6:	fe cf       	rjmp	.-4      	; 0xcc4 <uint2lcd+0xb4>
  SPDR = byte;                        //send payload
     cc8:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     cca:	77 9b       	sbis	0x0e, 7	; 14
     ccc:	fe cf       	rjmp	.-4      	; 0xcca <uint2lcd+0xba>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     cce:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cd2:	98 60       	ori	r25, 0x08	; 8
     cd4:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cd8:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cdc:	97 7f       	andi	r25, 0xF7	; 247
     cde:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ce2:	af cf       	rjmp	.-162    	; 0xc42 <uint2lcd+0x32>

00000ce4 <int2lcd>:
//Takes a 8bit signed and displays it in base ten on the LCD. Leading 0's are 
//not displayed.
//
void int2lcd(int8_t number){
    //if < 0, print minus sign, then take 2's complement of number and display
    if(number < 0){send_lcd(CHAR_BYTE, '-'); _delay_us(40); uint2lcd(~number+1);}  
     ce4:	87 ff       	sbrs	r24, 7
    else          {uint2lcd(number);                                            }
     ce6:	0c 94 08 06 	jmp	0xc10	; 0xc10 <uint2lcd>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     cea:	91 e0       	ldi	r25, 0x01	; 1
     cec:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     cee:	77 9b       	sbis	0x0e, 7	; 14
     cf0:	fe cf       	rjmp	.-4      	; 0xcee <int2lcd+0xa>
  SPDR = byte;                        //send payload
     cf2:	9d e2       	ldi	r25, 0x2D	; 45
     cf4:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     cf6:	77 9b       	sbis	0x0e, 7	; 14
     cf8:	fe cf       	rjmp	.-4      	; 0xcf6 <int2lcd+0x12>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     cfa:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cfe:	98 60       	ori	r25, 0x08	; 8
     d00:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d04:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d08:	97 7f       	andi	r25, 0xF7	; 247
     d0a:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d0e:	95 ed       	ldi	r25, 0xD5	; 213
     d10:	9a 95       	dec	r25
     d12:	f1 f7       	brne	.-4      	; 0xd10 <int2lcd+0x2c>
     d14:	00 00       	nop
//Takes a 8bit signed and displays it in base ten on the LCD. Leading 0's are 
//not displayed.
//
void int2lcd(int8_t number){
    //if < 0, print minus sign, then take 2's complement of number and display
    if(number < 0){send_lcd(CHAR_BYTE, '-'); _delay_us(40); uint2lcd(~number+1);}  
     d16:	81 95       	neg	r24
     d18:	0c 94 08 06 	jmp	0xc10	; 0xc10 <uint2lcd>

00000d1c <cursor_on>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d1c:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d1e:	77 9b       	sbis	0x0e, 7	; 14
     d20:	fe cf       	rjmp	.-4      	; 0xd1e <cursor_on+0x2>
  SPDR = byte;                        //send payload
     d22:	8e e0       	ldi	r24, 0x0E	; 14
     d24:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d26:	77 9b       	sbis	0x0e, 7	; 14
     d28:	fe cf       	rjmp	.-4      	; 0xd26 <cursor_on+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d2a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d2e:	88 60       	ori	r24, 0x08	; 8
     d30:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d34:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d38:	87 7f       	andi	r24, 0xF7	; 247
     d3a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d3e:	08 95       	ret

00000d40 <cursor_off>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d40:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d42:	77 9b       	sbis	0x0e, 7	; 14
     d44:	fe cf       	rjmp	.-4      	; 0xd42 <cursor_off+0x2>
  SPDR = byte;                        //send payload
     d46:	8c e0       	ldi	r24, 0x0C	; 12
     d48:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d4a:	77 9b       	sbis	0x0e, 7	; 14
     d4c:	fe cf       	rjmp	.-4      	; 0xd4a <cursor_off+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d4e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d52:	88 60       	ori	r24, 0x08	; 8
     d54:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d58:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d5c:	87 7f       	andi	r24, 0xF7	; 247
     d5e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d62:	08 95       	ret

00000d64 <shift_right>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d64:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d66:	77 9b       	sbis	0x0e, 7	; 14
     d68:	fe cf       	rjmp	.-4      	; 0xd66 <shift_right+0x2>
  SPDR = byte;                        //send payload
     d6a:	8e e1       	ldi	r24, 0x1E	; 30
     d6c:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d6e:	77 9b       	sbis	0x0e, 7	; 14
     d70:	fe cf       	rjmp	.-4      	; 0xd6e <shift_right+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d72:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d76:	88 60       	ori	r24, 0x08	; 8
     d78:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d7c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d80:	87 7f       	andi	r24, 0xF7	; 247
     d82:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d86:	08 95       	ret

00000d88 <shift_left>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d88:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d8a:	77 9b       	sbis	0x0e, 7	; 14
     d8c:	fe cf       	rjmp	.-4      	; 0xd8a <shift_left+0x2>
  SPDR = byte;                        //send payload
     d8e:	88 e1       	ldi	r24, 0x18	; 24
     d90:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d92:	77 9b       	sbis	0x0e, 7	; 14
     d94:	fe cf       	rjmp	.-4      	; 0xd92 <shift_left+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d96:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d9a:	88 60       	ori	r24, 0x08	; 8
     d9c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     da0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     da4:	87 7f       	andi	r24, 0xF7	; 247
     da6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     daa:	08 95       	ret

00000dac <strobe_lcd>:
     dac:	e2 e6       	ldi	r30, 0x62	; 98
     dae:	f0 e0       	ldi	r31, 0x00	; 0
     db0:	80 81       	ld	r24, Z
     db2:	88 60       	ori	r24, 0x08	; 8
     db4:	80 83       	st	Z, r24
     db6:	80 81       	ld	r24, Z
     db8:	87 7f       	andi	r24, 0xF7	; 247
     dba:	80 83       	st	Z, r24
     dbc:	08 95       	ret

00000dbe <clear_display>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     dbe:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     dc0:	77 9b       	sbis	0x0e, 7	; 14
     dc2:	fe cf       	rjmp	.-4      	; 0xdc0 <clear_display+0x2>
  SPDR = byte;                        //send payload
     dc4:	81 e0       	ldi	r24, 0x01	; 1
     dc6:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     dc8:	77 9b       	sbis	0x0e, 7	; 14
     dca:	fe cf       	rjmp	.-4      	; 0xdc8 <clear_display+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     dcc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dd0:	88 60       	ori	r24, 0x08	; 8
     dd2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dd6:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dda:	87 7f       	andi	r24, 0xF7	; 247
     ddc:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     de0:	8f e1       	ldi	r24, 0x1F	; 31
     de2:	9c e1       	ldi	r25, 0x1C	; 28
     de4:	01 97       	sbiw	r24, 0x01	; 1
     de6:	f1 f7       	brne	.-4      	; 0xde4 <clear_display+0x26>
     de8:	00 c0       	rjmp	.+0      	; 0xdea <clear_display+0x2c>
     dea:	00 00       	nop
     dec:	08 95       	ret

00000dee <cursor_home>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     dee:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     df0:	77 9b       	sbis	0x0e, 7	; 14
     df2:	fe cf       	rjmp	.-4      	; 0xdf0 <cursor_home+0x2>
  SPDR = byte;                        //send payload
     df4:	82 e0       	ldi	r24, 0x02	; 2
     df6:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     df8:	77 9b       	sbis	0x0e, 7	; 14
     dfa:	fe cf       	rjmp	.-4      	; 0xdf8 <cursor_home+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     dfc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e00:	88 60       	ori	r24, 0x08	; 8
     e02:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e06:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e0a:	87 7f       	andi	r24, 0xF7	; 247
     e0c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e10:	8f e6       	ldi	r24, 0x6F	; 111
     e12:	97 e1       	ldi	r25, 0x17	; 23
     e14:	01 97       	sbiw	r24, 0x01	; 1
     e16:	f1 f7       	brne	.-4      	; 0xe14 <cursor_home+0x26>
     e18:	00 c0       	rjmp	.+0      	; 0xe1a <cursor_home+0x2c>
     e1a:	00 00       	nop
     e1c:	08 95       	ret

00000e1e <line2_col1>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e1e:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e20:	77 9b       	sbis	0x0e, 7	; 14
     e22:	fe cf       	rjmp	.-4      	; 0xe20 <line2_col1+0x2>
  SPDR = byte;                        //send payload
     e24:	80 ec       	ldi	r24, 0xC0	; 192
     e26:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e28:	77 9b       	sbis	0x0e, 7	; 14
     e2a:	fe cf       	rjmp	.-4      	; 0xe28 <line2_col1+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     e2c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e30:	88 60       	ori	r24, 0x08	; 8
     e32:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e36:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e3a:	87 7f       	andi	r24, 0xF7	; 247
     e3c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e40:	85 ed       	ldi	r24, 0xD5	; 213
     e42:	8a 95       	dec	r24
     e44:	f1 f7       	brne	.-4      	; 0xe42 <line2_col1+0x24>
     e46:	00 00       	nop
     e48:	08 95       	ret

00000e4a <line1_col1>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e4a:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e4c:	77 9b       	sbis	0x0e, 7	; 14
     e4e:	fe cf       	rjmp	.-4      	; 0xe4c <line1_col1+0x2>
  SPDR = byte;                        //send payload
     e50:	80 e8       	ldi	r24, 0x80	; 128
     e52:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e54:	77 9b       	sbis	0x0e, 7	; 14
     e56:	fe cf       	rjmp	.-4      	; 0xe54 <line1_col1+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     e58:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e5c:	88 60       	ori	r24, 0x08	; 8
     e5e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e62:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e66:	87 7f       	andi	r24, 0xF7	; 247
     e68:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e6c:	85 ed       	ldi	r24, 0xD5	; 213
     e6e:	8a 95       	dec	r24
     e70:	f1 f7       	brne	.-4      	; 0xe6e <line1_col1+0x24>
     e72:	00 00       	nop
     e74:	08 95       	ret

00000e76 <fill_spaces>:

//-----------------------------------------------------------------------------
//                          fill_spaces   
//
//Fill an entire line with spaces.
void fill_spaces(void){
     e76:	90 e1       	ldi	r25, 0x10	; 16
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e78:	31 e0       	ldi	r19, 0x01	; 1
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
  SPDR = byte;                        //send payload
     e7a:	20 e2       	ldi	r18, 0x20	; 32
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e7c:	3f b9       	out	0x0f, r19	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e7e:	77 9b       	sbis	0x0e, 7	; 14
     e80:	fe cf       	rjmp	.-4      	; 0xe7e <fill_spaces+0x8>
  SPDR = byte;                        //send payload
     e82:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e84:	77 9b       	sbis	0x0e, 7	; 14
     e86:	fe cf       	rjmp	.-4      	; 0xe84 <fill_spaces+0xe>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     e88:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e8c:	88 60       	ori	r24, 0x08	; 8
     e8e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e92:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e96:	87 7f       	andi	r24, 0xF7	; 247
     e98:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e9c:	85 ed       	ldi	r24, 0xD5	; 213
     e9e:	8a 95       	dec	r24
     ea0:	f1 f7       	brne	.-4      	; 0xe9e <fill_spaces+0x28>
     ea2:	00 00       	nop
     ea4:	91 50       	subi	r25, 0x01	; 1
//                          fill_spaces   
//
//Fill an entire line with spaces.
void fill_spaces(void){
	uint8_t i;
	for (i=0; i<=(NUM_LCD_CHARS-1); i++){
     ea6:	51 f7       	brne	.-44     	; 0xe7c <fill_spaces+0x6>
		send_lcd(CHAR_BYTE, ' '); 
                _delay_us(40);  //40us wait between characters
	}
}  
     ea8:	08 95       	ret

00000eaa <char2lcd>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     eaa:	91 e0       	ldi	r25, 0x01	; 1
     eac:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     eae:	77 9b       	sbis	0x0e, 7	; 14
     eb0:	fe cf       	rjmp	.-4      	; 0xeae <char2lcd+0x4>
  SPDR = byte;                        //send payload
     eb2:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     eb4:	77 9b       	sbis	0x0e, 7	; 14
     eb6:	fe cf       	rjmp	.-4      	; 0xeb4 <char2lcd+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     eb8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ebc:	88 60       	ori	r24, 0x08	; 8
     ebe:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ec2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ec6:	87 7f       	andi	r24, 0xF7	; 247
     ec8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ecc:	08 95       	ret

00000ece <string2lcd>:

//----------------------------------------------------------------------------
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
     ece:	fc 01       	movw	r30, r24
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     ed0:	40 e0       	ldi	r20, 0x00	; 0
     ed2:	50 e0       	ldi	r21, 0x00	; 0
     ed4:	60 e0       	ldi	r22, 0x00	; 0
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ed6:	71 e0       	ldi	r23, 0x01	; 1
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     ed8:	df 01       	movw	r26, r30
     eda:	a4 0f       	add	r26, r20
     edc:	b5 1f       	adc	r27, r21
     ede:	8c 91       	ld	r24, X
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ee0:	7f b9       	out	0x0f, r23	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ee2:	77 9b       	sbis	0x0e, 7	; 14
     ee4:	fe cf       	rjmp	.-4      	; 0xee2 <string2lcd+0x14>
  SPDR = byte;                        //send payload
     ee6:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ee8:	77 9b       	sbis	0x0e, 7	; 14
     eea:	fe cf       	rjmp	.-4      	; 0xee8 <string2lcd+0x1a>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     eec:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ef0:	98 60       	ori	r25, 0x08	; 8
     ef2:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ef6:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     efa:	97 7f       	andi	r25, 0xF7	; 247
     efc:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f00:	85 ed       	ldi	r24, 0xD5	; 213
     f02:	8a 95       	dec	r24
     f04:	f1 f7       	brne	.-4      	; 0xf02 <string2lcd+0x34>
     f06:	00 00       	nop
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     f08:	6f 5f       	subi	r22, 0xFF	; 255
     f0a:	46 2f       	mov	r20, r22
     f0c:	50 e0       	ldi	r21, 0x00	; 0
     f0e:	df 01       	movw	r26, r30
     f10:	0d 90       	ld	r0, X+
     f12:	00 20       	and	r0, r0
     f14:	e9 f7       	brne	.-6      	; 0xf10 <string2lcd+0x42>
     f16:	9d 01       	movw	r18, r26
     f18:	2e 1b       	sub	r18, r30
     f1a:	3f 0b       	sbc	r19, r31
     f1c:	22 50       	subi	r18, 0x02	; 2
     f1e:	31 09       	sbc	r19, r1
     f20:	24 17       	cp	r18, r20
     f22:	35 07       	cpc	r19, r21
     f24:	c8 f6       	brcc	.-78     	; 0xed8 <string2lcd+0xa>
  _delay_us(40);  //execution takes 37us per character
  }                  
} 
     f26:	08 95       	ret

00000f28 <lcd_init>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     f28:	8f ef       	ldi	r24, 0xFF	; 255
     f2a:	99 ef       	ldi	r25, 0xF9	; 249
     f2c:	01 97       	sbiw	r24, 0x01	; 1
     f2e:	f1 f7       	brne	.-4      	; 0xf2c <lcd_init+0x4>
     f30:	00 c0       	rjmp	.+0      	; 0xf32 <lcd_init+0xa>
     f32:	00 00       	nop
//
void lcd_init(void){
  _delay_ms(16);      //power up delay
#if SPI_MODE==1       //assumption is that the SPI port is intialized
  //TODO: kludge alert! setting of DDRF should not be here, but is probably harmless.
  DDRF=0x08;          //port F bit 3 is enable for LCD in SPI mode
     f34:	88 e0       	ldi	r24, 0x08	; 8
     f36:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     f3a:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f3c:	77 9b       	sbis	0x0e, 7	; 14
     f3e:	fe cf       	rjmp	.-4      	; 0xf3c <lcd_init+0x14>
  SPDR = byte;                        //send payload
     f40:	80 e3       	ldi	r24, 0x30	; 48
     f42:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f44:	77 9b       	sbis	0x0e, 7	; 14
     f46:	fe cf       	rjmp	.-4      	; 0xf44 <lcd_init+0x1c>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     f48:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f4c:	88 60       	ori	r24, 0x08	; 8
     f4e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f52:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f56:	87 7f       	andi	r24, 0xF7	; 247
     f58:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f5c:	8f e5       	ldi	r24, 0x5F	; 95
     f5e:	9d e6       	ldi	r25, 0x6D	; 109
     f60:	01 97       	sbiw	r24, 0x01	; 1
     f62:	f1 f7       	brne	.-4      	; 0xf60 <lcd_init+0x38>
     f64:	00 c0       	rjmp	.+0      	; 0xf66 <lcd_init+0x3e>
     f66:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     f68:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f6a:	77 9b       	sbis	0x0e, 7	; 14
     f6c:	fe cf       	rjmp	.-4      	; 0xf6a <lcd_init+0x42>
  SPDR = byte;                        //send payload
     f6e:	80 e3       	ldi	r24, 0x30	; 48
     f70:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f72:	77 9b       	sbis	0x0e, 7	; 14
     f74:	fe cf       	rjmp	.-4      	; 0xf72 <lcd_init+0x4a>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     f76:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f7a:	88 60       	ori	r24, 0x08	; 8
     f7c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f80:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f84:	87 7f       	andi	r24, 0xF7	; 247
     f86:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f8a:	8f e5       	ldi	r24, 0x5F	; 95
     f8c:	9d e6       	ldi	r25, 0x6D	; 109
     f8e:	01 97       	sbiw	r24, 0x01	; 1
     f90:	f1 f7       	brne	.-4      	; 0xf8e <lcd_init+0x66>
     f92:	00 c0       	rjmp	.+0      	; 0xf94 <lcd_init+0x6c>
     f94:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     f96:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f98:	77 9b       	sbis	0x0e, 7	; 14
     f9a:	fe cf       	rjmp	.-4      	; 0xf98 <lcd_init+0x70>
  SPDR = byte;                        //send payload
     f9c:	80 e3       	ldi	r24, 0x30	; 48
     f9e:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     fa0:	77 9b       	sbis	0x0e, 7	; 14
     fa2:	fe cf       	rjmp	.-4      	; 0xfa0 <lcd_init+0x78>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     fa4:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fa8:	88 60       	ori	r24, 0x08	; 8
     faa:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fae:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fb2:	87 7f       	andi	r24, 0xF7	; 247
     fb4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fb8:	8f e5       	ldi	r24, 0x5F	; 95
     fba:	9d e6       	ldi	r25, 0x6D	; 109
     fbc:	01 97       	sbiw	r24, 0x01	; 1
     fbe:	f1 f7       	brne	.-4      	; 0xfbc <lcd_init+0x94>
     fc0:	00 c0       	rjmp	.+0      	; 0xfc2 <lcd_init+0x9a>
     fc2:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     fc4:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     fc6:	77 9b       	sbis	0x0e, 7	; 14
     fc8:	fe cf       	rjmp	.-4      	; 0xfc6 <lcd_init+0x9e>
  SPDR = byte;                        //send payload
     fca:	88 e3       	ldi	r24, 0x38	; 56
     fcc:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     fce:	77 9b       	sbis	0x0e, 7	; 14
     fd0:	fe cf       	rjmp	.-4      	; 0xfce <lcd_init+0xa6>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     fd2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fd6:	88 60       	ori	r24, 0x08	; 8
     fd8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fdc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fe0:	87 7f       	andi	r24, 0xF7	; 247
     fe2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fe6:	8f e1       	ldi	r24, 0x1F	; 31
     fe8:	9e e4       	ldi	r25, 0x4E	; 78
     fea:	01 97       	sbiw	r24, 0x01	; 1
     fec:	f1 f7       	brne	.-4      	; 0xfea <lcd_init+0xc2>
     fee:	00 c0       	rjmp	.+0      	; 0xff0 <lcd_init+0xc8>
     ff0:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ff2:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ff4:	77 9b       	sbis	0x0e, 7	; 14
     ff6:	fe cf       	rjmp	.-4      	; 0xff4 <lcd_init+0xcc>
  SPDR = byte;                        //send payload
     ff8:	88 e0       	ldi	r24, 0x08	; 8
     ffa:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ffc:	77 9b       	sbis	0x0e, 7	; 14
     ffe:	fe cf       	rjmp	.-4      	; 0xffc <lcd_init+0xd4>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    1000:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1004:	88 60       	ori	r24, 0x08	; 8
    1006:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    100a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    100e:	87 7f       	andi	r24, 0xF7	; 247
    1010:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1014:	8f e1       	ldi	r24, 0x1F	; 31
    1016:	9e e4       	ldi	r25, 0x4E	; 78
    1018:	01 97       	sbiw	r24, 0x01	; 1
    101a:	f1 f7       	brne	.-4      	; 0x1018 <lcd_init+0xf0>
    101c:	00 c0       	rjmp	.+0      	; 0x101e <lcd_init+0xf6>
    101e:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1020:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1022:	77 9b       	sbis	0x0e, 7	; 14
    1024:	fe cf       	rjmp	.-4      	; 0x1022 <lcd_init+0xfa>
  SPDR = byte;                        //send payload
    1026:	81 e0       	ldi	r24, 0x01	; 1
    1028:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    102a:	77 9b       	sbis	0x0e, 7	; 14
    102c:	fe cf       	rjmp	.-4      	; 0x102a <lcd_init+0x102>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    102e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1032:	88 60       	ori	r24, 0x08	; 8
    1034:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1038:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    103c:	87 7f       	andi	r24, 0xF7	; 247
    103e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1042:	8f e1       	ldi	r24, 0x1F	; 31
    1044:	9e e4       	ldi	r25, 0x4E	; 78
    1046:	01 97       	sbiw	r24, 0x01	; 1
    1048:	f1 f7       	brne	.-4      	; 0x1046 <lcd_init+0x11e>
    104a:	00 c0       	rjmp	.+0      	; 0x104c <lcd_init+0x124>
    104c:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    104e:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1050:	77 9b       	sbis	0x0e, 7	; 14
    1052:	fe cf       	rjmp	.-4      	; 0x1050 <lcd_init+0x128>
  SPDR = byte;                        //send payload
    1054:	86 e0       	ldi	r24, 0x06	; 6
    1056:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1058:	77 9b       	sbis	0x0e, 7	; 14
    105a:	fe cf       	rjmp	.-4      	; 0x1058 <lcd_init+0x130>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    105c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1060:	88 60       	ori	r24, 0x08	; 8
    1062:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1066:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    106a:	87 7f       	andi	r24, 0xF7	; 247
    106c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1070:	8f e1       	ldi	r24, 0x1F	; 31
    1072:	9e e4       	ldi	r25, 0x4E	; 78
    1074:	01 97       	sbiw	r24, 0x01	; 1
    1076:	f1 f7       	brne	.-4      	; 0x1074 <lcd_init+0x14c>
    1078:	00 c0       	rjmp	.+0      	; 0x107a <lcd_init+0x152>
    107a:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    107c:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    107e:	77 9b       	sbis	0x0e, 7	; 14
    1080:	fe cf       	rjmp	.-4      	; 0x107e <lcd_init+0x156>
  SPDR = byte;                        //send payload
    1082:	8c e0       	ldi	r24, 0x0C	; 12
    1084:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1086:	77 9b       	sbis	0x0e, 7	; 14
    1088:	fe cf       	rjmp	.-4      	; 0x1086 <lcd_init+0x15e>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    108a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    108e:	88 60       	ori	r24, 0x08	; 8
    1090:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1094:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1098:	87 7f       	andi	r24, 0xF7	; 247
    109a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    109e:	8f e1       	ldi	r24, 0x1F	; 31
    10a0:	9e e4       	ldi	r25, 0x4E	; 78
    10a2:	01 97       	sbiw	r24, 0x01	; 1
    10a4:	f1 f7       	brne	.-4      	; 0x10a2 <lcd_init+0x17a>
    10a6:	00 c0       	rjmp	.+0      	; 0x10a8 <lcd_init+0x180>
    10a8:	00 00       	nop
    10aa:	08 95       	ret

000010ac <lcd_int32>:
void  lcd_int32(int32_t l,          //number to display
                uint8_t fieldwidth, //width of the field for display
                uint8_t decpos,     //0 if no decimal point, otherwise
                uint8_t bSigned,    //non-zero if the number should be treated as signed 
                uint8_t bZeroFill)  //non-zero if a specified fieldwidth is to be zero filled
{
    10ac:	4f 92       	push	r4
    10ae:	5f 92       	push	r5
    10b0:	6f 92       	push	r6
    10b2:	7f 92       	push	r7
    10b4:	8f 92       	push	r8
    10b6:	9f 92       	push	r9
    10b8:	af 92       	push	r10
    10ba:	bf 92       	push	r11
    10bc:	cf 92       	push	r12
    10be:	df 92       	push	r13
    10c0:	ef 92       	push	r14
    10c2:	ff 92       	push	r15
    10c4:	0f 93       	push	r16
    10c6:	1f 93       	push	r17
    10c8:	cf 93       	push	r28
    10ca:	df 93       	push	r29
    10cc:	cd b7       	in	r28, 0x3d	; 61
    10ce:	de b7       	in	r29, 0x3e	; 62
    10d0:	69 97       	sbiw	r28, 0x19	; 25
    10d2:	0f b6       	in	r0, 0x3f	; 63
    10d4:	f8 94       	cli
    10d6:	de bf       	out	0x3e, r29	; 62
    10d8:	0f be       	out	0x3f, r0	; 63
    10da:	cd bf       	out	0x3d, r28	; 61
    10dc:	14 2f       	mov	r17, r20
    10de:	42 2e       	mov	r4, r18
    10e0:	5e 2c       	mov	r5, r14
      char    fillch;
      ldiv_t  qr;

      qr.quot = l; // initialize the quotient 

      if (bSigned){
    10e2:	00 23       	and	r16, r16
    10e4:	79 f0       	breq	.+30     	; 0x1104 <__stack+0x5>
        bSigned = (qr.quot<0);
    10e6:	6b 01       	movw	r12, r22
    10e8:	7c 01       	movw	r14, r24
    10ea:	cc 24       	eor	r12, r12
    10ec:	f7 fc       	sbrc	r15, 7
    10ee:	c3 94       	inc	r12
    10f0:	dd 24       	eor	r13, r13
    10f2:	ee 24       	eor	r14, r14
    10f4:	ff 24       	eor	r15, r15
    10f6:	0c 2d       	mov	r16, r12
        qr.quot = labs(qr.quot);
    10f8:	6b 01       	movw	r12, r22
    10fa:	7c 01       	movw	r14, r24
    10fc:	97 fd       	sbrc	r25, 7
    10fe:	a3 c0       	rjmp	.+326    	; 0x1246 <__stack+0x147>
    1100:	c7 01       	movw	r24, r14
    1102:	b6 01       	movw	r22, r12
      }

      // convert the digits to the right of the decimal point 
      if (decpos){
    1104:	44 20       	and	r4, r4
    1106:	09 f4       	brne	.+2      	; 0x110a <__stack+0xb>
    1108:	96 c0       	rjmp	.+300    	; 0x1236 <__stack+0x137>
    110a:	9e 01       	movw	r18, r28
    110c:	2f 5f       	subi	r18, 0xFF	; 255
    110e:	3f 4f       	sbci	r19, 0xFF	; 255
    1110:	59 01       	movw	r10, r18
    1112:	49 01       	movw	r8, r18
    1114:	66 24       	eor	r6, r6
    1116:	6a 94       	dec	r6
    1118:	64 0c       	add	r6, r4
    111a:	71 2c       	mov	r7, r1
    111c:	3f ef       	ldi	r19, 0xFF	; 255
    111e:	63 1a       	sub	r6, r19
    1120:	73 0a       	sbc	r7, r19
    1122:	6a 0c       	add	r6, r10
    1124:	7b 1c       	adc	r7, r11
        for (; decpos ; decpos--){
          qr = ldiv(qr.quot, 10);
    1126:	2a e0       	ldi	r18, 0x0A	; 10
    1128:	30 e0       	ldi	r19, 0x00	; 0
    112a:	40 e0       	ldi	r20, 0x00	; 0
    112c:	50 e0       	ldi	r21, 0x00	; 0
    112e:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <__divmodsi4>
    1132:	e6 2f       	mov	r30, r22
    1134:	2a 8b       	std	Y+18, r18	; 0x12
    1136:	3b 8b       	std	Y+19, r19	; 0x13
    1138:	4c 8b       	std	Y+20, r20	; 0x14
    113a:	5d 8b       	std	Y+21, r21	; 0x15
    113c:	6a 89       	ldd	r22, Y+18	; 0x12
    113e:	7b 89       	ldd	r23, Y+19	; 0x13
    1140:	8c 89       	ldd	r24, Y+20	; 0x14
    1142:	9d 89       	ldd	r25, Y+21	; 0x15
          sline[i++] = qr.rem + '0';
    1144:	20 e3       	ldi	r18, 0x30	; 48
    1146:	2e 0f       	add	r18, r30
    1148:	f4 01       	movw	r30, r8
    114a:	21 93       	st	Z+, r18
    114c:	4f 01       	movw	r8, r30
        qr.quot = labs(qr.quot);
      }

      // convert the digits to the right of the decimal point 
      if (decpos){
        for (; decpos ; decpos--){
    114e:	6e 16       	cp	r6, r30
    1150:	7f 06       	cpc	r7, r31
    1152:	49 f7       	brne	.-46     	; 0x1126 <__stack+0x27>
          qr = ldiv(qr.quot, 10);
          sline[i++] = qr.rem + '0';
        }
        sline[i++] = '.';
    1154:	99 24       	eor	r9, r9
    1156:	93 94       	inc	r9
    1158:	94 0c       	add	r9, r4
    115a:	f5 01       	movw	r30, r10
    115c:	e4 0d       	add	r30, r4
    115e:	f1 1d       	adc	r31, r1
    1160:	2e e2       	ldi	r18, 0x2E	; 46
    1162:	20 83       	st	Z, r18
      }

      // convert the digits to the left of the decimal point 
      do{
          qr = ldiv(qr.quot, 10);
    1164:	2a e0       	ldi	r18, 0x0A	; 10
    1166:	30 e0       	ldi	r19, 0x00	; 0
    1168:	40 e0       	ldi	r20, 0x00	; 0
    116a:	50 e0       	ldi	r21, 0x00	; 0
    116c:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <__divmodsi4>
    1170:	e6 2f       	mov	r30, r22
    1172:	2a 8b       	std	Y+18, r18	; 0x12
    1174:	3b 8b       	std	Y+19, r19	; 0x13
    1176:	4c 8b       	std	Y+20, r20	; 0x14
    1178:	5d 8b       	std	Y+21, r21	; 0x15
    117a:	6e 8b       	std	Y+22, r22	; 0x16
    117c:	7f 8b       	std	Y+23, r23	; 0x17
    117e:	88 8f       	std	Y+24, r24	; 0x18
    1180:	99 8f       	std	Y+25, r25	; 0x19
    1182:	6a 89       	ldd	r22, Y+18	; 0x12
    1184:	7b 89       	ldd	r23, Y+19	; 0x13
    1186:	8c 89       	ldd	r24, Y+20	; 0x14
    1188:	9d 89       	ldd	r25, Y+21	; 0x15
          sline[i++] = qr.rem + '0';
    118a:	31 e0       	ldi	r19, 0x01	; 1
    118c:	39 0d       	add	r19, r9
    118e:	d5 01       	movw	r26, r10
    1190:	a9 0d       	add	r26, r9
    1192:	b1 1d       	adc	r27, r1
    1194:	e0 5d       	subi	r30, 0xD0	; 208
    1196:	ec 93       	st	X, r30
    1198:	93 2e       	mov	r9, r19
        }while(qr.quot);
    119a:	61 15       	cp	r22, r1
    119c:	71 05       	cpc	r23, r1
    119e:	81 05       	cpc	r24, r1
    11a0:	91 05       	cpc	r25, r1
    11a2:	01 f7       	brne	.-64     	; 0x1164 <__stack+0x65>

      // fill the whole field if a width was specified
      if (fieldwidth){
    11a4:	11 23       	and	r17, r17
    11a6:	61 f0       	breq	.+24     	; 0x11c0 <__stack+0xc1>
        fillch = bZeroFill? '0': ' '; // determine the fill character
    11a8:	51 10       	cpse	r5, r1
    11aa:	4b c0       	rjmp	.+150    	; 0x1242 <__stack+0x143>
    11ac:	90 e2       	ldi	r25, 0x20	; 32
        for (; i<fieldwidth ; ){sline[i++] = fillch;}
    11ae:	31 17       	cp	r19, r17
    11b0:	38 f4       	brcc	.+14     	; 0x11c0 <__stack+0xc1>
    11b2:	f5 01       	movw	r30, r10
    11b4:	e3 0f       	add	r30, r19
    11b6:	f1 1d       	adc	r31, r1
    11b8:	90 83       	st	Z, r25
    11ba:	3f 5f       	subi	r19, 0xFF	; 255
    11bc:	13 13       	cpse	r17, r19
    11be:	f9 cf       	rjmp	.-14     	; 0x11b2 <__stack+0xb3>
      }

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}
    11c0:	00 23       	and	r16, r16
    11c2:	31 f0       	breq	.+12     	; 0x11d0 <__stack+0xd1>
    11c4:	f5 01       	movw	r30, r10
    11c6:	e3 0f       	add	r30, r19
    11c8:	f1 1d       	adc	r31, r1
    11ca:	9d e2       	ldi	r25, 0x2D	; 45
    11cc:	90 83       	st	Z, r25
    11ce:	3f 5f       	subi	r19, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    11d0:	21 e0       	ldi	r18, 0x01	; 1

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}

      // now output the formatted number
      do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    11d2:	31 50       	subi	r19, 0x01	; 1
    11d4:	f5 01       	movw	r30, r10
    11d6:	e3 0f       	add	r30, r19
    11d8:	f1 1d       	adc	r31, r1
    11da:	90 81       	ld	r25, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    11dc:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    11de:	77 9b       	sbis	0x0e, 7	; 14
    11e0:	fe cf       	rjmp	.-4      	; 0x11de <__stack+0xdf>
  SPDR = byte;                        //send payload
    11e2:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    11e4:	77 9b       	sbis	0x0e, 7	; 14
    11e6:	fe cf       	rjmp	.-4      	; 0x11e4 <__stack+0xe5>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    11e8:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    11ec:	98 60       	ori	r25, 0x08	; 8
    11ee:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    11f2:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    11f6:	97 7f       	andi	r25, 0xF7	; 247
    11f8:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    11fc:	85 ed       	ldi	r24, 0xD5	; 213
    11fe:	8a 95       	dec	r24
    1200:	f1 f7       	brne	.-4      	; 0x11fe <__stack+0xff>
    1202:	00 00       	nop

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}

      // now output the formatted number
      do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    1204:	31 11       	cpse	r19, r1
    1206:	e5 cf       	rjmp	.-54     	; 0x11d2 <__stack+0xd3>

}
    1208:	69 96       	adiw	r28, 0x19	; 25
    120a:	0f b6       	in	r0, 0x3f	; 63
    120c:	f8 94       	cli
    120e:	de bf       	out	0x3e, r29	; 62
    1210:	0f be       	out	0x3f, r0	; 63
    1212:	cd bf       	out	0x3d, r28	; 61
    1214:	df 91       	pop	r29
    1216:	cf 91       	pop	r28
    1218:	1f 91       	pop	r17
    121a:	0f 91       	pop	r16
    121c:	ff 90       	pop	r15
    121e:	ef 90       	pop	r14
    1220:	df 90       	pop	r13
    1222:	cf 90       	pop	r12
    1224:	bf 90       	pop	r11
    1226:	af 90       	pop	r10
    1228:	9f 90       	pop	r9
    122a:	8f 90       	pop	r8
    122c:	7f 90       	pop	r7
    122e:	6f 90       	pop	r6
    1230:	5f 90       	pop	r5
    1232:	4f 90       	pop	r4
    1234:	08 95       	ret
                uint8_t decpos,     //0 if no decimal point, otherwise
                uint8_t bSigned,    //non-zero if the number should be treated as signed 
                uint8_t bZeroFill)  //non-zero if a specified fieldwidth is to be zero filled
{
      char    sline[NUM_LCD_CHARS+1];
      uint8_t i=0;
    1236:	91 2c       	mov	r9, r1
    1238:	9e 01       	movw	r18, r28
    123a:	2f 5f       	subi	r18, 0xFF	; 255
    123c:	3f 4f       	sbci	r19, 0xFF	; 255
    123e:	59 01       	movw	r10, r18
    1240:	91 cf       	rjmp	.-222    	; 0x1164 <__stack+0x65>
          sline[i++] = qr.rem + '0';
        }while(qr.quot);

      // fill the whole field if a width was specified
      if (fieldwidth){
        fillch = bZeroFill? '0': ' '; // determine the fill character
    1242:	90 e3       	ldi	r25, 0x30	; 48
    1244:	b4 cf       	rjmp	.-152    	; 0x11ae <__stack+0xaf>

      qr.quot = l; // initialize the quotient 

      if (bSigned){
        bSigned = (qr.quot<0);
        qr.quot = labs(qr.quot);
    1246:	f0 94       	com	r15
    1248:	e0 94       	com	r14
    124a:	d0 94       	com	r13
    124c:	c0 94       	com	r12
    124e:	c1 1c       	adc	r12, r1
    1250:	d1 1c       	adc	r13, r1
    1252:	e1 1c       	adc	r14, r1
    1254:	f1 1c       	adc	r15, r1
    1256:	54 cf       	rjmp	.-344    	; 0x1100 <__stack+0x1>

00001258 <lcd_int16>:
void    lcd_int16(int16_t l, 
                  uint8_t fieldwidth, 
                  uint8_t decpos, 
                  uint8_t bSigned,
                  uint8_t bZeroFill)
{
    1258:	5f 92       	push	r5
    125a:	6f 92       	push	r6
    125c:	7f 92       	push	r7
    125e:	8f 92       	push	r8
    1260:	9f 92       	push	r9
    1262:	af 92       	push	r10
    1264:	bf 92       	push	r11
    1266:	cf 92       	push	r12
    1268:	df 92       	push	r13
    126a:	ef 92       	push	r14
    126c:	ff 92       	push	r15
    126e:	0f 93       	push	r16
    1270:	1f 93       	push	r17
    1272:	cf 93       	push	r28
    1274:	df 93       	push	r29
    1276:	cd b7       	in	r28, 0x3d	; 61
    1278:	de b7       	in	r29, 0x3e	; 62
    127a:	61 97       	sbiw	r28, 0x11	; 17
    127c:	0f b6       	in	r0, 0x3f	; 63
    127e:	f8 94       	cli
    1280:	de bf       	out	0x3e, r29	; 62
    1282:	0f be       	out	0x3f, r0	; 63
    1284:	cd bf       	out	0x3d, r28	; 61
    1286:	5c 01       	movw	r10, r24
    1288:	16 2f       	mov	r17, r22
    128a:	74 2e       	mov	r7, r20
//        uint8_t bSigned;   Now an argument for signed or not

        // initialize the quotient 
        qr.quot = l;

        if ( (bSigned=(qr.quot<0)) )
    128c:	6b 2c       	mov	r6, r11
    128e:	66 1c       	adc	r6, r6
    1290:	66 24       	eor	r6, r6
    1292:	66 1c       	adc	r6, r6
    1294:	56 2c       	mov	r5, r6
    1296:	9c 01       	movw	r18, r24
    1298:	97 fd       	sbrc	r25, 7
    129a:	9b c0       	rjmp	.+310    	; 0x13d2 <lcd_int16+0x17a>
                qr.quot = -qr.quot;

        // convert the digits to the right of the decimal point 
        if (decpos){
    129c:	77 20       	and	r7, r7
    129e:	09 f4       	brne	.+2      	; 0x12a2 <lcd_int16+0x4a>
    12a0:	8d c0       	rjmp	.+282    	; 0x13bc <lcd_int16+0x164>
    12a2:	ce 01       	movw	r24, r28
    12a4:	01 96       	adiw	r24, 0x01	; 1
    12a6:	7c 01       	movw	r14, r24
    12a8:	6c 01       	movw	r12, r24
    12aa:	88 24       	eor	r8, r8
    12ac:	8a 94       	dec	r8
    12ae:	87 0c       	add	r8, r7
    12b0:	91 2c       	mov	r9, r1
    12b2:	9f ef       	ldi	r25, 0xFF	; 255
    12b4:	89 1a       	sub	r8, r25
    12b6:	99 0a       	sbc	r9, r25
    12b8:	8e 0c       	add	r8, r14
    12ba:	9f 1c       	adc	r9, r15
          for (; decpos ; decpos--){
            qr = div(qr.quot, 10);
    12bc:	6a e0       	ldi	r22, 0x0A	; 10
    12be:	70 e0       	ldi	r23, 0x00	; 0
    12c0:	c9 01       	movw	r24, r18
    12c2:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <__divmodhi4>
    12c6:	46 2f       	mov	r20, r22
    12c8:	24 2f       	mov	r18, r20
    12ca:	37 2f       	mov	r19, r23
            sline[i++] = qr.rem + '0';
    12cc:	80 5d       	subi	r24, 0xD0	; 208
    12ce:	f6 01       	movw	r30, r12
    12d0:	81 93       	st	Z+, r24
    12d2:	6f 01       	movw	r12, r30
        if ( (bSigned=(qr.quot<0)) )
                qr.quot = -qr.quot;

        // convert the digits to the right of the decimal point 
        if (decpos){
          for (; decpos ; decpos--){
    12d4:	e8 15       	cp	r30, r8
    12d6:	f9 05       	cpc	r31, r9
    12d8:	89 f7       	brne	.-30     	; 0x12bc <lcd_int16+0x64>
            qr = div(qr.quot, 10);
            sline[i++] = qr.rem + '0';
          }
          sline[i++] = '.';
    12da:	dd 24       	eor	r13, r13
    12dc:	d3 94       	inc	r13
    12de:	d7 0c       	add	r13, r7
    12e0:	f7 01       	movw	r30, r14
    12e2:	e7 0d       	add	r30, r7
    12e4:	f1 1d       	adc	r31, r1
    12e6:	8e e2       	ldi	r24, 0x2E	; 46
    12e8:	80 83       	st	Z, r24
    12ea:	01 c0       	rjmp	.+2      	; 0x12ee <lcd_int16+0x96>

        // convert the digits to the left of the decimal point 
        do
        {
                qr = div(qr.quot, 10);
                sline[i++] = qr.rem + '0';
    12ec:	d9 2e       	mov	r13, r25
        }

        // convert the digits to the left of the decimal point 
        do
        {
                qr = div(qr.quot, 10);
    12ee:	6a e0       	ldi	r22, 0x0A	; 10
    12f0:	70 e0       	ldi	r23, 0x00	; 0
    12f2:	c9 01       	movw	r24, r18
    12f4:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <__divmodhi4>
    12f8:	46 2f       	mov	r20, r22
    12fa:	24 2f       	mov	r18, r20
    12fc:	37 2f       	mov	r19, r23
                sline[i++] = qr.rem + '0';
    12fe:	91 e0       	ldi	r25, 0x01	; 1
    1300:	9d 0d       	add	r25, r13
    1302:	f7 01       	movw	r30, r14
    1304:	ed 0d       	add	r30, r13
    1306:	f1 1d       	adc	r31, r1
    1308:	80 5d       	subi	r24, 0xD0	; 208
    130a:	80 83       	st	Z, r24
        }
        while(qr.quot);
    130c:	21 15       	cp	r18, r1
    130e:	31 05       	cpc	r19, r1
    1310:	69 f7       	brne	.-38     	; 0x12ec <lcd_int16+0x94>

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
    1312:	01 11       	cpse	r16, r1
    1314:	58 c0       	rjmp	.+176    	; 0x13c6 <lcd_int16+0x16e>
    1316:	b7 fc       	sbrc	r11, 7
    1318:	61 c0       	rjmp	.+194    	; 0x13dc <lcd_int16+0x184>
                sline[i++] = '-';
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    131a:	11 23       	and	r17, r17
    131c:	a9 f0       	breq	.+42     	; 0x1348 <lcd_int16+0xf0>
    131e:	71 2c       	mov	r7, r1
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    1320:	80 e2       	ldi	r24, 0x20	; 32
          for (; i<(fieldwidth-bSigned) ; ){ sline[i++] = fillch;}
    1322:	29 2f       	mov	r18, r25
    1324:	30 e0       	ldi	r19, 0x00	; 0
    1326:	41 2f       	mov	r20, r17
    1328:	50 e0       	ldi	r21, 0x00	; 0
    132a:	46 19       	sub	r20, r6
    132c:	57 09       	sbc	r21, r7
    132e:	24 17       	cp	r18, r20
    1330:	35 07       	cpc	r19, r21
    1332:	54 f4       	brge	.+20     	; 0x1348 <lcd_int16+0xf0>
    1334:	9f 5f       	subi	r25, 0xFF	; 255
    1336:	f7 01       	movw	r30, r14
    1338:	e2 0f       	add	r30, r18
    133a:	f3 1f       	adc	r31, r19
    133c:	80 83       	st	Z, r24
    133e:	29 2f       	mov	r18, r25
    1340:	30 e0       	ldi	r19, 0x00	; 0
    1342:	24 17       	cp	r18, r20
    1344:	35 07       	cpc	r19, r21
    1346:	b4 f3       	brlt	.-20     	; 0x1334 <lcd_int16+0xdc>
        }

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}
    1348:	55 20       	and	r5, r5
    134a:	31 f0       	breq	.+12     	; 0x1358 <lcd_int16+0x100>
    134c:	f7 01       	movw	r30, r14
    134e:	e9 0f       	add	r30, r25
    1350:	f1 1d       	adc	r31, r1
    1352:	8d e2       	ldi	r24, 0x2D	; 45
    1354:	80 83       	st	Z, r24
    1356:	9f 5f       	subi	r25, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1358:	21 e0       	ldi	r18, 0x01	; 1

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}

        // now output the formatted number 
            do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    135a:	91 50       	subi	r25, 0x01	; 1
    135c:	f7 01       	movw	r30, r14
    135e:	e9 0f       	add	r30, r25
    1360:	f1 1d       	adc	r31, r1
    1362:	80 81       	ld	r24, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1364:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1366:	77 9b       	sbis	0x0e, 7	; 14
    1368:	fe cf       	rjmp	.-4      	; 0x1366 <lcd_int16+0x10e>
  SPDR = byte;                        //send payload
    136a:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    136c:	77 9b       	sbis	0x0e, 7	; 14
    136e:	fe cf       	rjmp	.-4      	; 0x136c <lcd_int16+0x114>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    1370:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1374:	88 60       	ori	r24, 0x08	; 8
    1376:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    137a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    137e:	87 7f       	andi	r24, 0xF7	; 247
    1380:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1384:	e5 ed       	ldi	r30, 0xD5	; 213
    1386:	ea 95       	dec	r30
    1388:	f1 f7       	brne	.-4      	; 0x1386 <lcd_int16+0x12e>
    138a:	00 00       	nop

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}

        // now output the formatted number 
            do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    138c:	91 11       	cpse	r25, r1
    138e:	e5 cf       	rjmp	.-54     	; 0x135a <lcd_int16+0x102>
}
    1390:	61 96       	adiw	r28, 0x11	; 17
    1392:	0f b6       	in	r0, 0x3f	; 63
    1394:	f8 94       	cli
    1396:	de bf       	out	0x3e, r29	; 62
    1398:	0f be       	out	0x3f, r0	; 63
    139a:	cd bf       	out	0x3d, r28	; 61
    139c:	df 91       	pop	r29
    139e:	cf 91       	pop	r28
    13a0:	1f 91       	pop	r17
    13a2:	0f 91       	pop	r16
    13a4:	ff 90       	pop	r15
    13a6:	ef 90       	pop	r14
    13a8:	df 90       	pop	r13
    13aa:	cf 90       	pop	r12
    13ac:	bf 90       	pop	r11
    13ae:	af 90       	pop	r10
    13b0:	9f 90       	pop	r9
    13b2:	8f 90       	pop	r8
    13b4:	7f 90       	pop	r7
    13b6:	6f 90       	pop	r6
    13b8:	5f 90       	pop	r5
    13ba:	08 95       	ret
                  uint8_t decpos, 
                  uint8_t bSigned,
                  uint8_t bZeroFill)
{
        char    sline[NUM_LCD_CHARS+1];
        uint8_t i=0;
    13bc:	d1 2c       	mov	r13, r1
    13be:	ce 01       	movw	r24, r28
    13c0:	01 96       	adiw	r24, 0x01	; 1
    13c2:	7c 01       	movw	r14, r24
    13c4:	94 cf       	rjmp	.-216    	; 0x12ee <lcd_int16+0x96>
                sline[i++] = '-';
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    13c6:	11 23       	and	r17, r17
    13c8:	09 f4       	brne	.+2      	; 0x13cc <lcd_int16+0x174>
    13ca:	be cf       	rjmp	.-132    	; 0x1348 <lcd_int16+0xf0>
    13cc:	71 2c       	mov	r7, r1
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    13ce:	80 e3       	ldi	r24, 0x30	; 48
    13d0:	a8 cf       	rjmp	.-176    	; 0x1322 <lcd_int16+0xca>
    13d2:	22 27       	eor	r18, r18
    13d4:	33 27       	eor	r19, r19
    13d6:	28 1b       	sub	r18, r24
    13d8:	39 0b       	sbc	r19, r25
    13da:	60 cf       	rjmp	.-320    	; 0x129c <lcd_int16+0x44>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    13dc:	d3 94       	inc	r13
    13de:	d3 94       	inc	r13
    13e0:	f7 01       	movw	r30, r14
    13e2:	e9 0f       	add	r30, r25
    13e4:	f1 1d       	adc	r31, r1
    13e6:	8d e2       	ldi	r24, 0x2D	; 45
    13e8:	80 83       	st	Z, r24
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    13ea:	11 23       	and	r17, r17
    13ec:	59 f0       	breq	.+22     	; 0x1404 <lcd_int16+0x1ac>
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
          for (; i<(fieldwidth-bSigned) ; ){ sline[i++] = fillch;}
    13ee:	2d 2d       	mov	r18, r13
    13f0:	30 e0       	ldi	r19, 0x00	; 0
    13f2:	41 2f       	mov	r20, r17
    13f4:	50 e0       	ldi	r21, 0x00	; 0
    13f6:	24 17       	cp	r18, r20
    13f8:	35 07       	cpc	r19, r21
    13fa:	24 f4       	brge	.+8      	; 0x1404 <lcd_int16+0x1ac>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    13fc:	9d 2d       	mov	r25, r13
                bSigned = 0;
    13fe:	51 2c       	mov	r5, r1
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    1400:	80 e2       	ldi	r24, 0x20	; 32
    1402:	98 cf       	rjmp	.-208    	; 0x1334 <lcd_int16+0xdc>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    1404:	9d 2d       	mov	r25, r13
    1406:	a8 cf       	rjmp	.-176    	; 0x1358 <lcd_int16+0x100>

00001408 <__vector_33>:

//****************************************************************************
//This is the TWI ISR. Different actions are taken depending upon the value
//of the TWI status register TWSR.
//****************************************************************************/
ISR(TWI_vect){
    1408:	1f 92       	push	r1
    140a:	0f 92       	push	r0
    140c:	0f b6       	in	r0, 0x3f	; 63
    140e:	0f 92       	push	r0
    1410:	11 24       	eor	r1, r1
    1412:	0b b6       	in	r0, 0x3b	; 59
    1414:	0f 92       	push	r0
    1416:	2f 93       	push	r18
    1418:	3f 93       	push	r19
    141a:	8f 93       	push	r24
    141c:	9f 93       	push	r25
    141e:	af 93       	push	r26
    1420:	bf 93       	push	r27
    1422:	ef 93       	push	r30
    1424:	ff 93       	push	r31
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    1426:	e0 91 71 00 	lds	r30, 0x0071	; 0x800071 <__TEXT_REGION_LENGTH__+0x7e0071>
    142a:	8e 2f       	mov	r24, r30
    142c:	90 e0       	ldi	r25, 0x00	; 0
    142e:	fc 01       	movw	r30, r24
    1430:	38 97       	sbiw	r30, 0x08	; 8
    1432:	e1 35       	cpi	r30, 0x51	; 81
    1434:	f1 05       	cpc	r31, r1
    1436:	b0 f0       	brcs	.+44     	; 0x1464 <__vector_33+0x5c>
      break;      
    case TW_MT_ARB_LOST:                //Arbitration lost 
      TWCR = TWCR_START;                //initiate RESTART 
      break;
    default:                            //Error occured, save TWSR 
      twi_state = TWSR;         
    1438:	80 91 71 00 	lds	r24, 0x0071	; 0x800071 <__TEXT_REGION_LENGTH__+0x7e0071>
    143c:	80 93 94 01 	sts	0x0194, r24	; 0x800194 <twi_state>
      TWCR = TWCR_RST;                  //Reset TWI, disable interupts 
    1440:	84 e0       	ldi	r24, 0x04	; 4
    1442:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
  }//switch
}//TWI_isr
    1446:	ff 91       	pop	r31
    1448:	ef 91       	pop	r30
    144a:	bf 91       	pop	r27
    144c:	af 91       	pop	r26
    144e:	9f 91       	pop	r25
    1450:	8f 91       	pop	r24
    1452:	3f 91       	pop	r19
    1454:	2f 91       	pop	r18
    1456:	0f 90       	pop	r0
    1458:	0b be       	out	0x3b, r0	; 59
    145a:	0f 90       	pop	r0
    145c:	0f be       	out	0x3f, r0	; 63
    145e:	0f 90       	pop	r0
    1460:	1f 90       	pop	r1
    1462:	18 95       	reti
//of the TWI status register TWSR.
//****************************************************************************/
ISR(TWI_vect){
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    1464:	ea 5b       	subi	r30, 0xBA	; 186
    1466:	ff 4f       	sbci	r31, 0xFF	; 255
    1468:	0c 94 8d 0b 	jmp	0x171a	; 0x171a <__tablejump2__>
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
      else                               {TWCR = TWCR_RNACK;} //NACK last byte 
      break; 
    case TW_MR_DATA_NACK: //Data byte was rcvd and NACK xmitted
      twi_buf[twi_buf_ptr] = TWDR;      //save last byte to buffer
    146c:	80 91 5f 01 	lds	r24, 0x015F	; 0x80015f <twi_buf_ptr.1780>
    1470:	e0 91 95 01 	lds	r30, 0x0195	; 0x800195 <twi_buf>
    1474:	f0 91 96 01 	lds	r31, 0x0196	; 0x800196 <twi_buf+0x1>
    1478:	e8 0f       	add	r30, r24
    147a:	f1 1d       	adc	r31, r1
    147c:	80 91 73 00 	lds	r24, 0x0073	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
    1480:	80 83       	st	Z, r24
      TWCR = TWCR_STOP;                 //initiate a STOP
    1482:	84 e9       	ldi	r24, 0x94	; 148
    1484:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
      break;      
    1488:	de cf       	rjmp	.-68     	; 0x1446 <__vector_33+0x3e>
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    case TW_START:          //START has been xmitted, fall thorough
    case TW_REP_START:      //Repeated START was xmitted
      TWDR = twi_bus_addr;  //load up the twi bus address
    148a:	80 91 97 01 	lds	r24, 0x0197	; 0x800197 <twi_bus_addr>
    148e:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
      twi_buf_ptr = 0;      //initalize buffer pointer 
    1492:	10 92 5f 01 	sts	0x015F, r1	; 0x80015f <twi_buf_ptr.1780>
      TWCR = TWCR_SEND;     //send SLA+RW
    1496:	85 e8       	ldi	r24, 0x85	; 133
    1498:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
      break;
    149c:	d4 cf       	rjmp	.-88     	; 0x1446 <__vector_33+0x3e>
    case TW_MT_SLA_ACK:     //SLA+W was xmitted and ACK rcvd, fall through 
    case TW_MT_DATA_ACK:                //Data byte was xmitted and ACK rcvd
      if (twi_buf_ptr < twi_msg_size){  //send data till done
    149e:	80 91 5f 01 	lds	r24, 0x015F	; 0x80015f <twi_buf_ptr.1780>
    14a2:	90 91 98 01 	lds	r25, 0x0198	; 0x800198 <twi_msg_size>
    14a6:	89 17       	cp	r24, r25
    14a8:	60 f7       	brcc	.-40     	; 0x1482 <__vector_33+0x7a>
        TWDR = twi_buf[twi_buf_ptr++];  //load next and postincrement index
    14aa:	e0 91 95 01 	lds	r30, 0x0195	; 0x800195 <twi_buf>
    14ae:	f0 91 96 01 	lds	r31, 0x0196	; 0x800196 <twi_buf+0x1>
    14b2:	91 e0       	ldi	r25, 0x01	; 1
    14b4:	98 0f       	add	r25, r24
    14b6:	90 93 5f 01 	sts	0x015F, r25	; 0x80015f <twi_buf_ptr.1780>
    14ba:	e8 0f       	add	r30, r24
    14bc:	f1 1d       	adc	r31, r1
    14be:	80 81       	ld	r24, Z
    14c0:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
        TWCR = TWCR_SEND;               //send next byte 
    14c4:	85 e8       	ldi	r24, 0x85	; 133
    14c6:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
    14ca:	bd cf       	rjmp	.-134    	; 0x1446 <__vector_33+0x3e>
    case TW_MR_DATA_NACK: //Data byte was rcvd and NACK xmitted
      twi_buf[twi_buf_ptr] = TWDR;      //save last byte to buffer
      TWCR = TWCR_STOP;                 //initiate a STOP
      break;      
    case TW_MT_ARB_LOST:                //Arbitration lost 
      TWCR = TWCR_START;                //initiate RESTART 
    14cc:	85 ea       	ldi	r24, 0xA5	; 165
    14ce:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
      break;
    14d2:	b9 cf       	rjmp	.-142    	; 0x1446 <__vector_33+0x3e>
    14d4:	20 91 5f 01 	lds	r18, 0x015F	; 0x80015f <twi_buf_ptr.1780>
      else{TWCR = TWCR_STOP;}           //last byte sent, send STOP 
      break;
    case TW_MR_DATA_ACK:                //Data byte has been rcvd, ACK xmitted, fall through
      twi_buf[twi_buf_ptr++] = TWDR;    //fill buffer with rcvd data
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
    14d8:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <twi_msg_size>
    14dc:	30 e0       	ldi	r19, 0x00	; 0
    14de:	90 e0       	ldi	r25, 0x00	; 0
    14e0:	01 97       	sbiw	r24, 0x01	; 1
    14e2:	28 17       	cp	r18, r24
    14e4:	39 07       	cpc	r19, r25
    14e6:	dc f4       	brge	.+54     	; 0x151e <__vector_33+0x116>
    14e8:	85 ec       	ldi	r24, 0xC5	; 197
    14ea:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
    14ee:	ab cf       	rjmp	.-170    	; 0x1446 <__vector_33+0x3e>
        TWCR = TWCR_SEND;               //send next byte 
      }
      else{TWCR = TWCR_STOP;}           //last byte sent, send STOP 
      break;
    case TW_MR_DATA_ACK:                //Data byte has been rcvd, ACK xmitted, fall through
      twi_buf[twi_buf_ptr++] = TWDR;    //fill buffer with rcvd data
    14f0:	e0 91 95 01 	lds	r30, 0x0195	; 0x800195 <twi_buf>
    14f4:	f0 91 96 01 	lds	r31, 0x0196	; 0x800196 <twi_buf+0x1>
    14f8:	80 91 5f 01 	lds	r24, 0x015F	; 0x80015f <twi_buf_ptr.1780>
    14fc:	21 e0       	ldi	r18, 0x01	; 1
    14fe:	28 0f       	add	r18, r24
    1500:	20 93 5f 01 	sts	0x015F, r18	; 0x80015f <twi_buf_ptr.1780>
    1504:	e8 0f       	add	r30, r24
    1506:	f1 1d       	adc	r31, r1
    1508:	80 91 73 00 	lds	r24, 0x0073	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
    150c:	80 83       	st	Z, r24
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
    150e:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <twi_msg_size>
    1512:	30 e0       	ldi	r19, 0x00	; 0
    1514:	90 e0       	ldi	r25, 0x00	; 0
    1516:	01 97       	sbiw	r24, 0x01	; 1
    1518:	28 17       	cp	r18, r24
    151a:	39 07       	cpc	r19, r25
    151c:	2c f3       	brlt	.-54     	; 0x14e8 <__vector_33+0xe0>
      else                               {TWCR = TWCR_RNACK;} //NACK last byte 
    151e:	85 e8       	ldi	r24, 0x85	; 133
    1520:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
    1524:	90 cf       	rjmp	.-224    	; 0x1446 <__vector_33+0x3e>

00001526 <twi_busy>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    1526:	80 91 74 00 	lds	r24, 0x0074	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
}
    152a:	81 70       	andi	r24, 0x01	; 1
    152c:	08 95       	ret

0000152e <twi_start_wr>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    152e:	90 91 74 00 	lds	r25, 0x0074	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
//Initiates a write transfer. Loads global variables. Sends START. ISR handles
//the rest.
//****************************************************************************
void twi_start_wr(uint8_t twi_addr, uint8_t *twi_data, uint8_t byte_cnt){

  while(twi_busy());                    //wait till TWI rdy for next xfer
    1532:	90 fd       	sbrc	r25, 0
    1534:	fc cf       	rjmp	.-8      	; 0x152e <twi_start_wr>
  twi_bus_addr = (twi_addr & ~TW_READ); //set twi bus address, mark as write 
    1536:	8e 7f       	andi	r24, 0xFE	; 254
    1538:	80 93 97 01 	sts	0x0197, r24	; 0x800197 <twi_bus_addr>
  twi_buf = twi_data;                   //load pointer to write buffer
    153c:	70 93 96 01 	sts	0x0196, r23	; 0x800196 <twi_buf+0x1>
    1540:	60 93 95 01 	sts	0x0195, r22	; 0x800195 <twi_buf>
  twi_msg_size = byte_cnt;              //load size of xfer 
    1544:	40 93 98 01 	sts	0x0198, r20	; 0x800198 <twi_msg_size>
  TWCR = TWCR_START;                    //initiate START
    1548:	85 ea       	ldi	r24, 0xA5	; 165
    154a:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
    154e:	08 95       	ret

00001550 <twi_start_rd>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    1550:	90 91 74 00 	lds	r25, 0x0074	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
//Initiates a read transfer. Loads global variables. Sends START. ISR handles
//the rest.
//****************************************************************************
void twi_start_rd(uint8_t twi_addr, uint8_t *twi_data, uint8_t byte_cnt){

  while(twi_busy());                   //wait till TWI rdy for next xfer
    1554:	90 fd       	sbrc	r25, 0
    1556:	fc cf       	rjmp	.-8      	; 0x1550 <twi_start_rd>
  twi_bus_addr = (twi_addr | TW_READ); //set twi bus address, mark as read  
    1558:	81 60       	ori	r24, 0x01	; 1
    155a:	80 93 97 01 	sts	0x0197, r24	; 0x800197 <twi_bus_addr>
  twi_buf = twi_data;                  //load pointer to write buffer
    155e:	70 93 96 01 	sts	0x0196, r23	; 0x800196 <twi_buf+0x1>
    1562:	60 93 95 01 	sts	0x0195, r22	; 0x800195 <twi_buf>
  twi_msg_size = byte_cnt;             //load size of xfer 
    1566:	40 93 98 01 	sts	0x0198, r20	; 0x800198 <twi_msg_size>
  TWCR = TWCR_START;                   //initiate START
    156a:	85 ea       	ldi	r24, 0xA5	; 165
    156c:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
    1570:	08 95       	ret

00001572 <init_twi>:
//10K pullups are present on the board
//for alarm clock an additional 4.7K resistor is also there for pullup
//******************************************************************************

void init_twi(){
  TWDR = 0xFF;     //release SDA, default contents
    1572:	8f ef       	ldi	r24, 0xFF	; 255
    1574:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
  TWSR = 0x00;     //prescaler value = 1
    1578:	10 92 71 00 	sts	0x0071, r1	; 0x800071 <__TEXT_REGION_LENGTH__+0x7e0071>
  TWBR = TWI_TWBR; //defined in twi_master.h 
    157c:	8c e0       	ldi	r24, 0x0C	; 12
    157e:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x7e0070>
    1582:	08 95       	ret

00001584 <lm73_temp_convert>:
   else{ //deg C

   }
//Yeah, this is for you to do! ;^)

}//lm73_temp_convert
    1584:	08 95       	ret

00001586 <main>:
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
    1586:	87 b3       	in	r24, 0x17	; 23
    1588:	87 60       	ori	r24, 0x07	; 7
    158a:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
    158c:	8d b1       	in	r24, 0x0d	; 13
    158e:	8c 65       	ori	r24, 0x5C	; 92
    1590:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
    1592:	70 9a       	sbi	0x0e, 0	; 14
Description: Timer counter 0 is initialized in normal mode with no prescale
	and will be used as a seconds counter for the clock
Parameters: NA
**********************************************************************/
void tcnt0_init(){
   ASSR |= (1<<AS0);
    1594:	80 b7       	in	r24, 0x30	; 48
    1596:	88 60       	ori	r24, 0x08	; 8
    1598:	80 bf       	out	0x30, r24	; 48
   TIMSK |= (1<<OCIE0) | (1<<TOIE0);			//enable interrupts
    159a:	87 b7       	in	r24, 0x37	; 55
    159c:	83 60       	ori	r24, 0x03	; 3
    159e:	87 bf       	out	0x37, r24	; 55
   TCCR0 |= (1<<CS00);			//normal mode, no prescale
    15a0:	83 b7       	in	r24, 0x33	; 51
    15a2:	81 60       	ori	r24, 0x01	; 1
    15a4:	83 bf       	out	0x33, r24	; 51
   OCR0 = 0xFF;
    15a6:	8f ef       	ldi	r24, 0xFF	; 255
    15a8:	81 bf       	out	0x31, r24	; 49
Description: Timer counter 1 is initialized in CTC mode, 64 bit prescaler
	so that it can be used to generate an alarm frequency
Parameters: NA
**********************************************************************/
void tcnt1_init(){
   TCCR1B |= (1<<CS11) | (1<<CS10) | (1<<WGM12);		//CTC mode, 64bit prescaler
    15aa:	8e b5       	in	r24, 0x2e	; 46
    15ac:	8b 60       	ori	r24, 0x0B	; 11
    15ae:	8e bd       	out	0x2e, r24	; 46
   TCCR1C = 0x00;
    15b0:	10 92 7a 00 	sts	0x007A, r1	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
   TIMSK  |= (1<<OCIE1A);	//enable flag for interrupt 
    15b4:	87 b7       	in	r24, 0x37	; 55
    15b6:	80 61       	ori	r24, 0x10	; 16
    15b8:	87 bf       	out	0x37, r24	; 55
   OCR1A = 0x0040;		//compare match at 64
    15ba:	80 e4       	ldi	r24, 0x40	; 64
    15bc:	90 e0       	ldi	r25, 0x00	; 0
    15be:	9b bd       	out	0x2b, r25	; 43
    15c0:	8a bd       	out	0x2a, r24	; 42
	normal mode with a 64 bit prescaler. OCRA2 is adjusted to change
	the pwn produced.
Parameters: NA
**********************************************************************/
void tcnt2_init(){
   TCCR2 |= (1<<WGM21) | (1<<WGM20)| (1<<CS20) | (1<<COM21);			
    15c2:	85 b5       	in	r24, 0x25	; 37
    15c4:	89 66       	ori	r24, 0x69	; 105
    15c6:	85 bd       	out	0x25, r24	; 37
Description: This timer is used as a volume control for the audio amp.
	I adjust the value of OCR3A to change the pwm.
Parameters: NA
**********************************************************************/
void tcnt3_init(){
   TCCR3A |= (1<<COM3A1) | (1<<WGM31);	 //Clear on OCR3A match
    15c8:	80 91 8b 00 	lds	r24, 0x008B	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
    15cc:	82 68       	ori	r24, 0x82	; 130
    15ce:	80 93 8b 00 	sts	0x008B, r24	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
   TCCR3B |= (1<<CS30) | (1<<WGM32) | (1<<WGM33);		//Fast PWM mode, no prescaler
    15d2:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
    15d6:	89 61       	ori	r24, 0x19	; 25
    15d8:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
   TCCR3C = 0x00;
    15dc:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x7e008c>
   ICR3 = 0x9F;				//Setting the TOP value
    15e0:	8f e9       	ldi	r24, 0x9F	; 159
    15e2:	90 e0       	ldi	r25, 0x00	; 0
    15e4:	90 93 81 00 	sts	0x0081, r25	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
    15e8:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
   TCNT3 = 0x0000; 			//Initialize TNCT1 to 0
    15ec:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    15f0:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
   OCR3A = 0x9F;			//Volume Control 0x9F=Max 0x00=Min
    15f4:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
    15f8:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
   spi_init();				//Initalize spi, counters,adc, and lcd
   tcnt0_init();
   tcnt1_init();
   tcnt2_init();
   tcnt3_init();
   port_init();
    15fc:	0e 94 a9 04 	call	0x952	; 0x952 <port_init>
Description: Basic adc initialization used for single shot adc readings
Parameters: NA
**********************************************************************/
void adc_init(){
//Initalize ADC and its ports
   DDRF  &= ~(_BV(DDF7)); //make port F bit 7 is ADC input  
    1600:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
    1604:	8f 77       	andi	r24, 0x7F	; 127
    1606:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
   PORTF &= ~(_BV(PF7));  //port F bit 7 pullups must be off
    160a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    160e:	8f 77       	andi	r24, 0x7F	; 127
    1610:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
   ADMUX |= (1<<REFS0) | (1<<MUX2)| (1<<MUX1)| (1<<MUX0); //single-ended, input PORTF bit 7, right adjusted, 10 bits
    1614:	87 b1       	in	r24, 0x07	; 7
    1616:	87 64       	ori	r24, 0x47	; 71
    1618:	87 b9       	out	0x07, r24	; 7

   ADCSRA |= (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);//ADC enabled, don't start yet, single shot mode 
    161a:	86 b1       	in	r24, 0x06	; 6
    161c:	87 68       	ori	r24, 0x87	; 135
    161e:	86 b9       	out	0x06, r24	; 6
   tcnt1_init();
   tcnt2_init();
   tcnt3_init();
   port_init();
   adc_init();
   init_twi();
    1620:	0e 94 b9 0a 	call	0x1572	; 0x1572 <init_twi>
Description: 
Parameters: NA
**********************************************************************/
void local_temp_init(){

lm73_wr_buf[0] = 0x00; //load lm73_wr_buf[0] with temperature pointer address
    1624:	10 92 99 01 	sts	0x0199, r1	; 0x800199 <lm73_wr_buf>
twi_start_wr(LM73_ADDRESS, lm73_rd_buf, 1); //start the TWI write process
    1628:	41 e0       	ldi	r20, 0x01	; 1
    162a:	6b e9       	ldi	r22, 0x9B	; 155
    162c:	71 e0       	ldi	r23, 0x01	; 1
    162e:	80 e9       	ldi	r24, 0x90	; 144
    1630:	0e 94 97 0a 	call	0x152e	; 0x152e <twi_start_wr>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1634:	8f e3       	ldi	r24, 0x3F	; 63
    1636:	9f e1       	ldi	r25, 0x1F	; 31
    1638:	01 97       	sbiw	r24, 0x01	; 1
    163a:	f1 f7       	brne	.-4      	; 0x1638 <main+0xb2>
    163c:	00 c0       	rjmp	.+0      	; 0x163e <main+0xb8>
    163e:	00 00       	nop
   port_init();
   adc_init();
   init_twi();
   local_temp_init();   

   lcd_init();
    1640:	0e 94 94 07 	call	0xf28	; 0xf28 <lcd_init>
   sei();				//Enable interrupts
    1644:	78 94       	sei
	 }
	 PORTA = segment_data[j];	//Writes the segment data to PORTA aka the segments
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
				//the digit to be displayed is in pin 4, 5, and 6 
         _delay_us(200);		//delay so that the display does not flicker
         PORTA = 0xFF;
    1646:	cf ef       	ldi	r28, 0xFF	; 255
   local_temp_init();   

   lcd_init();
   sei();				//Enable interrupts
   while(1){
      refresh_lcd(lcd_array);
    1648:	86 e1       	ldi	r24, 0x16	; 22
    164a:	91 e0       	ldi	r25, 0x01	; 1
    164c:	0e 94 63 05 	call	0xac6	; 0xac6 <refresh_lcd>
Description: This function disables the snooze variable once the alarm
	seconds equals the normal seconds. 
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
    1650:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <snooze>
    1654:	81 11       	cpse	r24, r1
    1656:	2b c0       	rjmp	.+86     	; 0x16ae <main+0x128>
   lcd_init();
   sei();				//Enable interrupts
   while(1){
      refresh_lcd(lcd_array);
      snoozin();
      fetch_adc();
    1658:	0e 94 fd 04 	call	0x9fa	; 0x9fa <fetch_adc>
      clock_time();
    165c:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <clock_time>
      change_alarm_state();
    1660:	0e 94 ba 04 	call	0x974	; 0x974 <change_alarm_state>
    1664:	e6 e3       	ldi	r30, 0x36	; 54
    1666:	f1 e0       	ldi	r31, 0x01	; 1
    1668:	80 e0       	ldi	r24, 0x00	; 0
      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
         if(alarm){
    166a:	90 91 43 01 	lds	r25, 0x0143	; 0x800143 <alarm>
    166e:	99 23       	and	r25, r25
    1670:	29 f0       	breq	.+10     	; 0x167c <main+0xf6>
	    segment_data[2] &= 0b011;
    1672:	90 91 38 01 	lds	r25, 0x0138	; 0x800138 <__data_end+0x2>
    1676:	93 70       	andi	r25, 0x03	; 3
    1678:	90 93 38 01 	sts	0x0138, r25	; 0x800138 <__data_end+0x2>
	 }
	 PORTA = segment_data[j];	//Writes the segment data to PORTA aka the segments
    167c:	91 91       	ld	r25, Z+
    167e:	9b bb       	out	0x1b, r25	; 27
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
    1680:	98 2f       	mov	r25, r24
    1682:	92 95       	swap	r25
    1684:	90 7f       	andi	r25, 0xF0	; 240
    1686:	98 bb       	out	0x18, r25	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1688:	af e1       	ldi	r26, 0x1F	; 31
    168a:	b3 e0       	ldi	r27, 0x03	; 3
    168c:	11 97       	sbiw	r26, 0x01	; 1
    168e:	f1 f7       	brne	.-4      	; 0x168c <main+0x106>
    1690:	00 c0       	rjmp	.+0      	; 0x1692 <main+0x10c>
    1692:	00 00       	nop
				//the digit to be displayed is in pin 4, 5, and 6 
         _delay_us(200);		//delay so that the display does not flicker
         PORTA = 0xFF;
    1694:	cb bb       	out	0x1b, r28	; 27
    1696:	8f 5f       	subi	r24, 0xFF	; 255
      refresh_lcd(lcd_array);
      snoozin();
      fetch_adc();
      clock_time();
      change_alarm_state();
      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
    1698:	85 30       	cpi	r24, 0x05	; 5
    169a:	39 f7       	brne	.-50     	; 0x166a <main+0xe4>
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
				//the digit to be displayed is in pin 4, 5, and 6 
         _delay_us(200);		//delay so that the display does not flicker
         PORTA = 0xFF;
      }
	PORTB = 0x00;;
    169c:	18 ba       	out	0x18, r1	; 24
   local_temp_init();   

   lcd_init();
   sei();				//Enable interrupts
   while(1){
      refresh_lcd(lcd_array);
    169e:	86 e1       	ldi	r24, 0x16	; 22
    16a0:	91 e0       	ldi	r25, 0x01	; 1
    16a2:	0e 94 63 05 	call	0xac6	; 0xac6 <refresh_lcd>
Description: This function disables the snooze variable once the alarm
	seconds equals the normal seconds. 
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
    16a6:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <snooze>
    16aa:	88 23       	and	r24, r24
    16ac:	a9 f2       	breq	.-86     	; 0x1658 <main+0xd2>
    16ae:	0e 94 b8 00 	call	0x170	; 0x170 <snoozin.part.1>
    16b2:	d2 cf       	rjmp	.-92     	; 0x1658 <main+0xd2>

000016b4 <__divmodhi4>:
    16b4:	97 fb       	bst	r25, 7
    16b6:	07 2e       	mov	r0, r23
    16b8:	16 f4       	brtc	.+4      	; 0x16be <__divmodhi4+0xa>
    16ba:	00 94       	com	r0
    16bc:	07 d0       	rcall	.+14     	; 0x16cc <__divmodhi4_neg1>
    16be:	77 fd       	sbrc	r23, 7
    16c0:	09 d0       	rcall	.+18     	; 0x16d4 <__divmodhi4_neg2>
    16c2:	0e 94 96 0b 	call	0x172c	; 0x172c <__udivmodhi4>
    16c6:	07 fc       	sbrc	r0, 7
    16c8:	05 d0       	rcall	.+10     	; 0x16d4 <__divmodhi4_neg2>
    16ca:	3e f4       	brtc	.+14     	; 0x16da <__divmodhi4_exit>

000016cc <__divmodhi4_neg1>:
    16cc:	90 95       	com	r25
    16ce:	81 95       	neg	r24
    16d0:	9f 4f       	sbci	r25, 0xFF	; 255
    16d2:	08 95       	ret

000016d4 <__divmodhi4_neg2>:
    16d4:	70 95       	com	r23
    16d6:	61 95       	neg	r22
    16d8:	7f 4f       	sbci	r23, 0xFF	; 255

000016da <__divmodhi4_exit>:
    16da:	08 95       	ret

000016dc <__divmodsi4>:
    16dc:	05 2e       	mov	r0, r21
    16de:	97 fb       	bst	r25, 7
    16e0:	1e f4       	brtc	.+6      	; 0x16e8 <__divmodsi4+0xc>
    16e2:	00 94       	com	r0
    16e4:	0e 94 85 0b 	call	0x170a	; 0x170a <__negsi2>
    16e8:	57 fd       	sbrc	r21, 7
    16ea:	07 d0       	rcall	.+14     	; 0x16fa <__divmodsi4_neg2>
    16ec:	0e 94 aa 0b 	call	0x1754	; 0x1754 <__udivmodsi4>
    16f0:	07 fc       	sbrc	r0, 7
    16f2:	03 d0       	rcall	.+6      	; 0x16fa <__divmodsi4_neg2>
    16f4:	4e f4       	brtc	.+18     	; 0x1708 <__divmodsi4_exit>
    16f6:	0c 94 85 0b 	jmp	0x170a	; 0x170a <__negsi2>

000016fa <__divmodsi4_neg2>:
    16fa:	50 95       	com	r21
    16fc:	40 95       	com	r20
    16fe:	30 95       	com	r19
    1700:	21 95       	neg	r18
    1702:	3f 4f       	sbci	r19, 0xFF	; 255
    1704:	4f 4f       	sbci	r20, 0xFF	; 255
    1706:	5f 4f       	sbci	r21, 0xFF	; 255

00001708 <__divmodsi4_exit>:
    1708:	08 95       	ret

0000170a <__negsi2>:
    170a:	90 95       	com	r25
    170c:	80 95       	com	r24
    170e:	70 95       	com	r23
    1710:	61 95       	neg	r22
    1712:	7f 4f       	sbci	r23, 0xFF	; 255
    1714:	8f 4f       	sbci	r24, 0xFF	; 255
    1716:	9f 4f       	sbci	r25, 0xFF	; 255
    1718:	08 95       	ret

0000171a <__tablejump2__>:
    171a:	ee 0f       	add	r30, r30
    171c:	ff 1f       	adc	r31, r31
    171e:	00 24       	eor	r0, r0
    1720:	00 1c       	adc	r0, r0
    1722:	0b be       	out	0x3b, r0	; 59
    1724:	07 90       	elpm	r0, Z+
    1726:	f6 91       	elpm	r31, Z
    1728:	e0 2d       	mov	r30, r0
    172a:	09 94       	ijmp

0000172c <__udivmodhi4>:
    172c:	aa 1b       	sub	r26, r26
    172e:	bb 1b       	sub	r27, r27
    1730:	51 e1       	ldi	r21, 0x11	; 17
    1732:	07 c0       	rjmp	.+14     	; 0x1742 <__udivmodhi4_ep>

00001734 <__udivmodhi4_loop>:
    1734:	aa 1f       	adc	r26, r26
    1736:	bb 1f       	adc	r27, r27
    1738:	a6 17       	cp	r26, r22
    173a:	b7 07       	cpc	r27, r23
    173c:	10 f0       	brcs	.+4      	; 0x1742 <__udivmodhi4_ep>
    173e:	a6 1b       	sub	r26, r22
    1740:	b7 0b       	sbc	r27, r23

00001742 <__udivmodhi4_ep>:
    1742:	88 1f       	adc	r24, r24
    1744:	99 1f       	adc	r25, r25
    1746:	5a 95       	dec	r21
    1748:	a9 f7       	brne	.-22     	; 0x1734 <__udivmodhi4_loop>
    174a:	80 95       	com	r24
    174c:	90 95       	com	r25
    174e:	bc 01       	movw	r22, r24
    1750:	cd 01       	movw	r24, r26
    1752:	08 95       	ret

00001754 <__udivmodsi4>:
    1754:	a1 e2       	ldi	r26, 0x21	; 33
    1756:	1a 2e       	mov	r1, r26
    1758:	aa 1b       	sub	r26, r26
    175a:	bb 1b       	sub	r27, r27
    175c:	fd 01       	movw	r30, r26
    175e:	0d c0       	rjmp	.+26     	; 0x177a <__udivmodsi4_ep>

00001760 <__udivmodsi4_loop>:
    1760:	aa 1f       	adc	r26, r26
    1762:	bb 1f       	adc	r27, r27
    1764:	ee 1f       	adc	r30, r30
    1766:	ff 1f       	adc	r31, r31
    1768:	a2 17       	cp	r26, r18
    176a:	b3 07       	cpc	r27, r19
    176c:	e4 07       	cpc	r30, r20
    176e:	f5 07       	cpc	r31, r21
    1770:	20 f0       	brcs	.+8      	; 0x177a <__udivmodsi4_ep>
    1772:	a2 1b       	sub	r26, r18
    1774:	b3 0b       	sbc	r27, r19
    1776:	e4 0b       	sbc	r30, r20
    1778:	f5 0b       	sbc	r31, r21

0000177a <__udivmodsi4_ep>:
    177a:	66 1f       	adc	r22, r22
    177c:	77 1f       	adc	r23, r23
    177e:	88 1f       	adc	r24, r24
    1780:	99 1f       	adc	r25, r25
    1782:	1a 94       	dec	r1
    1784:	69 f7       	brne	.-38     	; 0x1760 <__udivmodsi4_loop>
    1786:	60 95       	com	r22
    1788:	70 95       	com	r23
    178a:	80 95       	com	r24
    178c:	90 95       	com	r25
    178e:	9b 01       	movw	r18, r22
    1790:	ac 01       	movw	r20, r24
    1792:	bd 01       	movw	r22, r26
    1794:	cf 01       	movw	r24, r30
    1796:	08 95       	ret

00001798 <__itoa_ncheck>:
    1798:	bb 27       	eor	r27, r27
    179a:	4a 30       	cpi	r20, 0x0A	; 10
    179c:	31 f4       	brne	.+12     	; 0x17aa <__itoa_ncheck+0x12>
    179e:	99 23       	and	r25, r25
    17a0:	22 f4       	brpl	.+8      	; 0x17aa <__itoa_ncheck+0x12>
    17a2:	bd e2       	ldi	r27, 0x2D	; 45
    17a4:	90 95       	com	r25
    17a6:	81 95       	neg	r24
    17a8:	9f 4f       	sbci	r25, 0xFF	; 255
    17aa:	0c 94 d8 0b 	jmp	0x17b0	; 0x17b0 <__utoa_common>

000017ae <__utoa_ncheck>:
    17ae:	bb 27       	eor	r27, r27

000017b0 <__utoa_common>:
    17b0:	fb 01       	movw	r30, r22
    17b2:	55 27       	eor	r21, r21
    17b4:	aa 27       	eor	r26, r26
    17b6:	88 0f       	add	r24, r24
    17b8:	99 1f       	adc	r25, r25
    17ba:	aa 1f       	adc	r26, r26
    17bc:	a4 17       	cp	r26, r20
    17be:	10 f0       	brcs	.+4      	; 0x17c4 <__utoa_common+0x14>
    17c0:	a4 1b       	sub	r26, r20
    17c2:	83 95       	inc	r24
    17c4:	50 51       	subi	r21, 0x10	; 16
    17c6:	b9 f7       	brne	.-18     	; 0x17b6 <__utoa_common+0x6>
    17c8:	a0 5d       	subi	r26, 0xD0	; 208
    17ca:	aa 33       	cpi	r26, 0x3A	; 58
    17cc:	08 f0       	brcs	.+2      	; 0x17d0 <__utoa_common+0x20>
    17ce:	a9 5d       	subi	r26, 0xD9	; 217
    17d0:	a1 93       	st	Z+, r26
    17d2:	00 97       	sbiw	r24, 0x00	; 0
    17d4:	79 f7       	brne	.-34     	; 0x17b4 <__utoa_common+0x4>
    17d6:	b1 11       	cpse	r27, r1
    17d8:	b1 93       	st	Z+, r27
    17da:	11 92       	st	Z+, r1
    17dc:	cb 01       	movw	r24, r22
    17de:	0c 94 f1 0b 	jmp	0x17e2	; 0x17e2 <strrev>

000017e2 <strrev>:
    17e2:	dc 01       	movw	r26, r24
    17e4:	fc 01       	movw	r30, r24
    17e6:	67 2f       	mov	r22, r23
    17e8:	71 91       	ld	r23, Z+
    17ea:	77 23       	and	r23, r23
    17ec:	e1 f7       	brne	.-8      	; 0x17e6 <strrev+0x4>
    17ee:	32 97       	sbiw	r30, 0x02	; 2
    17f0:	04 c0       	rjmp	.+8      	; 0x17fa <strrev+0x18>
    17f2:	7c 91       	ld	r23, X
    17f4:	6d 93       	st	X+, r22
    17f6:	70 83       	st	Z, r23
    17f8:	62 91       	ld	r22, -Z
    17fa:	ae 17       	cp	r26, r30
    17fc:	bf 07       	cpc	r27, r31
    17fe:	c8 f3       	brcs	.-14     	; 0x17f2 <strrev+0x10>
    1800:	08 95       	ret

00001802 <_exit>:
    1802:	f8 94       	cli

00001804 <__stop_program>:
    1804:	ff cf       	rjmp	.-2      	; 0x1804 <__stop_program>
