
lab5.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000046  00800100  00001920  000019b4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001920  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000ee  00800146  00800146  000019fa  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000019fa  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001a2c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000a8  00000000  00000000  00001a68  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002bd5  00000000  00000000  00001b10  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000010f5  00000000  00000000  000046e5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001563  00000000  00000000  000057da  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000598  00000000  00000000  00006d40  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000089a  00000000  00000000  000072d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001e6d  00000000  00000000  00007b72  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000e0  00000000  00000000  000099df  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 97 00 	jmp	0x12e	; 0x12e <__ctors_end>
       4:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
       8:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
       c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      10:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      14:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      18:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      1c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      20:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      24:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      28:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      2c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      30:	0c 94 07 05 	jmp	0xa0e	; 0xa0e <__vector_12>
      34:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      38:	0c 94 2e 05 	jmp	0xa5c	; 0xa5c <__vector_14>
      3c:	0c 94 ad 03 	jmp	0x75a	; 0x75a <__vector_15>
      40:	0c 94 77 03 	jmp	0x6ee	; 0x6ee <__vector_16>
      44:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      48:	0c 94 55 05 	jmp	0xaaa	; 0xaaa <__vector_18>
      4c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      50:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      54:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      58:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      5c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      60:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      64:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      68:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      6c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      70:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      74:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      78:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      7c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      80:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      84:	0c 94 39 0a 	jmp	0x1472	; 0x1472 <__vector_33>
      88:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      8c:	7a 0a       	sbc	r7, r26
      8e:	51 0a       	sbc	r5, r17
      90:	51 0a       	sbc	r5, r17
      92:	51 0a       	sbc	r5, r17
      94:	51 0a       	sbc	r5, r17
      96:	51 0a       	sbc	r5, r17
      98:	51 0a       	sbc	r5, r17
      9a:	51 0a       	sbc	r5, r17
      9c:	7a 0a       	sbc	r7, r26
      9e:	51 0a       	sbc	r5, r17
      a0:	51 0a       	sbc	r5, r17
      a2:	51 0a       	sbc	r5, r17
      a4:	51 0a       	sbc	r5, r17
      a6:	51 0a       	sbc	r5, r17
      a8:	51 0a       	sbc	r5, r17
      aa:	51 0a       	sbc	r5, r17
      ac:	84 0a       	sbc	r8, r20
      ae:	51 0a       	sbc	r5, r17
      b0:	51 0a       	sbc	r5, r17
      b2:	51 0a       	sbc	r5, r17
      b4:	51 0a       	sbc	r5, r17
      b6:	51 0a       	sbc	r5, r17
      b8:	51 0a       	sbc	r5, r17
      ba:	51 0a       	sbc	r5, r17
      bc:	51 0a       	sbc	r5, r17
      be:	51 0a       	sbc	r5, r17
      c0:	51 0a       	sbc	r5, r17
      c2:	51 0a       	sbc	r5, r17
      c4:	51 0a       	sbc	r5, r17
      c6:	51 0a       	sbc	r5, r17
      c8:	51 0a       	sbc	r5, r17
      ca:	51 0a       	sbc	r5, r17
      cc:	84 0a       	sbc	r8, r20
      ce:	51 0a       	sbc	r5, r17
      d0:	51 0a       	sbc	r5, r17
      d2:	51 0a       	sbc	r5, r17
      d4:	51 0a       	sbc	r5, r17
      d6:	51 0a       	sbc	r5, r17
      d8:	51 0a       	sbc	r5, r17
      da:	51 0a       	sbc	r5, r17
      dc:	51 0a       	sbc	r5, r17
      de:	51 0a       	sbc	r5, r17
      e0:	51 0a       	sbc	r5, r17
      e2:	51 0a       	sbc	r5, r17
      e4:	51 0a       	sbc	r5, r17
      e6:	51 0a       	sbc	r5, r17
      e8:	51 0a       	sbc	r5, r17
      ea:	51 0a       	sbc	r5, r17
      ec:	9b 0a       	sbc	r9, r27
      ee:	51 0a       	sbc	r5, r17
      f0:	51 0a       	sbc	r5, r17
      f2:	51 0a       	sbc	r5, r17
      f4:	51 0a       	sbc	r5, r17
      f6:	51 0a       	sbc	r5, r17
      f8:	51 0a       	sbc	r5, r17
      fa:	51 0a       	sbc	r5, r17
      fc:	9f 0a       	sbc	r9, r31
      fe:	51 0a       	sbc	r5, r17
     100:	51 0a       	sbc	r5, r17
     102:	51 0a       	sbc	r5, r17
     104:	51 0a       	sbc	r5, r17
     106:	51 0a       	sbc	r5, r17
     108:	51 0a       	sbc	r5, r17
     10a:	51 0a       	sbc	r5, r17
     10c:	51 0a       	sbc	r5, r17
     10e:	51 0a       	sbc	r5, r17
     110:	51 0a       	sbc	r5, r17
     112:	51 0a       	sbc	r5, r17
     114:	51 0a       	sbc	r5, r17
     116:	51 0a       	sbc	r5, r17
     118:	51 0a       	sbc	r5, r17
     11a:	51 0a       	sbc	r5, r17
     11c:	ad 0a       	sbc	r10, r29
     11e:	51 0a       	sbc	r5, r17
     120:	51 0a       	sbc	r5, r17
     122:	51 0a       	sbc	r5, r17
     124:	51 0a       	sbc	r5, r17
     126:	51 0a       	sbc	r5, r17
     128:	51 0a       	sbc	r5, r17
     12a:	51 0a       	sbc	r5, r17
     12c:	6b 0a       	sbc	r6, r27

0000012e <__ctors_end>:
     12e:	11 24       	eor	r1, r1
     130:	1f be       	out	0x3f, r1	; 63
     132:	cf ef       	ldi	r28, 0xFF	; 255
     134:	d0 e1       	ldi	r29, 0x10	; 16
     136:	de bf       	out	0x3e, r29	; 62
     138:	cd bf       	out	0x3d, r28	; 61

0000013a <__do_copy_data>:
     13a:	11 e0       	ldi	r17, 0x01	; 1
     13c:	a0 e0       	ldi	r26, 0x00	; 0
     13e:	b1 e0       	ldi	r27, 0x01	; 1
     140:	e0 e2       	ldi	r30, 0x20	; 32
     142:	f9 e1       	ldi	r31, 0x19	; 25
     144:	00 e0       	ldi	r16, 0x00	; 0
     146:	0b bf       	out	0x3b, r16	; 59
     148:	02 c0       	rjmp	.+4      	; 0x14e <__do_copy_data+0x14>
     14a:	07 90       	elpm	r0, Z+
     14c:	0d 92       	st	X+, r0
     14e:	a6 34       	cpi	r26, 0x46	; 70
     150:	b1 07       	cpc	r27, r17
     152:	d9 f7       	brne	.-10     	; 0x14a <__do_copy_data+0x10>

00000154 <__do_clear_bss>:
     154:	22 e0       	ldi	r18, 0x02	; 2
     156:	a6 e4       	ldi	r26, 0x46	; 70
     158:	b1 e0       	ldi	r27, 0x01	; 1
     15a:	01 c0       	rjmp	.+2      	; 0x15e <.do_clear_bss_start>

0000015c <.do_clear_bss_loop>:
     15c:	1d 92       	st	X+, r1

0000015e <.do_clear_bss_start>:
     15e:	a4 33       	cpi	r26, 0x34	; 52
     160:	b2 07       	cpc	r27, r18
     162:	e1 f7       	brne	.-8      	; 0x15c <.do_clear_bss_loop>
     164:	0e 94 38 0b 	call	0x1670	; 0x1670 <main>
     168:	0c 94 8e 0c 	jmp	0x191c	; 0x191c <_exit>

0000016c <__bad_interrupt>:
     16c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000170 <snoozin.part.1>:
	seconds equals the normal seconds. 
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
      if(a_sec_count == sec_count)
     170:	90 91 57 01 	lds	r25, 0x0157	; 0x800157 <a_sec_count>
     174:	80 91 5a 01 	lds	r24, 0x015A	; 0x80015a <sec_count>
     178:	98 17       	cp	r25, r24
     17a:	21 f0       	breq	.+8      	; 0x184 <snoozin.part.1+0x14>
         snooze = 0;
      else 
         snooze = 1;
     17c:	81 e0       	ldi	r24, 0x01	; 1
     17e:	80 93 52 01 	sts	0x0152, r24	; 0x800152 <snooze>
     182:	08 95       	ret
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
      if(a_sec_count == sec_count)
         snooze = 0;
     184:	10 92 52 01 	sts	0x0152, r1	; 0x800152 <snooze>
     188:	08 95       	ret

0000018a <spi_init>:
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
     18a:	87 b3       	in	r24, 0x17	; 23
     18c:	87 60       	ori	r24, 0x07	; 7
     18e:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
     190:	8d b1       	in	r24, 0x0d	; 13
     192:	8c 65       	ori	r24, 0x5C	; 92
     194:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
     196:	70 9a       	sbi	0x0e, 0	; 14
     198:	08 95       	ret

0000019a <tcnt0_init>:
Description: Timer counter 0 is initialized in normal mode with no prescale
	and will be used as a seconds counter for the clock
Parameters: NA
**********************************************************************/
void tcnt0_init(){
   ASSR |= (1<<AS0);
     19a:	80 b7       	in	r24, 0x30	; 48
     19c:	88 60       	ori	r24, 0x08	; 8
     19e:	80 bf       	out	0x30, r24	; 48
   TIMSK |= (1<<OCIE0) | (1<<TOIE0);			//enable interrupts
     1a0:	87 b7       	in	r24, 0x37	; 55
     1a2:	83 60       	ori	r24, 0x03	; 3
     1a4:	87 bf       	out	0x37, r24	; 55
   TCCR0 |= (1<<CS00);			//normal mode, no prescale
     1a6:	83 b7       	in	r24, 0x33	; 51
     1a8:	81 60       	ori	r24, 0x01	; 1
     1aa:	83 bf       	out	0x33, r24	; 51
   OCR0 = 0xFF;
     1ac:	8f ef       	ldi	r24, 0xFF	; 255
     1ae:	81 bf       	out	0x31, r24	; 49
     1b0:	08 95       	ret

000001b2 <tcnt1_init>:
Description: Timer counter 1 is initialized in CTC mode, 64 bit prescaler
	so that it can be used to generate an alarm frequency
Parameters: NA
**********************************************************************/
void tcnt1_init(){
   TCCR1B |= (1<<CS11) | (1<<CS10) | (1<<WGM12);		//CTC mode, 64bit prescaler
     1b2:	8e b5       	in	r24, 0x2e	; 46
     1b4:	8b 60       	ori	r24, 0x0B	; 11
     1b6:	8e bd       	out	0x2e, r24	; 46
   TCCR1C = 0x00;
     1b8:	10 92 7a 00 	sts	0x007A, r1	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
   TIMSK  |= (1<<OCIE1A) | (1<<TOIE1);	//enable flag for interrupt 
     1bc:	87 b7       	in	r24, 0x37	; 55
     1be:	84 61       	ori	r24, 0x14	; 20
     1c0:	87 bf       	out	0x37, r24	; 55
   OCR1A = 0x0040;		//compare match at 64
     1c2:	80 e4       	ldi	r24, 0x40	; 64
     1c4:	90 e0       	ldi	r25, 0x00	; 0
     1c6:	9b bd       	out	0x2b, r25	; 43
     1c8:	8a bd       	out	0x2a, r24	; 42
     1ca:	08 95       	ret

000001cc <tcnt2_init>:
	normal mode with a 64 bit prescaler. OCRA2 is adjusted to change
	the pwn produced.
Parameters: NA
**********************************************************************/
void tcnt2_init(){
   TCCR2 |= (1<<WGM21) | (1<<WGM20)| (1<<CS20) | (1<<COM21);			
     1cc:	85 b5       	in	r24, 0x25	; 37
     1ce:	89 66       	ori	r24, 0x69	; 105
     1d0:	85 bd       	out	0x25, r24	; 37
     1d2:	08 95       	ret

000001d4 <tcnt3_init>:
Description: This timer is used as a volume control for the audio amp.
	I adjust the value of OCR3A to change the pwm.
Parameters: NA
**********************************************************************/
void tcnt3_init(){
   TCCR3A |= (1<<COM3A1) | (1<<WGM31);	 //Clear on OCR3A match
     1d4:	eb e8       	ldi	r30, 0x8B	; 139
     1d6:	f0 e0       	ldi	r31, 0x00	; 0
     1d8:	80 81       	ld	r24, Z
     1da:	82 68       	ori	r24, 0x82	; 130
     1dc:	80 83       	st	Z, r24
   TCCR3B |= (1<<CS30) | (1<<WGM32) | (1<<WGM33);		//Fast PWM mode, no prescaler
     1de:	ea e8       	ldi	r30, 0x8A	; 138
     1e0:	f0 e0       	ldi	r31, 0x00	; 0
     1e2:	80 81       	ld	r24, Z
     1e4:	89 61       	ori	r24, 0x19	; 25
     1e6:	80 83       	st	Z, r24
   TCCR3C = 0x00;
     1e8:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x7e008c>
   ICR3 = 0x9F;				//Setting the TOP value
     1ec:	8f e9       	ldi	r24, 0x9F	; 159
     1ee:	90 e0       	ldi	r25, 0x00	; 0
     1f0:	90 93 81 00 	sts	0x0081, r25	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
     1f4:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
   TCNT3 = 0x0000; 			//Initialize TNCT1 to 0
     1f8:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     1fc:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
   OCR3A = 0x9F;			//Volume Control 0x9F=Max 0x00=Min
     200:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     204:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
     208:	08 95       	ret

0000020a <spi_read>:
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
     20a:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
     20c:	77 9b       	sbis	0x0e, 7	; 14
     20e:	fe cf       	rjmp	.-4      	; 0x20c <spi_read+0x2>
   return SPDR;
     210:	8f b1       	in	r24, 0x0f	; 15
}
     212:	08 95       	ret

00000214 <chk_buttons>:
	be implemented at the same time. Adapted to check all buttons from 
	Ganssel's "Guide to Debouncing" Expects active low pushbuttons on PINA 
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
     214:	48 2f       	mov	r20, r24
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
     216:	e8 2f       	mov	r30, r24
     218:	f0 e0       	ldi	r31, 0x00	; 0
     21a:	99 b3       	in	r25, 0x19	; 25
     21c:	ee 0f       	add	r30, r30
     21e:	ff 1f       	adc	r31, r31
     220:	e0 5a       	subi	r30, 0xA0	; 160
     222:	fe 4f       	sbci	r31, 0xFE	; 254
     224:	20 81       	ld	r18, Z
     226:	31 81       	ldd	r19, Z+1	; 0x01
     228:	22 0f       	add	r18, r18
     22a:	33 1f       	adc	r19, r19
     22c:	30 6e       	ori	r19, 0xE0	; 224
     22e:	89 2f       	mov	r24, r25
     230:	90 e0       	ldi	r25, 0x00	; 0
     232:	02 c0       	rjmp	.+4      	; 0x238 <chk_buttons+0x24>
     234:	95 95       	asr	r25
     236:	87 95       	ror	r24
     238:	4a 95       	dec	r20
     23a:	e2 f7       	brpl	.-8      	; 0x234 <chk_buttons+0x20>
     23c:	81 70       	andi	r24, 0x01	; 1
     23e:	99 27       	eor	r25, r25
     240:	28 2b       	or	r18, r24
     242:	39 2b       	or	r19, r25
     244:	31 83       	std	Z+1, r19	; 0x01
     246:	20 83       	st	Z, r18
     248:	81 e0       	ldi	r24, 0x01	; 1
     24a:	21 15       	cp	r18, r1
     24c:	30 4f       	sbci	r19, 0xF0	; 240
     24e:	09 f0       	breq	.+2      	; 0x252 <chk_buttons+0x3e>
     250:	80 e0       	ldi	r24, 0x00	; 0
  if (state[button] == 0xF000)
    return 1;
return 0;
}
     252:	08 95       	ret

00000254 <bars>:
Description:This function reads in the button board and updates the 
	LEDs on the bargraph through the serial port.
Parameters: NA
**********************************************************************/
void bars() {
   DDRA = 0x00;				//Set all as inputs
     254:	1a ba       	out	0x1a, r1	; 26
   PORTA = 0xFF;			//Pull up resistors
     256:	8f ef       	ldi	r24, 0xFF	; 255
     258:	8b bb       	out	0x1b, r24	; 27
   PORTB |= PINB | 0x70;		//Enable tristate buffer
     25a:	86 b3       	in	r24, 0x16	; 22
     25c:	98 b3       	in	r25, 0x18	; 24
     25e:	80 67       	ori	r24, 0x70	; 112
     260:	89 2b       	or	r24, r25
     262:	88 bb       	out	0x18, r24	; 24
     264:	e0 e6       	ldi	r30, 0x60	; 96
     266:	f1 e0       	ldi	r31, 0x01	; 1

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     268:	20 e0       	ldi	r18, 0x00	; 0
     26a:	30 e0       	ldi	r19, 0x00	; 0
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
     26c:	61 e0       	ldi	r22, 0x01	; 1
     26e:	70 e0       	ldi	r23, 0x00	; 0
     270:	05 c0       	rjmp	.+10     	; 0x27c <bars+0x28>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     272:	2f 5f       	subi	r18, 0xFF	; 255
     274:	3f 4f       	sbci	r19, 0xFF	; 255
     276:	28 30       	cpi	r18, 0x08	; 8
     278:	31 05       	cpc	r19, r1
     27a:	39 f1       	breq	.+78     	; 0x2ca <bars+0x76>
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
     27c:	99 b3       	in	r25, 0x19	; 25
     27e:	40 81       	ld	r20, Z
     280:	51 81       	ldd	r21, Z+1	; 0x01
     282:	44 0f       	add	r20, r20
     284:	55 1f       	adc	r21, r21
     286:	89 2f       	mov	r24, r25
     288:	90 e0       	ldi	r25, 0x00	; 0
     28a:	02 2e       	mov	r0, r18
     28c:	02 c0       	rjmp	.+4      	; 0x292 <bars+0x3e>
     28e:	95 95       	asr	r25
     290:	87 95       	ror	r24
     292:	0a 94       	dec	r0
     294:	e2 f7       	brpl	.-8      	; 0x28e <bars+0x3a>
     296:	81 70       	andi	r24, 0x01	; 1
     298:	99 27       	eor	r25, r25
     29a:	84 2b       	or	r24, r20
     29c:	95 2b       	or	r25, r21
     29e:	90 6e       	ori	r25, 0xE0	; 224
     2a0:	81 93       	st	Z+, r24
     2a2:	91 93       	st	Z+, r25
  if (state[button] == 0xF000)
     2a4:	81 15       	cp	r24, r1
     2a6:	90 4f       	sbci	r25, 0xF0	; 240
     2a8:	21 f7       	brne	.-56     	; 0x272 <bars+0x1e>
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
     2aa:	cb 01       	movw	r24, r22
     2ac:	02 2e       	mov	r0, r18
     2ae:	02 c0       	rjmp	.+4      	; 0x2b4 <bars+0x60>
     2b0:	88 0f       	add	r24, r24
     2b2:	99 1f       	adc	r25, r25
     2b4:	0a 94       	dec	r0
     2b6:	e2 f7       	brpl	.-8      	; 0x2b0 <bars+0x5c>
     2b8:	90 93 50 01 	sts	0x0150, r25	; 0x800150 <mult+0x1>
     2bc:	80 93 4f 01 	sts	0x014F, r24	; 0x80014f <mult>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     2c0:	2f 5f       	subi	r18, 0xFF	; 255
     2c2:	3f 4f       	sbci	r19, 0xFF	; 255
     2c4:	28 30       	cpi	r18, 0x08	; 8
     2c6:	31 05       	cpc	r19, r1
     2c8:	c9 f6       	brne	.-78     	; 0x27c <bars+0x28>
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
     2ca:	88 b3       	in	r24, 0x18	; 24
     2cc:	18 ba       	out	0x18, r1	; 24
   if(mult == 128){			//Button 8 toggles base 10 and 16
     2ce:	80 91 4f 01 	lds	r24, 0x014F	; 0x80014f <mult>
     2d2:	90 91 50 01 	lds	r25, 0x0150	; 0x800150 <mult+0x1>
     2d6:	80 38       	cpi	r24, 0x80	; 128
     2d8:	91 05       	cpc	r25, r1
     2da:	09 f4       	brne	.+2      	; 0x2de <bars+0x8a>
     2dc:	79 c0       	rjmp	.+242    	; 0x3d0 <bars+0x17c>
      alarm = !(alarm);			//on the LED display
   }
   if(mult == 64){		//Button 7 toggles snooze
     2de:	80 91 4f 01 	lds	r24, 0x014F	; 0x80014f <mult>
     2e2:	90 91 50 01 	lds	r25, 0x0150	; 0x800150 <mult+0x1>
     2e6:	80 34       	cpi	r24, 0x40	; 64
     2e8:	91 05       	cpc	r25, r1
     2ea:	c9 f1       	breq	.+114    	; 0x35e <bars+0x10a>
	       a_hour_count = 0;
	    }
	 }  
      }
   }
   if(mult > 4) {			//I only want values from the
     2ec:	80 91 4f 01 	lds	r24, 0x014F	; 0x80014f <mult>
     2f0:	90 91 50 01 	lds	r25, 0x0150	; 0x800150 <mult+0x1>
     2f4:	05 97       	sbiw	r24, 0x05	; 5
     2f6:	20 f0       	brcs	.+8      	; 0x300 <bars+0xac>
      mult = 0;				//first three buttons
     2f8:	10 92 50 01 	sts	0x0150, r1	; 0x800150 <mult+0x1>
     2fc:	10 92 4f 01 	sts	0x014F, r1	; 0x80014f <mult>
   }
   //This switch statement is used to enable a 'toggle' functionality
   //so that modes can be selected an deselected
   switch(mult) {
     300:	80 91 4f 01 	lds	r24, 0x014F	; 0x80014f <mult>
     304:	90 91 50 01 	lds	r25, 0x0150	; 0x800150 <mult+0x1>
     308:	81 30       	cpi	r24, 0x01	; 1
     30a:	91 05       	cpc	r25, r1
     30c:	19 f0       	breq	.+6      	; 0x314 <bars+0xc0>
     30e:	82 30       	cpi	r24, 0x02	; 2
     310:	91 05       	cpc	r25, r1
     312:	01 f5       	brne	.+64     	; 0x354 <bars+0x100>
	 }
	 else
	    mode_sel = 1;		//If not, then change mode
         break;
      case 2:
	 if((mode_sel ^ mult) == 0 ){//if((mode_sel ^ mult) && (mode_sel == 4)){//if cur &prev are diff
     314:	40 91 4b 01 	lds	r20, 0x014B	; 0x80014b <mode_sel>
     318:	50 91 4c 01 	lds	r21, 0x014C	; 0x80014c <mode_sel+0x1>
     31c:	20 91 4f 01 	lds	r18, 0x014F	; 0x80014f <mult>
     320:	30 91 50 01 	lds	r19, 0x0150	; 0x800150 <mult+0x1>
     324:	42 17       	cp	r20, r18
     326:	53 07       	cpc	r21, r19
     328:	09 f4       	brne	.+2      	; 0x32c <bars+0xd8>
     32a:	5a c0       	rjmp	.+180    	; 0x3e0 <bars+0x18c>
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
         break;*/
      default:
	 mode_sel = mode_sel;		//no/invalid button press
     32c:	90 93 4c 01 	sts	0x014C, r25	; 0x80014c <mode_sel+0x1>
     330:	80 93 4b 01 	sts	0x014B, r24	; 0x80014b <mode_sel>
   }   
   mult = 0;				//clear mult for next pass
     334:	10 92 50 01 	sts	0x0150, r1	; 0x800150 <mult+0x1>
     338:	10 92 4f 01 	sts	0x014F, r1	; 0x80014f <mult>

   DDRA = 0xFF;				//Set A to alloutputs
     33c:	8f ef       	ldi	r24, 0xFF	; 255
     33e:	8a bb       	out	0x1a, r24	; 26
   SPDR = mode_sel;			//Write mode to the Bargraph
     340:	80 91 4b 01 	lds	r24, 0x014B	; 0x80014b <mode_sel>
     344:	90 91 4c 01 	lds	r25, 0x014C	; 0x80014c <mode_sel+0x1>
     348:	8f b9       	out	0x0f, r24	; 15
   while(bit_is_clear(SPSR, SPIF)){}	
     34a:	77 9b       	sbis	0x0e, 7	; 14
     34c:	fe cf       	rjmp	.-4      	; 0x34a <bars+0xf6>
   PORTB |= (1<<PB0);			//Rgclk high on bargraph
     34e:	c0 9a       	sbi	0x18, 0	; 24
   PORTB &= 0xFE;			//Rgclk low on bargraph
     350:	c0 98       	cbi	0x18, 0	; 24
   
return ;
     352:	08 95       	ret
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
         break;*/
      default:
	 mode_sel = mode_sel;		//no/invalid button press
     354:	80 91 4b 01 	lds	r24, 0x014B	; 0x80014b <mode_sel>
     358:	90 91 4c 01 	lds	r25, 0x014C	; 0x80014c <mode_sel+0x1>
     35c:	e7 cf       	rjmp	.-50     	; 0x32c <bars+0xd8>
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
   }
   if(mult == 64){		//Button 7 toggles snooze
      snooze = !(snooze);		//10 second snooze functionality
     35e:	90 91 52 01 	lds	r25, 0x0152	; 0x800152 <snooze>
     362:	81 e0       	ldi	r24, 0x01	; 1
     364:	91 11       	cpse	r25, r1
     366:	45 c0       	rjmp	.+138    	; 0x3f2 <bars+0x19e>
     368:	80 93 52 01 	sts	0x0152, r24	; 0x800152 <snooze>
      a_sec_count = sec_count + 10;
     36c:	80 91 5a 01 	lds	r24, 0x015A	; 0x80015a <sec_count>
     370:	86 5f       	subi	r24, 0xF6	; 246
     372:	80 93 57 01 	sts	0x0157, r24	; 0x800157 <a_sec_count>
      if(a_sec_count > 60){
     376:	80 91 57 01 	lds	r24, 0x0157	; 0x800157 <a_sec_count>
     37a:	8d 33       	cpi	r24, 0x3D	; 61
     37c:	08 f4       	brcc	.+2      	; 0x380 <bars+0x12c>
     37e:	b6 cf       	rjmp	.-148    	; 0x2ec <bars+0x98>
         a_sec_count = a_sec_count % 60;
     380:	90 91 57 01 	lds	r25, 0x0157	; 0x800157 <a_sec_count>
     384:	89 e8       	ldi	r24, 0x89	; 137
     386:	98 9f       	mul	r25, r24
     388:	81 2d       	mov	r24, r1
     38a:	11 24       	eor	r1, r1
     38c:	82 95       	swap	r24
     38e:	86 95       	lsr	r24
     390:	87 70       	andi	r24, 0x07	; 7
     392:	2c e3       	ldi	r18, 0x3C	; 60
     394:	82 9f       	mul	r24, r18
     396:	90 19       	sub	r25, r0
     398:	11 24       	eor	r1, r1
     39a:	90 93 57 01 	sts	0x0157, r25	; 0x800157 <a_sec_count>
	 a_min_count++;
     39e:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <a_min_count>
     3a2:	8f 5f       	subi	r24, 0xFF	; 255
     3a4:	80 93 56 01 	sts	0x0156, r24	; 0x800156 <a_min_count>
	 if(a_min_count == 60){
     3a8:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <a_min_count>
     3ac:	8c 33       	cpi	r24, 0x3C	; 60
     3ae:	09 f0       	breq	.+2      	; 0x3b2 <bars+0x15e>
     3b0:	9d cf       	rjmp	.-198    	; 0x2ec <bars+0x98>
	    a_hour_count++;
     3b2:	80 91 55 01 	lds	r24, 0x0155	; 0x800155 <a_hour_count>
     3b6:	8f 5f       	subi	r24, 0xFF	; 255
     3b8:	80 93 55 01 	sts	0x0155, r24	; 0x800155 <a_hour_count>
	    a_min_count = 0;
     3bc:	10 92 56 01 	sts	0x0156, r1	; 0x800156 <a_min_count>
	    if(a_hour_count == 24){
     3c0:	80 91 55 01 	lds	r24, 0x0155	; 0x800155 <a_hour_count>
     3c4:	88 31       	cpi	r24, 0x18	; 24
     3c6:	09 f0       	breq	.+2      	; 0x3ca <bars+0x176>
     3c8:	91 cf       	rjmp	.-222    	; 0x2ec <bars+0x98>
	       a_hour_count = 0;
     3ca:	10 92 55 01 	sts	0x0155, r1	; 0x800155 <a_hour_count>
     3ce:	8e cf       	rjmp	.-228    	; 0x2ec <bars+0x98>
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
     3d0:	90 91 53 01 	lds	r25, 0x0153	; 0x800153 <alarm>
     3d4:	81 e0       	ldi	r24, 0x01	; 1
     3d6:	91 11       	cpse	r25, r1
     3d8:	08 c0       	rjmp	.+16     	; 0x3ea <bars+0x196>
     3da:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <alarm>
     3de:	7f cf       	rjmp	.-258    	; 0x2de <bars+0x8a>
	 else
	    mode_sel = 1;		//If not, then change mode
         break;
      case 2:
	 if((mode_sel ^ mult) == 0 ){//if((mode_sel ^ mult) && (mode_sel == 4)){//if cur &prev are diff
	    mode_sel = 0;//and prev isn't = 1 then two modes are selected
     3e0:	10 92 4c 01 	sts	0x014C, r1	; 0x80014c <mode_sel+0x1>
     3e4:	10 92 4b 01 	sts	0x014B, r1	; 0x80014b <mode_sel>
     3e8:	a5 cf       	rjmp	.-182    	; 0x334 <bars+0xe0>
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
     3ea:	80 e0       	ldi	r24, 0x00	; 0
     3ec:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <alarm>
     3f0:	76 cf       	rjmp	.-276    	; 0x2de <bars+0x8a>
   }
   if(mult == 64){		//Button 7 toggles snooze
      snooze = !(snooze);		//10 second snooze functionality
     3f2:	80 e0       	ldi	r24, 0x00	; 0
     3f4:	b9 cf       	rjmp	.-142    	; 0x368 <bars+0x114>

000003f6 <read_encoder>:
   int8_t value = 0x00;
   uint8_t ec_a;
   uint8_t ec_b;

   //Shift_LD_N low
   PORTE &= 0x00;	//Begining of SHIFT_LD_N pulse. It is low here
     3f6:	83 b1       	in	r24, 0x03	; 3
     3f8:	13 b8       	out	0x03, r1	; 3
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     3fa:	87 ec       	ldi	r24, 0xC7	; 199
     3fc:	90 e0       	ldi	r25, 0x00	; 0
     3fe:	01 97       	sbiw	r24, 0x01	; 1
     400:	f1 f7       	brne	.-4      	; 0x3fe <read_encoder+0x8>
     402:	00 c0       	rjmp	.+0      	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
     404:	00 00       	nop
   _delay_us(50);
   PORTE |= 0xFF;	//End of SHIFT_LD_N pulse. back to high
     406:	83 b1       	in	r24, 0x03	; 3
     408:	8f ef       	ldi	r24, 0xFF	; 255
     40a:	83 b9       	out	0x03, r24	; 3
   PORTD &= 0x0F;	//CLK_INH low
     40c:	82 b3       	in	r24, 0x12	; 18
     40e:	8f 70       	andi	r24, 0x0F	; 15
     410:	82 bb       	out	0x12, r24	; 18
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
     412:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
     414:	77 9b       	sbis	0x0e, 7	; 14
     416:	fe cf       	rjmp	.-4      	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
   return SPDR;
     418:	9f b1       	in	r25, 0x0f	; 15
   _delay_us(50);
   PORTE |= 0xFF;	//End of SHIFT_LD_N pulse. back to high
   PORTD &= 0x0F;	//CLK_INH low

   encoder_value = spi_read();
   PORTD |= 0xF0;	//CLK_INH high
     41a:	82 b3       	in	r24, 0x12	; 18
     41c:	80 6f       	ori	r24, 0xF0	; 240
     41e:	82 bb       	out	0x12, r24	; 18
   value = mode_sel;
     420:	20 91 4b 01 	lds	r18, 0x014B	; 0x80014b <mode_sel>
     424:	30 91 4c 01 	lds	r19, 0x014C	; 0x80014c <mode_sel+0x1>
     428:	82 2f       	mov	r24, r18
   ec_a = encoder_value & 0x03;  //Only grabs these bits 0000_0011
     42a:	69 2f       	mov	r22, r25
     42c:	63 70       	andi	r22, 0x03	; 3
   ec_b = encoder_value & 0x0C;  //Only grabs these bits 0000_1100 
     42e:	9c 70       	andi	r25, 0x0C	; 12
   ec_b = (ec_b >> 2);
     430:	96 95       	lsr	r25
     432:	96 95       	lsr	r25

//mode_sel == 0 means that no mode has been selected and the speaker volume can be adjusted
   if(mode_sel == 0){
     434:	20 91 4b 01 	lds	r18, 0x014B	; 0x80014b <mode_sel>
     438:	30 91 4c 01 	lds	r19, 0x014C	; 0x80014c <mode_sel+0x1>
     43c:	23 2b       	or	r18, r19
     43e:	09 f5       	brne	.+66     	; 0x482 <__LOCK_REGION_LENGTH__+0x82>
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     440:	20 91 aa 01 	lds	r18, 0x01AA	; 0x8001aa <EC_a_prev>
     444:	46 2f       	mov	r20, r22
     446:	50 e0       	ldi	r21, 0x00	; 0
     448:	02 2e       	mov	r0, r18
     44a:	00 0c       	add	r0, r0
     44c:	33 0b       	sbc	r19, r19
     44e:	42 17       	cp	r20, r18
     450:	53 07       	cpc	r21, r19
     452:	b9 f0       	breq	.+46     	; 0x482 <__LOCK_REGION_LENGTH__+0x82>
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     454:	20 91 aa 01 	lds	r18, 0x01AA	; 0x8001aa <EC_a_prev>
     458:	21 11       	cpse	r18, r1
     45a:	26 c0       	rjmp	.+76     	; 0x4a8 <__LOCK_REGION_LENGTH__+0xa8>
     45c:	61 30       	cpi	r22, 0x01	; 1
     45e:	21 f5       	brne	.+72     	; 0x4a8 <__LOCK_REGION_LENGTH__+0xa8>
            volume += 10;	//increment volume
     460:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     464:	26 5f       	subi	r18, 0xF6	; 246
     466:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <volume>
	    if(volume <= 0x9F){
     46a:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     46e:	20 3a       	cpi	r18, 0xA0	; 160
     470:	08 f0       	brcs	.+2      	; 0x474 <__LOCK_REGION_LENGTH__+0x74>
     472:	e5 c0       	rjmp	.+458    	; 0x63e <__LOCK_REGION_LENGTH__+0x23e>
	    }
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
	    volume -= 10;	//decrement volume 
	    if(volume >= 0x00){
		OCR3A = volume;	//minimum volume
     474:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     478:	30 e0       	ldi	r19, 0x00	; 0
     47a:	30 93 87 00 	sts	0x0087, r19	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     47e:	20 93 86 00 	sts	0x0086, r18	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
	    value = 0;
      }*/
   }

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
     482:	20 91 4b 01 	lds	r18, 0x014B	; 0x80014b <mode_sel>
     486:	30 91 4c 01 	lds	r19, 0x014C	; 0x80014c <mode_sel+0x1>
     48a:	21 30       	cpi	r18, 0x01	; 1
     48c:	31 05       	cpc	r19, r1
     48e:	f1 f0       	breq	.+60     	; 0x4cc <__LOCK_REGION_LENGTH__+0xcc>
         else
	    value = 0;
      }
   }
//mode_sel == 2 means that the user has selected the "alarm time change" mode
   if(mode_sel == 2){
     490:	20 91 4b 01 	lds	r18, 0x014B	; 0x80014b <mode_sel>
     494:	30 91 4c 01 	lds	r19, 0x014C	; 0x80014c <mode_sel+0x1>
     498:	22 30       	cpi	r18, 0x02	; 2
     49a:	31 05       	cpc	r19, r1
     49c:	b1 f1       	breq	.+108    	; 0x50a <__LOCK_REGION_LENGTH__+0x10a>
         else
	    value = 0;
      }
   }
//Saves previous values into volatile variables
EC_a_prev = ec_a;
     49e:	60 93 aa 01 	sts	0x01AA, r22	; 0x8001aa <EC_a_prev>
EC_b_prev = ec_b;
     4a2:	90 93 98 01 	sts	0x0198, r25	; 0x800198 <EC_b_prev>

return value;
}
     4a6:	08 95       	ret
	    else {
		volume = 0x9F;
		OCR3A = 0x9F;
	    }
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     4a8:	20 91 aa 01 	lds	r18, 0x01AA	; 0x8001aa <EC_a_prev>
     4ac:	21 11       	cpse	r18, r1
     4ae:	03 c0       	rjmp	.+6      	; 0x4b6 <__LOCK_REGION_LENGTH__+0xb6>
     4b0:	62 30       	cpi	r22, 0x02	; 2
     4b2:	09 f4       	brne	.+2      	; 0x4b6 <__LOCK_REGION_LENGTH__+0xb6>
     4b4:	af c0       	rjmp	.+350    	; 0x614 <__LOCK_REGION_LENGTH__+0x214>
		volume = 0x00;
		OCR3A = 0x00;
	    }
         }
         else	//If not one of the state changes above, do nothing
	 volume = volume;
     4b6:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     4ba:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <volume>
	    value = 0;
      }*/
   }

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
     4be:	20 91 4b 01 	lds	r18, 0x014B	; 0x80014b <mode_sel>
     4c2:	30 91 4c 01 	lds	r19, 0x014C	; 0x80014c <mode_sel+0x1>
     4c6:	21 30       	cpi	r18, 0x01	; 1
     4c8:	31 05       	cpc	r19, r1
     4ca:	11 f7       	brne	.-60     	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     4cc:	20 91 aa 01 	lds	r18, 0x01AA	; 0x8001aa <EC_a_prev>
     4d0:	46 2f       	mov	r20, r22
     4d2:	50 e0       	ldi	r21, 0x00	; 0
     4d4:	02 2e       	mov	r0, r18
     4d6:	00 0c       	add	r0, r0
     4d8:	33 0b       	sbc	r19, r19
     4da:	42 17       	cp	r20, r18
     4dc:	53 07       	cpc	r21, r19
     4de:	09 f4       	brne	.+2      	; 0x4e2 <__LOCK_REGION_LENGTH__+0xe2>
     4e0:	5a c0       	rjmp	.+180    	; 0x596 <__LOCK_REGION_LENGTH__+0x196>
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     4e2:	20 91 aa 01 	lds	r18, 0x01AA	; 0x8001aa <EC_a_prev>
     4e6:	22 23       	and	r18, r18
     4e8:	09 f4       	brne	.+2      	; 0x4ec <__LOCK_REGION_LENGTH__+0xec>
     4ea:	47 c0       	rjmp	.+142    	; 0x57a <__LOCK_REGION_LENGTH__+0x17a>
            hour_count = hour_count + 1;//value = value;
	    if(hour_count == 24)
	       hour_count = 0;
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     4ec:	20 91 aa 01 	lds	r18, 0x01AA	; 0x8001aa <EC_a_prev>
     4f0:	21 11       	cpse	r18, r1
     4f2:	03 c0       	rjmp	.+6      	; 0x4fa <__LOCK_REGION_LENGTH__+0xfa>
     4f4:	62 30       	cpi	r22, 0x02	; 2
     4f6:	09 f4       	brne	.+2      	; 0x4fa <__LOCK_REGION_LENGTH__+0xfa>
     4f8:	80 c0       	rjmp	.+256    	; 0x5fa <__LOCK_REGION_LENGTH__+0x1fa>
	    hour_count = hour_count - 1;//value = -(value);
	    if(hour_count < 0)
	       hour_count = 23; 
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
     4fa:	80 e0       	ldi	r24, 0x00	; 0
         else
	    value = 0;
      }
   }
//mode_sel == 2 means that the user has selected the "alarm time change" mode
   if(mode_sel == 2){
     4fc:	20 91 4b 01 	lds	r18, 0x014B	; 0x80014b <mode_sel>
     500:	30 91 4c 01 	lds	r19, 0x014C	; 0x80014c <mode_sel+0x1>
     504:	22 30       	cpi	r18, 0x02	; 2
     506:	31 05       	cpc	r19, r1
     508:	51 f6       	brne	.-108    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     50a:	20 91 aa 01 	lds	r18, 0x01AA	; 0x8001aa <EC_a_prev>
     50e:	46 2f       	mov	r20, r22
     510:	50 e0       	ldi	r21, 0x00	; 0
     512:	02 2e       	mov	r0, r18
     514:	00 0c       	add	r0, r0
     516:	33 0b       	sbc	r19, r19
     518:	42 17       	cp	r20, r18
     51a:	53 07       	cpc	r21, r19
     51c:	d1 f0       	breq	.+52     	; 0x552 <__LOCK_REGION_LENGTH__+0x152>
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     51e:	20 91 aa 01 	lds	r18, 0x01AA	; 0x8001aa <EC_a_prev>
     522:	21 11       	cpse	r18, r1
     524:	03 c0       	rjmp	.+6      	; 0x52c <__LOCK_REGION_LENGTH__+0x12c>
     526:	61 30       	cpi	r22, 0x01	; 1
     528:	09 f4       	brne	.+2      	; 0x52c <__LOCK_REGION_LENGTH__+0x12c>
     52a:	7c c0       	rjmp	.+248    	; 0x624 <__LOCK_REGION_LENGTH__+0x224>
            a_hour_count = a_hour_count + 1;//value = value;
	    if(a_hour_count == 24)
	       a_hour_count = 0;
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     52c:	20 91 aa 01 	lds	r18, 0x01AA	; 0x8001aa <EC_a_prev>
     530:	21 11       	cpse	r18, r1
     532:	1d c0       	rjmp	.+58     	; 0x56e <__LOCK_REGION_LENGTH__+0x16e>
     534:	62 30       	cpi	r22, 0x02	; 2
     536:	d9 f4       	brne	.+54     	; 0x56e <__LOCK_REGION_LENGTH__+0x16e>
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
	    a_min_count = a_min_count - 1; //value = -(value);
	    if(a_min_count < 0){
	       a_min_count = 59;
	       a_hour_count--;
     538:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <a_hour_count>
     53c:	21 50       	subi	r18, 0x01	; 1
     53e:	20 93 55 01 	sts	0x0155, r18	; 0x800155 <a_hour_count>
	       if(a_hour_count < 0){
     542:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <a_hour_count>
     546:	27 ff       	sbrs	r18, 7
     548:	aa cf       	rjmp	.-172    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
	          a_hour_count = 23;
     54a:	27 e1       	ldi	r18, 0x17	; 23
     54c:	20 93 55 01 	sts	0x0155, r18	; 0x800155 <a_hour_count>
     550:	a6 cf       	rjmp	.-180    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
     552:	20 91 98 01 	lds	r18, 0x0198	; 0x800198 <EC_b_prev>
     556:	21 11       	cpse	r18, r1
     558:	03 c0       	rjmp	.+6      	; 0x560 <__LOCK_REGION_LENGTH__+0x160>
     55a:	91 30       	cpi	r25, 0x01	; 1
     55c:	09 f4       	brne	.+2      	; 0x560 <__LOCK_REGION_LENGTH__+0x160>
     55e:	86 c0       	rjmp	.+268    	; 0x66c <__LOCK_REGION_LENGTH__+0x26c>
	       a_hour_count++;
	       if(a_hour_count > 23)
	          a_hour_count = 0;
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
     560:	20 91 98 01 	lds	r18, 0x0198	; 0x800198 <EC_b_prev>
     564:	21 11       	cpse	r18, r1
     566:	03 c0       	rjmp	.+6      	; 0x56e <__LOCK_REGION_LENGTH__+0x16e>
     568:	92 30       	cpi	r25, 0x02	; 2
     56a:	09 f4       	brne	.+2      	; 0x56e <__LOCK_REGION_LENGTH__+0x16e>
     56c:	72 c0       	rjmp	.+228    	; 0x652 <__LOCK_REGION_LENGTH__+0x252>
	    a_hour_count = a_hour_count - 1;//value = -(value);
	    if(a_hour_count < 0)
	       a_hour_count = 23; 
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
     56e:	80 e0       	ldi	r24, 0x00	; 0
         else
	    value = 0;
      }
   }
//Saves previous values into volatile variables
EC_a_prev = ec_a;
     570:	60 93 aa 01 	sts	0x01AA, r22	; 0x8001aa <EC_a_prev>
EC_b_prev = ec_b;
     574:	90 93 98 01 	sts	0x0198, r25	; 0x800198 <EC_b_prev>

return value;
}
     578:	08 95       	ret
   }

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     57a:	61 30       	cpi	r22, 0x01	; 1
     57c:	09 f0       	breq	.+2      	; 0x580 <__LOCK_REGION_LENGTH__+0x180>
     57e:	b6 cf       	rjmp	.-148    	; 0x4ec <__LOCK_REGION_LENGTH__+0xec>
            hour_count = hour_count + 1;//value = value;
     580:	20 91 58 01 	lds	r18, 0x0158	; 0x800158 <hour_count>
     584:	2f 5f       	subi	r18, 0xFF	; 255
     586:	20 93 58 01 	sts	0x0158, r18	; 0x800158 <hour_count>
	    if(hour_count == 24)
     58a:	20 91 58 01 	lds	r18, 0x0158	; 0x800158 <hour_count>
     58e:	28 31       	cpi	r18, 0x18	; 24
     590:	09 f0       	breq	.+2      	; 0x594 <__LOCK_REGION_LENGTH__+0x194>
     592:	7e cf       	rjmp	.-260    	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
     594:	1c c0       	rjmp	.+56     	; 0x5ce <__LOCK_REGION_LENGTH__+0x1ce>
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
     596:	20 91 98 01 	lds	r18, 0x0198	; 0x800198 <EC_b_prev>
     59a:	21 11       	cpse	r18, r1
     59c:	1b c0       	rjmp	.+54     	; 0x5d4 <__LOCK_REGION_LENGTH__+0x1d4>
     59e:	91 30       	cpi	r25, 0x01	; 1
     5a0:	c9 f4       	brne	.+50     	; 0x5d4 <__LOCK_REGION_LENGTH__+0x1d4>
            min_count = min_count + 1;//value = value;
     5a2:	20 91 59 01 	lds	r18, 0x0159	; 0x800159 <min_count>
     5a6:	2f 5f       	subi	r18, 0xFF	; 255
     5a8:	20 93 59 01 	sts	0x0159, r18	; 0x800159 <min_count>
	    if(min_count == 60){
     5ac:	20 91 59 01 	lds	r18, 0x0159	; 0x800159 <min_count>
     5b0:	2c 33       	cpi	r18, 0x3C	; 60
     5b2:	09 f0       	breq	.+2      	; 0x5b6 <__LOCK_REGION_LENGTH__+0x1b6>
     5b4:	6d cf       	rjmp	.-294    	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
	       min_count = 0; 
     5b6:	10 92 59 01 	sts	0x0159, r1	; 0x800159 <min_count>
	       hour_count++;
     5ba:	20 91 58 01 	lds	r18, 0x0158	; 0x800158 <hour_count>
     5be:	2f 5f       	subi	r18, 0xFF	; 255
     5c0:	20 93 58 01 	sts	0x0158, r18	; 0x800158 <hour_count>
	       if(hour_count > 23)
     5c4:	20 91 58 01 	lds	r18, 0x0158	; 0x800158 <hour_count>
     5c8:	28 31       	cpi	r18, 0x18	; 24
     5ca:	0c f4       	brge	.+2      	; 0x5ce <__LOCK_REGION_LENGTH__+0x1ce>
     5cc:	61 cf       	rjmp	.-318    	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
	          hour_count = 0;
     5ce:	10 92 58 01 	sts	0x0158, r1	; 0x800158 <hour_count>
     5d2:	5e cf       	rjmp	.-324    	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
     5d4:	20 91 98 01 	lds	r18, 0x0198	; 0x800198 <EC_b_prev>
     5d8:	21 11       	cpse	r18, r1
     5da:	8f cf       	rjmp	.-226    	; 0x4fa <__LOCK_REGION_LENGTH__+0xfa>
     5dc:	92 30       	cpi	r25, 0x02	; 2
     5de:	09 f0       	breq	.+2      	; 0x5e2 <__LOCK_REGION_LENGTH__+0x1e2>
     5e0:	8c cf       	rjmp	.-232    	; 0x4fa <__LOCK_REGION_LENGTH__+0xfa>
	    min_count = min_count - 1; //value = -(value);
     5e2:	20 91 59 01 	lds	r18, 0x0159	; 0x800159 <min_count>
     5e6:	21 50       	subi	r18, 0x01	; 1
     5e8:	20 93 59 01 	sts	0x0159, r18	; 0x800159 <min_count>
	    if(min_count < 0){
     5ec:	20 91 59 01 	lds	r18, 0x0159	; 0x800159 <min_count>
     5f0:	27 ff       	sbrs	r18, 7
     5f2:	4e cf       	rjmp	.-356    	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
	       min_count = 59;
     5f4:	2b e3       	ldi	r18, 0x3B	; 59
     5f6:	20 93 59 01 	sts	0x0159, r18	; 0x800159 <min_count>
	       hour_count--;
     5fa:	20 91 58 01 	lds	r18, 0x0158	; 0x800158 <hour_count>
     5fe:	21 50       	subi	r18, 0x01	; 1
     600:	20 93 58 01 	sts	0x0158, r18	; 0x800158 <hour_count>
	       if(hour_count < 0){
     604:	20 91 58 01 	lds	r18, 0x0158	; 0x800158 <hour_count>
     608:	27 ff       	sbrs	r18, 7
     60a:	42 cf       	rjmp	.-380    	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
	          hour_count = 23;
     60c:	27 e1       	ldi	r18, 0x17	; 23
     60e:	20 93 58 01 	sts	0x0158, r18	; 0x800158 <hour_count>
     612:	3e cf       	rjmp	.-388    	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
		volume = 0x9F;
		OCR3A = 0x9F;
	    }
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
	    volume -= 10;	//decrement volume 
     614:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     618:	2a 50       	subi	r18, 0x0A	; 10
     61a:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <volume>
	    if(volume >= 0x00){
     61e:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     622:	28 cf       	rjmp	.-432    	; 0x474 <__LOCK_REGION_LENGTH__+0x74>
   }
//mode_sel == 2 means that the user has selected the "alarm time change" mode
   if(mode_sel == 2){
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
            a_hour_count = a_hour_count + 1;//value = value;
     624:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <a_hour_count>
     628:	2f 5f       	subi	r18, 0xFF	; 255
     62a:	20 93 55 01 	sts	0x0155, r18	; 0x800155 <a_hour_count>
	    if(a_hour_count == 24)
     62e:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <a_hour_count>
     632:	28 31       	cpi	r18, 0x18	; 24
     634:	09 f0       	breq	.+2      	; 0x638 <__LOCK_REGION_LENGTH__+0x238>
     636:	33 cf       	rjmp	.-410    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
            a_min_count = a_min_count + 1;//value = value;
	    if(a_min_count == 60){
	       a_min_count = 0; 
	       a_hour_count++;
	       if(a_hour_count > 23)
	          a_hour_count = 0;
     638:	10 92 55 01 	sts	0x0155, r1	; 0x800155 <a_hour_count>
     63c:	30 cf       	rjmp	.-416    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
            volume += 10;	//increment volume
	    if(volume <= 0x9F){
		OCR3A = volume;	//maximum volume
	    }
	    else {
		volume = 0x9F;
     63e:	2f e9       	ldi	r18, 0x9F	; 159
     640:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <volume>
		OCR3A = 0x9F;
     644:	2f e9       	ldi	r18, 0x9F	; 159
     646:	30 e0       	ldi	r19, 0x00	; 0
     648:	30 93 87 00 	sts	0x0087, r19	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     64c:	20 93 86 00 	sts	0x0086, r18	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
     650:	18 cf       	rjmp	.-464    	; 0x482 <__LOCK_REGION_LENGTH__+0x82>
	       if(a_hour_count > 23)
	          a_hour_count = 0;
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
	    a_min_count = a_min_count - 1; //value = -(value);
     652:	20 91 56 01 	lds	r18, 0x0156	; 0x800156 <a_min_count>
     656:	21 50       	subi	r18, 0x01	; 1
     658:	20 93 56 01 	sts	0x0156, r18	; 0x800156 <a_min_count>
	    if(a_min_count < 0){
     65c:	20 91 56 01 	lds	r18, 0x0156	; 0x800156 <a_min_count>
     660:	27 ff       	sbrs	r18, 7
     662:	1d cf       	rjmp	.-454    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
	       a_min_count = 59;
     664:	2b e3       	ldi	r18, 0x3B	; 59
     666:	20 93 56 01 	sts	0x0156, r18	; 0x800156 <a_min_count>
     66a:	66 cf       	rjmp	.-308    	; 0x538 <__LOCK_REGION_LENGTH__+0x138>
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
            a_min_count = a_min_count + 1;//value = value;
     66c:	20 91 56 01 	lds	r18, 0x0156	; 0x800156 <a_min_count>
     670:	2f 5f       	subi	r18, 0xFF	; 255
     672:	20 93 56 01 	sts	0x0156, r18	; 0x800156 <a_min_count>
	    if(a_min_count == 60){
     676:	20 91 56 01 	lds	r18, 0x0156	; 0x800156 <a_min_count>
     67a:	2c 33       	cpi	r18, 0x3C	; 60
     67c:	09 f0       	breq	.+2      	; 0x680 <__LOCK_REGION_LENGTH__+0x280>
     67e:	0f cf       	rjmp	.-482    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
	       a_min_count = 0; 
     680:	10 92 56 01 	sts	0x0156, r1	; 0x800156 <a_min_count>
	       a_hour_count++;
     684:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <a_hour_count>
     688:	2f 5f       	subi	r18, 0xFF	; 255
     68a:	20 93 55 01 	sts	0x0155, r18	; 0x800155 <a_hour_count>
	       if(a_hour_count > 23)
     68e:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <a_hour_count>
     692:	28 31       	cpi	r18, 0x18	; 24
     694:	0c f4       	brge	.+2      	; 0x698 <__LOCK_REGION_LENGTH__+0x298>
     696:	03 cf       	rjmp	.-506    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
     698:	cf cf       	rjmp	.-98     	; 0x638 <__LOCK_REGION_LENGTH__+0x238>

0000069a <get_local_temp>:
**********************************************************************/
void get_local_temp(){
uint16_t lm73_temp;

  //_delay_ms(65); //tenth second wait
  twi_start_rd(LM73_ADDRESS, lm73_rd_buf, 2); //read temperature data from LM73 (2 bytes) 
     69a:	42 e0       	ldi	r20, 0x02	; 2
     69c:	62 ee       	ldi	r22, 0xE2	; 226
     69e:	71 e0       	ldi	r23, 0x01	; 1
     6a0:	80 e9       	ldi	r24, 0x90	; 144
     6a2:	0e 94 dd 0a 	call	0x15ba	; 0x15ba <twi_start_rd>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     6a6:	8f e3       	ldi	r24, 0x3F	; 63
     6a8:	9f e1       	ldi	r25, 0x1F	; 31
     6aa:	01 97       	sbiw	r24, 0x01	; 1
     6ac:	f1 f7       	brne	.-4      	; 0x6aa <get_local_temp+0x10>
     6ae:	00 c0       	rjmp	.+0      	; 0x6b0 <get_local_temp+0x16>
     6b0:	00 00       	nop
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
     6b2:	80 91 e2 01 	lds	r24, 0x01E2	; 0x8001e2 <lm73_rd_buf>
     6b6:	90 91 e3 01 	lds	r25, 0x01E3	; 0x8001e3 <lm73_rd_buf+0x1>
     6ba:	98 27       	eor	r25, r24
     6bc:	89 27       	eor	r24, r25
     6be:	98 27       	eor	r25, r24
     6c0:	4a e0       	ldi	r20, 0x0A	; 10
     6c2:	6b ea       	ldi	r22, 0xAB	; 171
     6c4:	71 e0       	ldi	r23, 0x01	; 1
     6c6:	88 0f       	add	r24, r24
     6c8:	89 2f       	mov	r24, r25
     6ca:	88 1f       	adc	r24, r24
     6cc:	99 0b       	sbc	r25, r25
     6ce:	91 95       	neg	r25
     6d0:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <__itoa_ncheck>
  lm73_temp = lm73_rd_buf[0]; //save high temperature byte into lm73_temp
  lm73_temp = lm73_temp << 8; //shift it into upper byte 
  lm73_temp |= lm73_rd_buf[1]; //"OR" in the low temp byte to lm73_temp 
  itoa(lm73_temp >> 7, lcd_string_array, 10); //convert to string in array with itoa() from avr-libc                           

  line2_col1();
     6d4:	0e 94 44 07 	call	0xe88	; 0xe88 <line2_col1>
  string2lcd("L:");
     6d8:	86 e1       	ldi	r24, 0x16	; 22
     6da:	91 e0       	ldi	r25, 0x01	; 1
     6dc:	0e 94 9c 07 	call	0xf38	; 0xf38 <string2lcd>
  string2lcd(lcd_string_array);
     6e0:	8b ea       	ldi	r24, 0xAB	; 171
     6e2:	91 e0       	ldi	r25, 0x01	; 1
     6e4:	0e 94 9c 07 	call	0xf38	; 0xf38 <string2lcd>
  //lcd_int16(lm73_temp, 2, 0, 0, 0);
  char2lcd('C');
     6e8:	83 e4       	ldi	r24, 0x43	; 67
     6ea:	0c 94 8a 07 	jmp	0xf14	; 0xf14 <char2lcd>

000006ee <__vector_16>:
	update the mode and bargraph. Then I change the sum based on	
	the value returned from the encoder reading. Sum is then bounded
	from 0-1023. 1023+1=1 and 0-any number > 0 = 1023.
Parameters: NA
**********************************************************************/
ISR(TIMER0_OVF_vect) { 
     6ee:	1f 92       	push	r1
     6f0:	0f 92       	push	r0
     6f2:	0f b6       	in	r0, 0x3f	; 63
     6f4:	0f 92       	push	r0
     6f6:	11 24       	eor	r1, r1
     6f8:	0b b6       	in	r0, 0x3b	; 59
     6fa:	0f 92       	push	r0
     6fc:	2f 93       	push	r18
     6fe:	3f 93       	push	r19
     700:	4f 93       	push	r20
     702:	5f 93       	push	r21
     704:	6f 93       	push	r22
     706:	7f 93       	push	r23
     708:	8f 93       	push	r24
     70a:	9f 93       	push	r25
     70c:	af 93       	push	r26
     70e:	bf 93       	push	r27
     710:	ef 93       	push	r30
     712:	ff 93       	push	r31
   static uint8_t count_7_8125ms = 0;

   count_7_8125ms++;
     714:	80 91 5f 01 	lds	r24, 0x015F	; 0x80015f <count_7_8125ms.2191>
     718:	8f 5f       	subi	r24, 0xFF	; 255
     71a:	80 93 5f 01 	sts	0x015F, r24	; 0x80015f <count_7_8125ms.2191>
   if((count_7_8125ms % 128) == 0) { //interrupts every 1 second
     71e:	8f 77       	andi	r24, 0x7F	; 127
     720:	29 f4       	brne	.+10     	; 0x72c <__vector_16+0x3e>
      sec_count++;
     722:	80 91 5a 01 	lds	r24, 0x015A	; 0x80015a <sec_count>
     726:	8f 5f       	subi	r24, 0xFF	; 255
     728:	80 93 5a 01 	sts	0x015A, r24	; 0x80015a <sec_count>
   }
   bars();  
     72c:	0e 94 2a 01 	call	0x254	; 0x254 <bars>
   read_encoder();      
     730:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <read_encoder>

}
     734:	ff 91       	pop	r31
     736:	ef 91       	pop	r30
     738:	bf 91       	pop	r27
     73a:	af 91       	pop	r26
     73c:	9f 91       	pop	r25
     73e:	8f 91       	pop	r24
     740:	7f 91       	pop	r23
     742:	6f 91       	pop	r22
     744:	5f 91       	pop	r21
     746:	4f 91       	pop	r20
     748:	3f 91       	pop	r19
     74a:	2f 91       	pop	r18
     74c:	0f 90       	pop	r0
     74e:	0b be       	out	0x3b, r0	; 59
     750:	0f 90       	pop	r0
     752:	0f be       	out	0x3f, r0	; 63
     754:	0f 90       	pop	r0
     756:	1f 90       	pop	r1
     758:	18 95       	reti

0000075a <__vector_15>:

ISR(TIMER0_COMP_vect) {
     75a:	1f 92       	push	r1
     75c:	0f 92       	push	r0
     75e:	0f b6       	in	r0, 0x3f	; 63
     760:	0f 92       	push	r0
     762:	11 24       	eor	r1, r1
     764:	0b b6       	in	r0, 0x3b	; 59
     766:	0f 92       	push	r0
     768:	2f 93       	push	r18
     76a:	3f 93       	push	r19
     76c:	4f 93       	push	r20
     76e:	5f 93       	push	r21
     770:	6f 93       	push	r22
     772:	7f 93       	push	r23
     774:	8f 93       	push	r24
     776:	9f 93       	push	r25
     778:	af 93       	push	r26
     77a:	bf 93       	push	r27
     77c:	ef 93       	push	r30
     77e:	ff 93       	push	r31
   static uint8_t count7_8125ms = 0;

   count7_8125ms++;
     780:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <count7_8125ms.2197>
     784:	8f 5f       	subi	r24, 0xFF	; 255
     786:	80 93 5e 01 	sts	0x015E, r24	; 0x80015e <count7_8125ms.2197>
   if((count7_8125ms % 128) == 0) { //interrupts every 1 second
     78a:	8f 77       	andi	r24, 0x7F	; 127
     78c:	31 f4       	brne	.+12     	; 0x79a <__vector_15+0x40>
      get_local_temp();
     78e:	0e 94 4d 03 	call	0x69a	; 0x69a <get_local_temp>
      uart_puts("A");
     792:	89 e1       	ldi	r24, 0x19	; 25
     794:	91 e0       	ldi	r25, 0x01	; 1
     796:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <uart_puts>
   }

}
     79a:	ff 91       	pop	r31
     79c:	ef 91       	pop	r30
     79e:	bf 91       	pop	r27
     7a0:	af 91       	pop	r26
     7a2:	9f 91       	pop	r25
     7a4:	8f 91       	pop	r24
     7a6:	7f 91       	pop	r23
     7a8:	6f 91       	pop	r22
     7aa:	5f 91       	pop	r21
     7ac:	4f 91       	pop	r20
     7ae:	3f 91       	pop	r19
     7b0:	2f 91       	pop	r18
     7b2:	0f 90       	pop	r0
     7b4:	0b be       	out	0x3b, r0	; 59
     7b6:	0f 90       	pop	r0
     7b8:	0f be       	out	0x3f, r0	; 63
     7ba:	0f 90       	pop	r0
     7bc:	1f 90       	pop	r1
     7be:	18 95       	reti

000007c0 <clock_time>:
	selected alarm time or normal time is displayed.
Parameters: NA
**********************************************************************/
void clock_time(){ //by default we use military time
//This block is used to increment the time based on an increasing seconds count   
   if(sec_count == 60){
     7c0:	80 91 5a 01 	lds	r24, 0x015A	; 0x80015a <sec_count>
     7c4:	8c 33       	cpi	r24, 0x3C	; 60
     7c6:	09 f4       	brne	.+2      	; 0x7ca <clock_time+0xa>
     7c8:	a4 c0       	rjmp	.+328    	; 0x912 <clock_time+0x152>
	 }//hours	
      }//mins
   }//secs

//This is where the digits are written to the data array
      if(mode_sel == 2){	//display alarm time
     7ca:	80 91 4b 01 	lds	r24, 0x014B	; 0x80014b <mode_sel>
     7ce:	90 91 4c 01 	lds	r25, 0x014C	; 0x80014c <mode_sel+0x1>
     7d2:	02 97       	sbiw	r24, 0x02	; 2
     7d4:	09 f4       	brne	.+2      	; 0x7d8 <clock_time+0x18>
     7d6:	5a c0       	rjmp	.+180    	; 0x88c <clock_time+0xcc>
         else {segment_data[2] = 0b111;}		//Turn colon off
         segment_data[1] = dec_to_7seg[a_min_count/10];
         segment_data[0] = dec_to_7seg[a_min_count%10];
      }
      else{			//display military time
         segment_data[4] = dec_to_7seg[hour_count/10];
     7d8:	90 91 58 01 	lds	r25, 0x0158	; 0x800158 <hour_count>
     7dc:	87 e6       	ldi	r24, 0x67	; 103
     7de:	98 02       	muls	r25, r24
     7e0:	e1 2d       	mov	r30, r1
     7e2:	11 24       	eor	r1, r1
     7e4:	e5 95       	asr	r30
     7e6:	e5 95       	asr	r30
     7e8:	97 fd       	sbrc	r25, 7
     7ea:	e3 95       	inc	r30
     7ec:	0e 2e       	mov	r0, r30
     7ee:	00 0c       	add	r0, r0
     7f0:	ff 0b       	sbc	r31, r31
     7f2:	e0 50       	subi	r30, 0x00	; 0
     7f4:	ff 4f       	sbci	r31, 0xFF	; 255
     7f6:	90 81       	ld	r25, Z
     7f8:	90 93 4a 01 	sts	0x014A, r25	; 0x80014a <__data_end+0x4>
         segment_data[3] = dec_to_7seg[hour_count%10];
     7fc:	e0 91 58 01 	lds	r30, 0x0158	; 0x800158 <hour_count>
     800:	e8 02       	muls	r30, r24
     802:	81 2d       	mov	r24, r1
     804:	11 24       	eor	r1, r1
     806:	85 95       	asr	r24
     808:	85 95       	asr	r24
     80a:	e7 fd       	sbrc	r30, 7
     80c:	83 95       	inc	r24
     80e:	9a e0       	ldi	r25, 0x0A	; 10
     810:	89 9f       	mul	r24, r25
     812:	e0 19       	sub	r30, r0
     814:	11 24       	eor	r1, r1
     816:	0e 2e       	mov	r0, r30
     818:	00 0c       	add	r0, r0
     81a:	ff 0b       	sbc	r31, r31
     81c:	e0 50       	subi	r30, 0x00	; 0
     81e:	ff 4f       	sbci	r31, 0xFF	; 255
     820:	80 81       	ld	r24, Z
     822:	80 93 49 01 	sts	0x0149, r24	; 0x800149 <__data_end+0x3>
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     826:	80 91 5a 01 	lds	r24, 0x015A	; 0x80015a <sec_count>
     82a:	80 fd       	sbrc	r24, 0
     82c:	2b c0       	rjmp	.+86     	; 0x884 <clock_time+0xc4>
         else {segment_data[2] = 0b111;}		//Turn colon off
     82e:	87 e0       	ldi	r24, 0x07	; 7
     830:	80 93 48 01 	sts	0x0148, r24	; 0x800148 <__data_end+0x2>
         segment_data[1] = dec_to_7seg[min_count/10];
     834:	90 91 59 01 	lds	r25, 0x0159	; 0x800159 <min_count>
     838:	87 e6       	ldi	r24, 0x67	; 103
     83a:	98 02       	muls	r25, r24
     83c:	e1 2d       	mov	r30, r1
     83e:	11 24       	eor	r1, r1
     840:	e5 95       	asr	r30
     842:	e5 95       	asr	r30
     844:	97 fd       	sbrc	r25, 7
     846:	e3 95       	inc	r30
     848:	0e 2e       	mov	r0, r30
     84a:	00 0c       	add	r0, r0
     84c:	ff 0b       	sbc	r31, r31
     84e:	e0 50       	subi	r30, 0x00	; 0
     850:	ff 4f       	sbci	r31, 0xFF	; 255
     852:	90 81       	ld	r25, Z
     854:	90 93 47 01 	sts	0x0147, r25	; 0x800147 <__data_end+0x1>
         segment_data[0] = dec_to_7seg[min_count%10];
     858:	e0 91 59 01 	lds	r30, 0x0159	; 0x800159 <min_count>
     85c:	e8 02       	muls	r30, r24
     85e:	81 2d       	mov	r24, r1
     860:	11 24       	eor	r1, r1
     862:	85 95       	asr	r24
     864:	85 95       	asr	r24
     866:	e7 fd       	sbrc	r30, 7
     868:	83 95       	inc	r24
     86a:	9a e0       	ldi	r25, 0x0A	; 10
     86c:	89 9f       	mul	r24, r25
     86e:	e0 19       	sub	r30, r0
     870:	11 24       	eor	r1, r1
     872:	0e 2e       	mov	r0, r30
     874:	00 0c       	add	r0, r0
     876:	ff 0b       	sbc	r31, r31
     878:	e0 50       	subi	r30, 0x00	; 0
     87a:	ff 4f       	sbci	r31, 0xFF	; 255
     87c:	80 81       	ld	r24, Z
     87e:	80 93 46 01 	sts	0x0146, r24	; 0x800146 <__data_end>
     882:	08 95       	ret
         segment_data[0] = dec_to_7seg[a_min_count%10];
      }
      else{			//display military time
         segment_data[4] = dec_to_7seg[hour_count/10];
         segment_data[3] = dec_to_7seg[hour_count%10];
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     884:	84 e0       	ldi	r24, 0x04	; 4
     886:	80 93 48 01 	sts	0x0148, r24	; 0x800148 <__data_end+0x2>
     88a:	d4 cf       	rjmp	.-88     	; 0x834 <clock_time+0x74>
      }//mins
   }//secs

//This is where the digits are written to the data array
      if(mode_sel == 2){	//display alarm time
         segment_data[4] = dec_to_7seg[a_hour_count/10];
     88c:	90 91 55 01 	lds	r25, 0x0155	; 0x800155 <a_hour_count>
     890:	87 e6       	ldi	r24, 0x67	; 103
     892:	98 02       	muls	r25, r24
     894:	e1 2d       	mov	r30, r1
     896:	11 24       	eor	r1, r1
     898:	e5 95       	asr	r30
     89a:	e5 95       	asr	r30
     89c:	97 fd       	sbrc	r25, 7
     89e:	e3 95       	inc	r30
     8a0:	0e 2e       	mov	r0, r30
     8a2:	00 0c       	add	r0, r0
     8a4:	ff 0b       	sbc	r31, r31
     8a6:	e0 50       	subi	r30, 0x00	; 0
     8a8:	ff 4f       	sbci	r31, 0xFF	; 255
     8aa:	90 81       	ld	r25, Z
     8ac:	90 93 4a 01 	sts	0x014A, r25	; 0x80014a <__data_end+0x4>
         segment_data[3] = dec_to_7seg[a_hour_count%10];
     8b0:	e0 91 55 01 	lds	r30, 0x0155	; 0x800155 <a_hour_count>
     8b4:	e8 02       	muls	r30, r24
     8b6:	81 2d       	mov	r24, r1
     8b8:	11 24       	eor	r1, r1
     8ba:	85 95       	asr	r24
     8bc:	85 95       	asr	r24
     8be:	e7 fd       	sbrc	r30, 7
     8c0:	83 95       	inc	r24
     8c2:	9a e0       	ldi	r25, 0x0A	; 10
     8c4:	89 9f       	mul	r24, r25
     8c6:	e0 19       	sub	r30, r0
     8c8:	11 24       	eor	r1, r1
     8ca:	0e 2e       	mov	r0, r30
     8cc:	00 0c       	add	r0, r0
     8ce:	ff 0b       	sbc	r31, r31
     8d0:	e0 50       	subi	r30, 0x00	; 0
     8d2:	ff 4f       	sbci	r31, 0xFF	; 255
     8d4:	80 81       	ld	r24, Z
     8d6:	80 93 49 01 	sts	0x0149, r24	; 0x800149 <__data_end+0x3>
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     8da:	80 91 5a 01 	lds	r24, 0x015A	; 0x80015a <sec_count>
     8de:	80 fd       	sbrc	r24, 0
     8e0:	33 c0       	rjmp	.+102    	; 0x948 <clock_time+0x188>
         else {segment_data[2] = 0b111;}		//Turn colon off
     8e2:	87 e0       	ldi	r24, 0x07	; 7
     8e4:	80 93 48 01 	sts	0x0148, r24	; 0x800148 <__data_end+0x2>
         segment_data[1] = dec_to_7seg[a_min_count/10];
     8e8:	90 91 56 01 	lds	r25, 0x0156	; 0x800156 <a_min_count>
     8ec:	87 e6       	ldi	r24, 0x67	; 103
     8ee:	98 02       	muls	r25, r24
     8f0:	e1 2d       	mov	r30, r1
     8f2:	11 24       	eor	r1, r1
     8f4:	e5 95       	asr	r30
     8f6:	e5 95       	asr	r30
     8f8:	97 fd       	sbrc	r25, 7
     8fa:	e3 95       	inc	r30
     8fc:	0e 2e       	mov	r0, r30
     8fe:	00 0c       	add	r0, r0
     900:	ff 0b       	sbc	r31, r31
     902:	e0 50       	subi	r30, 0x00	; 0
     904:	ff 4f       	sbci	r31, 0xFF	; 255
     906:	90 81       	ld	r25, Z
     908:	90 93 47 01 	sts	0x0147, r25	; 0x800147 <__data_end+0x1>
         segment_data[0] = dec_to_7seg[a_min_count%10];
     90c:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <a_min_count>
     910:	a5 cf       	rjmp	.-182    	; 0x85c <clock_time+0x9c>
Parameters: NA
**********************************************************************/
void clock_time(){ //by default we use military time
//This block is used to increment the time based on an increasing seconds count   
   if(sec_count == 60){
      min_count++;
     912:	80 91 59 01 	lds	r24, 0x0159	; 0x800159 <min_count>
     916:	8f 5f       	subi	r24, 0xFF	; 255
     918:	80 93 59 01 	sts	0x0159, r24	; 0x800159 <min_count>
      sec_count = 0;
     91c:	10 92 5a 01 	sts	0x015A, r1	; 0x80015a <sec_count>
      if(min_count == 60){
     920:	80 91 59 01 	lds	r24, 0x0159	; 0x800159 <min_count>
     924:	8c 33       	cpi	r24, 0x3C	; 60
     926:	09 f0       	breq	.+2      	; 0x92a <clock_time+0x16a>
     928:	50 cf       	rjmp	.-352    	; 0x7ca <clock_time+0xa>
	 hour_count++;
     92a:	80 91 58 01 	lds	r24, 0x0158	; 0x800158 <hour_count>
     92e:	8f 5f       	subi	r24, 0xFF	; 255
     930:	80 93 58 01 	sts	0x0158, r24	; 0x800158 <hour_count>
	 min_count = 0;
     934:	10 92 59 01 	sts	0x0159, r1	; 0x800159 <min_count>
	 if(hour_count == 24){
     938:	80 91 58 01 	lds	r24, 0x0158	; 0x800158 <hour_count>
     93c:	88 31       	cpi	r24, 0x18	; 24
     93e:	09 f0       	breq	.+2      	; 0x942 <clock_time+0x182>
     940:	44 cf       	rjmp	.-376    	; 0x7ca <clock_time+0xa>
	    hour_count = 0;
     942:	10 92 58 01 	sts	0x0158, r1	; 0x800158 <hour_count>
     946:	41 cf       	rjmp	.-382    	; 0x7ca <clock_time+0xa>

//This is where the digits are written to the data array
      if(mode_sel == 2){	//display alarm time
         segment_data[4] = dec_to_7seg[a_hour_count/10];
         segment_data[3] = dec_to_7seg[a_hour_count%10];
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     948:	84 e0       	ldi	r24, 0x04	; 4
     94a:	80 93 48 01 	sts	0x0148, r24	; 0x800148 <__data_end+0x2>
     94e:	cc cf       	rjmp	.-104    	; 0x8e8 <clock_time+0x128>

00000950 <port_init>:
Function: port_init
Description: General port initialization and setting pull up resistors
Parameters: NA
**********************************************************************/
void port_init(){
   DDRC |= 0xFF; 
     950:	84 b3       	in	r24, 0x14	; 20
     952:	8f ef       	ldi	r24, 0xFF	; 255
     954:	84 bb       	out	0x14, r24	; 20
   DDRB |= 0xF0;				//PB4-6 is SEL0-2, PB7 is PWM
     956:	97 b3       	in	r25, 0x17	; 23
     958:	90 6f       	ori	r25, 0xF0	; 240
     95a:	97 bb       	out	0x17, r25	; 23
   DDRE |= 0x4F;				//PE6 is SHIFT_LD_N
     95c:	92 b1       	in	r25, 0x02	; 2
     95e:	9f 64       	ori	r25, 0x4F	; 79
     960:	92 b9       	out	0x02, r25	; 2
   DDRD |= 0xFF;				//PE1 is CLK_INH and PE2 is SRCLK
     962:	91 b3       	in	r25, 0x11	; 17
     964:	81 bb       	out	0x11, r24	; 17
   DDRF |= 0x08;
     966:	e1 e6       	ldi	r30, 0x61	; 97
     968:	f0 e0       	ldi	r31, 0x00	; 0
     96a:	90 81       	ld	r25, Z
     96c:	98 60       	ori	r25, 0x08	; 8
     96e:	90 83       	st	Z, r25
   PORTC |= 0x01;
     970:	a8 9a       	sbi	0x15, 0	; 21
   PORTD |= 0xFF;
     972:	92 b3       	in	r25, 0x12	; 18
     974:	82 bb       	out	0x12, r24	; 18
   PORTE |= 0xFF;
     976:	93 b1       	in	r25, 0x03	; 3
     978:	83 b9       	out	0x03, r24	; 3
     97a:	08 95       	ret

0000097c <change_alarm_state>:
      }
      curr = 1;	//indicated that alarm has been written to the display next time
	//through the function
   }
	//clears display when the alarm is turned off*/
   if(alarm && (curr ==0)){
     97c:	80 91 53 01 	lds	r24, 0x0153	; 0x800153 <alarm>
     980:	88 23       	and	r24, r24
     982:	21 f0       	breq	.+8      	; 0x98c <change_alarm_state+0x10>
     984:	80 91 5d 01 	lds	r24, 0x015D	; 0x80015d <curr.2204>
     988:	88 23       	and	r24, r24
     98a:	89 f0       	breq	.+34     	; 0x9ae <change_alarm_state+0x32>
      //lcd_array[2] = 'a';
      //lcd_array[3] = 'r';
      //lcd_array[4] = 'm';
      curr = 1;
   }
   else if((!alarm) && (curr == 1)){
     98c:	80 91 53 01 	lds	r24, 0x0153	; 0x800153 <alarm>
     990:	81 11       	cpse	r24, r1
     992:	04 c0       	rjmp	.+8      	; 0x99c <change_alarm_state+0x20>
     994:	80 91 5d 01 	lds	r24, 0x015D	; 0x80015d <curr.2204>
     998:	81 30       	cpi	r24, 0x01	; 1
     99a:	09 f0       	breq	.+2      	; 0x99e <change_alarm_state+0x22>
     99c:	08 95       	ret
      curr = 0;
     99e:	10 92 5d 01 	sts	0x015D, r1	; 0x80015d <curr.2204>
      line1_col1();
     9a2:	0e 94 5a 07 	call	0xeb4	; 0xeb4 <line1_col1>
      string2lcd("     ");
     9a6:	80 e4       	ldi	r24, 0x40	; 64
     9a8:	91 e0       	ldi	r25, 0x01	; 1
     9aa:	0c 94 9c 07 	jmp	0xf38	; 0xf38 <string2lcd>
      curr = 1;	//indicated that alarm has been written to the display next time
	//through the function
   }
	//clears display when the alarm is turned off*/
   if(alarm && (curr ==0)){
      line1_col1();
     9ae:	0e 94 5a 07 	call	0xeb4	; 0xeb4 <line1_col1>
      string2lcd("Alarm");
     9b2:	8b e1       	ldi	r24, 0x1B	; 27
     9b4:	91 e0       	ldi	r25, 0x01	; 1
     9b6:	0e 94 9c 07 	call	0xf38	; 0xf38 <string2lcd>
      //lcd_array[0] = 'A';
      //lcd_array[1] = 'l';
      //lcd_array[2] = 'a';
      //lcd_array[3] = 'r';
      //lcd_array[4] = 'm';
      curr = 1;
     9ba:	81 e0       	ldi	r24, 0x01	; 1
     9bc:	80 93 5d 01 	sts	0x015D, r24	; 0x80015d <curr.2204>
     9c0:	08 95       	ret

000009c2 <adc_init>:
Description: Basic adc initialization used for single shot adc readings
Parameters: NA
**********************************************************************/
void adc_init(){
//Initalize ADC and its ports
   DDRF  &= ~(_BV(DDF7)); //make port F bit 7 is ADC input  
     9c2:	e1 e6       	ldi	r30, 0x61	; 97
     9c4:	f0 e0       	ldi	r31, 0x00	; 0
     9c6:	80 81       	ld	r24, Z
     9c8:	8f 77       	andi	r24, 0x7F	; 127
     9ca:	80 83       	st	Z, r24
   PORTF &= ~(_BV(PF7));  //port F bit 7 pullups must be off
     9cc:	e2 e6       	ldi	r30, 0x62	; 98
     9ce:	f0 e0       	ldi	r31, 0x00	; 0
     9d0:	80 81       	ld	r24, Z
     9d2:	8f 77       	andi	r24, 0x7F	; 127
     9d4:	80 83       	st	Z, r24
   ADMUX |= (1<<REFS0) | (1<<MUX2)| (1<<MUX1)| (1<<MUX0); //single-ended, input PORTF bit 7, right adjusted, 10 bits
     9d6:	87 b1       	in	r24, 0x07	; 7
     9d8:	87 64       	ori	r24, 0x47	; 71
     9da:	87 b9       	out	0x07, r24	; 7

   ADCSRA |= (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);//ADC enabled, don't start yet, single shot mode 
     9dc:	86 b1       	in	r24, 0x06	; 6
     9de:	87 68       	ori	r24, 0x87	; 135
     9e0:	86 b9       	out	0x06, r24	; 6
     9e2:	08 95       	ret

000009e4 <fetch_adc>:
void fetch_adc(){
   uint16_t adc_result;
   uint16_t step;   
   uint16_t step2;   

   ADCSRA |= (1<<ADSC); //poke ADSC and start conversion
     9e4:	36 9a       	sbi	0x06, 6	; 6
   while(bit_is_clear(ADCSRA, ADIF)){} //spin while interrupt flag not set
     9e6:	34 9b       	sbis	0x06, 4	; 6
     9e8:	fe cf       	rjmp	.-4      	; 0x9e6 <fetch_adc+0x2>
   ACSR |= (1<<ACI); //its done, clear flag by writing a one 
     9ea:	44 9a       	sbi	0x08, 4	; 8
   adc_result = ADC;                      //read the ADC output as 16 bits
     9ec:	24 b1       	in	r18, 0x04	; 4
     9ee:	35 b1       	in	r19, 0x05	; 5

   step = adc_result/4;//scales the adc result from 0-255
   step2 =  255 - step;//I need the complement to the adc result
     9f0:	36 95       	lsr	r19
     9f2:	27 95       	ror	r18
     9f4:	36 95       	lsr	r19
     9f6:	27 95       	ror	r18
   if(step2 > 235){	//this is a minimum brightness level
      step2 = 235;
   }

   OCR2 = step2;	//Write brightness level to tnct2 compare match register
     9f8:	8f ef       	ldi	r24, 0xFF	; 255
     9fa:	90 e0       	ldi	r25, 0x00	; 0
     9fc:	82 1b       	sub	r24, r18
     9fe:	93 0b       	sbc	r25, r19
     a00:	8c 3e       	cpi	r24, 0xEC	; 236
     a02:	91 05       	cpc	r25, r1
     a04:	10 f0       	brcs	.+4      	; 0xa0a <fetch_adc+0x26>
     a06:	8b ee       	ldi	r24, 0xEB	; 235
     a08:	90 e0       	ldi	r25, 0x00	; 0
     a0a:	83 bd       	out	0x23, r24	; 35
     a0c:	08 95       	ret

00000a0e <__vector_12>:
Function: TIMER!_COMPA_vect
Description: This ISR creates the alarm frequency on PORTD but 3 the is used
	for the alarm tone.
Parameters: NA
**********************************************************************/
ISR(TIMER1_COMPA_vect){
     a0e:	1f 92       	push	r1
     a10:	0f 92       	push	r0
     a12:	0f b6       	in	r0, 0x3f	; 63
     a14:	0f 92       	push	r0
     a16:	11 24       	eor	r1, r1
     a18:	8f 93       	push	r24
     a1a:	9f 93       	push	r25
   //static uint8_t seconds = 0;
   //bars();  //displays the mode on the bargraph
   //read_encoder();     //reads the encoder values
if(!snooze){ //alarm has not been snoozed
     a1c:	80 91 52 01 	lds	r24, 0x0152	; 0x800152 <snooze>
     a20:	81 11       	cpse	r24, r1
     a22:	0a c0       	rjmp	.+20     	; 0xa38 <__vector_12+0x2a>
//checks to see alarm is on and the alarm time matches clock time
   if(alarm && ((hour_count == a_hour_count) && (min_count == a_min_count))){
     a24:	80 91 53 01 	lds	r24, 0x0153	; 0x800153 <alarm>
     a28:	88 23       	and	r24, r24
     a2a:	31 f0       	breq	.+12     	; 0xa38 <__vector_12+0x2a>
     a2c:	90 91 58 01 	lds	r25, 0x0158	; 0x800158 <hour_count>
     a30:	80 91 55 01 	lds	r24, 0x0155	; 0x800155 <a_hour_count>
     a34:	98 17       	cp	r25, r24
     a36:	39 f0       	breq	.+14     	; 0xa46 <__vector_12+0x38>
      PORTD = PIND ^ 0b00000100;//toggles PD3 to create frequency
   }
}
}
     a38:	9f 91       	pop	r25
     a3a:	8f 91       	pop	r24
     a3c:	0f 90       	pop	r0
     a3e:	0f be       	out	0x3f, r0	; 63
     a40:	0f 90       	pop	r0
     a42:	1f 90       	pop	r1
     a44:	18 95       	reti
   //static uint8_t seconds = 0;
   //bars();  //displays the mode on the bargraph
   //read_encoder();     //reads the encoder values
if(!snooze){ //alarm has not been snoozed
//checks to see alarm is on and the alarm time matches clock time
   if(alarm && ((hour_count == a_hour_count) && (min_count == a_min_count))){
     a46:	90 91 59 01 	lds	r25, 0x0159	; 0x800159 <min_count>
     a4a:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <a_min_count>
     a4e:	98 13       	cpse	r25, r24
     a50:	f3 cf       	rjmp	.-26     	; 0xa38 <__vector_12+0x2a>
      PORTD = PIND ^ 0b00000100;//toggles PD3 to create frequency
     a52:	90 b3       	in	r25, 0x10	; 16
     a54:	84 e0       	ldi	r24, 0x04	; 4
     a56:	89 27       	eor	r24, r25
     a58:	82 bb       	out	0x12, r24	; 18
   }
}
}
     a5a:	ee cf       	rjmp	.-36     	; 0xa38 <__vector_12+0x2a>

00000a5c <__vector_14>:

ISR(TIMER1_OVF_vect){
     a5c:	1f 92       	push	r1
     a5e:	0f 92       	push	r0
     a60:	0f b6       	in	r0, 0x3f	; 63
     a62:	0f 92       	push	r0
     a64:	11 24       	eor	r1, r1
     a66:	8f 93       	push	r24

   lcd_array[25] = 'G';
     a68:	87 e4       	ldi	r24, 0x47	; 71
     a6a:	80 93 8c 01 	sts	0x018C, r24	; 0x80018c <lcd_array+0x19>

}
     a6e:	8f 91       	pop	r24
     a70:	0f 90       	pop	r0
     a72:	0f be       	out	0x3f, r0	; 63
     a74:	0f 90       	pop	r0
     a76:	1f 90       	pop	r1
     a78:	18 95       	reti

00000a7a <snoozin>:
Description: This function disables the snooze variable once the alarm
	seconds equals the normal seconds. 
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
     a7a:	80 91 52 01 	lds	r24, 0x0152	; 0x800152 <snooze>
     a7e:	81 11       	cpse	r24, r1
     a80:	0c 94 b8 00 	jmp	0x170	; 0x170 <snoozin.part.1>
     a84:	08 95       	ret

00000a86 <local_temp_init>:
Description: 
Parameters: NA
**********************************************************************/
void local_temp_init(){

lm73_wr_buf[0] = 0x00; //load lm73_wr_buf[0] with temperature pointer address
     a86:	10 92 e0 01 	sts	0x01E0, r1	; 0x8001e0 <lm73_wr_buf>
twi_start_wr(LM73_ADDRESS, lm73_rd_buf, 1); //start the TWI write process
     a8a:	41 e0       	ldi	r20, 0x01	; 1
     a8c:	62 ee       	ldi	r22, 0xE2	; 226
     a8e:	71 e0       	ldi	r23, 0x01	; 1
     a90:	80 e9       	ldi	r24, 0x90	; 144
     a92:	0e 94 cc 0a 	call	0x1598	; 0x1598 <twi_start_wr>
     a96:	2f ef       	ldi	r18, 0xFF	; 255
     a98:	81 ee       	ldi	r24, 0xE1	; 225
     a9a:	94 e0       	ldi	r25, 0x04	; 4
     a9c:	21 50       	subi	r18, 0x01	; 1
     a9e:	80 40       	sbci	r24, 0x00	; 0
     aa0:	90 40       	sbci	r25, 0x00	; 0
     aa2:	e1 f7       	brne	.-8      	; 0xa9c <local_temp_init+0x16>
     aa4:	00 c0       	rjmp	.+0      	; 0xaa6 <local_temp_init+0x20>
     aa6:	00 00       	nop
     aa8:	08 95       	ret

00000aaa <__vector_18>:
/**********************************************************************
Function: ()
Description: 
Parameters: NA
**********************************************************************/
ISR(USART0_RX_vect){
     aaa:	1f 92       	push	r1
     aac:	0f 92       	push	r0
     aae:	0f b6       	in	r0, 0x3f	; 63
     ab0:	0f 92       	push	r0
     ab2:	11 24       	eor	r1, r1
     ab4:	0b b6       	in	r0, 0x3b	; 59
     ab6:	0f 92       	push	r0
     ab8:	8f 93       	push	r24
     aba:	9f 93       	push	r25
     abc:	ef 93       	push	r30
     abe:	ff 93       	push	r31
static  uint8_t  i;
  rx_char = UDR0;              //get character
     ac0:	8c b1       	in	r24, 0x0c	; 12
     ac2:	80 93 a9 01 	sts	0x01A9, r24	; 0x8001a9 <rx_char>
  lcd_str_array[i++]=rx_char;  //store in array 
     ac6:	e0 91 5c 01 	lds	r30, 0x015C	; 0x80015c <i.2234>
     aca:	91 e0       	ldi	r25, 0x01	; 1
     acc:	9e 0f       	add	r25, r30
     ace:	90 93 5c 01 	sts	0x015C, r25	; 0x80015c <i.2234>
     ad2:	f0 e0       	ldi	r31, 0x00	; 0
     ad4:	e7 56       	subi	r30, 0x67	; 103
     ad6:	fe 4f       	sbci	r31, 0xFE	; 254
     ad8:	80 83       	st	Z, r24
 //if entire string has arrived, set flag, reset index
  if(rx_char == '\0'){
     ada:	81 11       	cpse	r24, r1
     adc:	09 c0       	rjmp	.+18     	; 0xaf0 <__vector_18+0x46>
    rcv_rdy=1; 
     ade:	81 e0       	ldi	r24, 0x01	; 1
     ae0:	80 93 72 01 	sts	0x0172, r24	; 0x800172 <rcv_rdy>
    lcd_str_array[--i]  = (' ');     //clear the count field
     ae4:	80 e2       	ldi	r24, 0x20	; 32
     ae6:	80 83       	st	Z, r24
    lcd_str_array[i+1]  = (' ');
     ae8:	81 83       	std	Z+1, r24	; 0x01
    lcd_str_array[i+2]  = (' ');
     aea:	82 83       	std	Z+2, r24	; 0x02
    i=0;  
     aec:	10 92 5c 01 	sts	0x015C, r1	; 0x80015c <i.2234>
  }
}
     af0:	ff 91       	pop	r31
     af2:	ef 91       	pop	r30
     af4:	9f 91       	pop	r25
     af6:	8f 91       	pop	r24
     af8:	0f 90       	pop	r0
     afa:	0b be       	out	0x3b, r0	; 59
     afc:	0f 90       	pop	r0
     afe:	0f be       	out	0x3f, r0	; 63
     b00:	0f 90       	pop	r0
     b02:	1f 90       	pop	r1
     b04:	18 95       	reti

00000b06 <send_lcd>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b06:	91 e0       	ldi	r25, 0x01	; 1
     b08:	81 11       	cpse	r24, r1
     b0a:	01 c0       	rjmp	.+2      	; 0xb0e <send_lcd+0x8>
     b0c:	90 e0       	ldi	r25, 0x00	; 0
     b0e:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b10:	77 9b       	sbis	0x0e, 7	; 14
     b12:	fe cf       	rjmp	.-4      	; 0xb10 <send_lcd+0xa>
  SPDR = byte;                        //send payload
     b14:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b16:	77 9b       	sbis	0x0e, 7	; 14
     b18:	fe cf       	rjmp	.-4      	; 0xb16 <send_lcd+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b1a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b1e:	88 60       	ori	r24, 0x08	; 8
     b20:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b24:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b28:	87 7f       	andi	r24, 0xF7	; 247
     b2a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b2e:	08 95       	ret

00000b30 <refresh_lcd>:
//
void refresh_lcd(char lcd_string_array[]) {

  static uint8_t i=0;           // index into string array 

 send_lcd(CHAR_BYTE,lcd_string_array[i]);
     b30:	20 91 70 01 	lds	r18, 0x0170	; 0x800170 <i.2095>
     b34:	82 0f       	add	r24, r18
     b36:	91 1d       	adc	r25, r1
     b38:	fc 01       	movw	r30, r24
     b3a:	80 81       	ld	r24, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b3c:	91 e0       	ldi	r25, 0x01	; 1
     b3e:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b40:	77 9b       	sbis	0x0e, 7	; 14
     b42:	fe cf       	rjmp	.-4      	; 0xb40 <refresh_lcd+0x10>
  SPDR = byte;                        //send payload
     b44:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b46:	77 9b       	sbis	0x0e, 7	; 14
     b48:	fe cf       	rjmp	.-4      	; 0xb46 <refresh_lcd+0x16>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b4a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b4e:	88 60       	ori	r24, 0x08	; 8
     b50:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b54:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b58:	87 7f       	andi	r24, 0xF7	; 247
     b5a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
void refresh_lcd(char lcd_string_array[]) {

  static uint8_t i=0;           // index into string array 

 send_lcd(CHAR_BYTE,lcd_string_array[i]);
 i++;   //increment to next character
     b5e:	80 91 70 01 	lds	r24, 0x0170	; 0x800170 <i.2095>
     b62:	8f 5f       	subi	r24, 0xFF	; 255
     b64:	80 93 70 01 	sts	0x0170, r24	; 0x800170 <i.2095>
 //delays are inserted to allow character to be written before moving
 //the cursor to the next line.
 if(i == 16){_delay_us(40); line2_col1();      } //goto line 2, 1st char 
     b68:	80 31       	cpi	r24, 0x10	; 16
     b6a:	f9 f0       	breq	.+62     	; 0xbaa <refresh_lcd+0x7a>
 if(i == 32){_delay_us(40); line1_col1(); i=0; } //goto line 1, 1st char 
     b6c:	80 32       	cpi	r24, 0x20	; 32
     b6e:	09 f0       	breq	.+2      	; 0xb72 <refresh_lcd+0x42>
     b70:	08 95       	ret
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     b72:	e5 ed       	ldi	r30, 0xD5	; 213
     b74:	ea 95       	dec	r30
     b76:	f1 f7       	brne	.-4      	; 0xb74 <refresh_lcd+0x44>
     b78:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b7a:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b7c:	77 9b       	sbis	0x0e, 7	; 14
     b7e:	fe cf       	rjmp	.-4      	; 0xb7c <refresh_lcd+0x4c>
  SPDR = byte;                        //send payload
     b80:	80 e8       	ldi	r24, 0x80	; 128
     b82:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b84:	77 9b       	sbis	0x0e, 7	; 14
     b86:	fe cf       	rjmp	.-4      	; 0xb84 <refresh_lcd+0x54>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b88:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b8c:	88 60       	ori	r24, 0x08	; 8
     b8e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b92:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b96:	87 7f       	andi	r24, 0xF7	; 247
     b98:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b9c:	f5 ed       	ldi	r31, 0xD5	; 213
     b9e:	fa 95       	dec	r31
     ba0:	f1 f7       	brne	.-4      	; 0xb9e <refresh_lcd+0x6e>
     ba2:	00 00       	nop
 send_lcd(CHAR_BYTE,lcd_string_array[i]);
 i++;   //increment to next character
 //delays are inserted to allow character to be written before moving
 //the cursor to the next line.
 if(i == 16){_delay_us(40); line2_col1();      } //goto line 2, 1st char 
 if(i == 32){_delay_us(40); line1_col1(); i=0; } //goto line 1, 1st char 
     ba4:	10 92 70 01 	sts	0x0170, r1	; 0x800170 <i.2095>
     ba8:	08 95       	ret
     baa:	f5 ed       	ldi	r31, 0xD5	; 213
     bac:	fa 95       	dec	r31
     bae:	f1 f7       	brne	.-4      	; 0xbac <refresh_lcd+0x7c>
     bb0:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     bb2:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     bb4:	77 9b       	sbis	0x0e, 7	; 14
     bb6:	fe cf       	rjmp	.-4      	; 0xbb4 <refresh_lcd+0x84>
  SPDR = byte;                        //send payload
     bb8:	80 ec       	ldi	r24, 0xC0	; 192
     bba:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     bbc:	77 9b       	sbis	0x0e, 7	; 14
     bbe:	fe cf       	rjmp	.-4      	; 0xbbc <refresh_lcd+0x8c>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     bc0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bc4:	88 60       	ori	r24, 0x08	; 8
     bc6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bca:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bce:	87 7f       	andi	r24, 0xF7	; 247
     bd0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bd4:	85 ed       	ldi	r24, 0xD5	; 213
     bd6:	8a 95       	dec	r24
     bd8:	f1 f7       	brne	.-4      	; 0xbd6 <refresh_lcd+0xa6>
     bda:	00 00       	nop
     bdc:	80 91 70 01 	lds	r24, 0x0170	; 0x800170 <i.2095>
     be0:	c5 cf       	rjmp	.-118    	; 0xb6c <refresh_lcd+0x3c>

00000be2 <set_custom_character>:
//address, such as send_lcd(CHAR_BYTE, 0x01, 1) or it can be insteretd into a string 
//via a forward slash escape as in string2lcd("this is my music note \1")

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
     be2:	66 0f       	add	r22, r22
     be4:	66 0f       	add	r22, r22
     be6:	66 0f       	add	r22, r22
     be8:	60 5c       	subi	r22, 0xC0	; 192
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     bea:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     bec:	77 9b       	sbis	0x0e, 7	; 14
     bee:	fe cf       	rjmp	.-4      	; 0xbec <set_custom_character+0xa>
  SPDR = byte;                        //send payload
     bf0:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     bf2:	77 9b       	sbis	0x0e, 7	; 14
     bf4:	fe cf       	rjmp	.-4      	; 0xbf2 <set_custom_character+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     bf6:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bfa:	28 60       	ori	r18, 0x08	; 8
     bfc:	20 93 62 00 	sts	0x0062, r18	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c00:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c04:	27 7f       	andi	r18, 0xF7	; 247
     c06:	20 93 62 00 	sts	0x0062, r18	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c0a:	25 ed       	ldi	r18, 0xD5	; 213
     c0c:	2a 95       	dec	r18
     c0e:	f1 f7       	brne	.-4      	; 0xc0c <set_custom_character+0x2a>
     c10:	00 00       	nop
     c12:	fc 01       	movw	r30, r24
     c14:	9c 01       	movw	r18, r24
     c16:	28 5f       	subi	r18, 0xF8	; 248
     c18:	3f 4f       	sbci	r19, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c1a:	91 e0       	ldi	r25, 0x01	; 1

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
    for(i=0; i<8; i++){
      send_lcd(CHAR_BYTE, data[i]); _delay_us(40); //each char byte takes 37us to execute
     c1c:	81 91       	ld	r24, Z+
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c1e:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c20:	77 9b       	sbis	0x0e, 7	; 14
     c22:	fe cf       	rjmp	.-4      	; 0xc20 <set_custom_character+0x3e>
  SPDR = byte;                        //send payload
     c24:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c26:	77 9b       	sbis	0x0e, 7	; 14
     c28:	fe cf       	rjmp	.-4      	; 0xc26 <set_custom_character+0x44>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     c2a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c2e:	88 60       	ori	r24, 0x08	; 8
     c30:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c34:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c38:	87 7f       	andi	r24, 0xF7	; 247
     c3a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c3e:	85 ed       	ldi	r24, 0xD5	; 213
     c40:	8a 95       	dec	r24
     c42:	f1 f7       	brne	.-4      	; 0xc40 <set_custom_character+0x5e>
     c44:	00 00       	nop
//via a forward slash escape as in string2lcd("this is my music note \1")

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
    for(i=0; i<8; i++){
     c46:	e2 17       	cp	r30, r18
     c48:	f3 07       	cpc	r31, r19
     c4a:	41 f7       	brne	.-48     	; 0xc1c <set_custom_character+0x3a>
      send_lcd(CHAR_BYTE, data[i]); _delay_us(40); //each char byte takes 37us to execute
    }
}
     c4c:	08 95       	ret

00000c4e <set_cursor>:
//                          set_cursor 
//
//Sets the cursor to an arbitrary potition on the screen, row is either 1 or 2
//col is a number form 0-15, counting from left to right
void set_cursor(uint8_t row, uint8_t col){
    send_lcd(CMD_BYTE, 0x80 + col + ((row-1)*0x40));
     c4e:	90 e4       	ldi	r25, 0x40	; 64
     c50:	89 9f       	mul	r24, r25
     c52:	60 0d       	add	r22, r0
     c54:	11 24       	eor	r1, r1
     c56:	60 5c       	subi	r22, 0xC0	; 192
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c58:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c5a:	77 9b       	sbis	0x0e, 7	; 14
     c5c:	fe cf       	rjmp	.-4      	; 0xc5a <set_cursor+0xc>
  SPDR = byte;                        //send payload
     c5e:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c60:	77 9b       	sbis	0x0e, 7	; 14
     c62:	fe cf       	rjmp	.-4      	; 0xc60 <set_cursor+0x12>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     c64:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c68:	88 60       	ori	r24, 0x08	; 8
     c6a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c6e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c72:	87 7f       	andi	r24, 0xF7	; 247
     c74:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c78:	08 95       	ret

00000c7a <uint2lcd>:
//not displayed.  
//TODO: optimize by removing the mod operators
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
     c7a:	81 11       	cpse	r24, r1
     c7c:	13 c0       	rjmp	.+38     	; 0xca4 <uint2lcd+0x2a>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c7e:	81 e0       	ldi	r24, 0x01	; 1
     c80:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c82:	77 9b       	sbis	0x0e, 7	; 14
     c84:	fe cf       	rjmp	.-4      	; 0xc82 <uint2lcd+0x8>
  SPDR = byte;                        //send payload
     c86:	80 e3       	ldi	r24, 0x30	; 48
     c88:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c8a:	77 9b       	sbis	0x0e, 7	; 14
     c8c:	fe cf       	rjmp	.-4      	; 0xc8a <uint2lcd+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     c8e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c92:	88 60       	ori	r24, 0x08	; 8
     c94:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c98:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c9c:	87 7f       	andi	r24, 0xF7	; 247
     c9e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ca2:	08 95       	ret
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
     ca4:	84 36       	cpi	r24, 0x64	; 100
     ca6:	b0 f4       	brcc	.+44     	; 0xcd4 <uint2lcd+0x5a>
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
     ca8:	8a 30       	cpi	r24, 0x0A	; 10
     caa:	60 f5       	brcc	.+88     	; 0xd04 <uint2lcd+0x8a>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     cac:	91 e0       	ldi	r25, 0x01	; 1
     cae:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     cb0:	77 9b       	sbis	0x0e, 7	; 14
     cb2:	fe cf       	rjmp	.-4      	; 0xcb0 <uint2lcd+0x36>
void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
      if(number >= 1)  {send_lcd(CHAR_BYTE, 0x30+(number%10)    ); }
     cb4:	9d ec       	ldi	r25, 0xCD	; 205
     cb6:	89 9f       	mul	r24, r25
     cb8:	91 2d       	mov	r25, r1
     cba:	11 24       	eor	r1, r1
     cbc:	96 95       	lsr	r25
     cbe:	96 95       	lsr	r25
     cc0:	96 95       	lsr	r25
     cc2:	2a e0       	ldi	r18, 0x0A	; 10
     cc4:	92 9f       	mul	r25, r18
     cc6:	80 19       	sub	r24, r0
     cc8:	11 24       	eor	r1, r1
     cca:	80 5d       	subi	r24, 0xD0	; 208
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
  SPDR = byte;                        //send payload
     ccc:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     cce:	77 9b       	sbis	0x0e, 7	; 14
     cd0:	fe cf       	rjmp	.-4      	; 0xcce <uint2lcd+0x54>
     cd2:	dd cf       	rjmp	.-70     	; 0xc8e <uint2lcd+0x14>
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
     cd4:	99 e2       	ldi	r25, 0x29	; 41
     cd6:	89 9f       	mul	r24, r25
     cd8:	91 2d       	mov	r25, r1
     cda:	11 24       	eor	r1, r1
     cdc:	92 95       	swap	r25
     cde:	9f 70       	andi	r25, 0x0F	; 15
     ce0:	90 5d       	subi	r25, 0xD0	; 208
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ce2:	21 e0       	ldi	r18, 0x01	; 1
     ce4:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ce6:	77 9b       	sbis	0x0e, 7	; 14
     ce8:	fe cf       	rjmp	.-4      	; 0xce6 <uint2lcd+0x6c>
  SPDR = byte;                        //send payload
     cea:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     cec:	77 9b       	sbis	0x0e, 7	; 14
     cee:	fe cf       	rjmp	.-4      	; 0xcec <uint2lcd+0x72>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     cf0:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cf4:	98 60       	ori	r25, 0x08	; 8
     cf6:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cfa:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cfe:	97 7f       	andi	r25, 0xF7	; 247
     d00:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
     d04:	99 e2       	ldi	r25, 0x29	; 41
     d06:	89 9f       	mul	r24, r25
     d08:	91 2d       	mov	r25, r1
     d0a:	11 24       	eor	r1, r1
     d0c:	92 95       	swap	r25
     d0e:	9f 70       	andi	r25, 0x0F	; 15
     d10:	38 2f       	mov	r19, r24
     d12:	24 e6       	ldi	r18, 0x64	; 100
     d14:	92 9f       	mul	r25, r18
     d16:	30 19       	sub	r19, r0
     d18:	11 24       	eor	r1, r1
     d1a:	2d ec       	ldi	r18, 0xCD	; 205
     d1c:	32 9f       	mul	r19, r18
     d1e:	91 2d       	mov	r25, r1
     d20:	11 24       	eor	r1, r1
     d22:	96 95       	lsr	r25
     d24:	96 95       	lsr	r25
     d26:	96 95       	lsr	r25
     d28:	90 5d       	subi	r25, 0xD0	; 208
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d2a:	21 e0       	ldi	r18, 0x01	; 1
     d2c:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d2e:	77 9b       	sbis	0x0e, 7	; 14
     d30:	fe cf       	rjmp	.-4      	; 0xd2e <uint2lcd+0xb4>
  SPDR = byte;                        //send payload
     d32:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d34:	77 9b       	sbis	0x0e, 7	; 14
     d36:	fe cf       	rjmp	.-4      	; 0xd34 <uint2lcd+0xba>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d38:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d3c:	98 60       	ori	r25, 0x08	; 8
     d3e:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d42:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d46:	97 7f       	andi	r25, 0xF7	; 247
     d48:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d4c:	af cf       	rjmp	.-162    	; 0xcac <uint2lcd+0x32>

00000d4e <int2lcd>:
//Takes a 8bit signed and displays it in base ten on the LCD. Leading 0's are 
//not displayed.
//
void int2lcd(int8_t number){
    //if < 0, print minus sign, then take 2's complement of number and display
    if(number < 0){send_lcd(CHAR_BYTE, '-'); _delay_us(40); uint2lcd(~number+1);}  
     d4e:	87 ff       	sbrs	r24, 7
    else          {uint2lcd(number);                                            }
     d50:	0c 94 3d 06 	jmp	0xc7a	; 0xc7a <uint2lcd>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d54:	91 e0       	ldi	r25, 0x01	; 1
     d56:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d58:	77 9b       	sbis	0x0e, 7	; 14
     d5a:	fe cf       	rjmp	.-4      	; 0xd58 <int2lcd+0xa>
  SPDR = byte;                        //send payload
     d5c:	9d e2       	ldi	r25, 0x2D	; 45
     d5e:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d60:	77 9b       	sbis	0x0e, 7	; 14
     d62:	fe cf       	rjmp	.-4      	; 0xd60 <int2lcd+0x12>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d64:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d68:	98 60       	ori	r25, 0x08	; 8
     d6a:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d6e:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d72:	97 7f       	andi	r25, 0xF7	; 247
     d74:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d78:	95 ed       	ldi	r25, 0xD5	; 213
     d7a:	9a 95       	dec	r25
     d7c:	f1 f7       	brne	.-4      	; 0xd7a <int2lcd+0x2c>
     d7e:	00 00       	nop
//Takes a 8bit signed and displays it in base ten on the LCD. Leading 0's are 
//not displayed.
//
void int2lcd(int8_t number){
    //if < 0, print minus sign, then take 2's complement of number and display
    if(number < 0){send_lcd(CHAR_BYTE, '-'); _delay_us(40); uint2lcd(~number+1);}  
     d80:	81 95       	neg	r24
     d82:	0c 94 3d 06 	jmp	0xc7a	; 0xc7a <uint2lcd>

00000d86 <cursor_on>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d86:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d88:	77 9b       	sbis	0x0e, 7	; 14
     d8a:	fe cf       	rjmp	.-4      	; 0xd88 <cursor_on+0x2>
  SPDR = byte;                        //send payload
     d8c:	8e e0       	ldi	r24, 0x0E	; 14
     d8e:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d90:	77 9b       	sbis	0x0e, 7	; 14
     d92:	fe cf       	rjmp	.-4      	; 0xd90 <cursor_on+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d94:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d98:	88 60       	ori	r24, 0x08	; 8
     d9a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d9e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     da2:	87 7f       	andi	r24, 0xF7	; 247
     da4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     da8:	08 95       	ret

00000daa <cursor_off>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     daa:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     dac:	77 9b       	sbis	0x0e, 7	; 14
     dae:	fe cf       	rjmp	.-4      	; 0xdac <cursor_off+0x2>
  SPDR = byte;                        //send payload
     db0:	8c e0       	ldi	r24, 0x0C	; 12
     db2:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     db4:	77 9b       	sbis	0x0e, 7	; 14
     db6:	fe cf       	rjmp	.-4      	; 0xdb4 <cursor_off+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     db8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dbc:	88 60       	ori	r24, 0x08	; 8
     dbe:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dc2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dc6:	87 7f       	andi	r24, 0xF7	; 247
     dc8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dcc:	08 95       	ret

00000dce <shift_right>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     dce:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     dd0:	77 9b       	sbis	0x0e, 7	; 14
     dd2:	fe cf       	rjmp	.-4      	; 0xdd0 <shift_right+0x2>
  SPDR = byte;                        //send payload
     dd4:	8e e1       	ldi	r24, 0x1E	; 30
     dd6:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     dd8:	77 9b       	sbis	0x0e, 7	; 14
     dda:	fe cf       	rjmp	.-4      	; 0xdd8 <shift_right+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     ddc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     de0:	88 60       	ori	r24, 0x08	; 8
     de2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     de6:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dea:	87 7f       	andi	r24, 0xF7	; 247
     dec:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     df0:	08 95       	ret

00000df2 <shift_left>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     df2:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     df4:	77 9b       	sbis	0x0e, 7	; 14
     df6:	fe cf       	rjmp	.-4      	; 0xdf4 <shift_left+0x2>
  SPDR = byte;                        //send payload
     df8:	88 e1       	ldi	r24, 0x18	; 24
     dfa:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     dfc:	77 9b       	sbis	0x0e, 7	; 14
     dfe:	fe cf       	rjmp	.-4      	; 0xdfc <shift_left+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     e00:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e04:	88 60       	ori	r24, 0x08	; 8
     e06:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e0a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e0e:	87 7f       	andi	r24, 0xF7	; 247
     e10:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e14:	08 95       	ret

00000e16 <strobe_lcd>:
     e16:	e2 e6       	ldi	r30, 0x62	; 98
     e18:	f0 e0       	ldi	r31, 0x00	; 0
     e1a:	80 81       	ld	r24, Z
     e1c:	88 60       	ori	r24, 0x08	; 8
     e1e:	80 83       	st	Z, r24
     e20:	80 81       	ld	r24, Z
     e22:	87 7f       	andi	r24, 0xF7	; 247
     e24:	80 83       	st	Z, r24
     e26:	08 95       	ret

00000e28 <clear_display>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e28:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e2a:	77 9b       	sbis	0x0e, 7	; 14
     e2c:	fe cf       	rjmp	.-4      	; 0xe2a <clear_display+0x2>
  SPDR = byte;                        //send payload
     e2e:	81 e0       	ldi	r24, 0x01	; 1
     e30:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e32:	77 9b       	sbis	0x0e, 7	; 14
     e34:	fe cf       	rjmp	.-4      	; 0xe32 <clear_display+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     e36:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e3a:	88 60       	ori	r24, 0x08	; 8
     e3c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e40:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e44:	87 7f       	andi	r24, 0xF7	; 247
     e46:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e4a:	8f e1       	ldi	r24, 0x1F	; 31
     e4c:	9c e1       	ldi	r25, 0x1C	; 28
     e4e:	01 97       	sbiw	r24, 0x01	; 1
     e50:	f1 f7       	brne	.-4      	; 0xe4e <clear_display+0x26>
     e52:	00 c0       	rjmp	.+0      	; 0xe54 <clear_display+0x2c>
     e54:	00 00       	nop
     e56:	08 95       	ret

00000e58 <cursor_home>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e58:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e5a:	77 9b       	sbis	0x0e, 7	; 14
     e5c:	fe cf       	rjmp	.-4      	; 0xe5a <cursor_home+0x2>
  SPDR = byte;                        //send payload
     e5e:	82 e0       	ldi	r24, 0x02	; 2
     e60:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e62:	77 9b       	sbis	0x0e, 7	; 14
     e64:	fe cf       	rjmp	.-4      	; 0xe62 <cursor_home+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     e66:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e6a:	88 60       	ori	r24, 0x08	; 8
     e6c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e70:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e74:	87 7f       	andi	r24, 0xF7	; 247
     e76:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e7a:	8f e6       	ldi	r24, 0x6F	; 111
     e7c:	97 e1       	ldi	r25, 0x17	; 23
     e7e:	01 97       	sbiw	r24, 0x01	; 1
     e80:	f1 f7       	brne	.-4      	; 0xe7e <cursor_home+0x26>
     e82:	00 c0       	rjmp	.+0      	; 0xe84 <cursor_home+0x2c>
     e84:	00 00       	nop
     e86:	08 95       	ret

00000e88 <line2_col1>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e88:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e8a:	77 9b       	sbis	0x0e, 7	; 14
     e8c:	fe cf       	rjmp	.-4      	; 0xe8a <line2_col1+0x2>
  SPDR = byte;                        //send payload
     e8e:	80 ec       	ldi	r24, 0xC0	; 192
     e90:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e92:	77 9b       	sbis	0x0e, 7	; 14
     e94:	fe cf       	rjmp	.-4      	; 0xe92 <line2_col1+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     e96:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e9a:	88 60       	ori	r24, 0x08	; 8
     e9c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ea0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ea4:	87 7f       	andi	r24, 0xF7	; 247
     ea6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     eaa:	85 ed       	ldi	r24, 0xD5	; 213
     eac:	8a 95       	dec	r24
     eae:	f1 f7       	brne	.-4      	; 0xeac <line2_col1+0x24>
     eb0:	00 00       	nop
     eb2:	08 95       	ret

00000eb4 <line1_col1>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     eb4:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     eb6:	77 9b       	sbis	0x0e, 7	; 14
     eb8:	fe cf       	rjmp	.-4      	; 0xeb6 <line1_col1+0x2>
  SPDR = byte;                        //send payload
     eba:	80 e8       	ldi	r24, 0x80	; 128
     ebc:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ebe:	77 9b       	sbis	0x0e, 7	; 14
     ec0:	fe cf       	rjmp	.-4      	; 0xebe <line1_col1+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     ec2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ec6:	88 60       	ori	r24, 0x08	; 8
     ec8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ecc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ed0:	87 7f       	andi	r24, 0xF7	; 247
     ed2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ed6:	85 ed       	ldi	r24, 0xD5	; 213
     ed8:	8a 95       	dec	r24
     eda:	f1 f7       	brne	.-4      	; 0xed8 <line1_col1+0x24>
     edc:	00 00       	nop
     ede:	08 95       	ret

00000ee0 <fill_spaces>:

//-----------------------------------------------------------------------------
//                          fill_spaces   
//
//Fill an entire line with spaces.
void fill_spaces(void){
     ee0:	90 e1       	ldi	r25, 0x10	; 16
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ee2:	31 e0       	ldi	r19, 0x01	; 1
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
  SPDR = byte;                        //send payload
     ee4:	20 e2       	ldi	r18, 0x20	; 32
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ee6:	3f b9       	out	0x0f, r19	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ee8:	77 9b       	sbis	0x0e, 7	; 14
     eea:	fe cf       	rjmp	.-4      	; 0xee8 <fill_spaces+0x8>
  SPDR = byte;                        //send payload
     eec:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     eee:	77 9b       	sbis	0x0e, 7	; 14
     ef0:	fe cf       	rjmp	.-4      	; 0xeee <fill_spaces+0xe>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     ef2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ef6:	88 60       	ori	r24, 0x08	; 8
     ef8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     efc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f00:	87 7f       	andi	r24, 0xF7	; 247
     f02:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f06:	85 ed       	ldi	r24, 0xD5	; 213
     f08:	8a 95       	dec	r24
     f0a:	f1 f7       	brne	.-4      	; 0xf08 <fill_spaces+0x28>
     f0c:	00 00       	nop
     f0e:	91 50       	subi	r25, 0x01	; 1
//                          fill_spaces   
//
//Fill an entire line with spaces.
void fill_spaces(void){
	uint8_t i;
	for (i=0; i<=(NUM_LCD_CHARS-1); i++){
     f10:	51 f7       	brne	.-44     	; 0xee6 <fill_spaces+0x6>
		send_lcd(CHAR_BYTE, ' '); 
                _delay_us(40);  //40us wait between characters
	}
}  
     f12:	08 95       	ret

00000f14 <char2lcd>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     f14:	91 e0       	ldi	r25, 0x01	; 1
     f16:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f18:	77 9b       	sbis	0x0e, 7	; 14
     f1a:	fe cf       	rjmp	.-4      	; 0xf18 <char2lcd+0x4>
  SPDR = byte;                        //send payload
     f1c:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f1e:	77 9b       	sbis	0x0e, 7	; 14
     f20:	fe cf       	rjmp	.-4      	; 0xf1e <char2lcd+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     f22:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f26:	88 60       	ori	r24, 0x08	; 8
     f28:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f2c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f30:	87 7f       	andi	r24, 0xF7	; 247
     f32:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f36:	08 95       	ret

00000f38 <string2lcd>:

//----------------------------------------------------------------------------
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
     f38:	fc 01       	movw	r30, r24
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     f3a:	40 e0       	ldi	r20, 0x00	; 0
     f3c:	50 e0       	ldi	r21, 0x00	; 0
     f3e:	60 e0       	ldi	r22, 0x00	; 0
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     f40:	71 e0       	ldi	r23, 0x01	; 1
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     f42:	df 01       	movw	r26, r30
     f44:	a4 0f       	add	r26, r20
     f46:	b5 1f       	adc	r27, r21
     f48:	8c 91       	ld	r24, X
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     f4a:	7f b9       	out	0x0f, r23	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f4c:	77 9b       	sbis	0x0e, 7	; 14
     f4e:	fe cf       	rjmp	.-4      	; 0xf4c <string2lcd+0x14>
  SPDR = byte;                        //send payload
     f50:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f52:	77 9b       	sbis	0x0e, 7	; 14
     f54:	fe cf       	rjmp	.-4      	; 0xf52 <string2lcd+0x1a>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     f56:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f5a:	98 60       	ori	r25, 0x08	; 8
     f5c:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f60:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f64:	97 7f       	andi	r25, 0xF7	; 247
     f66:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f6a:	85 ed       	ldi	r24, 0xD5	; 213
     f6c:	8a 95       	dec	r24
     f6e:	f1 f7       	brne	.-4      	; 0xf6c <string2lcd+0x34>
     f70:	00 00       	nop
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     f72:	6f 5f       	subi	r22, 0xFF	; 255
     f74:	46 2f       	mov	r20, r22
     f76:	50 e0       	ldi	r21, 0x00	; 0
     f78:	df 01       	movw	r26, r30
     f7a:	0d 90       	ld	r0, X+
     f7c:	00 20       	and	r0, r0
     f7e:	e9 f7       	brne	.-6      	; 0xf7a <string2lcd+0x42>
     f80:	9d 01       	movw	r18, r26
     f82:	2e 1b       	sub	r18, r30
     f84:	3f 0b       	sbc	r19, r31
     f86:	22 50       	subi	r18, 0x02	; 2
     f88:	31 09       	sbc	r19, r1
     f8a:	24 17       	cp	r18, r20
     f8c:	35 07       	cpc	r19, r21
     f8e:	c8 f6       	brcc	.-78     	; 0xf42 <string2lcd+0xa>
  _delay_us(40);  //execution takes 37us per character
  }                  
} 
     f90:	08 95       	ret

00000f92 <lcd_init>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     f92:	8f ef       	ldi	r24, 0xFF	; 255
     f94:	99 ef       	ldi	r25, 0xF9	; 249
     f96:	01 97       	sbiw	r24, 0x01	; 1
     f98:	f1 f7       	brne	.-4      	; 0xf96 <lcd_init+0x4>
     f9a:	00 c0       	rjmp	.+0      	; 0xf9c <lcd_init+0xa>
     f9c:	00 00       	nop
//
void lcd_init(void){
  _delay_ms(16);      //power up delay
#if SPI_MODE==1       //assumption is that the SPI port is intialized
  //TODO: kludge alert! setting of DDRF should not be here, but is probably harmless.
  DDRF=0x08;          //port F bit 3 is enable for LCD in SPI mode
     f9e:	88 e0       	ldi	r24, 0x08	; 8
     fa0:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     fa4:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     fa6:	77 9b       	sbis	0x0e, 7	; 14
     fa8:	fe cf       	rjmp	.-4      	; 0xfa6 <lcd_init+0x14>
  SPDR = byte;                        //send payload
     faa:	80 e3       	ldi	r24, 0x30	; 48
     fac:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     fae:	77 9b       	sbis	0x0e, 7	; 14
     fb0:	fe cf       	rjmp	.-4      	; 0xfae <lcd_init+0x1c>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     fb2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fb6:	88 60       	ori	r24, 0x08	; 8
     fb8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fbc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fc0:	87 7f       	andi	r24, 0xF7	; 247
     fc2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fc6:	8f e5       	ldi	r24, 0x5F	; 95
     fc8:	9d e6       	ldi	r25, 0x6D	; 109
     fca:	01 97       	sbiw	r24, 0x01	; 1
     fcc:	f1 f7       	brne	.-4      	; 0xfca <lcd_init+0x38>
     fce:	00 c0       	rjmp	.+0      	; 0xfd0 <lcd_init+0x3e>
     fd0:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     fd2:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     fd4:	77 9b       	sbis	0x0e, 7	; 14
     fd6:	fe cf       	rjmp	.-4      	; 0xfd4 <lcd_init+0x42>
  SPDR = byte;                        //send payload
     fd8:	80 e3       	ldi	r24, 0x30	; 48
     fda:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     fdc:	77 9b       	sbis	0x0e, 7	; 14
     fde:	fe cf       	rjmp	.-4      	; 0xfdc <lcd_init+0x4a>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     fe0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fe4:	88 60       	ori	r24, 0x08	; 8
     fe6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fea:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fee:	87 7f       	andi	r24, 0xF7	; 247
     ff0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ff4:	8f e5       	ldi	r24, 0x5F	; 95
     ff6:	9d e6       	ldi	r25, 0x6D	; 109
     ff8:	01 97       	sbiw	r24, 0x01	; 1
     ffa:	f1 f7       	brne	.-4      	; 0xff8 <lcd_init+0x66>
     ffc:	00 c0       	rjmp	.+0      	; 0xffe <lcd_init+0x6c>
     ffe:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1000:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1002:	77 9b       	sbis	0x0e, 7	; 14
    1004:	fe cf       	rjmp	.-4      	; 0x1002 <lcd_init+0x70>
  SPDR = byte;                        //send payload
    1006:	80 e3       	ldi	r24, 0x30	; 48
    1008:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    100a:	77 9b       	sbis	0x0e, 7	; 14
    100c:	fe cf       	rjmp	.-4      	; 0x100a <lcd_init+0x78>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    100e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1012:	88 60       	ori	r24, 0x08	; 8
    1014:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1018:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    101c:	87 7f       	andi	r24, 0xF7	; 247
    101e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1022:	8f e5       	ldi	r24, 0x5F	; 95
    1024:	9d e6       	ldi	r25, 0x6D	; 109
    1026:	01 97       	sbiw	r24, 0x01	; 1
    1028:	f1 f7       	brne	.-4      	; 0x1026 <lcd_init+0x94>
    102a:	00 c0       	rjmp	.+0      	; 0x102c <lcd_init+0x9a>
    102c:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    102e:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1030:	77 9b       	sbis	0x0e, 7	; 14
    1032:	fe cf       	rjmp	.-4      	; 0x1030 <lcd_init+0x9e>
  SPDR = byte;                        //send payload
    1034:	88 e3       	ldi	r24, 0x38	; 56
    1036:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1038:	77 9b       	sbis	0x0e, 7	; 14
    103a:	fe cf       	rjmp	.-4      	; 0x1038 <lcd_init+0xa6>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    103c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1040:	88 60       	ori	r24, 0x08	; 8
    1042:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1046:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    104a:	87 7f       	andi	r24, 0xF7	; 247
    104c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1050:	8f e1       	ldi	r24, 0x1F	; 31
    1052:	9e e4       	ldi	r25, 0x4E	; 78
    1054:	01 97       	sbiw	r24, 0x01	; 1
    1056:	f1 f7       	brne	.-4      	; 0x1054 <lcd_init+0xc2>
    1058:	00 c0       	rjmp	.+0      	; 0x105a <lcd_init+0xc8>
    105a:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    105c:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    105e:	77 9b       	sbis	0x0e, 7	; 14
    1060:	fe cf       	rjmp	.-4      	; 0x105e <lcd_init+0xcc>
  SPDR = byte;                        //send payload
    1062:	88 e0       	ldi	r24, 0x08	; 8
    1064:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1066:	77 9b       	sbis	0x0e, 7	; 14
    1068:	fe cf       	rjmp	.-4      	; 0x1066 <lcd_init+0xd4>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    106a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    106e:	88 60       	ori	r24, 0x08	; 8
    1070:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1074:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1078:	87 7f       	andi	r24, 0xF7	; 247
    107a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    107e:	8f e1       	ldi	r24, 0x1F	; 31
    1080:	9e e4       	ldi	r25, 0x4E	; 78
    1082:	01 97       	sbiw	r24, 0x01	; 1
    1084:	f1 f7       	brne	.-4      	; 0x1082 <lcd_init+0xf0>
    1086:	00 c0       	rjmp	.+0      	; 0x1088 <lcd_init+0xf6>
    1088:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    108a:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    108c:	77 9b       	sbis	0x0e, 7	; 14
    108e:	fe cf       	rjmp	.-4      	; 0x108c <lcd_init+0xfa>
  SPDR = byte;                        //send payload
    1090:	81 e0       	ldi	r24, 0x01	; 1
    1092:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1094:	77 9b       	sbis	0x0e, 7	; 14
    1096:	fe cf       	rjmp	.-4      	; 0x1094 <lcd_init+0x102>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    1098:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    109c:	88 60       	ori	r24, 0x08	; 8
    109e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10a2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10a6:	87 7f       	andi	r24, 0xF7	; 247
    10a8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10ac:	8f e1       	ldi	r24, 0x1F	; 31
    10ae:	9e e4       	ldi	r25, 0x4E	; 78
    10b0:	01 97       	sbiw	r24, 0x01	; 1
    10b2:	f1 f7       	brne	.-4      	; 0x10b0 <lcd_init+0x11e>
    10b4:	00 c0       	rjmp	.+0      	; 0x10b6 <lcd_init+0x124>
    10b6:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    10b8:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    10ba:	77 9b       	sbis	0x0e, 7	; 14
    10bc:	fe cf       	rjmp	.-4      	; 0x10ba <lcd_init+0x128>
  SPDR = byte;                        //send payload
    10be:	86 e0       	ldi	r24, 0x06	; 6
    10c0:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    10c2:	77 9b       	sbis	0x0e, 7	; 14
    10c4:	fe cf       	rjmp	.-4      	; 0x10c2 <lcd_init+0x130>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    10c6:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10ca:	88 60       	ori	r24, 0x08	; 8
    10cc:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10d0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10d4:	87 7f       	andi	r24, 0xF7	; 247
    10d6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10da:	8f e1       	ldi	r24, 0x1F	; 31
    10dc:	9e e4       	ldi	r25, 0x4E	; 78
    10de:	01 97       	sbiw	r24, 0x01	; 1
    10e0:	f1 f7       	brne	.-4      	; 0x10de <lcd_init+0x14c>
    10e2:	00 c0       	rjmp	.+0      	; 0x10e4 <lcd_init+0x152>
    10e4:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    10e6:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    10e8:	77 9b       	sbis	0x0e, 7	; 14
    10ea:	fe cf       	rjmp	.-4      	; 0x10e8 <lcd_init+0x156>
  SPDR = byte;                        //send payload
    10ec:	8c e0       	ldi	r24, 0x0C	; 12
    10ee:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    10f0:	77 9b       	sbis	0x0e, 7	; 14
    10f2:	fe cf       	rjmp	.-4      	; 0x10f0 <lcd_init+0x15e>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    10f4:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10f8:	88 60       	ori	r24, 0x08	; 8
    10fa:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10fe:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1102:	87 7f       	andi	r24, 0xF7	; 247
    1104:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1108:	8f e1       	ldi	r24, 0x1F	; 31
    110a:	9e e4       	ldi	r25, 0x4E	; 78
    110c:	01 97       	sbiw	r24, 0x01	; 1
    110e:	f1 f7       	brne	.-4      	; 0x110c <__stack+0xd>
    1110:	00 c0       	rjmp	.+0      	; 0x1112 <__stack+0x13>
    1112:	00 00       	nop
    1114:	08 95       	ret

00001116 <lcd_int32>:
void  lcd_int32(int32_t l,          //number to display
                uint8_t fieldwidth, //width of the field for display
                uint8_t decpos,     //0 if no decimal point, otherwise
                uint8_t bSigned,    //non-zero if the number should be treated as signed 
                uint8_t bZeroFill)  //non-zero if a specified fieldwidth is to be zero filled
{
    1116:	4f 92       	push	r4
    1118:	5f 92       	push	r5
    111a:	6f 92       	push	r6
    111c:	7f 92       	push	r7
    111e:	8f 92       	push	r8
    1120:	9f 92       	push	r9
    1122:	af 92       	push	r10
    1124:	bf 92       	push	r11
    1126:	cf 92       	push	r12
    1128:	df 92       	push	r13
    112a:	ef 92       	push	r14
    112c:	ff 92       	push	r15
    112e:	0f 93       	push	r16
    1130:	1f 93       	push	r17
    1132:	cf 93       	push	r28
    1134:	df 93       	push	r29
    1136:	cd b7       	in	r28, 0x3d	; 61
    1138:	de b7       	in	r29, 0x3e	; 62
    113a:	69 97       	sbiw	r28, 0x19	; 25
    113c:	0f b6       	in	r0, 0x3f	; 63
    113e:	f8 94       	cli
    1140:	de bf       	out	0x3e, r29	; 62
    1142:	0f be       	out	0x3f, r0	; 63
    1144:	cd bf       	out	0x3d, r28	; 61
    1146:	14 2f       	mov	r17, r20
    1148:	42 2e       	mov	r4, r18
    114a:	5e 2c       	mov	r5, r14
      char    fillch;
      ldiv_t  qr;

      qr.quot = l; // initialize the quotient 

      if (bSigned){
    114c:	00 23       	and	r16, r16
    114e:	79 f0       	breq	.+30     	; 0x116e <lcd_int32+0x58>
        bSigned = (qr.quot<0);
    1150:	6b 01       	movw	r12, r22
    1152:	7c 01       	movw	r14, r24
    1154:	cc 24       	eor	r12, r12
    1156:	f7 fc       	sbrc	r15, 7
    1158:	c3 94       	inc	r12
    115a:	dd 24       	eor	r13, r13
    115c:	ee 24       	eor	r14, r14
    115e:	ff 24       	eor	r15, r15
    1160:	0c 2d       	mov	r16, r12
        qr.quot = labs(qr.quot);
    1162:	6b 01       	movw	r12, r22
    1164:	7c 01       	movw	r14, r24
    1166:	97 fd       	sbrc	r25, 7
    1168:	a3 c0       	rjmp	.+326    	; 0x12b0 <lcd_int32+0x19a>
    116a:	c7 01       	movw	r24, r14
    116c:	b6 01       	movw	r22, r12
      }

      // convert the digits to the right of the decimal point 
      if (decpos){
    116e:	44 20       	and	r4, r4
    1170:	09 f4       	brne	.+2      	; 0x1174 <lcd_int32+0x5e>
    1172:	96 c0       	rjmp	.+300    	; 0x12a0 <lcd_int32+0x18a>
    1174:	9e 01       	movw	r18, r28
    1176:	2f 5f       	subi	r18, 0xFF	; 255
    1178:	3f 4f       	sbci	r19, 0xFF	; 255
    117a:	59 01       	movw	r10, r18
    117c:	49 01       	movw	r8, r18
    117e:	66 24       	eor	r6, r6
    1180:	6a 94       	dec	r6
    1182:	64 0c       	add	r6, r4
    1184:	71 2c       	mov	r7, r1
    1186:	3f ef       	ldi	r19, 0xFF	; 255
    1188:	63 1a       	sub	r6, r19
    118a:	73 0a       	sbc	r7, r19
    118c:	6a 0c       	add	r6, r10
    118e:	7b 1c       	adc	r7, r11
        for (; decpos ; decpos--){
          qr = ldiv(qr.quot, 10);
    1190:	2a e0       	ldi	r18, 0x0A	; 10
    1192:	30 e0       	ldi	r19, 0x00	; 0
    1194:	40 e0       	ldi	r20, 0x00	; 0
    1196:	50 e0       	ldi	r21, 0x00	; 0
    1198:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <__divmodsi4>
    119c:	e6 2f       	mov	r30, r22
    119e:	2a 8b       	std	Y+18, r18	; 0x12
    11a0:	3b 8b       	std	Y+19, r19	; 0x13
    11a2:	4c 8b       	std	Y+20, r20	; 0x14
    11a4:	5d 8b       	std	Y+21, r21	; 0x15
    11a6:	6a 89       	ldd	r22, Y+18	; 0x12
    11a8:	7b 89       	ldd	r23, Y+19	; 0x13
    11aa:	8c 89       	ldd	r24, Y+20	; 0x14
    11ac:	9d 89       	ldd	r25, Y+21	; 0x15
          sline[i++] = qr.rem + '0';
    11ae:	20 e3       	ldi	r18, 0x30	; 48
    11b0:	2e 0f       	add	r18, r30
    11b2:	f4 01       	movw	r30, r8
    11b4:	21 93       	st	Z+, r18
    11b6:	4f 01       	movw	r8, r30
        qr.quot = labs(qr.quot);
      }

      // convert the digits to the right of the decimal point 
      if (decpos){
        for (; decpos ; decpos--){
    11b8:	6e 16       	cp	r6, r30
    11ba:	7f 06       	cpc	r7, r31
    11bc:	49 f7       	brne	.-46     	; 0x1190 <lcd_int32+0x7a>
          qr = ldiv(qr.quot, 10);
          sline[i++] = qr.rem + '0';
        }
        sline[i++] = '.';
    11be:	99 24       	eor	r9, r9
    11c0:	93 94       	inc	r9
    11c2:	94 0c       	add	r9, r4
    11c4:	f5 01       	movw	r30, r10
    11c6:	e4 0d       	add	r30, r4
    11c8:	f1 1d       	adc	r31, r1
    11ca:	2e e2       	ldi	r18, 0x2E	; 46
    11cc:	20 83       	st	Z, r18
      }

      // convert the digits to the left of the decimal point 
      do{
          qr = ldiv(qr.quot, 10);
    11ce:	2a e0       	ldi	r18, 0x0A	; 10
    11d0:	30 e0       	ldi	r19, 0x00	; 0
    11d2:	40 e0       	ldi	r20, 0x00	; 0
    11d4:	50 e0       	ldi	r21, 0x00	; 0
    11d6:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <__divmodsi4>
    11da:	e6 2f       	mov	r30, r22
    11dc:	2a 8b       	std	Y+18, r18	; 0x12
    11de:	3b 8b       	std	Y+19, r19	; 0x13
    11e0:	4c 8b       	std	Y+20, r20	; 0x14
    11e2:	5d 8b       	std	Y+21, r21	; 0x15
    11e4:	6e 8b       	std	Y+22, r22	; 0x16
    11e6:	7f 8b       	std	Y+23, r23	; 0x17
    11e8:	88 8f       	std	Y+24, r24	; 0x18
    11ea:	99 8f       	std	Y+25, r25	; 0x19
    11ec:	6a 89       	ldd	r22, Y+18	; 0x12
    11ee:	7b 89       	ldd	r23, Y+19	; 0x13
    11f0:	8c 89       	ldd	r24, Y+20	; 0x14
    11f2:	9d 89       	ldd	r25, Y+21	; 0x15
          sline[i++] = qr.rem + '0';
    11f4:	31 e0       	ldi	r19, 0x01	; 1
    11f6:	39 0d       	add	r19, r9
    11f8:	d5 01       	movw	r26, r10
    11fa:	a9 0d       	add	r26, r9
    11fc:	b1 1d       	adc	r27, r1
    11fe:	e0 5d       	subi	r30, 0xD0	; 208
    1200:	ec 93       	st	X, r30
    1202:	93 2e       	mov	r9, r19
        }while(qr.quot);
    1204:	61 15       	cp	r22, r1
    1206:	71 05       	cpc	r23, r1
    1208:	81 05       	cpc	r24, r1
    120a:	91 05       	cpc	r25, r1
    120c:	01 f7       	brne	.-64     	; 0x11ce <lcd_int32+0xb8>

      // fill the whole field if a width was specified
      if (fieldwidth){
    120e:	11 23       	and	r17, r17
    1210:	61 f0       	breq	.+24     	; 0x122a <lcd_int32+0x114>
        fillch = bZeroFill? '0': ' '; // determine the fill character
    1212:	51 10       	cpse	r5, r1
    1214:	4b c0       	rjmp	.+150    	; 0x12ac <lcd_int32+0x196>
    1216:	90 e2       	ldi	r25, 0x20	; 32
        for (; i<fieldwidth ; ){sline[i++] = fillch;}
    1218:	31 17       	cp	r19, r17
    121a:	38 f4       	brcc	.+14     	; 0x122a <lcd_int32+0x114>
    121c:	f5 01       	movw	r30, r10
    121e:	e3 0f       	add	r30, r19
    1220:	f1 1d       	adc	r31, r1
    1222:	90 83       	st	Z, r25
    1224:	3f 5f       	subi	r19, 0xFF	; 255
    1226:	13 13       	cpse	r17, r19
    1228:	f9 cf       	rjmp	.-14     	; 0x121c <lcd_int32+0x106>
      }

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}
    122a:	00 23       	and	r16, r16
    122c:	31 f0       	breq	.+12     	; 0x123a <lcd_int32+0x124>
    122e:	f5 01       	movw	r30, r10
    1230:	e3 0f       	add	r30, r19
    1232:	f1 1d       	adc	r31, r1
    1234:	9d e2       	ldi	r25, 0x2D	; 45
    1236:	90 83       	st	Z, r25
    1238:	3f 5f       	subi	r19, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    123a:	21 e0       	ldi	r18, 0x01	; 1

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}

      // now output the formatted number
      do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    123c:	31 50       	subi	r19, 0x01	; 1
    123e:	f5 01       	movw	r30, r10
    1240:	e3 0f       	add	r30, r19
    1242:	f1 1d       	adc	r31, r1
    1244:	90 81       	ld	r25, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1246:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1248:	77 9b       	sbis	0x0e, 7	; 14
    124a:	fe cf       	rjmp	.-4      	; 0x1248 <lcd_int32+0x132>
  SPDR = byte;                        //send payload
    124c:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    124e:	77 9b       	sbis	0x0e, 7	; 14
    1250:	fe cf       	rjmp	.-4      	; 0x124e <lcd_int32+0x138>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    1252:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1256:	98 60       	ori	r25, 0x08	; 8
    1258:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    125c:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1260:	97 7f       	andi	r25, 0xF7	; 247
    1262:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1266:	85 ed       	ldi	r24, 0xD5	; 213
    1268:	8a 95       	dec	r24
    126a:	f1 f7       	brne	.-4      	; 0x1268 <lcd_int32+0x152>
    126c:	00 00       	nop

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}

      // now output the formatted number
      do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    126e:	31 11       	cpse	r19, r1
    1270:	e5 cf       	rjmp	.-54     	; 0x123c <lcd_int32+0x126>

}
    1272:	69 96       	adiw	r28, 0x19	; 25
    1274:	0f b6       	in	r0, 0x3f	; 63
    1276:	f8 94       	cli
    1278:	de bf       	out	0x3e, r29	; 62
    127a:	0f be       	out	0x3f, r0	; 63
    127c:	cd bf       	out	0x3d, r28	; 61
    127e:	df 91       	pop	r29
    1280:	cf 91       	pop	r28
    1282:	1f 91       	pop	r17
    1284:	0f 91       	pop	r16
    1286:	ff 90       	pop	r15
    1288:	ef 90       	pop	r14
    128a:	df 90       	pop	r13
    128c:	cf 90       	pop	r12
    128e:	bf 90       	pop	r11
    1290:	af 90       	pop	r10
    1292:	9f 90       	pop	r9
    1294:	8f 90       	pop	r8
    1296:	7f 90       	pop	r7
    1298:	6f 90       	pop	r6
    129a:	5f 90       	pop	r5
    129c:	4f 90       	pop	r4
    129e:	08 95       	ret
                uint8_t decpos,     //0 if no decimal point, otherwise
                uint8_t bSigned,    //non-zero if the number should be treated as signed 
                uint8_t bZeroFill)  //non-zero if a specified fieldwidth is to be zero filled
{
      char    sline[NUM_LCD_CHARS+1];
      uint8_t i=0;
    12a0:	91 2c       	mov	r9, r1
    12a2:	9e 01       	movw	r18, r28
    12a4:	2f 5f       	subi	r18, 0xFF	; 255
    12a6:	3f 4f       	sbci	r19, 0xFF	; 255
    12a8:	59 01       	movw	r10, r18
    12aa:	91 cf       	rjmp	.-222    	; 0x11ce <lcd_int32+0xb8>
          sline[i++] = qr.rem + '0';
        }while(qr.quot);

      // fill the whole field if a width was specified
      if (fieldwidth){
        fillch = bZeroFill? '0': ' '; // determine the fill character
    12ac:	90 e3       	ldi	r25, 0x30	; 48
    12ae:	b4 cf       	rjmp	.-152    	; 0x1218 <lcd_int32+0x102>

      qr.quot = l; // initialize the quotient 

      if (bSigned){
        bSigned = (qr.quot<0);
        qr.quot = labs(qr.quot);
    12b0:	f0 94       	com	r15
    12b2:	e0 94       	com	r14
    12b4:	d0 94       	com	r13
    12b6:	c0 94       	com	r12
    12b8:	c1 1c       	adc	r12, r1
    12ba:	d1 1c       	adc	r13, r1
    12bc:	e1 1c       	adc	r14, r1
    12be:	f1 1c       	adc	r15, r1
    12c0:	54 cf       	rjmp	.-344    	; 0x116a <lcd_int32+0x54>

000012c2 <lcd_int16>:
void    lcd_int16(int16_t l, 
                  uint8_t fieldwidth, 
                  uint8_t decpos, 
                  uint8_t bSigned,
                  uint8_t bZeroFill)
{
    12c2:	5f 92       	push	r5
    12c4:	6f 92       	push	r6
    12c6:	7f 92       	push	r7
    12c8:	8f 92       	push	r8
    12ca:	9f 92       	push	r9
    12cc:	af 92       	push	r10
    12ce:	bf 92       	push	r11
    12d0:	cf 92       	push	r12
    12d2:	df 92       	push	r13
    12d4:	ef 92       	push	r14
    12d6:	ff 92       	push	r15
    12d8:	0f 93       	push	r16
    12da:	1f 93       	push	r17
    12dc:	cf 93       	push	r28
    12de:	df 93       	push	r29
    12e0:	cd b7       	in	r28, 0x3d	; 61
    12e2:	de b7       	in	r29, 0x3e	; 62
    12e4:	61 97       	sbiw	r28, 0x11	; 17
    12e6:	0f b6       	in	r0, 0x3f	; 63
    12e8:	f8 94       	cli
    12ea:	de bf       	out	0x3e, r29	; 62
    12ec:	0f be       	out	0x3f, r0	; 63
    12ee:	cd bf       	out	0x3d, r28	; 61
    12f0:	5c 01       	movw	r10, r24
    12f2:	16 2f       	mov	r17, r22
    12f4:	74 2e       	mov	r7, r20
//        uint8_t bSigned;   Now an argument for signed or not

        // initialize the quotient 
        qr.quot = l;

        if ( (bSigned=(qr.quot<0)) )
    12f6:	6b 2c       	mov	r6, r11
    12f8:	66 1c       	adc	r6, r6
    12fa:	66 24       	eor	r6, r6
    12fc:	66 1c       	adc	r6, r6
    12fe:	56 2c       	mov	r5, r6
    1300:	9c 01       	movw	r18, r24
    1302:	97 fd       	sbrc	r25, 7
    1304:	9b c0       	rjmp	.+310    	; 0x143c <lcd_int16+0x17a>
                qr.quot = -qr.quot;

        // convert the digits to the right of the decimal point 
        if (decpos){
    1306:	77 20       	and	r7, r7
    1308:	09 f4       	brne	.+2      	; 0x130c <lcd_int16+0x4a>
    130a:	8d c0       	rjmp	.+282    	; 0x1426 <lcd_int16+0x164>
    130c:	ce 01       	movw	r24, r28
    130e:	01 96       	adiw	r24, 0x01	; 1
    1310:	7c 01       	movw	r14, r24
    1312:	6c 01       	movw	r12, r24
    1314:	88 24       	eor	r8, r8
    1316:	8a 94       	dec	r8
    1318:	87 0c       	add	r8, r7
    131a:	91 2c       	mov	r9, r1
    131c:	9f ef       	ldi	r25, 0xFF	; 255
    131e:	89 1a       	sub	r8, r25
    1320:	99 0a       	sbc	r9, r25
    1322:	8e 0c       	add	r8, r14
    1324:	9f 1c       	adc	r9, r15
          for (; decpos ; decpos--){
            qr = div(qr.quot, 10);
    1326:	6a e0       	ldi	r22, 0x0A	; 10
    1328:	70 e0       	ldi	r23, 0x00	; 0
    132a:	c9 01       	movw	r24, r18
    132c:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <__divmodhi4>
    1330:	46 2f       	mov	r20, r22
    1332:	24 2f       	mov	r18, r20
    1334:	37 2f       	mov	r19, r23
            sline[i++] = qr.rem + '0';
    1336:	80 5d       	subi	r24, 0xD0	; 208
    1338:	f6 01       	movw	r30, r12
    133a:	81 93       	st	Z+, r24
    133c:	6f 01       	movw	r12, r30
        if ( (bSigned=(qr.quot<0)) )
                qr.quot = -qr.quot;

        // convert the digits to the right of the decimal point 
        if (decpos){
          for (; decpos ; decpos--){
    133e:	e8 15       	cp	r30, r8
    1340:	f9 05       	cpc	r31, r9
    1342:	89 f7       	brne	.-30     	; 0x1326 <lcd_int16+0x64>
            qr = div(qr.quot, 10);
            sline[i++] = qr.rem + '0';
          }
          sline[i++] = '.';
    1344:	dd 24       	eor	r13, r13
    1346:	d3 94       	inc	r13
    1348:	d7 0c       	add	r13, r7
    134a:	f7 01       	movw	r30, r14
    134c:	e7 0d       	add	r30, r7
    134e:	f1 1d       	adc	r31, r1
    1350:	8e e2       	ldi	r24, 0x2E	; 46
    1352:	80 83       	st	Z, r24
    1354:	01 c0       	rjmp	.+2      	; 0x1358 <lcd_int16+0x96>

        // convert the digits to the left of the decimal point 
        do
        {
                qr = div(qr.quot, 10);
                sline[i++] = qr.rem + '0';
    1356:	d9 2e       	mov	r13, r25
        }

        // convert the digits to the left of the decimal point 
        do
        {
                qr = div(qr.quot, 10);
    1358:	6a e0       	ldi	r22, 0x0A	; 10
    135a:	70 e0       	ldi	r23, 0x00	; 0
    135c:	c9 01       	movw	r24, r18
    135e:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <__divmodhi4>
    1362:	46 2f       	mov	r20, r22
    1364:	24 2f       	mov	r18, r20
    1366:	37 2f       	mov	r19, r23
                sline[i++] = qr.rem + '0';
    1368:	91 e0       	ldi	r25, 0x01	; 1
    136a:	9d 0d       	add	r25, r13
    136c:	f7 01       	movw	r30, r14
    136e:	ed 0d       	add	r30, r13
    1370:	f1 1d       	adc	r31, r1
    1372:	80 5d       	subi	r24, 0xD0	; 208
    1374:	80 83       	st	Z, r24
        }
        while(qr.quot);
    1376:	21 15       	cp	r18, r1
    1378:	31 05       	cpc	r19, r1
    137a:	69 f7       	brne	.-38     	; 0x1356 <lcd_int16+0x94>

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
    137c:	01 11       	cpse	r16, r1
    137e:	58 c0       	rjmp	.+176    	; 0x1430 <lcd_int16+0x16e>
    1380:	b7 fc       	sbrc	r11, 7
    1382:	61 c0       	rjmp	.+194    	; 0x1446 <lcd_int16+0x184>
                sline[i++] = '-';
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    1384:	11 23       	and	r17, r17
    1386:	a9 f0       	breq	.+42     	; 0x13b2 <lcd_int16+0xf0>
    1388:	71 2c       	mov	r7, r1
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    138a:	80 e2       	ldi	r24, 0x20	; 32
          for (; i<(fieldwidth-bSigned) ; ){ sline[i++] = fillch;}
    138c:	29 2f       	mov	r18, r25
    138e:	30 e0       	ldi	r19, 0x00	; 0
    1390:	41 2f       	mov	r20, r17
    1392:	50 e0       	ldi	r21, 0x00	; 0
    1394:	46 19       	sub	r20, r6
    1396:	57 09       	sbc	r21, r7
    1398:	24 17       	cp	r18, r20
    139a:	35 07       	cpc	r19, r21
    139c:	54 f4       	brge	.+20     	; 0x13b2 <lcd_int16+0xf0>
    139e:	9f 5f       	subi	r25, 0xFF	; 255
    13a0:	f7 01       	movw	r30, r14
    13a2:	e2 0f       	add	r30, r18
    13a4:	f3 1f       	adc	r31, r19
    13a6:	80 83       	st	Z, r24
    13a8:	29 2f       	mov	r18, r25
    13aa:	30 e0       	ldi	r19, 0x00	; 0
    13ac:	24 17       	cp	r18, r20
    13ae:	35 07       	cpc	r19, r21
    13b0:	b4 f3       	brlt	.-20     	; 0x139e <lcd_int16+0xdc>
        }

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}
    13b2:	55 20       	and	r5, r5
    13b4:	31 f0       	breq	.+12     	; 0x13c2 <lcd_int16+0x100>
    13b6:	f7 01       	movw	r30, r14
    13b8:	e9 0f       	add	r30, r25
    13ba:	f1 1d       	adc	r31, r1
    13bc:	8d e2       	ldi	r24, 0x2D	; 45
    13be:	80 83       	st	Z, r24
    13c0:	9f 5f       	subi	r25, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    13c2:	21 e0       	ldi	r18, 0x01	; 1

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}

        // now output the formatted number 
            do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    13c4:	91 50       	subi	r25, 0x01	; 1
    13c6:	f7 01       	movw	r30, r14
    13c8:	e9 0f       	add	r30, r25
    13ca:	f1 1d       	adc	r31, r1
    13cc:	80 81       	ld	r24, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    13ce:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    13d0:	77 9b       	sbis	0x0e, 7	; 14
    13d2:	fe cf       	rjmp	.-4      	; 0x13d0 <lcd_int16+0x10e>
  SPDR = byte;                        //send payload
    13d4:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    13d6:	77 9b       	sbis	0x0e, 7	; 14
    13d8:	fe cf       	rjmp	.-4      	; 0x13d6 <lcd_int16+0x114>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    13da:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    13de:	88 60       	ori	r24, 0x08	; 8
    13e0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    13e4:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    13e8:	87 7f       	andi	r24, 0xF7	; 247
    13ea:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    13ee:	e5 ed       	ldi	r30, 0xD5	; 213
    13f0:	ea 95       	dec	r30
    13f2:	f1 f7       	brne	.-4      	; 0x13f0 <lcd_int16+0x12e>
    13f4:	00 00       	nop

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}

        // now output the formatted number 
            do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    13f6:	91 11       	cpse	r25, r1
    13f8:	e5 cf       	rjmp	.-54     	; 0x13c4 <lcd_int16+0x102>
}
    13fa:	61 96       	adiw	r28, 0x11	; 17
    13fc:	0f b6       	in	r0, 0x3f	; 63
    13fe:	f8 94       	cli
    1400:	de bf       	out	0x3e, r29	; 62
    1402:	0f be       	out	0x3f, r0	; 63
    1404:	cd bf       	out	0x3d, r28	; 61
    1406:	df 91       	pop	r29
    1408:	cf 91       	pop	r28
    140a:	1f 91       	pop	r17
    140c:	0f 91       	pop	r16
    140e:	ff 90       	pop	r15
    1410:	ef 90       	pop	r14
    1412:	df 90       	pop	r13
    1414:	cf 90       	pop	r12
    1416:	bf 90       	pop	r11
    1418:	af 90       	pop	r10
    141a:	9f 90       	pop	r9
    141c:	8f 90       	pop	r8
    141e:	7f 90       	pop	r7
    1420:	6f 90       	pop	r6
    1422:	5f 90       	pop	r5
    1424:	08 95       	ret
                  uint8_t decpos, 
                  uint8_t bSigned,
                  uint8_t bZeroFill)
{
        char    sline[NUM_LCD_CHARS+1];
        uint8_t i=0;
    1426:	d1 2c       	mov	r13, r1
    1428:	ce 01       	movw	r24, r28
    142a:	01 96       	adiw	r24, 0x01	; 1
    142c:	7c 01       	movw	r14, r24
    142e:	94 cf       	rjmp	.-216    	; 0x1358 <lcd_int16+0x96>
                sline[i++] = '-';
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    1430:	11 23       	and	r17, r17
    1432:	09 f4       	brne	.+2      	; 0x1436 <lcd_int16+0x174>
    1434:	be cf       	rjmp	.-132    	; 0x13b2 <lcd_int16+0xf0>
    1436:	71 2c       	mov	r7, r1
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    1438:	80 e3       	ldi	r24, 0x30	; 48
    143a:	a8 cf       	rjmp	.-176    	; 0x138c <lcd_int16+0xca>
    143c:	22 27       	eor	r18, r18
    143e:	33 27       	eor	r19, r19
    1440:	28 1b       	sub	r18, r24
    1442:	39 0b       	sbc	r19, r25
    1444:	60 cf       	rjmp	.-320    	; 0x1306 <lcd_int16+0x44>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    1446:	d3 94       	inc	r13
    1448:	d3 94       	inc	r13
    144a:	f7 01       	movw	r30, r14
    144c:	e9 0f       	add	r30, r25
    144e:	f1 1d       	adc	r31, r1
    1450:	8d e2       	ldi	r24, 0x2D	; 45
    1452:	80 83       	st	Z, r24
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    1454:	11 23       	and	r17, r17
    1456:	59 f0       	breq	.+22     	; 0x146e <lcd_int16+0x1ac>
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
          for (; i<(fieldwidth-bSigned) ; ){ sline[i++] = fillch;}
    1458:	2d 2d       	mov	r18, r13
    145a:	30 e0       	ldi	r19, 0x00	; 0
    145c:	41 2f       	mov	r20, r17
    145e:	50 e0       	ldi	r21, 0x00	; 0
    1460:	24 17       	cp	r18, r20
    1462:	35 07       	cpc	r19, r21
    1464:	24 f4       	brge	.+8      	; 0x146e <lcd_int16+0x1ac>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    1466:	9d 2d       	mov	r25, r13
                bSigned = 0;
    1468:	51 2c       	mov	r5, r1
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    146a:	80 e2       	ldi	r24, 0x20	; 32
    146c:	98 cf       	rjmp	.-208    	; 0x139e <lcd_int16+0xdc>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    146e:	9d 2d       	mov	r25, r13
    1470:	a8 cf       	rjmp	.-176    	; 0x13c2 <lcd_int16+0x100>

00001472 <__vector_33>:

//****************************************************************************
//This is the TWI ISR. Different actions are taken depending upon the value
//of the TWI status register TWSR.
//****************************************************************************/
ISR(TWI_vect){
    1472:	1f 92       	push	r1
    1474:	0f 92       	push	r0
    1476:	0f b6       	in	r0, 0x3f	; 63
    1478:	0f 92       	push	r0
    147a:	11 24       	eor	r1, r1
    147c:	0b b6       	in	r0, 0x3b	; 59
    147e:	0f 92       	push	r0
    1480:	2f 93       	push	r18
    1482:	3f 93       	push	r19
    1484:	8f 93       	push	r24
    1486:	9f 93       	push	r25
    1488:	af 93       	push	r26
    148a:	bf 93       	push	r27
    148c:	ef 93       	push	r30
    148e:	ff 93       	push	r31
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    1490:	e0 91 71 00 	lds	r30, 0x0071	; 0x800071 <__TEXT_REGION_LENGTH__+0x7e0071>
    1494:	8e 2f       	mov	r24, r30
    1496:	90 e0       	ldi	r25, 0x00	; 0
    1498:	fc 01       	movw	r30, r24
    149a:	38 97       	sbiw	r30, 0x08	; 8
    149c:	e1 35       	cpi	r30, 0x51	; 81
    149e:	f1 05       	cpc	r31, r1
    14a0:	b0 f0       	brcs	.+44     	; 0x14ce <__vector_33+0x5c>
      break;      
    case TW_MT_ARB_LOST:                //Arbitration lost 
      TWCR = TWCR_START;                //initiate RESTART 
      break;
    default:                            //Error occured, save TWSR 
      twi_state = TWSR;         
    14a2:	80 91 71 00 	lds	r24, 0x0071	; 0x800071 <__TEXT_REGION_LENGTH__+0x7e0071>
    14a6:	80 93 db 01 	sts	0x01DB, r24	; 0x8001db <twi_state>
      TWCR = TWCR_RST;                  //Reset TWI, disable interupts 
    14aa:	84 e0       	ldi	r24, 0x04	; 4
    14ac:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
  }//switch
}//TWI_isr
    14b0:	ff 91       	pop	r31
    14b2:	ef 91       	pop	r30
    14b4:	bf 91       	pop	r27
    14b6:	af 91       	pop	r26
    14b8:	9f 91       	pop	r25
    14ba:	8f 91       	pop	r24
    14bc:	3f 91       	pop	r19
    14be:	2f 91       	pop	r18
    14c0:	0f 90       	pop	r0
    14c2:	0b be       	out	0x3b, r0	; 59
    14c4:	0f 90       	pop	r0
    14c6:	0f be       	out	0x3f, r0	; 63
    14c8:	0f 90       	pop	r0
    14ca:	1f 90       	pop	r1
    14cc:	18 95       	reti
//of the TWI status register TWSR.
//****************************************************************************/
ISR(TWI_vect){
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    14ce:	ea 5b       	subi	r30, 0xBA	; 186
    14d0:	ff 4f       	sbci	r31, 0xFF	; 255
    14d2:	0c 94 1a 0c 	jmp	0x1834	; 0x1834 <__tablejump2__>
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
      else                               {TWCR = TWCR_RNACK;} //NACK last byte 
      break; 
    case TW_MR_DATA_NACK: //Data byte was rcvd and NACK xmitted
      twi_buf[twi_buf_ptr] = TWDR;      //save last byte to buffer
    14d6:	80 91 71 01 	lds	r24, 0x0171	; 0x800171 <twi_buf_ptr.1780>
    14da:	e0 91 dc 01 	lds	r30, 0x01DC	; 0x8001dc <twi_buf>
    14de:	f0 91 dd 01 	lds	r31, 0x01DD	; 0x8001dd <twi_buf+0x1>
    14e2:	e8 0f       	add	r30, r24
    14e4:	f1 1d       	adc	r31, r1
    14e6:	80 91 73 00 	lds	r24, 0x0073	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
    14ea:	80 83       	st	Z, r24
      TWCR = TWCR_STOP;                 //initiate a STOP
    14ec:	84 e9       	ldi	r24, 0x94	; 148
    14ee:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
      break;      
    14f2:	de cf       	rjmp	.-68     	; 0x14b0 <__vector_33+0x3e>
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    case TW_START:          //START has been xmitted, fall thorough
    case TW_REP_START:      //Repeated START was xmitted
      TWDR = twi_bus_addr;  //load up the twi bus address
    14f4:	80 91 de 01 	lds	r24, 0x01DE	; 0x8001de <twi_bus_addr>
    14f8:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
      twi_buf_ptr = 0;      //initalize buffer pointer 
    14fc:	10 92 71 01 	sts	0x0171, r1	; 0x800171 <twi_buf_ptr.1780>
      TWCR = TWCR_SEND;     //send SLA+RW
    1500:	85 e8       	ldi	r24, 0x85	; 133
    1502:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
      break;
    1506:	d4 cf       	rjmp	.-88     	; 0x14b0 <__vector_33+0x3e>
    case TW_MT_SLA_ACK:     //SLA+W was xmitted and ACK rcvd, fall through 
    case TW_MT_DATA_ACK:                //Data byte was xmitted and ACK rcvd
      if (twi_buf_ptr < twi_msg_size){  //send data till done
    1508:	80 91 71 01 	lds	r24, 0x0171	; 0x800171 <twi_buf_ptr.1780>
    150c:	90 91 df 01 	lds	r25, 0x01DF	; 0x8001df <twi_msg_size>
    1510:	89 17       	cp	r24, r25
    1512:	60 f7       	brcc	.-40     	; 0x14ec <__vector_33+0x7a>
        TWDR = twi_buf[twi_buf_ptr++];  //load next and postincrement index
    1514:	e0 91 dc 01 	lds	r30, 0x01DC	; 0x8001dc <twi_buf>
    1518:	f0 91 dd 01 	lds	r31, 0x01DD	; 0x8001dd <twi_buf+0x1>
    151c:	91 e0       	ldi	r25, 0x01	; 1
    151e:	98 0f       	add	r25, r24
    1520:	90 93 71 01 	sts	0x0171, r25	; 0x800171 <twi_buf_ptr.1780>
    1524:	e8 0f       	add	r30, r24
    1526:	f1 1d       	adc	r31, r1
    1528:	80 81       	ld	r24, Z
    152a:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
        TWCR = TWCR_SEND;               //send next byte 
    152e:	85 e8       	ldi	r24, 0x85	; 133
    1530:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
    1534:	bd cf       	rjmp	.-134    	; 0x14b0 <__vector_33+0x3e>
    case TW_MR_DATA_NACK: //Data byte was rcvd and NACK xmitted
      twi_buf[twi_buf_ptr] = TWDR;      //save last byte to buffer
      TWCR = TWCR_STOP;                 //initiate a STOP
      break;      
    case TW_MT_ARB_LOST:                //Arbitration lost 
      TWCR = TWCR_START;                //initiate RESTART 
    1536:	85 ea       	ldi	r24, 0xA5	; 165
    1538:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
      break;
    153c:	b9 cf       	rjmp	.-142    	; 0x14b0 <__vector_33+0x3e>
    153e:	20 91 71 01 	lds	r18, 0x0171	; 0x800171 <twi_buf_ptr.1780>
      else{TWCR = TWCR_STOP;}           //last byte sent, send STOP 
      break;
    case TW_MR_DATA_ACK:                //Data byte has been rcvd, ACK xmitted, fall through
      twi_buf[twi_buf_ptr++] = TWDR;    //fill buffer with rcvd data
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
    1542:	80 91 df 01 	lds	r24, 0x01DF	; 0x8001df <twi_msg_size>
    1546:	30 e0       	ldi	r19, 0x00	; 0
    1548:	90 e0       	ldi	r25, 0x00	; 0
    154a:	01 97       	sbiw	r24, 0x01	; 1
    154c:	28 17       	cp	r18, r24
    154e:	39 07       	cpc	r19, r25
    1550:	dc f4       	brge	.+54     	; 0x1588 <__vector_33+0x116>
    1552:	85 ec       	ldi	r24, 0xC5	; 197
    1554:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
    1558:	ab cf       	rjmp	.-170    	; 0x14b0 <__vector_33+0x3e>
        TWCR = TWCR_SEND;               //send next byte 
      }
      else{TWCR = TWCR_STOP;}           //last byte sent, send STOP 
      break;
    case TW_MR_DATA_ACK:                //Data byte has been rcvd, ACK xmitted, fall through
      twi_buf[twi_buf_ptr++] = TWDR;    //fill buffer with rcvd data
    155a:	e0 91 dc 01 	lds	r30, 0x01DC	; 0x8001dc <twi_buf>
    155e:	f0 91 dd 01 	lds	r31, 0x01DD	; 0x8001dd <twi_buf+0x1>
    1562:	80 91 71 01 	lds	r24, 0x0171	; 0x800171 <twi_buf_ptr.1780>
    1566:	21 e0       	ldi	r18, 0x01	; 1
    1568:	28 0f       	add	r18, r24
    156a:	20 93 71 01 	sts	0x0171, r18	; 0x800171 <twi_buf_ptr.1780>
    156e:	e8 0f       	add	r30, r24
    1570:	f1 1d       	adc	r31, r1
    1572:	80 91 73 00 	lds	r24, 0x0073	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
    1576:	80 83       	st	Z, r24
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
    1578:	80 91 df 01 	lds	r24, 0x01DF	; 0x8001df <twi_msg_size>
    157c:	30 e0       	ldi	r19, 0x00	; 0
    157e:	90 e0       	ldi	r25, 0x00	; 0
    1580:	01 97       	sbiw	r24, 0x01	; 1
    1582:	28 17       	cp	r18, r24
    1584:	39 07       	cpc	r19, r25
    1586:	2c f3       	brlt	.-54     	; 0x1552 <__vector_33+0xe0>
      else                               {TWCR = TWCR_RNACK;} //NACK last byte 
    1588:	85 e8       	ldi	r24, 0x85	; 133
    158a:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
    158e:	90 cf       	rjmp	.-224    	; 0x14b0 <__vector_33+0x3e>

00001590 <twi_busy>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    1590:	80 91 74 00 	lds	r24, 0x0074	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
}
    1594:	81 70       	andi	r24, 0x01	; 1
    1596:	08 95       	ret

00001598 <twi_start_wr>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    1598:	90 91 74 00 	lds	r25, 0x0074	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
//Initiates a write transfer. Loads global variables. Sends START. ISR handles
//the rest.
//****************************************************************************
void twi_start_wr(uint8_t twi_addr, uint8_t *twi_data, uint8_t byte_cnt){

  while(twi_busy());                    //wait till TWI rdy for next xfer
    159c:	90 fd       	sbrc	r25, 0
    159e:	fc cf       	rjmp	.-8      	; 0x1598 <twi_start_wr>
  twi_bus_addr = (twi_addr & ~TW_READ); //set twi bus address, mark as write 
    15a0:	8e 7f       	andi	r24, 0xFE	; 254
    15a2:	80 93 de 01 	sts	0x01DE, r24	; 0x8001de <twi_bus_addr>
  twi_buf = twi_data;                   //load pointer to write buffer
    15a6:	70 93 dd 01 	sts	0x01DD, r23	; 0x8001dd <twi_buf+0x1>
    15aa:	60 93 dc 01 	sts	0x01DC, r22	; 0x8001dc <twi_buf>
  twi_msg_size = byte_cnt;              //load size of xfer 
    15ae:	40 93 df 01 	sts	0x01DF, r20	; 0x8001df <twi_msg_size>
  TWCR = TWCR_START;                    //initiate START
    15b2:	85 ea       	ldi	r24, 0xA5	; 165
    15b4:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
    15b8:	08 95       	ret

000015ba <twi_start_rd>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    15ba:	90 91 74 00 	lds	r25, 0x0074	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
//Initiates a read transfer. Loads global variables. Sends START. ISR handles
//the rest.
//****************************************************************************
void twi_start_rd(uint8_t twi_addr, uint8_t *twi_data, uint8_t byte_cnt){

  while(twi_busy());                   //wait till TWI rdy for next xfer
    15be:	90 fd       	sbrc	r25, 0
    15c0:	fc cf       	rjmp	.-8      	; 0x15ba <twi_start_rd>
  twi_bus_addr = (twi_addr | TW_READ); //set twi bus address, mark as read  
    15c2:	81 60       	ori	r24, 0x01	; 1
    15c4:	80 93 de 01 	sts	0x01DE, r24	; 0x8001de <twi_bus_addr>
  twi_buf = twi_data;                  //load pointer to write buffer
    15c8:	70 93 dd 01 	sts	0x01DD, r23	; 0x8001dd <twi_buf+0x1>
    15cc:	60 93 dc 01 	sts	0x01DC, r22	; 0x8001dc <twi_buf>
  twi_msg_size = byte_cnt;             //load size of xfer 
    15d0:	40 93 df 01 	sts	0x01DF, r20	; 0x8001df <twi_msg_size>
  TWCR = TWCR_START;                   //initiate START
    15d4:	85 ea       	ldi	r24, 0xA5	; 165
    15d6:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
    15da:	08 95       	ret

000015dc <init_twi>:
//10K pullups are present on the board
//for alarm clock an additional 4.7K resistor is also there for pullup
//******************************************************************************

void init_twi(){
  TWDR = 0xFF;     //release SDA, default contents
    15dc:	8f ef       	ldi	r24, 0xFF	; 255
    15de:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
  TWSR = 0x00;     //prescaler value = 1
    15e2:	10 92 71 00 	sts	0x0071, r1	; 0x800071 <__TEXT_REGION_LENGTH__+0x7e0071>
  TWBR = TWI_TWBR; //defined in twi_master.h 
    15e6:	8c e0       	ldi	r24, 0x0C	; 12
    15e8:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x7e0070>
    15ec:	08 95       	ret

000015ee <lm73_temp_convert>:
   else{ //deg C

   }
//Yeah, this is for you to do! ;^)
return 0b11111111;
}//lm73_temp_convert
    15ee:	8f ef       	ldi	r24, 0xFF	; 255
    15f0:	08 95       	ret

000015f2 <uart_putc>:
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    15f2:	5d 9b       	sbis	0x0b, 5	; 11
    15f4:	fe cf       	rjmp	.-4      	; 0x15f2 <uart_putc>
    UDR0 = data;    // Send data byte
    15f6:	8c b9       	out	0x0c, r24	; 12
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    15f8:	5d 9b       	sbis	0x0b, 5	; 11
    15fa:	fe cf       	rjmp	.-4      	; 0x15f8 <uart_putc+0x6>
}
    15fc:	08 95       	ret

000015fe <uart_puts>:

//******************************************************************
//                        uart_puts
// Takes a string and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts(char *str) {
    15fe:	fc 01       	movw	r30, r24
    int i = 0;
    while(str[i] != '\0') { // Loop through string, sending each character
    1600:	90 81       	ld	r25, Z
    1602:	99 23       	and	r25, r25
    1604:	49 f0       	breq	.+18     	; 0x1618 <uart_puts+0x1a>
    1606:	31 96       	adiw	r30, 0x01	; 1
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    1608:	5d 9b       	sbis	0x0b, 5	; 11
    160a:	fe cf       	rjmp	.-4      	; 0x1608 <uart_puts+0xa>
    UDR0 = data;    // Send data byte
    160c:	9c b9       	out	0x0c, r25	; 12
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    160e:	5d 9b       	sbis	0x0b, 5	; 11
    1610:	fe cf       	rjmp	.-4      	; 0x160e <uart_puts+0x10>
//                        uart_puts
// Takes a string and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts(char *str) {
    int i = 0;
    while(str[i] != '\0') { // Loop through string, sending each character
    1612:	91 91       	ld	r25, Z+
    1614:	91 11       	cpse	r25, r1
    1616:	f8 cf       	rjmp	.-16     	; 0x1608 <uart_puts+0xa>
    1618:	08 95       	ret

0000161a <uart_puts_p>:
//******************************************************************
//                        uart_puts_p
// Takes a string in flash memory and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts_p(const char *str) {
    while(pgm_read_byte(str) != 0x00) { // Loop through string, sending each character
    161a:	9c 01       	movw	r18, r24
    161c:	fc 01       	movw	r30, r24
    161e:	44 91       	lpm	r20, Z
    1620:	44 23       	and	r20, r20
    1622:	69 f0       	breq	.+26     	; 0x163e <uart_puts_p+0x24>
        uart_putc(pgm_read_byte(str++));
    1624:	01 96       	adiw	r24, 0x01	; 1
    1626:	f9 01       	movw	r30, r18
    1628:	24 91       	lpm	r18, Z
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    162a:	5d 9b       	sbis	0x0b, 5	; 11
    162c:	fe cf       	rjmp	.-4      	; 0x162a <uart_puts_p+0x10>
    UDR0 = data;    // Send data byte
    162e:	2c b9       	out	0x0c, r18	; 12
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    1630:	5d 9b       	sbis	0x0b, 5	; 11
    1632:	fe cf       	rjmp	.-4      	; 0x1630 <uart_puts_p+0x16>
//******************************************************************
//                        uart_puts_p
// Takes a string in flash memory and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts_p(const char *str) {
    while(pgm_read_byte(str) != 0x00) { // Loop through string, sending each character
    1634:	9c 01       	movw	r18, r24
    1636:	fc 01       	movw	r30, r24
    1638:	44 91       	lpm	r20, Z
    163a:	41 11       	cpse	r20, r1
    163c:	f3 cf       	rjmp	.-26     	; 0x1624 <uart_puts_p+0xa>
        uart_putc(pgm_read_byte(str++));
    }
}
    163e:	08 95       	ret

00001640 <uart_init>:
//must be in place for the MAX232 chip to get data.

void uart_init(){
//rx and tx enable, receive interrupt enabled, 8 bit characters
//  UCSR0B |= (1<<RXEN0) | (1<<TXEN0) | (1<<RXCIE0);
  UCSR0B |= (1<<RXEN0) | (1<<TXEN0);  //INTERRUPS DISABLED!!!
    1640:	8a b1       	in	r24, 0x0a	; 10
    1642:	88 61       	ori	r24, 0x18	; 24
    1644:	8a b9       	out	0x0a, r24	; 10

//  UCSR0B |= (1<<RXEN0) | (1<<TXEN0) ;
//async operation, no parity,  one stop bit, 8-bit characters
UCSR0C |= (1<<UCSZ01) | (1<<UCSZ00);
    1646:	e5 e9       	ldi	r30, 0x95	; 149
    1648:	f0 e0       	ldi	r31, 0x00	; 0
    164a:	80 81       	ld	r24, Z
    164c:	86 60       	ori	r24, 0x06	; 6
    164e:	80 83       	st	Z, r24
UBRR0H = (BAUDVALUE >>8 ); //load upper byte of the baud rate into UBRR 
    1650:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
UBRR0L =  BAUDVALUE;       //load lower byte of the baud rate into UBRR 
    1654:	80 e1       	ldi	r24, 0x10	; 16
    1656:	89 b9       	out	0x09, r24	; 9
    1658:	08 95       	ret

0000165a <uart_getc>:
//Modified to not block indefinately in the case of a lost byte
//
char uart_getc(void) {
  uint16_t timer = 0;

  while (!(UCSR0A & (1<<RXC0))) {
    165a:	80 e8       	ldi	r24, 0x80	; 128
    165c:	9e e3       	ldi	r25, 0x3E	; 62
    165e:	02 c0       	rjmp	.+4      	; 0x1664 <uart_getc+0xa>
    1660:	01 97       	sbiw	r24, 0x01	; 1
  timer++;
  if(timer >= 16000){ return(0);}
    1662:	21 f0       	breq	.+8      	; 0x166c <uart_getc+0x12>
//Modified to not block indefinately in the case of a lost byte
//
char uart_getc(void) {
  uint16_t timer = 0;

  while (!(UCSR0A & (1<<RXC0))) {
    1664:	5f 9b       	sbis	0x0b, 7	; 11
    1666:	fc cf       	rjmp	.-8      	; 0x1660 <uart_getc+0x6>
  //what should we return if nothing comes in?
  //return the data into a global variable
  //give uart_getc the address of the variable
  //return a -1 if no data comes back.
  } // Wait for byte to arrive
  return(UDR0); //return the received data
    1668:	8c b1       	in	r24, 0x0c	; 12
    166a:	08 95       	ret
char uart_getc(void) {
  uint16_t timer = 0;

  while (!(UCSR0A & (1<<RXC0))) {
  timer++;
  if(timer >= 16000){ return(0);}
    166c:	80 e0       	ldi	r24, 0x00	; 0
  //return the data into a global variable
  //give uart_getc the address of the variable
  //return a -1 if no data comes back.
  } // Wait for byte to arrive
  return(UDR0); //return the received data
}
    166e:	08 95       	ret

00001670 <main>:
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
    1670:	87 b3       	in	r24, 0x17	; 23
    1672:	87 60       	ori	r24, 0x07	; 7
    1674:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
    1676:	8d b1       	in	r24, 0x0d	; 13
    1678:	8c 65       	ori	r24, 0x5C	; 92
    167a:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
    167c:	70 9a       	sbi	0x0e, 0	; 14
Description: Timer counter 0 is initialized in normal mode with no prescale
	and will be used as a seconds counter for the clock
Parameters: NA
**********************************************************************/
void tcnt0_init(){
   ASSR |= (1<<AS0);
    167e:	80 b7       	in	r24, 0x30	; 48
    1680:	88 60       	ori	r24, 0x08	; 8
    1682:	80 bf       	out	0x30, r24	; 48
   TIMSK |= (1<<OCIE0) | (1<<TOIE0);			//enable interrupts
    1684:	87 b7       	in	r24, 0x37	; 55
    1686:	83 60       	ori	r24, 0x03	; 3
    1688:	87 bf       	out	0x37, r24	; 55
   TCCR0 |= (1<<CS00);			//normal mode, no prescale
    168a:	83 b7       	in	r24, 0x33	; 51
    168c:	81 60       	ori	r24, 0x01	; 1
    168e:	83 bf       	out	0x33, r24	; 51
   OCR0 = 0xFF;
    1690:	8f ef       	ldi	r24, 0xFF	; 255
    1692:	81 bf       	out	0x31, r24	; 49
Description: Timer counter 1 is initialized in CTC mode, 64 bit prescaler
	so that it can be used to generate an alarm frequency
Parameters: NA
**********************************************************************/
void tcnt1_init(){
   TCCR1B |= (1<<CS11) | (1<<CS10) | (1<<WGM12);		//CTC mode, 64bit prescaler
    1694:	8e b5       	in	r24, 0x2e	; 46
    1696:	8b 60       	ori	r24, 0x0B	; 11
    1698:	8e bd       	out	0x2e, r24	; 46
   TCCR1C = 0x00;
    169a:	10 92 7a 00 	sts	0x007A, r1	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
   TIMSK  |= (1<<OCIE1A) | (1<<TOIE1);	//enable flag for interrupt 
    169e:	87 b7       	in	r24, 0x37	; 55
    16a0:	84 61       	ori	r24, 0x14	; 20
    16a2:	87 bf       	out	0x37, r24	; 55
   OCR1A = 0x0040;		//compare match at 64
    16a4:	80 e4       	ldi	r24, 0x40	; 64
    16a6:	90 e0       	ldi	r25, 0x00	; 0
    16a8:	9b bd       	out	0x2b, r25	; 43
    16aa:	8a bd       	out	0x2a, r24	; 42
	normal mode with a 64 bit prescaler. OCRA2 is adjusted to change
	the pwn produced.
Parameters: NA
**********************************************************************/
void tcnt2_init(){
   TCCR2 |= (1<<WGM21) | (1<<WGM20)| (1<<CS20) | (1<<COM21);			
    16ac:	85 b5       	in	r24, 0x25	; 37
    16ae:	89 66       	ori	r24, 0x69	; 105
    16b0:	85 bd       	out	0x25, r24	; 37
Description: This timer is used as a volume control for the audio amp.
	I adjust the value of OCR3A to change the pwm.
Parameters: NA
**********************************************************************/
void tcnt3_init(){
   TCCR3A |= (1<<COM3A1) | (1<<WGM31);	 //Clear on OCR3A match
    16b2:	80 91 8b 00 	lds	r24, 0x008B	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
    16b6:	82 68       	ori	r24, 0x82	; 130
    16b8:	80 93 8b 00 	sts	0x008B, r24	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
   TCCR3B |= (1<<CS30) | (1<<WGM32) | (1<<WGM33);		//Fast PWM mode, no prescaler
    16bc:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
    16c0:	89 61       	ori	r24, 0x19	; 25
    16c2:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
   TCCR3C = 0x00;
    16c6:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x7e008c>
   ICR3 = 0x9F;				//Setting the TOP value
    16ca:	8f e9       	ldi	r24, 0x9F	; 159
    16cc:	90 e0       	ldi	r25, 0x00	; 0
    16ce:	90 93 81 00 	sts	0x0081, r25	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
    16d2:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
   TCNT3 = 0x0000; 			//Initialize TNCT1 to 0
    16d6:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    16da:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
   OCR3A = 0x9F;			//Volume Control 0x9F=Max 0x00=Min
    16de:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
    16e2:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
Description: Basic adc initialization used for single shot adc readings
Parameters: NA
**********************************************************************/
void adc_init(){
//Initalize ADC and its ports
   DDRF  &= ~(_BV(DDF7)); //make port F bit 7 is ADC input  
    16e6:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
    16ea:	8f 77       	andi	r24, 0x7F	; 127
    16ec:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
   PORTF &= ~(_BV(PF7));  //port F bit 7 pullups must be off
    16f0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    16f4:	8f 77       	andi	r24, 0x7F	; 127
    16f6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
   ADMUX |= (1<<REFS0) | (1<<MUX2)| (1<<MUX1)| (1<<MUX0); //single-ended, input PORTF bit 7, right adjusted, 10 bits
    16fa:	87 b1       	in	r24, 0x07	; 7
    16fc:	87 64       	ori	r24, 0x47	; 71
    16fe:	87 b9       	out	0x07, r24	; 7

   ADCSRA |= (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);//ADC enabled, don't start yet, single shot mode 
    1700:	86 b1       	in	r24, 0x06	; 6
    1702:	87 68       	ori	r24, 0x87	; 135
    1704:	86 b9       	out	0x06, r24	; 6
   tcnt0_init();
   tcnt1_init();
   tcnt2_init();
   tcnt3_init();
   adc_init();
   port_init();
    1706:	0e 94 a8 04 	call	0x950	; 0x950 <port_init>
   init_twi();
    170a:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <init_twi>
Description: 
Parameters: NA
**********************************************************************/
void local_temp_init(){

lm73_wr_buf[0] = 0x00; //load lm73_wr_buf[0] with temperature pointer address
    170e:	10 92 e0 01 	sts	0x01E0, r1	; 0x8001e0 <lm73_wr_buf>
twi_start_wr(LM73_ADDRESS, lm73_rd_buf, 1); //start the TWI write process
    1712:	41 e0       	ldi	r20, 0x01	; 1
    1714:	62 ee       	ldi	r22, 0xE2	; 226
    1716:	71 e0       	ldi	r23, 0x01	; 1
    1718:	80 e9       	ldi	r24, 0x90	; 144
    171a:	0e 94 cc 0a 	call	0x1598	; 0x1598 <twi_start_wr>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    171e:	2f ef       	ldi	r18, 0xFF	; 255
    1720:	81 ee       	ldi	r24, 0xE1	; 225
    1722:	94 e0       	ldi	r25, 0x04	; 4
    1724:	21 50       	subi	r18, 0x01	; 1
    1726:	80 40       	sbci	r24, 0x00	; 0
    1728:	90 40       	sbci	r25, 0x00	; 0
    172a:	e1 f7       	brne	.-8      	; 0x1724 <main+0xb4>
    172c:	00 c0       	rjmp	.+0      	; 0x172e <main+0xbe>
    172e:	00 00       	nop
   tcnt3_init();
   adc_init();
   port_init();
   init_twi();
   local_temp_init();   
   strncpy(lcd_array, "                                    ",32);
    1730:	80 e2       	ldi	r24, 0x20	; 32
    1732:	e1 e2       	ldi	r30, 0x21	; 33
    1734:	f1 e0       	ldi	r31, 0x01	; 1
    1736:	a3 e7       	ldi	r26, 0x73	; 115
    1738:	b1 e0       	ldi	r27, 0x01	; 1
    173a:	01 90       	ld	r0, Z+
    173c:	0d 92       	st	X+, r0
    173e:	8a 95       	dec	r24
    1740:	e1 f7       	brne	.-8      	; 0x173a <main+0xca>

   uart_init();
    1742:	0e 94 20 0b 	call	0x1640	; 0x1640 <uart_init>
   lcd_init();
    1746:	0e 94 c9 07 	call	0xf92	; 0xf92 <lcd_init>
   sei();				//Enable interrupts
    174a:	78 94       	sei
	 }
	 PORTA = segment_data[j];	//Writes the segment data to PORTA aka the segments
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
				//the digit to be displayed is in pin 4, 5, and 6 
         _delay_us(200);		//delay so that the display does not flicker
         PORTA = 0xFF;
    174c:	cf ef       	ldi	r28, 0xFF	; 255
   lcd_init();
   sei();				//Enable interrupts
   while(1){

//***************  start rcv portion ***************
    if(rcv_rdy==1){
    174e:	80 91 72 01 	lds	r24, 0x0172	; 0x800172 <rcv_rdy>
    1752:	81 30       	cpi	r24, 0x01	; 1
    1754:	59 f1       	breq	.+86     	; 0x17ac <main+0x13c>
Description: This function disables the snooze variable once the alarm
	seconds equals the normal seconds. 
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
    1756:	80 91 52 01 	lds	r24, 0x0152	; 0x800152 <snooze>
    175a:	81 11       	cpse	r24, r1
    175c:	35 c0       	rjmp	.+106    	; 0x17c8 <main+0x158>
    }//if 
//**************  end rcv portion ***************
 
//      refresh_lcd(lcd_array);
      snoozin();
      fetch_adc();
    175e:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <fetch_adc>
      clock_time();
    1762:	0e 94 e0 03 	call	0x7c0	; 0x7c0 <clock_time>
      change_alarm_state();
    1766:	0e 94 be 04 	call	0x97c	; 0x97c <change_alarm_state>
    176a:	e6 e4       	ldi	r30, 0x46	; 70
    176c:	f1 e0       	ldi	r31, 0x01	; 1
    176e:	80 e0       	ldi	r24, 0x00	; 0
      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
         if(alarm){
    1770:	90 91 53 01 	lds	r25, 0x0153	; 0x800153 <alarm>
    1774:	99 23       	and	r25, r25
    1776:	29 f0       	breq	.+10     	; 0x1782 <main+0x112>
	    segment_data[2] &= 0b011;
    1778:	90 91 48 01 	lds	r25, 0x0148	; 0x800148 <__data_end+0x2>
    177c:	93 70       	andi	r25, 0x03	; 3
    177e:	90 93 48 01 	sts	0x0148, r25	; 0x800148 <__data_end+0x2>
	 }
	 PORTA = segment_data[j];	//Writes the segment data to PORTA aka the segments
    1782:	91 91       	ld	r25, Z+
    1784:	9b bb       	out	0x1b, r25	; 27
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
    1786:	98 2f       	mov	r25, r24
    1788:	92 95       	swap	r25
    178a:	90 7f       	andi	r25, 0xF0	; 240
    178c:	98 bb       	out	0x18, r25	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    178e:	af e1       	ldi	r26, 0x1F	; 31
    1790:	b3 e0       	ldi	r27, 0x03	; 3
    1792:	11 97       	sbiw	r26, 0x01	; 1
    1794:	f1 f7       	brne	.-4      	; 0x1792 <main+0x122>
    1796:	00 c0       	rjmp	.+0      	; 0x1798 <main+0x128>
    1798:	00 00       	nop
				//the digit to be displayed is in pin 4, 5, and 6 
         _delay_us(200);		//delay so that the display does not flicker
         PORTA = 0xFF;
    179a:	cb bb       	out	0x1b, r28	; 27
    179c:	8f 5f       	subi	r24, 0xFF	; 255
//      refresh_lcd(lcd_array);
      snoozin();
      fetch_adc();
      clock_time();
      change_alarm_state();
      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
    179e:	85 30       	cpi	r24, 0x05	; 5
    17a0:	39 f7       	brne	.-50     	; 0x1770 <main+0x100>
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
				//the digit to be displayed is in pin 4, 5, and 6 
         _delay_us(200);		//delay so that the display does not flicker
         PORTA = 0xFF;
      }
	PORTB = 0x00;;
    17a2:	18 ba       	out	0x18, r1	; 24
   lcd_init();
   sei();				//Enable interrupts
   while(1){

//***************  start rcv portion ***************
    if(rcv_rdy==1){
    17a4:	80 91 72 01 	lds	r24, 0x0172	; 0x800172 <rcv_rdy>
    17a8:	81 30       	cpi	r24, 0x01	; 1
    17aa:	a9 f6       	brne	.-86     	; 0x1756 <main+0xe6>
        lcd_array[25] = lcd_str_array[0];
    17ac:	80 91 99 01 	lds	r24, 0x0199	; 0x800199 <lcd_str_array>
    17b0:	80 93 8c 01 	sts	0x018C, r24	; 0x80018c <lcd_array+0x19>
        lcd_array[26] = lcd_str_array[1];
    17b4:	80 91 9a 01 	lds	r24, 0x019A	; 0x80019a <lcd_str_array+0x1>
    17b8:	80 93 8d 01 	sts	0x018D, r24	; 0x80018d <lcd_array+0x1a>
	rcv_rdy=0;
    17bc:	10 92 72 01 	sts	0x0172, r1	; 0x800172 <rcv_rdy>
Description: This function disables the snooze variable once the alarm
	seconds equals the normal seconds. 
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
    17c0:	80 91 52 01 	lds	r24, 0x0152	; 0x800152 <snooze>
    17c4:	88 23       	and	r24, r24
    17c6:	59 f2       	breq	.-106    	; 0x175e <main+0xee>
    17c8:	0e 94 b8 00 	call	0x170	; 0x170 <snoozin.part.1>
    17cc:	c8 cf       	rjmp	.-112    	; 0x175e <main+0xee>

000017ce <__divmodhi4>:
    17ce:	97 fb       	bst	r25, 7
    17d0:	07 2e       	mov	r0, r23
    17d2:	16 f4       	brtc	.+4      	; 0x17d8 <__divmodhi4+0xa>
    17d4:	00 94       	com	r0
    17d6:	07 d0       	rcall	.+14     	; 0x17e6 <__divmodhi4_neg1>
    17d8:	77 fd       	sbrc	r23, 7
    17da:	09 d0       	rcall	.+18     	; 0x17ee <__divmodhi4_neg2>
    17dc:	0e 94 23 0c 	call	0x1846	; 0x1846 <__udivmodhi4>
    17e0:	07 fc       	sbrc	r0, 7
    17e2:	05 d0       	rcall	.+10     	; 0x17ee <__divmodhi4_neg2>
    17e4:	3e f4       	brtc	.+14     	; 0x17f4 <__divmodhi4_exit>

000017e6 <__divmodhi4_neg1>:
    17e6:	90 95       	com	r25
    17e8:	81 95       	neg	r24
    17ea:	9f 4f       	sbci	r25, 0xFF	; 255
    17ec:	08 95       	ret

000017ee <__divmodhi4_neg2>:
    17ee:	70 95       	com	r23
    17f0:	61 95       	neg	r22
    17f2:	7f 4f       	sbci	r23, 0xFF	; 255

000017f4 <__divmodhi4_exit>:
    17f4:	08 95       	ret

000017f6 <__divmodsi4>:
    17f6:	05 2e       	mov	r0, r21
    17f8:	97 fb       	bst	r25, 7
    17fa:	1e f4       	brtc	.+6      	; 0x1802 <__divmodsi4+0xc>
    17fc:	00 94       	com	r0
    17fe:	0e 94 12 0c 	call	0x1824	; 0x1824 <__negsi2>
    1802:	57 fd       	sbrc	r21, 7
    1804:	07 d0       	rcall	.+14     	; 0x1814 <__divmodsi4_neg2>
    1806:	0e 94 37 0c 	call	0x186e	; 0x186e <__udivmodsi4>
    180a:	07 fc       	sbrc	r0, 7
    180c:	03 d0       	rcall	.+6      	; 0x1814 <__divmodsi4_neg2>
    180e:	4e f4       	brtc	.+18     	; 0x1822 <__divmodsi4_exit>
    1810:	0c 94 12 0c 	jmp	0x1824	; 0x1824 <__negsi2>

00001814 <__divmodsi4_neg2>:
    1814:	50 95       	com	r21
    1816:	40 95       	com	r20
    1818:	30 95       	com	r19
    181a:	21 95       	neg	r18
    181c:	3f 4f       	sbci	r19, 0xFF	; 255
    181e:	4f 4f       	sbci	r20, 0xFF	; 255
    1820:	5f 4f       	sbci	r21, 0xFF	; 255

00001822 <__divmodsi4_exit>:
    1822:	08 95       	ret

00001824 <__negsi2>:
    1824:	90 95       	com	r25
    1826:	80 95       	com	r24
    1828:	70 95       	com	r23
    182a:	61 95       	neg	r22
    182c:	7f 4f       	sbci	r23, 0xFF	; 255
    182e:	8f 4f       	sbci	r24, 0xFF	; 255
    1830:	9f 4f       	sbci	r25, 0xFF	; 255
    1832:	08 95       	ret

00001834 <__tablejump2__>:
    1834:	ee 0f       	add	r30, r30
    1836:	ff 1f       	adc	r31, r31
    1838:	00 24       	eor	r0, r0
    183a:	00 1c       	adc	r0, r0
    183c:	0b be       	out	0x3b, r0	; 59
    183e:	07 90       	elpm	r0, Z+
    1840:	f6 91       	elpm	r31, Z
    1842:	e0 2d       	mov	r30, r0
    1844:	09 94       	ijmp

00001846 <__udivmodhi4>:
    1846:	aa 1b       	sub	r26, r26
    1848:	bb 1b       	sub	r27, r27
    184a:	51 e1       	ldi	r21, 0x11	; 17
    184c:	07 c0       	rjmp	.+14     	; 0x185c <__udivmodhi4_ep>

0000184e <__udivmodhi4_loop>:
    184e:	aa 1f       	adc	r26, r26
    1850:	bb 1f       	adc	r27, r27
    1852:	a6 17       	cp	r26, r22
    1854:	b7 07       	cpc	r27, r23
    1856:	10 f0       	brcs	.+4      	; 0x185c <__udivmodhi4_ep>
    1858:	a6 1b       	sub	r26, r22
    185a:	b7 0b       	sbc	r27, r23

0000185c <__udivmodhi4_ep>:
    185c:	88 1f       	adc	r24, r24
    185e:	99 1f       	adc	r25, r25
    1860:	5a 95       	dec	r21
    1862:	a9 f7       	brne	.-22     	; 0x184e <__udivmodhi4_loop>
    1864:	80 95       	com	r24
    1866:	90 95       	com	r25
    1868:	bc 01       	movw	r22, r24
    186a:	cd 01       	movw	r24, r26
    186c:	08 95       	ret

0000186e <__udivmodsi4>:
    186e:	a1 e2       	ldi	r26, 0x21	; 33
    1870:	1a 2e       	mov	r1, r26
    1872:	aa 1b       	sub	r26, r26
    1874:	bb 1b       	sub	r27, r27
    1876:	fd 01       	movw	r30, r26
    1878:	0d c0       	rjmp	.+26     	; 0x1894 <__udivmodsi4_ep>

0000187a <__udivmodsi4_loop>:
    187a:	aa 1f       	adc	r26, r26
    187c:	bb 1f       	adc	r27, r27
    187e:	ee 1f       	adc	r30, r30
    1880:	ff 1f       	adc	r31, r31
    1882:	a2 17       	cp	r26, r18
    1884:	b3 07       	cpc	r27, r19
    1886:	e4 07       	cpc	r30, r20
    1888:	f5 07       	cpc	r31, r21
    188a:	20 f0       	brcs	.+8      	; 0x1894 <__udivmodsi4_ep>
    188c:	a2 1b       	sub	r26, r18
    188e:	b3 0b       	sbc	r27, r19
    1890:	e4 0b       	sbc	r30, r20
    1892:	f5 0b       	sbc	r31, r21

00001894 <__udivmodsi4_ep>:
    1894:	66 1f       	adc	r22, r22
    1896:	77 1f       	adc	r23, r23
    1898:	88 1f       	adc	r24, r24
    189a:	99 1f       	adc	r25, r25
    189c:	1a 94       	dec	r1
    189e:	69 f7       	brne	.-38     	; 0x187a <__udivmodsi4_loop>
    18a0:	60 95       	com	r22
    18a2:	70 95       	com	r23
    18a4:	80 95       	com	r24
    18a6:	90 95       	com	r25
    18a8:	9b 01       	movw	r18, r22
    18aa:	ac 01       	movw	r20, r24
    18ac:	bd 01       	movw	r22, r26
    18ae:	cf 01       	movw	r24, r30
    18b0:	08 95       	ret

000018b2 <__itoa_ncheck>:
    18b2:	bb 27       	eor	r27, r27
    18b4:	4a 30       	cpi	r20, 0x0A	; 10
    18b6:	31 f4       	brne	.+12     	; 0x18c4 <__itoa_ncheck+0x12>
    18b8:	99 23       	and	r25, r25
    18ba:	22 f4       	brpl	.+8      	; 0x18c4 <__itoa_ncheck+0x12>
    18bc:	bd e2       	ldi	r27, 0x2D	; 45
    18be:	90 95       	com	r25
    18c0:	81 95       	neg	r24
    18c2:	9f 4f       	sbci	r25, 0xFF	; 255
    18c4:	0c 94 65 0c 	jmp	0x18ca	; 0x18ca <__utoa_common>

000018c8 <__utoa_ncheck>:
    18c8:	bb 27       	eor	r27, r27

000018ca <__utoa_common>:
    18ca:	fb 01       	movw	r30, r22
    18cc:	55 27       	eor	r21, r21
    18ce:	aa 27       	eor	r26, r26
    18d0:	88 0f       	add	r24, r24
    18d2:	99 1f       	adc	r25, r25
    18d4:	aa 1f       	adc	r26, r26
    18d6:	a4 17       	cp	r26, r20
    18d8:	10 f0       	brcs	.+4      	; 0x18de <__utoa_common+0x14>
    18da:	a4 1b       	sub	r26, r20
    18dc:	83 95       	inc	r24
    18de:	50 51       	subi	r21, 0x10	; 16
    18e0:	b9 f7       	brne	.-18     	; 0x18d0 <__utoa_common+0x6>
    18e2:	a0 5d       	subi	r26, 0xD0	; 208
    18e4:	aa 33       	cpi	r26, 0x3A	; 58
    18e6:	08 f0       	brcs	.+2      	; 0x18ea <__utoa_common+0x20>
    18e8:	a9 5d       	subi	r26, 0xD9	; 217
    18ea:	a1 93       	st	Z+, r26
    18ec:	00 97       	sbiw	r24, 0x00	; 0
    18ee:	79 f7       	brne	.-34     	; 0x18ce <__utoa_common+0x4>
    18f0:	b1 11       	cpse	r27, r1
    18f2:	b1 93       	st	Z+, r27
    18f4:	11 92       	st	Z+, r1
    18f6:	cb 01       	movw	r24, r22
    18f8:	0c 94 7e 0c 	jmp	0x18fc	; 0x18fc <strrev>

000018fc <strrev>:
    18fc:	dc 01       	movw	r26, r24
    18fe:	fc 01       	movw	r30, r24
    1900:	67 2f       	mov	r22, r23
    1902:	71 91       	ld	r23, Z+
    1904:	77 23       	and	r23, r23
    1906:	e1 f7       	brne	.-8      	; 0x1900 <strrev+0x4>
    1908:	32 97       	sbiw	r30, 0x02	; 2
    190a:	04 c0       	rjmp	.+8      	; 0x1914 <strrev+0x18>
    190c:	7c 91       	ld	r23, X
    190e:	6d 93       	st	X+, r22
    1910:	70 83       	st	Z, r23
    1912:	62 91       	ld	r22, -Z
    1914:	ae 17       	cp	r26, r30
    1916:	bf 07       	cpc	r27, r31
    1918:	c8 f3       	brcs	.-14     	; 0x190c <strrev+0x10>
    191a:	08 95       	ret

0000191c <_exit>:
    191c:	f8 94       	cli

0000191e <__stop_program>:
    191e:	ff cf       	rjmp	.-2      	; 0x191e <__stop_program>
