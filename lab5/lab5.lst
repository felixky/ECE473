
lab5.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000002e  00800100  000017f2  00001886  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000017f2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000064  0080012e  0080012e  000018b4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000018b4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000018e4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000088  00000000  00000000  00001920  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000289e  00000000  00000000  000019a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000f8d  00000000  00000000  00004246  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000013c4  00000000  00000000  000051d3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000484  00000000  00000000  00006598  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000007ac  00000000  00000000  00006a1c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001bb3  00000000  00000000  000071c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000f0  00000000  00000000  00008d7b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 97 00 	jmp	0x12e	; 0x12e <__ctors_end>
       4:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
       8:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
       c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      10:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      14:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      18:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      1c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      20:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      24:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      28:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      2c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      30:	0c 94 f2 04 	jmp	0x9e4	; 0x9e4 <__vector_12>
      34:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      38:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      3c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      40:	0c 94 4b 03 	jmp	0x696	; 0x696 <__vector_16>
      44:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      48:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      4c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      50:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      54:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      58:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      5c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      60:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      64:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      68:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      6c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      70:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      74:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      78:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      7c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      80:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      84:	0c 94 12 0a 	jmp	0x1424	; 0x1424 <__vector_33>
      88:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      8c:	53 0a       	sbc	r5, r19
      8e:	2a 0a       	sbc	r2, r26
      90:	2a 0a       	sbc	r2, r26
      92:	2a 0a       	sbc	r2, r26
      94:	2a 0a       	sbc	r2, r26
      96:	2a 0a       	sbc	r2, r26
      98:	2a 0a       	sbc	r2, r26
      9a:	2a 0a       	sbc	r2, r26
      9c:	53 0a       	sbc	r5, r19
      9e:	2a 0a       	sbc	r2, r26
      a0:	2a 0a       	sbc	r2, r26
      a2:	2a 0a       	sbc	r2, r26
      a4:	2a 0a       	sbc	r2, r26
      a6:	2a 0a       	sbc	r2, r26
      a8:	2a 0a       	sbc	r2, r26
      aa:	2a 0a       	sbc	r2, r26
      ac:	5d 0a       	sbc	r5, r29
      ae:	2a 0a       	sbc	r2, r26
      b0:	2a 0a       	sbc	r2, r26
      b2:	2a 0a       	sbc	r2, r26
      b4:	2a 0a       	sbc	r2, r26
      b6:	2a 0a       	sbc	r2, r26
      b8:	2a 0a       	sbc	r2, r26
      ba:	2a 0a       	sbc	r2, r26
      bc:	2a 0a       	sbc	r2, r26
      be:	2a 0a       	sbc	r2, r26
      c0:	2a 0a       	sbc	r2, r26
      c2:	2a 0a       	sbc	r2, r26
      c4:	2a 0a       	sbc	r2, r26
      c6:	2a 0a       	sbc	r2, r26
      c8:	2a 0a       	sbc	r2, r26
      ca:	2a 0a       	sbc	r2, r26
      cc:	5d 0a       	sbc	r5, r29
      ce:	2a 0a       	sbc	r2, r26
      d0:	2a 0a       	sbc	r2, r26
      d2:	2a 0a       	sbc	r2, r26
      d4:	2a 0a       	sbc	r2, r26
      d6:	2a 0a       	sbc	r2, r26
      d8:	2a 0a       	sbc	r2, r26
      da:	2a 0a       	sbc	r2, r26
      dc:	2a 0a       	sbc	r2, r26
      de:	2a 0a       	sbc	r2, r26
      e0:	2a 0a       	sbc	r2, r26
      e2:	2a 0a       	sbc	r2, r26
      e4:	2a 0a       	sbc	r2, r26
      e6:	2a 0a       	sbc	r2, r26
      e8:	2a 0a       	sbc	r2, r26
      ea:	2a 0a       	sbc	r2, r26
      ec:	74 0a       	sbc	r7, r20
      ee:	2a 0a       	sbc	r2, r26
      f0:	2a 0a       	sbc	r2, r26
      f2:	2a 0a       	sbc	r2, r26
      f4:	2a 0a       	sbc	r2, r26
      f6:	2a 0a       	sbc	r2, r26
      f8:	2a 0a       	sbc	r2, r26
      fa:	2a 0a       	sbc	r2, r26
      fc:	78 0a       	sbc	r7, r24
      fe:	2a 0a       	sbc	r2, r26
     100:	2a 0a       	sbc	r2, r26
     102:	2a 0a       	sbc	r2, r26
     104:	2a 0a       	sbc	r2, r26
     106:	2a 0a       	sbc	r2, r26
     108:	2a 0a       	sbc	r2, r26
     10a:	2a 0a       	sbc	r2, r26
     10c:	2a 0a       	sbc	r2, r26
     10e:	2a 0a       	sbc	r2, r26
     110:	2a 0a       	sbc	r2, r26
     112:	2a 0a       	sbc	r2, r26
     114:	2a 0a       	sbc	r2, r26
     116:	2a 0a       	sbc	r2, r26
     118:	2a 0a       	sbc	r2, r26
     11a:	2a 0a       	sbc	r2, r26
     11c:	86 0a       	sbc	r8, r22
     11e:	2a 0a       	sbc	r2, r26
     120:	2a 0a       	sbc	r2, r26
     122:	2a 0a       	sbc	r2, r26
     124:	2a 0a       	sbc	r2, r26
     126:	2a 0a       	sbc	r2, r26
     128:	2a 0a       	sbc	r2, r26
     12a:	2a 0a       	sbc	r2, r26
     12c:	44 0a       	sbc	r4, r20

0000012e <__ctors_end>:
     12e:	11 24       	eor	r1, r1
     130:	1f be       	out	0x3f, r1	; 63
     132:	cf ef       	ldi	r28, 0xFF	; 255
     134:	d0 e1       	ldi	r29, 0x10	; 16
     136:	de bf       	out	0x3e, r29	; 62
     138:	cd bf       	out	0x3d, r28	; 61

0000013a <__do_copy_data>:
     13a:	11 e0       	ldi	r17, 0x01	; 1
     13c:	a0 e0       	ldi	r26, 0x00	; 0
     13e:	b1 e0       	ldi	r27, 0x01	; 1
     140:	e2 ef       	ldi	r30, 0xF2	; 242
     142:	f7 e1       	ldi	r31, 0x17	; 23
     144:	00 e0       	ldi	r16, 0x00	; 0
     146:	0b bf       	out	0x3b, r16	; 59
     148:	02 c0       	rjmp	.+4      	; 0x14e <__do_copy_data+0x14>
     14a:	07 90       	elpm	r0, Z+
     14c:	0d 92       	st	X+, r0
     14e:	ae 32       	cpi	r26, 0x2E	; 46
     150:	b1 07       	cpc	r27, r17
     152:	d9 f7       	brne	.-10     	; 0x14a <__do_copy_data+0x10>

00000154 <__do_clear_bss>:
     154:	21 e0       	ldi	r18, 0x01	; 1
     156:	ae e2       	ldi	r26, 0x2E	; 46
     158:	b1 e0       	ldi	r27, 0x01	; 1
     15a:	01 c0       	rjmp	.+2      	; 0x15e <.do_clear_bss_start>

0000015c <.do_clear_bss_loop>:
     15c:	1d 92       	st	X+, r1

0000015e <.do_clear_bss_start>:
     15e:	a2 39       	cpi	r26, 0x92	; 146
     160:	b2 07       	cpc	r27, r18
     162:	e1 f7       	brne	.-8      	; 0x15c <.do_clear_bss_loop>
     164:	0e 94 d1 0a 	call	0x15a2	; 0x15a2 <main>
     168:	0c 94 f7 0b 	jmp	0x17ee	; 0x17ee <_exit>

0000016c <__bad_interrupt>:
     16c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000170 <snoozin.part.1>:
	seconds equals the normal seconds. 
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
      if(a_sec_count == sec_count)
     170:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <a_sec_count>
     174:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <sec_count>
     178:	98 17       	cp	r25, r24
     17a:	21 f0       	breq	.+8      	; 0x184 <snoozin.part.1+0x14>
         snooze = 0;
      else 
         snooze = 1;
     17c:	81 e0       	ldi	r24, 0x01	; 1
     17e:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <snooze>
     182:	08 95       	ret
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
      if(a_sec_count == sec_count)
         snooze = 0;
     184:	10 92 3a 01 	sts	0x013A, r1	; 0x80013a <snooze>
     188:	08 95       	ret

0000018a <spi_init>:
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
     18a:	87 b3       	in	r24, 0x17	; 23
     18c:	87 60       	ori	r24, 0x07	; 7
     18e:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
     190:	8d b1       	in	r24, 0x0d	; 13
     192:	8c 65       	ori	r24, 0x5C	; 92
     194:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
     196:	70 9a       	sbi	0x0e, 0	; 14
     198:	08 95       	ret

0000019a <tcnt0_init>:
Description: Timer counter 0 is initialized in normal mode with no prescale
	and will be used as a seconds counter for the clock
Parameters: NA
**********************************************************************/
void tcnt0_init(){
   ASSR |= (1<<AS0);
     19a:	80 b7       	in	r24, 0x30	; 48
     19c:	88 60       	ori	r24, 0x08	; 8
     19e:	80 bf       	out	0x30, r24	; 48
   TIMSK |= (1<<TOIE0);			//enable interrupts
     1a0:	87 b7       	in	r24, 0x37	; 55
     1a2:	81 60       	ori	r24, 0x01	; 1
     1a4:	87 bf       	out	0x37, r24	; 55
   TCCR0 |= (1<<CS00);			//normal mode, no prescale
     1a6:	83 b7       	in	r24, 0x33	; 51
     1a8:	81 60       	ori	r24, 0x01	; 1
     1aa:	83 bf       	out	0x33, r24	; 51
     1ac:	08 95       	ret

000001ae <tcnt1_init>:
Description: Timer counter 1 is initialized in CTC mode, 64 bit prescaler
	so that it can be used to generate an alarm frequency
Parameters: NA
**********************************************************************/
void tcnt1_init(){
   TCCR1B |= (1<<CS11) | (1<<CS10) | (1<<WGM12);		//CTC mode, 64bit prescaler
     1ae:	8e b5       	in	r24, 0x2e	; 46
     1b0:	8b 60       	ori	r24, 0x0B	; 11
     1b2:	8e bd       	out	0x2e, r24	; 46
   TCCR1C = 0x00;
     1b4:	10 92 7a 00 	sts	0x007A, r1	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
   TIMSK  |= (1<<OCIE1A);	//enable flag for interrupt 
     1b8:	87 b7       	in	r24, 0x37	; 55
     1ba:	80 61       	ori	r24, 0x10	; 16
     1bc:	87 bf       	out	0x37, r24	; 55
   OCR1A = 0x0040;		//compare match at 64
     1be:	80 e4       	ldi	r24, 0x40	; 64
     1c0:	90 e0       	ldi	r25, 0x00	; 0
     1c2:	9b bd       	out	0x2b, r25	; 43
     1c4:	8a bd       	out	0x2a, r24	; 42
     1c6:	08 95       	ret

000001c8 <tcnt2_init>:
	normal mode with a 64 bit prescaler. OCRA2 is adjusted to change
	the pwn produced.
Parameters: NA
**********************************************************************/
void tcnt2_init(){
   TCCR2 |= (1<<WGM21) | (1<<WGM20)| (1<<CS20) | (1<<COM21);			
     1c8:	85 b5       	in	r24, 0x25	; 37
     1ca:	89 66       	ori	r24, 0x69	; 105
     1cc:	85 bd       	out	0x25, r24	; 37
     1ce:	08 95       	ret

000001d0 <tcnt3_init>:
Description: This timer is used as a volume control for the audio amp.
	I adjust the value of OCR3A to change the pwm.
Parameters: NA
**********************************************************************/
void tcnt3_init(){
   TCCR3A |= (1<<COM3A1) | (1<<WGM31);	 //Clear on OCR3A match
     1d0:	eb e8       	ldi	r30, 0x8B	; 139
     1d2:	f0 e0       	ldi	r31, 0x00	; 0
     1d4:	80 81       	ld	r24, Z
     1d6:	82 68       	ori	r24, 0x82	; 130
     1d8:	80 83       	st	Z, r24
   TCCR3B |= (1<<CS30) | (1<<WGM32) | (1<<WGM33);		//Fast PWM mode, no prescaler
     1da:	ea e8       	ldi	r30, 0x8A	; 138
     1dc:	f0 e0       	ldi	r31, 0x00	; 0
     1de:	80 81       	ld	r24, Z
     1e0:	89 61       	ori	r24, 0x19	; 25
     1e2:	80 83       	st	Z, r24
   TCCR3C = 0x00;
     1e4:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x7e008c>
   ICR3 = 0x9F;				//Setting the TOP value
     1e8:	8f e9       	ldi	r24, 0x9F	; 159
     1ea:	90 e0       	ldi	r25, 0x00	; 0
     1ec:	90 93 81 00 	sts	0x0081, r25	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
     1f0:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
   TCNT3 = 0x0000; 			//Initialize TNCT1 to 0
     1f4:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     1f8:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
   OCR3A = 0x9F;			//Volume Control 0x9F=Max 0x00=Min
     1fc:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     200:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
     204:	08 95       	ret

00000206 <spi_read>:
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
     206:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
     208:	77 9b       	sbis	0x0e, 7	; 14
     20a:	fe cf       	rjmp	.-4      	; 0x208 <spi_read+0x2>
   return SPDR;
     20c:	8f b1       	in	r24, 0x0f	; 15
}
     20e:	08 95       	ret

00000210 <chk_buttons>:
	be implemented at the same time. Adapted to check all buttons from 
	Ganssel's "Guide to Debouncing" Expects active low pushbuttons on PINA 
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
     210:	48 2f       	mov	r20, r24
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
     212:	e8 2f       	mov	r30, r24
     214:	f0 e0       	ldi	r31, 0x00	; 0
     216:	99 b3       	in	r25, 0x19	; 25
     218:	ee 0f       	add	r30, r30
     21a:	ff 1f       	adc	r31, r31
     21c:	eb 5b       	subi	r30, 0xBB	; 187
     21e:	fe 4f       	sbci	r31, 0xFE	; 254
     220:	20 81       	ld	r18, Z
     222:	31 81       	ldd	r19, Z+1	; 0x01
     224:	22 0f       	add	r18, r18
     226:	33 1f       	adc	r19, r19
     228:	30 6e       	ori	r19, 0xE0	; 224
     22a:	89 2f       	mov	r24, r25
     22c:	90 e0       	ldi	r25, 0x00	; 0
     22e:	02 c0       	rjmp	.+4      	; 0x234 <chk_buttons+0x24>
     230:	95 95       	asr	r25
     232:	87 95       	ror	r24
     234:	4a 95       	dec	r20
     236:	e2 f7       	brpl	.-8      	; 0x230 <chk_buttons+0x20>
     238:	81 70       	andi	r24, 0x01	; 1
     23a:	99 27       	eor	r25, r25
     23c:	28 2b       	or	r18, r24
     23e:	39 2b       	or	r19, r25
     240:	31 83       	std	Z+1, r19	; 0x01
     242:	20 83       	st	Z, r18
     244:	81 e0       	ldi	r24, 0x01	; 1
     246:	21 15       	cp	r18, r1
     248:	30 4f       	sbci	r19, 0xF0	; 240
     24a:	09 f0       	breq	.+2      	; 0x24e <chk_buttons+0x3e>
     24c:	80 e0       	ldi	r24, 0x00	; 0
  if (state[button] == 0xF000)
    return 1;
return 0;
}
     24e:	08 95       	ret

00000250 <bars>:
Description:This function reads in the button board and updates the 
	LEDs on the bargraph through the serial port.
Parameters: NA
**********************************************************************/
void bars() {
   DDRA = 0x00;				//Set all as inputs
     250:	1a ba       	out	0x1a, r1	; 26
   PORTA = 0xFF;			//Pull up resistors
     252:	8f ef       	ldi	r24, 0xFF	; 255
     254:	8b bb       	out	0x1b, r24	; 27
   PORTB |= PINB | 0x70;		//Enable tristate buffer
     256:	86 b3       	in	r24, 0x16	; 22
     258:	98 b3       	in	r25, 0x18	; 24
     25a:	80 67       	ori	r24, 0x70	; 112
     25c:	89 2b       	or	r24, r25
     25e:	88 bb       	out	0x18, r24	; 24
     260:	e5 e4       	ldi	r30, 0x45	; 69
     262:	f1 e0       	ldi	r31, 0x01	; 1

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     264:	20 e0       	ldi	r18, 0x00	; 0
     266:	30 e0       	ldi	r19, 0x00	; 0
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
     268:	61 e0       	ldi	r22, 0x01	; 1
     26a:	70 e0       	ldi	r23, 0x00	; 0
     26c:	05 c0       	rjmp	.+10     	; 0x278 <bars+0x28>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     26e:	2f 5f       	subi	r18, 0xFF	; 255
     270:	3f 4f       	sbci	r19, 0xFF	; 255
     272:	28 30       	cpi	r18, 0x08	; 8
     274:	31 05       	cpc	r19, r1
     276:	39 f1       	breq	.+78     	; 0x2c6 <bars+0x76>
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
     278:	99 b3       	in	r25, 0x19	; 25
     27a:	40 81       	ld	r20, Z
     27c:	51 81       	ldd	r21, Z+1	; 0x01
     27e:	44 0f       	add	r20, r20
     280:	55 1f       	adc	r21, r21
     282:	89 2f       	mov	r24, r25
     284:	90 e0       	ldi	r25, 0x00	; 0
     286:	02 2e       	mov	r0, r18
     288:	02 c0       	rjmp	.+4      	; 0x28e <bars+0x3e>
     28a:	95 95       	asr	r25
     28c:	87 95       	ror	r24
     28e:	0a 94       	dec	r0
     290:	e2 f7       	brpl	.-8      	; 0x28a <bars+0x3a>
     292:	81 70       	andi	r24, 0x01	; 1
     294:	99 27       	eor	r25, r25
     296:	84 2b       	or	r24, r20
     298:	95 2b       	or	r25, r21
     29a:	90 6e       	ori	r25, 0xE0	; 224
     29c:	81 93       	st	Z+, r24
     29e:	91 93       	st	Z+, r25
  if (state[button] == 0xF000)
     2a0:	81 15       	cp	r24, r1
     2a2:	90 4f       	sbci	r25, 0xF0	; 240
     2a4:	21 f7       	brne	.-56     	; 0x26e <bars+0x1e>
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
     2a6:	cb 01       	movw	r24, r22
     2a8:	02 2e       	mov	r0, r18
     2aa:	02 c0       	rjmp	.+4      	; 0x2b0 <bars+0x60>
     2ac:	88 0f       	add	r24, r24
     2ae:	99 1f       	adc	r25, r25
     2b0:	0a 94       	dec	r0
     2b2:	e2 f7       	brpl	.-8      	; 0x2ac <bars+0x5c>
     2b4:	90 93 38 01 	sts	0x0138, r25	; 0x800138 <mult+0x1>
     2b8:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <mult>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     2bc:	2f 5f       	subi	r18, 0xFF	; 255
     2be:	3f 4f       	sbci	r19, 0xFF	; 255
     2c0:	28 30       	cpi	r18, 0x08	; 8
     2c2:	31 05       	cpc	r19, r1
     2c4:	c9 f6       	brne	.-78     	; 0x278 <bars+0x28>
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
     2c6:	88 b3       	in	r24, 0x18	; 24
     2c8:	18 ba       	out	0x18, r1	; 24
   if(mult == 128){			//Button 8 toggles base 10 and 16
     2ca:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <mult>
     2ce:	90 91 38 01 	lds	r25, 0x0138	; 0x800138 <mult+0x1>
     2d2:	80 38       	cpi	r24, 0x80	; 128
     2d4:	91 05       	cpc	r25, r1
     2d6:	09 f4       	brne	.+2      	; 0x2da <bars+0x8a>
     2d8:	79 c0       	rjmp	.+242    	; 0x3cc <bars+0x17c>
      alarm = !(alarm);			//on the LED display
   }
   if(mult == 64){		//Button 7 toggles snooze
     2da:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <mult>
     2de:	90 91 38 01 	lds	r25, 0x0138	; 0x800138 <mult+0x1>
     2e2:	80 34       	cpi	r24, 0x40	; 64
     2e4:	91 05       	cpc	r25, r1
     2e6:	c9 f1       	breq	.+114    	; 0x35a <bars+0x10a>
	       a_hour_count = 0;
	    }
	 }  
      }
   }
   if(mult > 4) {			//I only want values from the
     2e8:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <mult>
     2ec:	90 91 38 01 	lds	r25, 0x0138	; 0x800138 <mult+0x1>
     2f0:	05 97       	sbiw	r24, 0x05	; 5
     2f2:	20 f0       	brcs	.+8      	; 0x2fc <bars+0xac>
      mult = 0;				//first three buttons
     2f4:	10 92 38 01 	sts	0x0138, r1	; 0x800138 <mult+0x1>
     2f8:	10 92 37 01 	sts	0x0137, r1	; 0x800137 <mult>
   }
   //This switch statement is used to enable a 'toggle' functionality
   //so that modes can be selected an deselected
   switch(mult) {
     2fc:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <mult>
     300:	90 91 38 01 	lds	r25, 0x0138	; 0x800138 <mult+0x1>
     304:	81 30       	cpi	r24, 0x01	; 1
     306:	91 05       	cpc	r25, r1
     308:	19 f0       	breq	.+6      	; 0x310 <bars+0xc0>
     30a:	82 30       	cpi	r24, 0x02	; 2
     30c:	91 05       	cpc	r25, r1
     30e:	01 f5       	brne	.+64     	; 0x350 <bars+0x100>
	 }
	 else
	    mode_sel = 1;		//If not, then change mode
         break;
      case 2:
	 if((mode_sel ^ mult) == 0 ){//if((mode_sel ^ mult) && (mode_sel == 4)){//if cur &prev are diff
     310:	40 91 33 01 	lds	r20, 0x0133	; 0x800133 <mode_sel>
     314:	50 91 34 01 	lds	r21, 0x0134	; 0x800134 <mode_sel+0x1>
     318:	20 91 37 01 	lds	r18, 0x0137	; 0x800137 <mult>
     31c:	30 91 38 01 	lds	r19, 0x0138	; 0x800138 <mult+0x1>
     320:	42 17       	cp	r20, r18
     322:	53 07       	cpc	r21, r19
     324:	09 f4       	brne	.+2      	; 0x328 <bars+0xd8>
     326:	5a c0       	rjmp	.+180    	; 0x3dc <bars+0x18c>
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
         break;*/
      default:
	 mode_sel = mode_sel;		//no/invalid button press
     328:	90 93 34 01 	sts	0x0134, r25	; 0x800134 <mode_sel+0x1>
     32c:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <mode_sel>
   }   
   mult = 0;				//clear mult for next pass
     330:	10 92 38 01 	sts	0x0138, r1	; 0x800138 <mult+0x1>
     334:	10 92 37 01 	sts	0x0137, r1	; 0x800137 <mult>

   DDRA = 0xFF;				//Set A to alloutputs
     338:	8f ef       	ldi	r24, 0xFF	; 255
     33a:	8a bb       	out	0x1a, r24	; 26
   SPDR = mode_sel;			//Write mode to the Bargraph
     33c:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <mode_sel>
     340:	90 91 34 01 	lds	r25, 0x0134	; 0x800134 <mode_sel+0x1>
     344:	8f b9       	out	0x0f, r24	; 15
   while(bit_is_clear(SPSR, SPIF)){}	
     346:	77 9b       	sbis	0x0e, 7	; 14
     348:	fe cf       	rjmp	.-4      	; 0x346 <bars+0xf6>
   PORTB |= (1<<PB0);			//Rgclk high on bargraph
     34a:	c0 9a       	sbi	0x18, 0	; 24
   PORTB &= 0xFE;			//Rgclk low on bargraph
     34c:	c0 98       	cbi	0x18, 0	; 24
   
return ;
     34e:	08 95       	ret
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
         break;*/
      default:
	 mode_sel = mode_sel;		//no/invalid button press
     350:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <mode_sel>
     354:	90 91 34 01 	lds	r25, 0x0134	; 0x800134 <mode_sel+0x1>
     358:	e7 cf       	rjmp	.-50     	; 0x328 <bars+0xd8>
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
   }
   if(mult == 64){		//Button 7 toggles snooze
      snooze = !(snooze);		//10 second snooze functionality
     35a:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <snooze>
     35e:	81 e0       	ldi	r24, 0x01	; 1
     360:	91 11       	cpse	r25, r1
     362:	45 c0       	rjmp	.+138    	; 0x3ee <bars+0x19e>
     364:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <snooze>
      a_sec_count = sec_count + 10;
     368:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <sec_count>
     36c:	86 5f       	subi	r24, 0xF6	; 246
     36e:	80 93 3f 01 	sts	0x013F, r24	; 0x80013f <a_sec_count>
      if(a_sec_count > 60){
     372:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <a_sec_count>
     376:	8d 33       	cpi	r24, 0x3D	; 61
     378:	08 f4       	brcc	.+2      	; 0x37c <bars+0x12c>
     37a:	b6 cf       	rjmp	.-148    	; 0x2e8 <bars+0x98>
         a_sec_count = a_sec_count % 60;
     37c:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <a_sec_count>
     380:	89 e8       	ldi	r24, 0x89	; 137
     382:	98 9f       	mul	r25, r24
     384:	81 2d       	mov	r24, r1
     386:	11 24       	eor	r1, r1
     388:	82 95       	swap	r24
     38a:	86 95       	lsr	r24
     38c:	87 70       	andi	r24, 0x07	; 7
     38e:	2c e3       	ldi	r18, 0x3C	; 60
     390:	82 9f       	mul	r24, r18
     392:	90 19       	sub	r25, r0
     394:	11 24       	eor	r1, r1
     396:	90 93 3f 01 	sts	0x013F, r25	; 0x80013f <a_sec_count>
	 a_min_count++;
     39a:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <a_min_count>
     39e:	8f 5f       	subi	r24, 0xFF	; 255
     3a0:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <a_min_count>
	 if(a_min_count == 60){
     3a4:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <a_min_count>
     3a8:	8c 33       	cpi	r24, 0x3C	; 60
     3aa:	09 f0       	breq	.+2      	; 0x3ae <bars+0x15e>
     3ac:	9d cf       	rjmp	.-198    	; 0x2e8 <bars+0x98>
	    a_hour_count++;
     3ae:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <a_hour_count>
     3b2:	8f 5f       	subi	r24, 0xFF	; 255
     3b4:	80 93 3d 01 	sts	0x013D, r24	; 0x80013d <a_hour_count>
	    a_min_count = 0;
     3b8:	10 92 3e 01 	sts	0x013E, r1	; 0x80013e <a_min_count>
	    if(a_hour_count == 24){
     3bc:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <a_hour_count>
     3c0:	88 31       	cpi	r24, 0x18	; 24
     3c2:	09 f0       	breq	.+2      	; 0x3c6 <bars+0x176>
     3c4:	91 cf       	rjmp	.-222    	; 0x2e8 <bars+0x98>
	       a_hour_count = 0;
     3c6:	10 92 3d 01 	sts	0x013D, r1	; 0x80013d <a_hour_count>
     3ca:	8e cf       	rjmp	.-228    	; 0x2e8 <bars+0x98>
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
     3cc:	90 91 3b 01 	lds	r25, 0x013B	; 0x80013b <alarm>
     3d0:	81 e0       	ldi	r24, 0x01	; 1
     3d2:	91 11       	cpse	r25, r1
     3d4:	08 c0       	rjmp	.+16     	; 0x3e6 <bars+0x196>
     3d6:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <alarm>
     3da:	7f cf       	rjmp	.-258    	; 0x2da <bars+0x8a>
	 else
	    mode_sel = 1;		//If not, then change mode
         break;
      case 2:
	 if((mode_sel ^ mult) == 0 ){//if((mode_sel ^ mult) && (mode_sel == 4)){//if cur &prev are diff
	    mode_sel = 0;//and prev isn't = 1 then two modes are selected
     3dc:	10 92 34 01 	sts	0x0134, r1	; 0x800134 <mode_sel+0x1>
     3e0:	10 92 33 01 	sts	0x0133, r1	; 0x800133 <mode_sel>
     3e4:	a5 cf       	rjmp	.-182    	; 0x330 <bars+0xe0>
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
     3e6:	80 e0       	ldi	r24, 0x00	; 0
     3e8:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <alarm>
     3ec:	76 cf       	rjmp	.-276    	; 0x2da <bars+0x8a>
   }
   if(mult == 64){		//Button 7 toggles snooze
      snooze = !(snooze);		//10 second snooze functionality
     3ee:	80 e0       	ldi	r24, 0x00	; 0
     3f0:	b9 cf       	rjmp	.-142    	; 0x364 <bars+0x114>

000003f2 <read_encoder>:
   int8_t value = 0x00;
   uint8_t ec_a;
   uint8_t ec_b;

   //Shift_LD_N low
   PORTE &= 0x00;	//Begining of SHIFT_LD_N pulse. It is low here
     3f2:	83 b1       	in	r24, 0x03	; 3
     3f4:	13 b8       	out	0x03, r1	; 3
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     3f6:	87 ec       	ldi	r24, 0xC7	; 199
     3f8:	90 e0       	ldi	r25, 0x00	; 0
     3fa:	01 97       	sbiw	r24, 0x01	; 1
     3fc:	f1 f7       	brne	.-4      	; 0x3fa <read_encoder+0x8>
     3fe:	00 c0       	rjmp	.+0      	; 0x400 <__LOCK_REGION_LENGTH__>
     400:	00 00       	nop
   _delay_us(50);
   PORTE |= 0xFF;	//End of SHIFT_LD_N pulse. back to high
     402:	83 b1       	in	r24, 0x03	; 3
     404:	8f ef       	ldi	r24, 0xFF	; 255
     406:	83 b9       	out	0x03, r24	; 3
   PORTD &= 0x0F;	//CLK_INH low
     408:	82 b3       	in	r24, 0x12	; 18
     40a:	8f 70       	andi	r24, 0x0F	; 15
     40c:	82 bb       	out	0x12, r24	; 18
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
     40e:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
     410:	77 9b       	sbis	0x0e, 7	; 14
     412:	fe cf       	rjmp	.-4      	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
   return SPDR;
     414:	9f b1       	in	r25, 0x0f	; 15
   _delay_us(50);
   PORTE |= 0xFF;	//End of SHIFT_LD_N pulse. back to high
   PORTD &= 0x0F;	//CLK_INH low

   encoder_value = spi_read();
   PORTD |= 0xF0;	//CLK_INH high
     416:	82 b3       	in	r24, 0x12	; 18
     418:	80 6f       	ori	r24, 0xF0	; 240
     41a:	82 bb       	out	0x12, r24	; 18
   value = mode_sel;
     41c:	20 91 33 01 	lds	r18, 0x0133	; 0x800133 <mode_sel>
     420:	30 91 34 01 	lds	r19, 0x0134	; 0x800134 <mode_sel+0x1>
     424:	82 2f       	mov	r24, r18
   ec_a = encoder_value & 0x03;  //Only grabs these bits 0000_0011
     426:	69 2f       	mov	r22, r25
     428:	63 70       	andi	r22, 0x03	; 3
   ec_b = encoder_value & 0x0C;  //Only grabs these bits 0000_1100 
     42a:	9c 70       	andi	r25, 0x0C	; 12
   ec_b = (ec_b >> 2);
     42c:	96 95       	lsr	r25
     42e:	96 95       	lsr	r25

//mode_sel == 0 means that no mode has been selected and the speaker volume can be adjusted
   if(mode_sel == 0){
     430:	20 91 33 01 	lds	r18, 0x0133	; 0x800133 <mode_sel>
     434:	30 91 34 01 	lds	r19, 0x0134	; 0x800134 <mode_sel+0x1>
     438:	23 2b       	or	r18, r19
     43a:	09 f5       	brne	.+66     	; 0x47e <__LOCK_REGION_LENGTH__+0x7e>
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     43c:	20 91 58 01 	lds	r18, 0x0158	; 0x800158 <EC_a_prev>
     440:	46 2f       	mov	r20, r22
     442:	50 e0       	ldi	r21, 0x00	; 0
     444:	02 2e       	mov	r0, r18
     446:	00 0c       	add	r0, r0
     448:	33 0b       	sbc	r19, r19
     44a:	42 17       	cp	r20, r18
     44c:	53 07       	cpc	r21, r19
     44e:	b9 f0       	breq	.+46     	; 0x47e <__LOCK_REGION_LENGTH__+0x7e>
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     450:	20 91 58 01 	lds	r18, 0x0158	; 0x800158 <EC_a_prev>
     454:	21 11       	cpse	r18, r1
     456:	26 c0       	rjmp	.+76     	; 0x4a4 <__LOCK_REGION_LENGTH__+0xa4>
     458:	61 30       	cpi	r22, 0x01	; 1
     45a:	21 f5       	brne	.+72     	; 0x4a4 <__LOCK_REGION_LENGTH__+0xa4>
            volume += 10;	//increment volume
     45c:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     460:	26 5f       	subi	r18, 0xF6	; 246
     462:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <volume>
	    if(volume <= 0x9F){
     466:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     46a:	20 3a       	cpi	r18, 0xA0	; 160
     46c:	08 f0       	brcs	.+2      	; 0x470 <__LOCK_REGION_LENGTH__+0x70>
     46e:	e5 c0       	rjmp	.+458    	; 0x63a <__LOCK_REGION_LENGTH__+0x23a>
	    }
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
	    volume -= 10;	//decrement volume 
	    if(volume >= 0x00){
		OCR3A = volume;	//minimum volume
     470:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     474:	30 e0       	ldi	r19, 0x00	; 0
     476:	30 93 87 00 	sts	0x0087, r19	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     47a:	20 93 86 00 	sts	0x0086, r18	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
	    value = 0;
      }*/
   }

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
     47e:	20 91 33 01 	lds	r18, 0x0133	; 0x800133 <mode_sel>
     482:	30 91 34 01 	lds	r19, 0x0134	; 0x800134 <mode_sel+0x1>
     486:	21 30       	cpi	r18, 0x01	; 1
     488:	31 05       	cpc	r19, r1
     48a:	f1 f0       	breq	.+60     	; 0x4c8 <__LOCK_REGION_LENGTH__+0xc8>
         else
	    value = 0;
      }
   }
//mode_sel == 2 means that the user has selected the "alarm time change" mode
   if(mode_sel == 2){
     48c:	20 91 33 01 	lds	r18, 0x0133	; 0x800133 <mode_sel>
     490:	30 91 34 01 	lds	r19, 0x0134	; 0x800134 <mode_sel+0x1>
     494:	22 30       	cpi	r18, 0x02	; 2
     496:	31 05       	cpc	r19, r1
     498:	b1 f1       	breq	.+108    	; 0x506 <__LOCK_REGION_LENGTH__+0x106>
         else
	    value = 0;
      }
   }
//Saves previous values into volatile variables
EC_a_prev = ec_a;
     49a:	60 93 58 01 	sts	0x0158, r22	; 0x800158 <EC_a_prev>
EC_b_prev = ec_b;
     49e:	90 93 57 01 	sts	0x0157, r25	; 0x800157 <EC_b_prev>

return value;
}
     4a2:	08 95       	ret
	    else {
		volume = 0x9F;
		OCR3A = 0x9F;
	    }
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     4a4:	20 91 58 01 	lds	r18, 0x0158	; 0x800158 <EC_a_prev>
     4a8:	21 11       	cpse	r18, r1
     4aa:	03 c0       	rjmp	.+6      	; 0x4b2 <__LOCK_REGION_LENGTH__+0xb2>
     4ac:	62 30       	cpi	r22, 0x02	; 2
     4ae:	09 f4       	brne	.+2      	; 0x4b2 <__LOCK_REGION_LENGTH__+0xb2>
     4b0:	af c0       	rjmp	.+350    	; 0x610 <__LOCK_REGION_LENGTH__+0x210>
		volume = 0x00;
		OCR3A = 0x00;
	    }
         }
         else	//If not one of the state changes above, do nothing
	 volume = volume;
     4b2:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     4b6:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <volume>
	    value = 0;
      }*/
   }

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
     4ba:	20 91 33 01 	lds	r18, 0x0133	; 0x800133 <mode_sel>
     4be:	30 91 34 01 	lds	r19, 0x0134	; 0x800134 <mode_sel+0x1>
     4c2:	21 30       	cpi	r18, 0x01	; 1
     4c4:	31 05       	cpc	r19, r1
     4c6:	11 f7       	brne	.-60     	; 0x48c <__LOCK_REGION_LENGTH__+0x8c>
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     4c8:	20 91 58 01 	lds	r18, 0x0158	; 0x800158 <EC_a_prev>
     4cc:	46 2f       	mov	r20, r22
     4ce:	50 e0       	ldi	r21, 0x00	; 0
     4d0:	02 2e       	mov	r0, r18
     4d2:	00 0c       	add	r0, r0
     4d4:	33 0b       	sbc	r19, r19
     4d6:	42 17       	cp	r20, r18
     4d8:	53 07       	cpc	r21, r19
     4da:	09 f4       	brne	.+2      	; 0x4de <__LOCK_REGION_LENGTH__+0xde>
     4dc:	5a c0       	rjmp	.+180    	; 0x592 <__LOCK_REGION_LENGTH__+0x192>
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     4de:	20 91 58 01 	lds	r18, 0x0158	; 0x800158 <EC_a_prev>
     4e2:	22 23       	and	r18, r18
     4e4:	09 f4       	brne	.+2      	; 0x4e8 <__LOCK_REGION_LENGTH__+0xe8>
     4e6:	47 c0       	rjmp	.+142    	; 0x576 <__LOCK_REGION_LENGTH__+0x176>
            hour_count = hour_count + 1;//value = value;
	    if(hour_count == 24)
	       hour_count = 0;
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     4e8:	20 91 58 01 	lds	r18, 0x0158	; 0x800158 <EC_a_prev>
     4ec:	21 11       	cpse	r18, r1
     4ee:	03 c0       	rjmp	.+6      	; 0x4f6 <__LOCK_REGION_LENGTH__+0xf6>
     4f0:	62 30       	cpi	r22, 0x02	; 2
     4f2:	09 f4       	brne	.+2      	; 0x4f6 <__LOCK_REGION_LENGTH__+0xf6>
     4f4:	80 c0       	rjmp	.+256    	; 0x5f6 <__LOCK_REGION_LENGTH__+0x1f6>
	    hour_count = hour_count - 1;//value = -(value);
	    if(hour_count < 0)
	       hour_count = 23; 
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
     4f6:	80 e0       	ldi	r24, 0x00	; 0
         else
	    value = 0;
      }
   }
//mode_sel == 2 means that the user has selected the "alarm time change" mode
   if(mode_sel == 2){
     4f8:	20 91 33 01 	lds	r18, 0x0133	; 0x800133 <mode_sel>
     4fc:	30 91 34 01 	lds	r19, 0x0134	; 0x800134 <mode_sel+0x1>
     500:	22 30       	cpi	r18, 0x02	; 2
     502:	31 05       	cpc	r19, r1
     504:	51 f6       	brne	.-108    	; 0x49a <__LOCK_REGION_LENGTH__+0x9a>
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     506:	20 91 58 01 	lds	r18, 0x0158	; 0x800158 <EC_a_prev>
     50a:	46 2f       	mov	r20, r22
     50c:	50 e0       	ldi	r21, 0x00	; 0
     50e:	02 2e       	mov	r0, r18
     510:	00 0c       	add	r0, r0
     512:	33 0b       	sbc	r19, r19
     514:	42 17       	cp	r20, r18
     516:	53 07       	cpc	r21, r19
     518:	d1 f0       	breq	.+52     	; 0x54e <__LOCK_REGION_LENGTH__+0x14e>
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     51a:	20 91 58 01 	lds	r18, 0x0158	; 0x800158 <EC_a_prev>
     51e:	21 11       	cpse	r18, r1
     520:	03 c0       	rjmp	.+6      	; 0x528 <__LOCK_REGION_LENGTH__+0x128>
     522:	61 30       	cpi	r22, 0x01	; 1
     524:	09 f4       	brne	.+2      	; 0x528 <__LOCK_REGION_LENGTH__+0x128>
     526:	7c c0       	rjmp	.+248    	; 0x620 <__LOCK_REGION_LENGTH__+0x220>
            a_hour_count = a_hour_count + 1;//value = value;
	    if(a_hour_count == 24)
	       a_hour_count = 0;
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     528:	20 91 58 01 	lds	r18, 0x0158	; 0x800158 <EC_a_prev>
     52c:	21 11       	cpse	r18, r1
     52e:	1d c0       	rjmp	.+58     	; 0x56a <__LOCK_REGION_LENGTH__+0x16a>
     530:	62 30       	cpi	r22, 0x02	; 2
     532:	d9 f4       	brne	.+54     	; 0x56a <__LOCK_REGION_LENGTH__+0x16a>
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
	    a_min_count = a_min_count - 1; //value = -(value);
	    if(a_min_count < 0){
	       a_min_count = 59;
	       a_hour_count--;
     534:	20 91 3d 01 	lds	r18, 0x013D	; 0x80013d <a_hour_count>
     538:	21 50       	subi	r18, 0x01	; 1
     53a:	20 93 3d 01 	sts	0x013D, r18	; 0x80013d <a_hour_count>
	       if(a_hour_count < 0){
     53e:	20 91 3d 01 	lds	r18, 0x013D	; 0x80013d <a_hour_count>
     542:	27 ff       	sbrs	r18, 7
     544:	aa cf       	rjmp	.-172    	; 0x49a <__LOCK_REGION_LENGTH__+0x9a>
	          a_hour_count = 23;
     546:	27 e1       	ldi	r18, 0x17	; 23
     548:	20 93 3d 01 	sts	0x013D, r18	; 0x80013d <a_hour_count>
     54c:	a6 cf       	rjmp	.-180    	; 0x49a <__LOCK_REGION_LENGTH__+0x9a>
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
     54e:	20 91 57 01 	lds	r18, 0x0157	; 0x800157 <EC_b_prev>
     552:	21 11       	cpse	r18, r1
     554:	03 c0       	rjmp	.+6      	; 0x55c <__LOCK_REGION_LENGTH__+0x15c>
     556:	91 30       	cpi	r25, 0x01	; 1
     558:	09 f4       	brne	.+2      	; 0x55c <__LOCK_REGION_LENGTH__+0x15c>
     55a:	86 c0       	rjmp	.+268    	; 0x668 <__LOCK_REGION_LENGTH__+0x268>
	       a_hour_count++;
	       if(a_hour_count > 23)
	          a_hour_count = 0;
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
     55c:	20 91 57 01 	lds	r18, 0x0157	; 0x800157 <EC_b_prev>
     560:	21 11       	cpse	r18, r1
     562:	03 c0       	rjmp	.+6      	; 0x56a <__LOCK_REGION_LENGTH__+0x16a>
     564:	92 30       	cpi	r25, 0x02	; 2
     566:	09 f4       	brne	.+2      	; 0x56a <__LOCK_REGION_LENGTH__+0x16a>
     568:	72 c0       	rjmp	.+228    	; 0x64e <__LOCK_REGION_LENGTH__+0x24e>
	    a_hour_count = a_hour_count - 1;//value = -(value);
	    if(a_hour_count < 0)
	       a_hour_count = 23; 
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
     56a:	80 e0       	ldi	r24, 0x00	; 0
         else
	    value = 0;
      }
   }
//Saves previous values into volatile variables
EC_a_prev = ec_a;
     56c:	60 93 58 01 	sts	0x0158, r22	; 0x800158 <EC_a_prev>
EC_b_prev = ec_b;
     570:	90 93 57 01 	sts	0x0157, r25	; 0x800157 <EC_b_prev>

return value;
}
     574:	08 95       	ret
   }

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     576:	61 30       	cpi	r22, 0x01	; 1
     578:	09 f0       	breq	.+2      	; 0x57c <__LOCK_REGION_LENGTH__+0x17c>
     57a:	b6 cf       	rjmp	.-148    	; 0x4e8 <__LOCK_REGION_LENGTH__+0xe8>
            hour_count = hour_count + 1;//value = value;
     57c:	20 91 40 01 	lds	r18, 0x0140	; 0x800140 <hour_count>
     580:	2f 5f       	subi	r18, 0xFF	; 255
     582:	20 93 40 01 	sts	0x0140, r18	; 0x800140 <hour_count>
	    if(hour_count == 24)
     586:	20 91 40 01 	lds	r18, 0x0140	; 0x800140 <hour_count>
     58a:	28 31       	cpi	r18, 0x18	; 24
     58c:	09 f0       	breq	.+2      	; 0x590 <__LOCK_REGION_LENGTH__+0x190>
     58e:	7e cf       	rjmp	.-260    	; 0x48c <__LOCK_REGION_LENGTH__+0x8c>
     590:	1c c0       	rjmp	.+56     	; 0x5ca <__LOCK_REGION_LENGTH__+0x1ca>
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
     592:	20 91 57 01 	lds	r18, 0x0157	; 0x800157 <EC_b_prev>
     596:	21 11       	cpse	r18, r1
     598:	1b c0       	rjmp	.+54     	; 0x5d0 <__LOCK_REGION_LENGTH__+0x1d0>
     59a:	91 30       	cpi	r25, 0x01	; 1
     59c:	c9 f4       	brne	.+50     	; 0x5d0 <__LOCK_REGION_LENGTH__+0x1d0>
            min_count = min_count + 1;//value = value;
     59e:	20 91 41 01 	lds	r18, 0x0141	; 0x800141 <min_count>
     5a2:	2f 5f       	subi	r18, 0xFF	; 255
     5a4:	20 93 41 01 	sts	0x0141, r18	; 0x800141 <min_count>
	    if(min_count == 60){
     5a8:	20 91 41 01 	lds	r18, 0x0141	; 0x800141 <min_count>
     5ac:	2c 33       	cpi	r18, 0x3C	; 60
     5ae:	09 f0       	breq	.+2      	; 0x5b2 <__LOCK_REGION_LENGTH__+0x1b2>
     5b0:	6d cf       	rjmp	.-294    	; 0x48c <__LOCK_REGION_LENGTH__+0x8c>
	       min_count = 0; 
     5b2:	10 92 41 01 	sts	0x0141, r1	; 0x800141 <min_count>
	       hour_count++;
     5b6:	20 91 40 01 	lds	r18, 0x0140	; 0x800140 <hour_count>
     5ba:	2f 5f       	subi	r18, 0xFF	; 255
     5bc:	20 93 40 01 	sts	0x0140, r18	; 0x800140 <hour_count>
	       if(hour_count > 23)
     5c0:	20 91 40 01 	lds	r18, 0x0140	; 0x800140 <hour_count>
     5c4:	28 31       	cpi	r18, 0x18	; 24
     5c6:	0c f4       	brge	.+2      	; 0x5ca <__LOCK_REGION_LENGTH__+0x1ca>
     5c8:	61 cf       	rjmp	.-318    	; 0x48c <__LOCK_REGION_LENGTH__+0x8c>
	          hour_count = 0;
     5ca:	10 92 40 01 	sts	0x0140, r1	; 0x800140 <hour_count>
     5ce:	5e cf       	rjmp	.-324    	; 0x48c <__LOCK_REGION_LENGTH__+0x8c>
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
     5d0:	20 91 57 01 	lds	r18, 0x0157	; 0x800157 <EC_b_prev>
     5d4:	21 11       	cpse	r18, r1
     5d6:	8f cf       	rjmp	.-226    	; 0x4f6 <__LOCK_REGION_LENGTH__+0xf6>
     5d8:	92 30       	cpi	r25, 0x02	; 2
     5da:	09 f0       	breq	.+2      	; 0x5de <__LOCK_REGION_LENGTH__+0x1de>
     5dc:	8c cf       	rjmp	.-232    	; 0x4f6 <__LOCK_REGION_LENGTH__+0xf6>
	    min_count = min_count - 1; //value = -(value);
     5de:	20 91 41 01 	lds	r18, 0x0141	; 0x800141 <min_count>
     5e2:	21 50       	subi	r18, 0x01	; 1
     5e4:	20 93 41 01 	sts	0x0141, r18	; 0x800141 <min_count>
	    if(min_count < 0){
     5e8:	20 91 41 01 	lds	r18, 0x0141	; 0x800141 <min_count>
     5ec:	27 ff       	sbrs	r18, 7
     5ee:	4e cf       	rjmp	.-356    	; 0x48c <__LOCK_REGION_LENGTH__+0x8c>
	       min_count = 59;
     5f0:	2b e3       	ldi	r18, 0x3B	; 59
     5f2:	20 93 41 01 	sts	0x0141, r18	; 0x800141 <min_count>
	       hour_count--;
     5f6:	20 91 40 01 	lds	r18, 0x0140	; 0x800140 <hour_count>
     5fa:	21 50       	subi	r18, 0x01	; 1
     5fc:	20 93 40 01 	sts	0x0140, r18	; 0x800140 <hour_count>
	       if(hour_count < 0){
     600:	20 91 40 01 	lds	r18, 0x0140	; 0x800140 <hour_count>
     604:	27 ff       	sbrs	r18, 7
     606:	42 cf       	rjmp	.-380    	; 0x48c <__LOCK_REGION_LENGTH__+0x8c>
	          hour_count = 23;
     608:	27 e1       	ldi	r18, 0x17	; 23
     60a:	20 93 40 01 	sts	0x0140, r18	; 0x800140 <hour_count>
     60e:	3e cf       	rjmp	.-388    	; 0x48c <__LOCK_REGION_LENGTH__+0x8c>
		volume = 0x9F;
		OCR3A = 0x9F;
	    }
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
	    volume -= 10;	//decrement volume 
     610:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     614:	2a 50       	subi	r18, 0x0A	; 10
     616:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <volume>
	    if(volume >= 0x00){
     61a:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <volume>
     61e:	28 cf       	rjmp	.-432    	; 0x470 <__LOCK_REGION_LENGTH__+0x70>
   }
//mode_sel == 2 means that the user has selected the "alarm time change" mode
   if(mode_sel == 2){
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
            a_hour_count = a_hour_count + 1;//value = value;
     620:	20 91 3d 01 	lds	r18, 0x013D	; 0x80013d <a_hour_count>
     624:	2f 5f       	subi	r18, 0xFF	; 255
     626:	20 93 3d 01 	sts	0x013D, r18	; 0x80013d <a_hour_count>
	    if(a_hour_count == 24)
     62a:	20 91 3d 01 	lds	r18, 0x013D	; 0x80013d <a_hour_count>
     62e:	28 31       	cpi	r18, 0x18	; 24
     630:	09 f0       	breq	.+2      	; 0x634 <__LOCK_REGION_LENGTH__+0x234>
     632:	33 cf       	rjmp	.-410    	; 0x49a <__LOCK_REGION_LENGTH__+0x9a>
            a_min_count = a_min_count + 1;//value = value;
	    if(a_min_count == 60){
	       a_min_count = 0; 
	       a_hour_count++;
	       if(a_hour_count > 23)
	          a_hour_count = 0;
     634:	10 92 3d 01 	sts	0x013D, r1	; 0x80013d <a_hour_count>
     638:	30 cf       	rjmp	.-416    	; 0x49a <__LOCK_REGION_LENGTH__+0x9a>
            volume += 10;	//increment volume
	    if(volume <= 0x9F){
		OCR3A = volume;	//maximum volume
	    }
	    else {
		volume = 0x9F;
     63a:	2f e9       	ldi	r18, 0x9F	; 159
     63c:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <volume>
		OCR3A = 0x9F;
     640:	2f e9       	ldi	r18, 0x9F	; 159
     642:	30 e0       	ldi	r19, 0x00	; 0
     644:	30 93 87 00 	sts	0x0087, r19	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     648:	20 93 86 00 	sts	0x0086, r18	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
     64c:	18 cf       	rjmp	.-464    	; 0x47e <__LOCK_REGION_LENGTH__+0x7e>
	       if(a_hour_count > 23)
	          a_hour_count = 0;
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
	    a_min_count = a_min_count - 1; //value = -(value);
     64e:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <a_min_count>
     652:	21 50       	subi	r18, 0x01	; 1
     654:	20 93 3e 01 	sts	0x013E, r18	; 0x80013e <a_min_count>
	    if(a_min_count < 0){
     658:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <a_min_count>
     65c:	27 ff       	sbrs	r18, 7
     65e:	1d cf       	rjmp	.-454    	; 0x49a <__LOCK_REGION_LENGTH__+0x9a>
	       a_min_count = 59;
     660:	2b e3       	ldi	r18, 0x3B	; 59
     662:	20 93 3e 01 	sts	0x013E, r18	; 0x80013e <a_min_count>
     666:	66 cf       	rjmp	.-308    	; 0x534 <__LOCK_REGION_LENGTH__+0x134>
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
            a_min_count = a_min_count + 1;//value = value;
     668:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <a_min_count>
     66c:	2f 5f       	subi	r18, 0xFF	; 255
     66e:	20 93 3e 01 	sts	0x013E, r18	; 0x80013e <a_min_count>
	    if(a_min_count == 60){
     672:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <a_min_count>
     676:	2c 33       	cpi	r18, 0x3C	; 60
     678:	09 f0       	breq	.+2      	; 0x67c <__LOCK_REGION_LENGTH__+0x27c>
     67a:	0f cf       	rjmp	.-482    	; 0x49a <__LOCK_REGION_LENGTH__+0x9a>
	       a_min_count = 0; 
     67c:	10 92 3e 01 	sts	0x013E, r1	; 0x80013e <a_min_count>
	       a_hour_count++;
     680:	20 91 3d 01 	lds	r18, 0x013D	; 0x80013d <a_hour_count>
     684:	2f 5f       	subi	r18, 0xFF	; 255
     686:	20 93 3d 01 	sts	0x013D, r18	; 0x80013d <a_hour_count>
	       if(a_hour_count > 23)
     68a:	20 91 3d 01 	lds	r18, 0x013D	; 0x80013d <a_hour_count>
     68e:	28 31       	cpi	r18, 0x18	; 24
     690:	0c f4       	brge	.+2      	; 0x694 <__LOCK_REGION_LENGTH__+0x294>
     692:	03 cf       	rjmp	.-506    	; 0x49a <__LOCK_REGION_LENGTH__+0x9a>
     694:	cf cf       	rjmp	.-98     	; 0x634 <__LOCK_REGION_LENGTH__+0x234>

00000696 <__vector_16>:
	update the mode and bargraph. Then I change the sum based on	
	the value returned from the encoder reading. Sum is then bounded
	from 0-1023. 1023+1=1 and 0-any number > 0 = 1023.
Parameters: NA
**********************************************************************/
ISR(TIMER0_OVF_vect) { 
     696:	1f 92       	push	r1
     698:	0f 92       	push	r0
     69a:	0f b6       	in	r0, 0x3f	; 63
     69c:	0f 92       	push	r0
     69e:	11 24       	eor	r1, r1
     6a0:	0b b6       	in	r0, 0x3b	; 59
     6a2:	0f 92       	push	r0
     6a4:	2f 93       	push	r18
     6a6:	3f 93       	push	r19
     6a8:	4f 93       	push	r20
     6aa:	5f 93       	push	r21
     6ac:	6f 93       	push	r22
     6ae:	7f 93       	push	r23
     6b0:	8f 93       	push	r24
     6b2:	9f 93       	push	r25
     6b4:	af 93       	push	r26
     6b6:	bf 93       	push	r27
     6b8:	ef 93       	push	r30
     6ba:	ff 93       	push	r31
   static uint8_t count_7_8125ms = 0;

   count_7_8125ms++;
     6bc:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <count_7_8125ms.2040>
     6c0:	8f 5f       	subi	r24, 0xFF	; 255
     6c2:	80 93 44 01 	sts	0x0144, r24	; 0x800144 <count_7_8125ms.2040>
   if((count_7_8125ms % 128) == 0) { //interrupts every 1 second
     6c6:	8f 77       	andi	r24, 0x7F	; 127
     6c8:	29 f4       	brne	.+10     	; 0x6d4 <__vector_16+0x3e>
      sec_count++;
     6ca:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <sec_count>
     6ce:	8f 5f       	subi	r24, 0xFF	; 255
     6d0:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <sec_count>
   }
   bars();  
     6d4:	0e 94 28 01 	call	0x250	; 0x250 <bars>
   read_encoder();      
     6d8:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <read_encoder>

}
     6dc:	ff 91       	pop	r31
     6de:	ef 91       	pop	r30
     6e0:	bf 91       	pop	r27
     6e2:	af 91       	pop	r26
     6e4:	9f 91       	pop	r25
     6e6:	8f 91       	pop	r24
     6e8:	7f 91       	pop	r23
     6ea:	6f 91       	pop	r22
     6ec:	5f 91       	pop	r21
     6ee:	4f 91       	pop	r20
     6f0:	3f 91       	pop	r19
     6f2:	2f 91       	pop	r18
     6f4:	0f 90       	pop	r0
     6f6:	0b be       	out	0x3b, r0	; 59
     6f8:	0f 90       	pop	r0
     6fa:	0f be       	out	0x3f, r0	; 63
     6fc:	0f 90       	pop	r0
     6fe:	1f 90       	pop	r1
     700:	18 95       	reti

00000702 <clock_time>:
	selected alarm time or normal time is displayed.
Parameters: NA
**********************************************************************/
void clock_time(){ //by default we use military time
//This block is used to increment the time based on an increasing seconds count   
   if(sec_count == 60){
     702:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <sec_count>
     706:	8c 33       	cpi	r24, 0x3C	; 60
     708:	09 f4       	brne	.+2      	; 0x70c <clock_time+0xa>
     70a:	a4 c0       	rjmp	.+328    	; 0x854 <clock_time+0x152>
	 }//hours	
      }//mins
   }//secs

//This is where the digits are written to the data array
      if(mode_sel == 2){	//display alarm time
     70c:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <mode_sel>
     710:	90 91 34 01 	lds	r25, 0x0134	; 0x800134 <mode_sel+0x1>
     714:	02 97       	sbiw	r24, 0x02	; 2
     716:	09 f4       	brne	.+2      	; 0x71a <clock_time+0x18>
     718:	5a c0       	rjmp	.+180    	; 0x7ce <clock_time+0xcc>
         else {segment_data[2] = 0b111;}		//Turn colon off
         segment_data[1] = dec_to_7seg[a_min_count/10];
         segment_data[0] = dec_to_7seg[a_min_count%10];
      }
      else{			//display military time
         segment_data[4] = dec_to_7seg[hour_count/10];
     71a:	90 91 40 01 	lds	r25, 0x0140	; 0x800140 <hour_count>
     71e:	87 e6       	ldi	r24, 0x67	; 103
     720:	98 02       	muls	r25, r24
     722:	e1 2d       	mov	r30, r1
     724:	11 24       	eor	r1, r1
     726:	e5 95       	asr	r30
     728:	e5 95       	asr	r30
     72a:	97 fd       	sbrc	r25, 7
     72c:	e3 95       	inc	r30
     72e:	0e 2e       	mov	r0, r30
     730:	00 0c       	add	r0, r0
     732:	ff 0b       	sbc	r31, r31
     734:	e0 50       	subi	r30, 0x00	; 0
     736:	ff 4f       	sbci	r31, 0xFF	; 255
     738:	90 81       	ld	r25, Z
     73a:	90 93 32 01 	sts	0x0132, r25	; 0x800132 <__data_end+0x4>
         segment_data[3] = dec_to_7seg[hour_count%10];
     73e:	e0 91 40 01 	lds	r30, 0x0140	; 0x800140 <hour_count>
     742:	e8 02       	muls	r30, r24
     744:	81 2d       	mov	r24, r1
     746:	11 24       	eor	r1, r1
     748:	85 95       	asr	r24
     74a:	85 95       	asr	r24
     74c:	e7 fd       	sbrc	r30, 7
     74e:	83 95       	inc	r24
     750:	9a e0       	ldi	r25, 0x0A	; 10
     752:	89 9f       	mul	r24, r25
     754:	e0 19       	sub	r30, r0
     756:	11 24       	eor	r1, r1
     758:	0e 2e       	mov	r0, r30
     75a:	00 0c       	add	r0, r0
     75c:	ff 0b       	sbc	r31, r31
     75e:	e0 50       	subi	r30, 0x00	; 0
     760:	ff 4f       	sbci	r31, 0xFF	; 255
     762:	80 81       	ld	r24, Z
     764:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__data_end+0x3>
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     768:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <sec_count>
     76c:	80 fd       	sbrc	r24, 0
     76e:	2b c0       	rjmp	.+86     	; 0x7c6 <clock_time+0xc4>
         else {segment_data[2] = 0b111;}		//Turn colon off
     770:	87 e0       	ldi	r24, 0x07	; 7
     772:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__data_end+0x2>
         segment_data[1] = dec_to_7seg[min_count/10];
     776:	90 91 41 01 	lds	r25, 0x0141	; 0x800141 <min_count>
     77a:	87 e6       	ldi	r24, 0x67	; 103
     77c:	98 02       	muls	r25, r24
     77e:	e1 2d       	mov	r30, r1
     780:	11 24       	eor	r1, r1
     782:	e5 95       	asr	r30
     784:	e5 95       	asr	r30
     786:	97 fd       	sbrc	r25, 7
     788:	e3 95       	inc	r30
     78a:	0e 2e       	mov	r0, r30
     78c:	00 0c       	add	r0, r0
     78e:	ff 0b       	sbc	r31, r31
     790:	e0 50       	subi	r30, 0x00	; 0
     792:	ff 4f       	sbci	r31, 0xFF	; 255
     794:	90 81       	ld	r25, Z
     796:	90 93 2f 01 	sts	0x012F, r25	; 0x80012f <__data_end+0x1>
         segment_data[0] = dec_to_7seg[min_count%10];
     79a:	e0 91 41 01 	lds	r30, 0x0141	; 0x800141 <min_count>
     79e:	e8 02       	muls	r30, r24
     7a0:	81 2d       	mov	r24, r1
     7a2:	11 24       	eor	r1, r1
     7a4:	85 95       	asr	r24
     7a6:	85 95       	asr	r24
     7a8:	e7 fd       	sbrc	r30, 7
     7aa:	83 95       	inc	r24
     7ac:	9a e0       	ldi	r25, 0x0A	; 10
     7ae:	89 9f       	mul	r24, r25
     7b0:	e0 19       	sub	r30, r0
     7b2:	11 24       	eor	r1, r1
     7b4:	0e 2e       	mov	r0, r30
     7b6:	00 0c       	add	r0, r0
     7b8:	ff 0b       	sbc	r31, r31
     7ba:	e0 50       	subi	r30, 0x00	; 0
     7bc:	ff 4f       	sbci	r31, 0xFF	; 255
     7be:	80 81       	ld	r24, Z
     7c0:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <__data_end>
     7c4:	08 95       	ret
         segment_data[0] = dec_to_7seg[a_min_count%10];
      }
      else{			//display military time
         segment_data[4] = dec_to_7seg[hour_count/10];
         segment_data[3] = dec_to_7seg[hour_count%10];
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     7c6:	84 e0       	ldi	r24, 0x04	; 4
     7c8:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__data_end+0x2>
     7cc:	d4 cf       	rjmp	.-88     	; 0x776 <clock_time+0x74>
      }//mins
   }//secs

//This is where the digits are written to the data array
      if(mode_sel == 2){	//display alarm time
         segment_data[4] = dec_to_7seg[a_hour_count/10];
     7ce:	90 91 3d 01 	lds	r25, 0x013D	; 0x80013d <a_hour_count>
     7d2:	87 e6       	ldi	r24, 0x67	; 103
     7d4:	98 02       	muls	r25, r24
     7d6:	e1 2d       	mov	r30, r1
     7d8:	11 24       	eor	r1, r1
     7da:	e5 95       	asr	r30
     7dc:	e5 95       	asr	r30
     7de:	97 fd       	sbrc	r25, 7
     7e0:	e3 95       	inc	r30
     7e2:	0e 2e       	mov	r0, r30
     7e4:	00 0c       	add	r0, r0
     7e6:	ff 0b       	sbc	r31, r31
     7e8:	e0 50       	subi	r30, 0x00	; 0
     7ea:	ff 4f       	sbci	r31, 0xFF	; 255
     7ec:	90 81       	ld	r25, Z
     7ee:	90 93 32 01 	sts	0x0132, r25	; 0x800132 <__data_end+0x4>
         segment_data[3] = dec_to_7seg[a_hour_count%10];
     7f2:	e0 91 3d 01 	lds	r30, 0x013D	; 0x80013d <a_hour_count>
     7f6:	e8 02       	muls	r30, r24
     7f8:	81 2d       	mov	r24, r1
     7fa:	11 24       	eor	r1, r1
     7fc:	85 95       	asr	r24
     7fe:	85 95       	asr	r24
     800:	e7 fd       	sbrc	r30, 7
     802:	83 95       	inc	r24
     804:	9a e0       	ldi	r25, 0x0A	; 10
     806:	89 9f       	mul	r24, r25
     808:	e0 19       	sub	r30, r0
     80a:	11 24       	eor	r1, r1
     80c:	0e 2e       	mov	r0, r30
     80e:	00 0c       	add	r0, r0
     810:	ff 0b       	sbc	r31, r31
     812:	e0 50       	subi	r30, 0x00	; 0
     814:	ff 4f       	sbci	r31, 0xFF	; 255
     816:	80 81       	ld	r24, Z
     818:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__data_end+0x3>
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     81c:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <sec_count>
     820:	80 fd       	sbrc	r24, 0
     822:	33 c0       	rjmp	.+102    	; 0x88a <clock_time+0x188>
         else {segment_data[2] = 0b111;}		//Turn colon off
     824:	87 e0       	ldi	r24, 0x07	; 7
     826:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__data_end+0x2>
         segment_data[1] = dec_to_7seg[a_min_count/10];
     82a:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <a_min_count>
     82e:	87 e6       	ldi	r24, 0x67	; 103
     830:	98 02       	muls	r25, r24
     832:	e1 2d       	mov	r30, r1
     834:	11 24       	eor	r1, r1
     836:	e5 95       	asr	r30
     838:	e5 95       	asr	r30
     83a:	97 fd       	sbrc	r25, 7
     83c:	e3 95       	inc	r30
     83e:	0e 2e       	mov	r0, r30
     840:	00 0c       	add	r0, r0
     842:	ff 0b       	sbc	r31, r31
     844:	e0 50       	subi	r30, 0x00	; 0
     846:	ff 4f       	sbci	r31, 0xFF	; 255
     848:	90 81       	ld	r25, Z
     84a:	90 93 2f 01 	sts	0x012F, r25	; 0x80012f <__data_end+0x1>
         segment_data[0] = dec_to_7seg[a_min_count%10];
     84e:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <a_min_count>
     852:	a5 cf       	rjmp	.-182    	; 0x79e <clock_time+0x9c>
Parameters: NA
**********************************************************************/
void clock_time(){ //by default we use military time
//This block is used to increment the time based on an increasing seconds count   
   if(sec_count == 60){
      min_count++;
     854:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <min_count>
     858:	8f 5f       	subi	r24, 0xFF	; 255
     85a:	80 93 41 01 	sts	0x0141, r24	; 0x800141 <min_count>
      sec_count = 0;
     85e:	10 92 42 01 	sts	0x0142, r1	; 0x800142 <sec_count>
      if(min_count == 60){
     862:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <min_count>
     866:	8c 33       	cpi	r24, 0x3C	; 60
     868:	09 f0       	breq	.+2      	; 0x86c <clock_time+0x16a>
     86a:	50 cf       	rjmp	.-352    	; 0x70c <clock_time+0xa>
	 hour_count++;
     86c:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <hour_count>
     870:	8f 5f       	subi	r24, 0xFF	; 255
     872:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <hour_count>
	 min_count = 0;
     876:	10 92 41 01 	sts	0x0141, r1	; 0x800141 <min_count>
	 if(hour_count == 24){
     87a:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <hour_count>
     87e:	88 31       	cpi	r24, 0x18	; 24
     880:	09 f0       	breq	.+2      	; 0x884 <clock_time+0x182>
     882:	44 cf       	rjmp	.-376    	; 0x70c <clock_time+0xa>
	    hour_count = 0;
     884:	10 92 40 01 	sts	0x0140, r1	; 0x800140 <hour_count>
     888:	41 cf       	rjmp	.-382    	; 0x70c <clock_time+0xa>

//This is where the digits are written to the data array
      if(mode_sel == 2){	//display alarm time
         segment_data[4] = dec_to_7seg[a_hour_count/10];
         segment_data[3] = dec_to_7seg[a_hour_count%10];
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     88a:	84 e0       	ldi	r24, 0x04	; 4
     88c:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__data_end+0x2>
     890:	cc cf       	rjmp	.-104    	; 0x82a <clock_time+0x128>

00000892 <port_init>:
Function: port_init
Description: General port initialization and setting pull up resistors
Parameters: NA
**********************************************************************/
void port_init(){
   DDRC |= 0xFF; 
     892:	84 b3       	in	r24, 0x14	; 20
     894:	8f ef       	ldi	r24, 0xFF	; 255
     896:	84 bb       	out	0x14, r24	; 20
   DDRB |= 0xF0;				//PB4-6 is SEL0-2, PB7 is PWM
     898:	97 b3       	in	r25, 0x17	; 23
     89a:	90 6f       	ori	r25, 0xF0	; 240
     89c:	97 bb       	out	0x17, r25	; 23
   DDRE |= 0x4F;				//PE6 is SHIFT_LD_N
     89e:	92 b1       	in	r25, 0x02	; 2
     8a0:	9f 64       	ori	r25, 0x4F	; 79
     8a2:	92 b9       	out	0x02, r25	; 2
   DDRD |= 0xFF;				//PE1 is CLK_INH and PE2 is SRCLK
     8a4:	91 b3       	in	r25, 0x11	; 17
     8a6:	81 bb       	out	0x11, r24	; 17
   PORTC |= 0x01;
     8a8:	a8 9a       	sbi	0x15, 0	; 21
   PORTD |= 0xFF;
     8aa:	92 b3       	in	r25, 0x12	; 18
     8ac:	82 bb       	out	0x12, r24	; 18
   PORTE |= 0xFF;
     8ae:	93 b1       	in	r25, 0x03	; 3
     8b0:	83 b9       	out	0x03, r24	; 3
     8b2:	08 95       	ret

000008b4 <change_alarm_state>:
Function: change_alarm_state
Description: This function is used to display when the alarm is armed
	and what time it is set for on the LCD.
Parameters: NA
**********************************************************************/
void change_alarm_state(){
     8b4:	0f 93       	push	r16
   static uint8_t curr = 0;
   if(alarm && (curr == 0)){	//First time through function with alarm on
     8b6:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <alarm>
     8ba:	88 23       	and	r24, r24
     8bc:	c1 f1       	breq	.+112    	; 0x92e <change_alarm_state+0x7a>
     8be:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <curr.2047>
     8c2:	81 11       	cpse	r24, r1
     8c4:	34 c0       	rjmp	.+104    	; 0x92e <change_alarm_state+0x7a>
      if((a_hour_count > 9) && (a_min_count > 9)){	//hours and min counts > 9
     8c6:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <a_hour_count>
     8ca:	8a 30       	cpi	r24, 0x0A	; 10
     8cc:	2c f0       	brlt	.+10     	; 0x8d8 <change_alarm_state+0x24>
     8ce:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <a_min_count>
     8d2:	8a 30       	cpi	r24, 0x0A	; 10
     8d4:	0c f0       	brlt	.+2      	; 0x8d8 <change_alarm_state+0x24>
     8d6:	5d c0       	rjmp	.+186    	; 0x992 <change_alarm_state+0xde>
         string2lcd("ALARM at ");
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         lcd_int16(a_min_count, 2, 0, 0, 0);
      }
      else if(a_hour_count > 9){ //hour>9 and min<10
     8d8:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <a_hour_count>
     8dc:	8a 30       	cpi	r24, 0x0A	; 10
     8de:	a4 f5       	brge	.+104    	; 0x948 <change_alarm_state+0x94>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         string2lcd("0");
         lcd_int16(a_min_count, 1, 0, 0, 0);
      }
      else if(a_min_count > 9){ //min>9 and hour<10
     8e0:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <a_min_count>
     8e4:	8a 30       	cpi	r24, 0x0A	; 10
     8e6:	0c f4       	brge	.+2      	; 0x8ea <change_alarm_state+0x36>
     8e8:	51 c0       	rjmp	.+162    	; 0x98c <change_alarm_state+0xd8>
         string2lcd("ALARM at");
     8ea:	84 e2       	ldi	r24, 0x24	; 36
     8ec:	91 e0       	ldi	r25, 0x01	; 1
     8ee:	0e 94 75 07 	call	0xeea	; 0xeea <string2lcd>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
     8f2:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <a_hour_count>
     8f6:	00 e0       	ldi	r16, 0x00	; 0
     8f8:	20 e0       	ldi	r18, 0x00	; 0
     8fa:	40 e0       	ldi	r20, 0x00	; 0
     8fc:	62 e0       	ldi	r22, 0x02	; 2
     8fe:	08 2e       	mov	r0, r24
     900:	00 0c       	add	r0, r0
     902:	99 0b       	sbc	r25, r25
     904:	0e 94 3a 09 	call	0x1274	; 0x1274 <lcd_int16>
         string2lcd(":");
     908:	80 e2       	ldi	r24, 0x20	; 32
     90a:	91 e0       	ldi	r25, 0x01	; 1
     90c:	0e 94 75 07 	call	0xeea	; 0xeea <string2lcd>
         lcd_int16(a_min_count, 2, 0, 0, 0);
     910:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <a_min_count>
     914:	20 e0       	ldi	r18, 0x00	; 0
     916:	40 e0       	ldi	r20, 0x00	; 0
     918:	62 e0       	ldi	r22, 0x02	; 2
     91a:	08 2e       	mov	r0, r24
     91c:	00 0c       	add	r0, r0
     91e:	99 0b       	sbc	r25, r25
     920:	0e 94 3a 09 	call	0x1274	; 0x1274 <lcd_int16>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         string2lcd("0");
         lcd_int16(a_min_count, 1, 0, 0, 0);
      }
      curr = 1;	//indicated that alarm has been written to the display next time
     924:	81 e0       	ldi	r24, 0x01	; 1
     926:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <curr.2047>
   else if((!alarm) && (curr == 1)){
      curr = 0;
      clear_display();
   }
   else{}
}
     92a:	0f 91       	pop	r16
     92c:	08 95       	ret
      }
      curr = 1;	//indicated that alarm has been written to the display next time
	//through the function
   }
	//clears display when the alarm is turned off
   else if((!alarm) && (curr == 1)){
     92e:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <alarm>
     932:	81 11       	cpse	r24, r1
     934:	fa cf       	rjmp	.-12     	; 0x92a <change_alarm_state+0x76>
     936:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <curr.2047>
     93a:	81 30       	cpi	r24, 0x01	; 1
     93c:	b1 f7       	brne	.-20     	; 0x92a <change_alarm_state+0x76>
      curr = 0;
     93e:	10 92 43 01 	sts	0x0143, r1	; 0x800143 <curr.2047>
      clear_display();
   }
   else{}
}
     942:	0f 91       	pop	r16
	//through the function
   }
	//clears display when the alarm is turned off
   else if((!alarm) && (curr == 1)){
      curr = 0;
      clear_display();
     944:	0c 94 ed 06 	jmp	0xdda	; 0xdda <clear_display>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         lcd_int16(a_min_count, 2, 0, 0, 0);
      }
      else if(a_hour_count > 9){ //hour>9 and min<10
         string2lcd("ALARM at ");
     948:	86 e1       	ldi	r24, 0x16	; 22
     94a:	91 e0       	ldi	r25, 0x01	; 1
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         lcd_int16(a_min_count, 2, 0, 0, 0);
      }
      else { //hour and min < 10
         string2lcd("ALARM at");
     94c:	0e 94 75 07 	call	0xeea	; 0xeea <string2lcd>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
     950:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <a_hour_count>
     954:	00 e0       	ldi	r16, 0x00	; 0
     956:	20 e0       	ldi	r18, 0x00	; 0
     958:	40 e0       	ldi	r20, 0x00	; 0
     95a:	62 e0       	ldi	r22, 0x02	; 2
     95c:	08 2e       	mov	r0, r24
     95e:	00 0c       	add	r0, r0
     960:	99 0b       	sbc	r25, r25
     962:	0e 94 3a 09 	call	0x1274	; 0x1274 <lcd_int16>
         string2lcd(":");
     966:	80 e2       	ldi	r24, 0x20	; 32
     968:	91 e0       	ldi	r25, 0x01	; 1
     96a:	0e 94 75 07 	call	0xeea	; 0xeea <string2lcd>
         string2lcd("0");
     96e:	82 e2       	ldi	r24, 0x22	; 34
     970:	91 e0       	ldi	r25, 0x01	; 1
     972:	0e 94 75 07 	call	0xeea	; 0xeea <string2lcd>
         lcd_int16(a_min_count, 1, 0, 0, 0);
     976:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <a_min_count>
     97a:	20 e0       	ldi	r18, 0x00	; 0
     97c:	40 e0       	ldi	r20, 0x00	; 0
     97e:	61 e0       	ldi	r22, 0x01	; 1
     980:	08 2e       	mov	r0, r24
     982:	00 0c       	add	r0, r0
     984:	99 0b       	sbc	r25, r25
     986:	0e 94 3a 09 	call	0x1274	; 0x1274 <lcd_int16>
     98a:	cc cf       	rjmp	.-104    	; 0x924 <change_alarm_state+0x70>
         lcd_int16(a_hour_count, 2, 0, 0, 0);
         string2lcd(":");
         lcd_int16(a_min_count, 2, 0, 0, 0);
      }
      else { //hour and min < 10
         string2lcd("ALARM at");
     98c:	84 e2       	ldi	r24, 0x24	; 36
     98e:	91 e0       	ldi	r25, 0x01	; 1
     990:	dd cf       	rjmp	.-70     	; 0x94c <change_alarm_state+0x98>
**********************************************************************/
void change_alarm_state(){
   static uint8_t curr = 0;
   if(alarm && (curr == 0)){	//First time through function with alarm on
      if((a_hour_count > 9) && (a_min_count > 9)){	//hours and min counts > 9
         string2lcd("ALARM at ");
     992:	86 e1       	ldi	r24, 0x16	; 22
     994:	91 e0       	ldi	r25, 0x01	; 1
     996:	ab cf       	rjmp	.-170    	; 0x8ee <change_alarm_state+0x3a>

00000998 <adc_init>:
Description: Basic adc initialization used for single shot adc readings
Parameters: NA
**********************************************************************/
void adc_init(){
//Initalize ADC and its ports
   DDRF  &= ~(_BV(DDF7)); //make port F bit 7 is ADC input  
     998:	e1 e6       	ldi	r30, 0x61	; 97
     99a:	f0 e0       	ldi	r31, 0x00	; 0
     99c:	80 81       	ld	r24, Z
     99e:	8f 77       	andi	r24, 0x7F	; 127
     9a0:	80 83       	st	Z, r24
   PORTF &= ~(_BV(PF7));  //port F bit 7 pullups must be off
     9a2:	e2 e6       	ldi	r30, 0x62	; 98
     9a4:	f0 e0       	ldi	r31, 0x00	; 0
     9a6:	80 81       	ld	r24, Z
     9a8:	8f 77       	andi	r24, 0x7F	; 127
     9aa:	80 83       	st	Z, r24
   ADMUX |= (1<<REFS0) | (1<<MUX2)| (1<<MUX1)| (1<<MUX0); //single-ended, input PORTF bit 7, right adjusted, 10 bits
     9ac:	87 b1       	in	r24, 0x07	; 7
     9ae:	87 64       	ori	r24, 0x47	; 71
     9b0:	87 b9       	out	0x07, r24	; 7

   ADCSRA |= (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);//ADC enabled, don't start yet, single shot mode 
     9b2:	86 b1       	in	r24, 0x06	; 6
     9b4:	87 68       	ori	r24, 0x87	; 135
     9b6:	86 b9       	out	0x06, r24	; 6
     9b8:	08 95       	ret

000009ba <fetch_adc>:
void fetch_adc(){
   uint16_t adc_result;
   uint16_t step;   
   uint16_t step2;   

   ADCSRA |= (1<<ADSC); //poke ADSC and start conversion
     9ba:	36 9a       	sbi	0x06, 6	; 6
   while(bit_is_clear(ADCSRA, ADIF)){} //spin while interrupt flag not set
     9bc:	34 9b       	sbis	0x06, 4	; 6
     9be:	fe cf       	rjmp	.-4      	; 0x9bc <fetch_adc+0x2>
   ACSR |= (1<<ACI); //its done, clear flag by writing a one 
     9c0:	44 9a       	sbi	0x08, 4	; 8
   adc_result = ADC;                      //read the ADC output as 16 bits
     9c2:	24 b1       	in	r18, 0x04	; 4
     9c4:	35 b1       	in	r19, 0x05	; 5

   step = adc_result/4;//scales the adc result from 0-255
   step2 =  255 - step;//I need the complement to the adc result
     9c6:	36 95       	lsr	r19
     9c8:	27 95       	ror	r18
     9ca:	36 95       	lsr	r19
     9cc:	27 95       	ror	r18
   if(step2 > 235){	//this is a minimum brightness level
      step2 = 235;
   }

   OCR2 = step2;	//Write brightness level to tnct2 compare match register
     9ce:	8f ef       	ldi	r24, 0xFF	; 255
     9d0:	90 e0       	ldi	r25, 0x00	; 0
     9d2:	82 1b       	sub	r24, r18
     9d4:	93 0b       	sbc	r25, r19
     9d6:	8c 3e       	cpi	r24, 0xEC	; 236
     9d8:	91 05       	cpc	r25, r1
     9da:	10 f0       	brcs	.+4      	; 0x9e0 <fetch_adc+0x26>
     9dc:	8b ee       	ldi	r24, 0xEB	; 235
     9de:	90 e0       	ldi	r25, 0x00	; 0
     9e0:	83 bd       	out	0x23, r24	; 35
     9e2:	08 95       	ret

000009e4 <__vector_12>:
Function: TIMER!_COMPA_vect
Description: This ISR creates the alarm frequency on PORTD but 3 the is used
	for the alarm tone.
Parameters: NA
**********************************************************************/
ISR(TIMER1_COMPA_vect){
     9e4:	1f 92       	push	r1
     9e6:	0f 92       	push	r0
     9e8:	0f b6       	in	r0, 0x3f	; 63
     9ea:	0f 92       	push	r0
     9ec:	11 24       	eor	r1, r1
     9ee:	8f 93       	push	r24
     9f0:	9f 93       	push	r25
   //static uint8_t seconds = 0;
   //bars();  //displays the mode on the bargraph
   //read_encoder();     //reads the encoder values
if(!snooze){ //alarm has not been snoozed
     9f2:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <snooze>
     9f6:	81 11       	cpse	r24, r1
     9f8:	0a c0       	rjmp	.+20     	; 0xa0e <__vector_12+0x2a>
//checks to see alarm is on and the alarm time matches clock time
   if(alarm && ((hour_count == a_hour_count) && (min_count == a_min_count))){
     9fa:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <alarm>
     9fe:	88 23       	and	r24, r24
     a00:	31 f0       	breq	.+12     	; 0xa0e <__vector_12+0x2a>
     a02:	90 91 40 01 	lds	r25, 0x0140	; 0x800140 <hour_count>
     a06:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <a_hour_count>
     a0a:	98 17       	cp	r25, r24
     a0c:	39 f0       	breq	.+14     	; 0xa1c <__vector_12+0x38>
      PORTD = PIND ^ 0b00000100;//toggles PD3 to create frequency
   }
}
}
     a0e:	9f 91       	pop	r25
     a10:	8f 91       	pop	r24
     a12:	0f 90       	pop	r0
     a14:	0f be       	out	0x3f, r0	; 63
     a16:	0f 90       	pop	r0
     a18:	1f 90       	pop	r1
     a1a:	18 95       	reti
   //static uint8_t seconds = 0;
   //bars();  //displays the mode on the bargraph
   //read_encoder();     //reads the encoder values
if(!snooze){ //alarm has not been snoozed
//checks to see alarm is on and the alarm time matches clock time
   if(alarm && ((hour_count == a_hour_count) && (min_count == a_min_count))){
     a1c:	90 91 41 01 	lds	r25, 0x0141	; 0x800141 <min_count>
     a20:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <a_min_count>
     a24:	98 13       	cpse	r25, r24
     a26:	f3 cf       	rjmp	.-26     	; 0xa0e <__vector_12+0x2a>
      PORTD = PIND ^ 0b00000100;//toggles PD3 to create frequency
     a28:	90 b3       	in	r25, 0x10	; 16
     a2a:	84 e0       	ldi	r24, 0x04	; 4
     a2c:	89 27       	eor	r24, r25
     a2e:	82 bb       	out	0x12, r24	; 18
   }
}
}
     a30:	ee cf       	rjmp	.-36     	; 0xa0e <__vector_12+0x2a>

00000a32 <snoozin>:
Description: This function disables the snooze variable once the alarm
	seconds equals the normal seconds. 
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
     a32:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <snooze>
     a36:	81 11       	cpse	r24, r1
     a38:	0c 94 b8 00 	jmp	0x170	; 0x170 <snoozin.part.1>
     a3c:	08 95       	ret

00000a3e <get_local_temp>:
Parameters: NA
**********************************************************************/
void get_local_temp(){
uint16_t lm73_temp;

lm73_wr_buf[0] = 0x00; //load lm73_wr_buf[0] with temperature pointer address
     a3e:	10 92 8e 01 	sts	0x018E, r1	; 0x80018e <lm73_wr_buf>
twi_start_wr(LM73_ADDRESS, lm73_rd_buf, 1); //start the TWI write process
     a42:	41 e0       	ldi	r20, 0x01	; 1
     a44:	60 e9       	ldi	r22, 0x90	; 144
     a46:	71 e0       	ldi	r23, 0x01	; 1
     a48:	80 e9       	ldi	r24, 0x90	; 144
     a4a:	0e 94 a5 0a 	call	0x154a	; 0x154a <twi_start_wr>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     a4e:	8f e3       	ldi	r24, 0x3F	; 63
     a50:	9f e1       	ldi	r25, 0x1F	; 31
     a52:	01 97       	sbiw	r24, 0x01	; 1
     a54:	f1 f7       	brne	.-4      	; 0xa52 <get_local_temp+0x14>
     a56:	00 c0       	rjmp	.+0      	; 0xa58 <get_local_temp+0x1a>
     a58:	00 00       	nop
_delay_ms(2);    //wait for the xfer to finish

clear_display(); //clean up the display
     a5a:	0e 94 ed 06 	call	0xdda	; 0xdda <clear_display>
     a5e:	9f ef       	ldi	r25, 0xFF	; 255
     a60:	21 ee       	ldi	r18, 0xE1	; 225
     a62:	84 e0       	ldi	r24, 0x04	; 4
     a64:	91 50       	subi	r25, 0x01	; 1
     a66:	20 40       	sbci	r18, 0x00	; 0
     a68:	80 40       	sbci	r24, 0x00	; 0
     a6a:	e1 f7       	brne	.-8      	; 0xa64 <get_local_temp+0x26>
     a6c:	00 c0       	rjmp	.+0      	; 0xa6e <get_local_temp+0x30>
     a6e:	00 00       	nop

while(1){          //main while loop
  _delay_ms(100); //tenth second wait
  clear_display();                  //wipe the display
     a70:	0e 94 ed 06 	call	0xdda	; 0xdda <clear_display>
  twi_start_rd(LM73_ADDRESS, lm73_rd_buf, 2); //read temperature data from LM73 (2 bytes) 
     a74:	42 e0       	ldi	r20, 0x02	; 2
     a76:	60 e9       	ldi	r22, 0x90	; 144
     a78:	71 e0       	ldi	r23, 0x01	; 1
     a7a:	80 e9       	ldi	r24, 0x90	; 144
     a7c:	0e 94 b6 0a 	call	0x156c	; 0x156c <twi_start_rd>
     a80:	8f e3       	ldi	r24, 0x3F	; 63
     a82:	9f e1       	ldi	r25, 0x1F	; 31
     a84:	01 97       	sbiw	r24, 0x01	; 1
     a86:	f1 f7       	brne	.-4      	; 0xa84 <get_local_temp+0x46>
     a88:	00 c0       	rjmp	.+0      	; 0xa8a <get_local_temp+0x4c>
     a8a:	00 00       	nop
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
     a8c:	80 91 90 01 	lds	r24, 0x0190	; 0x800190 <lm73_rd_buf>
     a90:	90 91 91 01 	lds	r25, 0x0191	; 0x800191 <lm73_rd_buf+0x1>
     a94:	98 27       	eor	r25, r24
     a96:	89 27       	eor	r24, r25
     a98:	98 27       	eor	r25, r24
     a9a:	4a e0       	ldi	r20, 0x0A	; 10
     a9c:	69 e5       	ldi	r22, 0x59	; 89
     a9e:	71 e0       	ldi	r23, 0x01	; 1
     aa0:	88 0f       	add	r24, r24
     aa2:	89 2f       	mov	r24, r25
     aa4:	88 1f       	adc	r24, r24
     aa6:	99 0b       	sbc	r25, r25
     aa8:	91 95       	neg	r25
     aaa:	0e 94 c2 0b 	call	0x1784	; 0x1784 <__itoa_ncheck>
  _delay_ms(2);    //wait for it to finish
  lm73_temp = lm73_rd_buf[0]; //save high temperature byte into lm73_temp
  lm73_temp = lm73_temp << 8; //shift it into upper byte 
  lm73_temp |= lm73_rd_buf[1]; //"OR" in the low temp byte to lm73_temp 
  itoa(lm73_temp >> 7, lcd_string_array, 10); //convert to string in array with itoa() from avr-libc                           
  string2lcd(lcd_string_array); //send the string to LCD (lcd_functions)
     aae:	89 e5       	ldi	r24, 0x59	; 89
     ab0:	91 e0       	ldi	r25, 0x01	; 1
     ab2:	0e 94 75 07 	call	0xeea	; 0xeea <string2lcd>
     ab6:	d3 cf       	rjmp	.-90     	; 0xa5e <get_local_temp+0x20>

00000ab8 <send_lcd>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ab8:	91 e0       	ldi	r25, 0x01	; 1
     aba:	81 11       	cpse	r24, r1
     abc:	01 c0       	rjmp	.+2      	; 0xac0 <send_lcd+0x8>
     abe:	90 e0       	ldi	r25, 0x00	; 0
     ac0:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ac2:	77 9b       	sbis	0x0e, 7	; 14
     ac4:	fe cf       	rjmp	.-4      	; 0xac2 <send_lcd+0xa>
  SPDR = byte;                        //send payload
     ac6:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ac8:	77 9b       	sbis	0x0e, 7	; 14
     aca:	fe cf       	rjmp	.-4      	; 0xac8 <send_lcd+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     acc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ad0:	88 60       	ori	r24, 0x08	; 8
     ad2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ad6:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ada:	87 7f       	andi	r24, 0xF7	; 247
     adc:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ae0:	08 95       	ret

00000ae2 <refresh_lcd>:
//
void refresh_lcd(char lcd_string_array[]) {

  static uint8_t i=0;           // index into string array 

 send_lcd(CHAR_BYTE,lcd_string_array[i]);
     ae2:	20 91 55 01 	lds	r18, 0x0155	; 0x800155 <i.2095>
     ae6:	82 0f       	add	r24, r18
     ae8:	91 1d       	adc	r25, r1
     aea:	fc 01       	movw	r30, r24
     aec:	80 81       	ld	r24, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     aee:	91 e0       	ldi	r25, 0x01	; 1
     af0:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     af2:	77 9b       	sbis	0x0e, 7	; 14
     af4:	fe cf       	rjmp	.-4      	; 0xaf2 <refresh_lcd+0x10>
  SPDR = byte;                        //send payload
     af6:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     af8:	77 9b       	sbis	0x0e, 7	; 14
     afa:	fe cf       	rjmp	.-4      	; 0xaf8 <refresh_lcd+0x16>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     afc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b00:	88 60       	ori	r24, 0x08	; 8
     b02:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b06:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b0a:	87 7f       	andi	r24, 0xF7	; 247
     b0c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
void refresh_lcd(char lcd_string_array[]) {

  static uint8_t i=0;           // index into string array 

 send_lcd(CHAR_BYTE,lcd_string_array[i]);
 i++;   //increment to next character
     b10:	80 91 55 01 	lds	r24, 0x0155	; 0x800155 <i.2095>
     b14:	8f 5f       	subi	r24, 0xFF	; 255
     b16:	80 93 55 01 	sts	0x0155, r24	; 0x800155 <i.2095>
 //delays are inserted to allow character to be written before moving
 //the cursor to the next line.
 if(i == 16){_delay_us(40); line2_col1();      } //goto line 2, 1st char 
     b1a:	80 31       	cpi	r24, 0x10	; 16
     b1c:	f9 f0       	breq	.+62     	; 0xb5c <refresh_lcd+0x7a>
 if(i == 32){_delay_us(40); line1_col1(); i=0; } //goto line 1, 1st char 
     b1e:	80 32       	cpi	r24, 0x20	; 32
     b20:	09 f0       	breq	.+2      	; 0xb24 <refresh_lcd+0x42>
     b22:	08 95       	ret
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     b24:	e5 ed       	ldi	r30, 0xD5	; 213
     b26:	ea 95       	dec	r30
     b28:	f1 f7       	brne	.-4      	; 0xb26 <refresh_lcd+0x44>
     b2a:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b2c:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b2e:	77 9b       	sbis	0x0e, 7	; 14
     b30:	fe cf       	rjmp	.-4      	; 0xb2e <refresh_lcd+0x4c>
  SPDR = byte;                        //send payload
     b32:	80 e8       	ldi	r24, 0x80	; 128
     b34:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b36:	77 9b       	sbis	0x0e, 7	; 14
     b38:	fe cf       	rjmp	.-4      	; 0xb36 <refresh_lcd+0x54>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b3a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b3e:	88 60       	ori	r24, 0x08	; 8
     b40:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b44:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b48:	87 7f       	andi	r24, 0xF7	; 247
     b4a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b4e:	f5 ed       	ldi	r31, 0xD5	; 213
     b50:	fa 95       	dec	r31
     b52:	f1 f7       	brne	.-4      	; 0xb50 <refresh_lcd+0x6e>
     b54:	00 00       	nop
 send_lcd(CHAR_BYTE,lcd_string_array[i]);
 i++;   //increment to next character
 //delays are inserted to allow character to be written before moving
 //the cursor to the next line.
 if(i == 16){_delay_us(40); line2_col1();      } //goto line 2, 1st char 
 if(i == 32){_delay_us(40); line1_col1(); i=0; } //goto line 1, 1st char 
     b56:	10 92 55 01 	sts	0x0155, r1	; 0x800155 <i.2095>
     b5a:	08 95       	ret
     b5c:	f5 ed       	ldi	r31, 0xD5	; 213
     b5e:	fa 95       	dec	r31
     b60:	f1 f7       	brne	.-4      	; 0xb5e <refresh_lcd+0x7c>
     b62:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b64:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b66:	77 9b       	sbis	0x0e, 7	; 14
     b68:	fe cf       	rjmp	.-4      	; 0xb66 <refresh_lcd+0x84>
  SPDR = byte;                        //send payload
     b6a:	80 ec       	ldi	r24, 0xC0	; 192
     b6c:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b6e:	77 9b       	sbis	0x0e, 7	; 14
     b70:	fe cf       	rjmp	.-4      	; 0xb6e <refresh_lcd+0x8c>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     b72:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b76:	88 60       	ori	r24, 0x08	; 8
     b78:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b7c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b80:	87 7f       	andi	r24, 0xF7	; 247
     b82:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     b86:	85 ed       	ldi	r24, 0xD5	; 213
     b88:	8a 95       	dec	r24
     b8a:	f1 f7       	brne	.-4      	; 0xb88 <refresh_lcd+0xa6>
     b8c:	00 00       	nop
     b8e:	80 91 55 01 	lds	r24, 0x0155	; 0x800155 <i.2095>
     b92:	c5 cf       	rjmp	.-118    	; 0xb1e <refresh_lcd+0x3c>

00000b94 <set_custom_character>:
//address, such as send_lcd(CHAR_BYTE, 0x01, 1) or it can be insteretd into a string 
//via a forward slash escape as in string2lcd("this is my music note \1")

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
     b94:	66 0f       	add	r22, r22
     b96:	66 0f       	add	r22, r22
     b98:	66 0f       	add	r22, r22
     b9a:	60 5c       	subi	r22, 0xC0	; 192
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     b9c:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     b9e:	77 9b       	sbis	0x0e, 7	; 14
     ba0:	fe cf       	rjmp	.-4      	; 0xb9e <set_custom_character+0xa>
  SPDR = byte;                        //send payload
     ba2:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ba4:	77 9b       	sbis	0x0e, 7	; 14
     ba6:	fe cf       	rjmp	.-4      	; 0xba4 <set_custom_character+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     ba8:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bac:	28 60       	ori	r18, 0x08	; 8
     bae:	20 93 62 00 	sts	0x0062, r18	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bb2:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bb6:	27 7f       	andi	r18, 0xF7	; 247
     bb8:	20 93 62 00 	sts	0x0062, r18	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bbc:	25 ed       	ldi	r18, 0xD5	; 213
     bbe:	2a 95       	dec	r18
     bc0:	f1 f7       	brne	.-4      	; 0xbbe <set_custom_character+0x2a>
     bc2:	00 00       	nop
     bc4:	fc 01       	movw	r30, r24
     bc6:	9c 01       	movw	r18, r24
     bc8:	28 5f       	subi	r18, 0xF8	; 248
     bca:	3f 4f       	sbci	r19, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     bcc:	91 e0       	ldi	r25, 0x01	; 1

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
    for(i=0; i<8; i++){
      send_lcd(CHAR_BYTE, data[i]); _delay_us(40); //each char byte takes 37us to execute
     bce:	81 91       	ld	r24, Z+
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     bd0:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     bd2:	77 9b       	sbis	0x0e, 7	; 14
     bd4:	fe cf       	rjmp	.-4      	; 0xbd2 <set_custom_character+0x3e>
  SPDR = byte;                        //send payload
     bd6:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     bd8:	77 9b       	sbis	0x0e, 7	; 14
     bda:	fe cf       	rjmp	.-4      	; 0xbd8 <set_custom_character+0x44>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     bdc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     be0:	88 60       	ori	r24, 0x08	; 8
     be2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     be6:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bea:	87 7f       	andi	r24, 0xF7	; 247
     bec:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     bf0:	85 ed       	ldi	r24, 0xD5	; 213
     bf2:	8a 95       	dec	r24
     bf4:	f1 f7       	brne	.-4      	; 0xbf2 <set_custom_character+0x5e>
     bf6:	00 00       	nop
//via a forward slash escape as in string2lcd("this is my music note \1")

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
    for(i=0; i<8; i++){
     bf8:	e2 17       	cp	r30, r18
     bfa:	f3 07       	cpc	r31, r19
     bfc:	41 f7       	brne	.-48     	; 0xbce <set_custom_character+0x3a>
      send_lcd(CHAR_BYTE, data[i]); _delay_us(40); //each char byte takes 37us to execute
    }
}
     bfe:	08 95       	ret

00000c00 <set_cursor>:
//                          set_cursor 
//
//Sets the cursor to an arbitrary potition on the screen, row is either 1 or 2
//col is a number form 0-15, counting from left to right
void set_cursor(uint8_t row, uint8_t col){
    send_lcd(CMD_BYTE, 0x80 + col + ((row-1)*0x40));
     c00:	90 e4       	ldi	r25, 0x40	; 64
     c02:	89 9f       	mul	r24, r25
     c04:	60 0d       	add	r22, r0
     c06:	11 24       	eor	r1, r1
     c08:	60 5c       	subi	r22, 0xC0	; 192
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c0a:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c0c:	77 9b       	sbis	0x0e, 7	; 14
     c0e:	fe cf       	rjmp	.-4      	; 0xc0c <set_cursor+0xc>
  SPDR = byte;                        //send payload
     c10:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c12:	77 9b       	sbis	0x0e, 7	; 14
     c14:	fe cf       	rjmp	.-4      	; 0xc12 <set_cursor+0x12>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     c16:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c1a:	88 60       	ori	r24, 0x08	; 8
     c1c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c20:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c24:	87 7f       	andi	r24, 0xF7	; 247
     c26:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c2a:	08 95       	ret

00000c2c <uint2lcd>:
//not displayed.  
//TODO: optimize by removing the mod operators
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
     c2c:	81 11       	cpse	r24, r1
     c2e:	13 c0       	rjmp	.+38     	; 0xc56 <uint2lcd+0x2a>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c30:	81 e0       	ldi	r24, 0x01	; 1
     c32:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c34:	77 9b       	sbis	0x0e, 7	; 14
     c36:	fe cf       	rjmp	.-4      	; 0xc34 <uint2lcd+0x8>
  SPDR = byte;                        //send payload
     c38:	80 e3       	ldi	r24, 0x30	; 48
     c3a:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c3c:	77 9b       	sbis	0x0e, 7	; 14
     c3e:	fe cf       	rjmp	.-4      	; 0xc3c <uint2lcd+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     c40:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c44:	88 60       	ori	r24, 0x08	; 8
     c46:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c4a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c4e:	87 7f       	andi	r24, 0xF7	; 247
     c50:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     c54:	08 95       	ret
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
     c56:	84 36       	cpi	r24, 0x64	; 100
     c58:	b0 f4       	brcc	.+44     	; 0xc86 <uint2lcd+0x5a>
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
     c5a:	8a 30       	cpi	r24, 0x0A	; 10
     c5c:	60 f5       	brcc	.+88     	; 0xcb6 <uint2lcd+0x8a>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c5e:	91 e0       	ldi	r25, 0x01	; 1
     c60:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c62:	77 9b       	sbis	0x0e, 7	; 14
     c64:	fe cf       	rjmp	.-4      	; 0xc62 <uint2lcd+0x36>
void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
      if(number >= 1)  {send_lcd(CHAR_BYTE, 0x30+(number%10)    ); }
     c66:	9d ec       	ldi	r25, 0xCD	; 205
     c68:	89 9f       	mul	r24, r25
     c6a:	91 2d       	mov	r25, r1
     c6c:	11 24       	eor	r1, r1
     c6e:	96 95       	lsr	r25
     c70:	96 95       	lsr	r25
     c72:	96 95       	lsr	r25
     c74:	2a e0       	ldi	r18, 0x0A	; 10
     c76:	92 9f       	mul	r25, r18
     c78:	80 19       	sub	r24, r0
     c7a:	11 24       	eor	r1, r1
     c7c:	80 5d       	subi	r24, 0xD0	; 208
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
  SPDR = byte;                        //send payload
     c7e:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c80:	77 9b       	sbis	0x0e, 7	; 14
     c82:	fe cf       	rjmp	.-4      	; 0xc80 <uint2lcd+0x54>
     c84:	dd cf       	rjmp	.-70     	; 0xc40 <uint2lcd+0x14>
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
     c86:	99 e2       	ldi	r25, 0x29	; 41
     c88:	89 9f       	mul	r24, r25
     c8a:	91 2d       	mov	r25, r1
     c8c:	11 24       	eor	r1, r1
     c8e:	92 95       	swap	r25
     c90:	9f 70       	andi	r25, 0x0F	; 15
     c92:	90 5d       	subi	r25, 0xD0	; 208
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     c94:	21 e0       	ldi	r18, 0x01	; 1
     c96:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c98:	77 9b       	sbis	0x0e, 7	; 14
     c9a:	fe cf       	rjmp	.-4      	; 0xc98 <uint2lcd+0x6c>
  SPDR = byte;                        //send payload
     c9c:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     c9e:	77 9b       	sbis	0x0e, 7	; 14
     ca0:	fe cf       	rjmp	.-4      	; 0xc9e <uint2lcd+0x72>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     ca2:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ca6:	98 60       	ori	r25, 0x08	; 8
     ca8:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cac:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cb0:	97 7f       	andi	r25, 0xF7	; 247
     cb2:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
     cb6:	99 e2       	ldi	r25, 0x29	; 41
     cb8:	89 9f       	mul	r24, r25
     cba:	91 2d       	mov	r25, r1
     cbc:	11 24       	eor	r1, r1
     cbe:	92 95       	swap	r25
     cc0:	9f 70       	andi	r25, 0x0F	; 15
     cc2:	38 2f       	mov	r19, r24
     cc4:	24 e6       	ldi	r18, 0x64	; 100
     cc6:	92 9f       	mul	r25, r18
     cc8:	30 19       	sub	r19, r0
     cca:	11 24       	eor	r1, r1
     ccc:	2d ec       	ldi	r18, 0xCD	; 205
     cce:	32 9f       	mul	r19, r18
     cd0:	91 2d       	mov	r25, r1
     cd2:	11 24       	eor	r1, r1
     cd4:	96 95       	lsr	r25
     cd6:	96 95       	lsr	r25
     cd8:	96 95       	lsr	r25
     cda:	90 5d       	subi	r25, 0xD0	; 208
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     cdc:	21 e0       	ldi	r18, 0x01	; 1
     cde:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ce0:	77 9b       	sbis	0x0e, 7	; 14
     ce2:	fe cf       	rjmp	.-4      	; 0xce0 <uint2lcd+0xb4>
  SPDR = byte;                        //send payload
     ce4:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ce6:	77 9b       	sbis	0x0e, 7	; 14
     ce8:	fe cf       	rjmp	.-4      	; 0xce6 <uint2lcd+0xba>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     cea:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cee:	98 60       	ori	r25, 0x08	; 8
     cf0:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cf4:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cf8:	97 7f       	andi	r25, 0xF7	; 247
     cfa:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     cfe:	af cf       	rjmp	.-162    	; 0xc5e <uint2lcd+0x32>

00000d00 <int2lcd>:
//Takes a 8bit signed and displays it in base ten on the LCD. Leading 0's are 
//not displayed.
//
void int2lcd(int8_t number){
    //if < 0, print minus sign, then take 2's complement of number and display
    if(number < 0){send_lcd(CHAR_BYTE, '-'); _delay_us(40); uint2lcd(~number+1);}  
     d00:	87 ff       	sbrs	r24, 7
    else          {uint2lcd(number);                                            }
     d02:	0c 94 16 06 	jmp	0xc2c	; 0xc2c <uint2lcd>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d06:	91 e0       	ldi	r25, 0x01	; 1
     d08:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d0a:	77 9b       	sbis	0x0e, 7	; 14
     d0c:	fe cf       	rjmp	.-4      	; 0xd0a <int2lcd+0xa>
  SPDR = byte;                        //send payload
     d0e:	9d e2       	ldi	r25, 0x2D	; 45
     d10:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d12:	77 9b       	sbis	0x0e, 7	; 14
     d14:	fe cf       	rjmp	.-4      	; 0xd12 <int2lcd+0x12>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d16:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d1a:	98 60       	ori	r25, 0x08	; 8
     d1c:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d20:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d24:	97 7f       	andi	r25, 0xF7	; 247
     d26:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d2a:	95 ed       	ldi	r25, 0xD5	; 213
     d2c:	9a 95       	dec	r25
     d2e:	f1 f7       	brne	.-4      	; 0xd2c <int2lcd+0x2c>
     d30:	00 00       	nop
//Takes a 8bit signed and displays it in base ten on the LCD. Leading 0's are 
//not displayed.
//
void int2lcd(int8_t number){
    //if < 0, print minus sign, then take 2's complement of number and display
    if(number < 0){send_lcd(CHAR_BYTE, '-'); _delay_us(40); uint2lcd(~number+1);}  
     d32:	81 95       	neg	r24
     d34:	0c 94 16 06 	jmp	0xc2c	; 0xc2c <uint2lcd>

00000d38 <cursor_on>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d38:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d3a:	77 9b       	sbis	0x0e, 7	; 14
     d3c:	fe cf       	rjmp	.-4      	; 0xd3a <cursor_on+0x2>
  SPDR = byte;                        //send payload
     d3e:	8e e0       	ldi	r24, 0x0E	; 14
     d40:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d42:	77 9b       	sbis	0x0e, 7	; 14
     d44:	fe cf       	rjmp	.-4      	; 0xd42 <cursor_on+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d46:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d4a:	88 60       	ori	r24, 0x08	; 8
     d4c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d50:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d54:	87 7f       	andi	r24, 0xF7	; 247
     d56:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d5a:	08 95       	ret

00000d5c <cursor_off>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d5c:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d5e:	77 9b       	sbis	0x0e, 7	; 14
     d60:	fe cf       	rjmp	.-4      	; 0xd5e <cursor_off+0x2>
  SPDR = byte;                        //send payload
     d62:	8c e0       	ldi	r24, 0x0C	; 12
     d64:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d66:	77 9b       	sbis	0x0e, 7	; 14
     d68:	fe cf       	rjmp	.-4      	; 0xd66 <cursor_off+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d6a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d6e:	88 60       	ori	r24, 0x08	; 8
     d70:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d74:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d78:	87 7f       	andi	r24, 0xF7	; 247
     d7a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d7e:	08 95       	ret

00000d80 <shift_right>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     d80:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d82:	77 9b       	sbis	0x0e, 7	; 14
     d84:	fe cf       	rjmp	.-4      	; 0xd82 <shift_right+0x2>
  SPDR = byte;                        //send payload
     d86:	8e e1       	ldi	r24, 0x1E	; 30
     d88:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     d8a:	77 9b       	sbis	0x0e, 7	; 14
     d8c:	fe cf       	rjmp	.-4      	; 0xd8a <shift_right+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     d8e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d92:	88 60       	ori	r24, 0x08	; 8
     d94:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d98:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     d9c:	87 7f       	andi	r24, 0xF7	; 247
     d9e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     da2:	08 95       	ret

00000da4 <shift_left>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     da4:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     da6:	77 9b       	sbis	0x0e, 7	; 14
     da8:	fe cf       	rjmp	.-4      	; 0xda6 <shift_left+0x2>
  SPDR = byte;                        //send payload
     daa:	88 e1       	ldi	r24, 0x18	; 24
     dac:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     dae:	77 9b       	sbis	0x0e, 7	; 14
     db0:	fe cf       	rjmp	.-4      	; 0xdae <shift_left+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     db2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     db6:	88 60       	ori	r24, 0x08	; 8
     db8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dbc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dc0:	87 7f       	andi	r24, 0xF7	; 247
     dc2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dc6:	08 95       	ret

00000dc8 <strobe_lcd>:
     dc8:	e2 e6       	ldi	r30, 0x62	; 98
     dca:	f0 e0       	ldi	r31, 0x00	; 0
     dcc:	80 81       	ld	r24, Z
     dce:	88 60       	ori	r24, 0x08	; 8
     dd0:	80 83       	st	Z, r24
     dd2:	80 81       	ld	r24, Z
     dd4:	87 7f       	andi	r24, 0xF7	; 247
     dd6:	80 83       	st	Z, r24
     dd8:	08 95       	ret

00000dda <clear_display>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     dda:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ddc:	77 9b       	sbis	0x0e, 7	; 14
     dde:	fe cf       	rjmp	.-4      	; 0xddc <clear_display+0x2>
  SPDR = byte;                        //send payload
     de0:	81 e0       	ldi	r24, 0x01	; 1
     de2:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     de4:	77 9b       	sbis	0x0e, 7	; 14
     de6:	fe cf       	rjmp	.-4      	; 0xde4 <clear_display+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     de8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dec:	88 60       	ori	r24, 0x08	; 8
     dee:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     df2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     df6:	87 7f       	andi	r24, 0xF7	; 247
     df8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     dfc:	8f e1       	ldi	r24, 0x1F	; 31
     dfe:	9c e1       	ldi	r25, 0x1C	; 28
     e00:	01 97       	sbiw	r24, 0x01	; 1
     e02:	f1 f7       	brne	.-4      	; 0xe00 <clear_display+0x26>
     e04:	00 c0       	rjmp	.+0      	; 0xe06 <clear_display+0x2c>
     e06:	00 00       	nop
     e08:	08 95       	ret

00000e0a <cursor_home>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e0a:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e0c:	77 9b       	sbis	0x0e, 7	; 14
     e0e:	fe cf       	rjmp	.-4      	; 0xe0c <cursor_home+0x2>
  SPDR = byte;                        //send payload
     e10:	82 e0       	ldi	r24, 0x02	; 2
     e12:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e14:	77 9b       	sbis	0x0e, 7	; 14
     e16:	fe cf       	rjmp	.-4      	; 0xe14 <cursor_home+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     e18:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e1c:	88 60       	ori	r24, 0x08	; 8
     e1e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e22:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e26:	87 7f       	andi	r24, 0xF7	; 247
     e28:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e2c:	8f e6       	ldi	r24, 0x6F	; 111
     e2e:	97 e1       	ldi	r25, 0x17	; 23
     e30:	01 97       	sbiw	r24, 0x01	; 1
     e32:	f1 f7       	brne	.-4      	; 0xe30 <cursor_home+0x26>
     e34:	00 c0       	rjmp	.+0      	; 0xe36 <cursor_home+0x2c>
     e36:	00 00       	nop
     e38:	08 95       	ret

00000e3a <line2_col1>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e3a:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e3c:	77 9b       	sbis	0x0e, 7	; 14
     e3e:	fe cf       	rjmp	.-4      	; 0xe3c <line2_col1+0x2>
  SPDR = byte;                        //send payload
     e40:	80 ec       	ldi	r24, 0xC0	; 192
     e42:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e44:	77 9b       	sbis	0x0e, 7	; 14
     e46:	fe cf       	rjmp	.-4      	; 0xe44 <line2_col1+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     e48:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e4c:	88 60       	ori	r24, 0x08	; 8
     e4e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e52:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e56:	87 7f       	andi	r24, 0xF7	; 247
     e58:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e5c:	85 ed       	ldi	r24, 0xD5	; 213
     e5e:	8a 95       	dec	r24
     e60:	f1 f7       	brne	.-4      	; 0xe5e <line2_col1+0x24>
     e62:	00 00       	nop
     e64:	08 95       	ret

00000e66 <line1_col1>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e66:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e68:	77 9b       	sbis	0x0e, 7	; 14
     e6a:	fe cf       	rjmp	.-4      	; 0xe68 <line1_col1+0x2>
  SPDR = byte;                        //send payload
     e6c:	80 e8       	ldi	r24, 0x80	; 128
     e6e:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e70:	77 9b       	sbis	0x0e, 7	; 14
     e72:	fe cf       	rjmp	.-4      	; 0xe70 <line1_col1+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     e74:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e78:	88 60       	ori	r24, 0x08	; 8
     e7a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e7e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e82:	87 7f       	andi	r24, 0xF7	; 247
     e84:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e88:	85 ed       	ldi	r24, 0xD5	; 213
     e8a:	8a 95       	dec	r24
     e8c:	f1 f7       	brne	.-4      	; 0xe8a <line1_col1+0x24>
     e8e:	00 00       	nop
     e90:	08 95       	ret

00000e92 <fill_spaces>:

//-----------------------------------------------------------------------------
//                          fill_spaces   
//
//Fill an entire line with spaces.
void fill_spaces(void){
     e92:	90 e1       	ldi	r25, 0x10	; 16
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e94:	31 e0       	ldi	r19, 0x01	; 1
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
  SPDR = byte;                        //send payload
     e96:	20 e2       	ldi	r18, 0x20	; 32
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e98:	3f b9       	out	0x0f, r19	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e9a:	77 9b       	sbis	0x0e, 7	; 14
     e9c:	fe cf       	rjmp	.-4      	; 0xe9a <fill_spaces+0x8>
  SPDR = byte;                        //send payload
     e9e:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ea0:	77 9b       	sbis	0x0e, 7	; 14
     ea2:	fe cf       	rjmp	.-4      	; 0xea0 <fill_spaces+0xe>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     ea4:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ea8:	88 60       	ori	r24, 0x08	; 8
     eaa:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     eae:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     eb2:	87 7f       	andi	r24, 0xF7	; 247
     eb4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     eb8:	85 ed       	ldi	r24, 0xD5	; 213
     eba:	8a 95       	dec	r24
     ebc:	f1 f7       	brne	.-4      	; 0xeba <fill_spaces+0x28>
     ebe:	00 00       	nop
     ec0:	91 50       	subi	r25, 0x01	; 1
//                          fill_spaces   
//
//Fill an entire line with spaces.
void fill_spaces(void){
	uint8_t i;
	for (i=0; i<=(NUM_LCD_CHARS-1); i++){
     ec2:	51 f7       	brne	.-44     	; 0xe98 <fill_spaces+0x6>
		send_lcd(CHAR_BYTE, ' '); 
                _delay_us(40);  //40us wait between characters
	}
}  
     ec4:	08 95       	ret

00000ec6 <char2lcd>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ec6:	91 e0       	ldi	r25, 0x01	; 1
     ec8:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     eca:	77 9b       	sbis	0x0e, 7	; 14
     ecc:	fe cf       	rjmp	.-4      	; 0xeca <char2lcd+0x4>
  SPDR = byte;                        //send payload
     ece:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ed0:	77 9b       	sbis	0x0e, 7	; 14
     ed2:	fe cf       	rjmp	.-4      	; 0xed0 <char2lcd+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     ed4:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ed8:	88 60       	ori	r24, 0x08	; 8
     eda:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ede:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ee2:	87 7f       	andi	r24, 0xF7	; 247
     ee4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ee8:	08 95       	ret

00000eea <string2lcd>:

//----------------------------------------------------------------------------
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
     eea:	fc 01       	movw	r30, r24
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     eec:	40 e0       	ldi	r20, 0x00	; 0
     eee:	50 e0       	ldi	r21, 0x00	; 0
     ef0:	60 e0       	ldi	r22, 0x00	; 0
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ef2:	71 e0       	ldi	r23, 0x01	; 1
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     ef4:	df 01       	movw	r26, r30
     ef6:	a4 0f       	add	r26, r20
     ef8:	b5 1f       	adc	r27, r21
     efa:	8c 91       	ld	r24, X
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     efc:	7f b9       	out	0x0f, r23	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     efe:	77 9b       	sbis	0x0e, 7	; 14
     f00:	fe cf       	rjmp	.-4      	; 0xefe <string2lcd+0x14>
  SPDR = byte;                        //send payload
     f02:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f04:	77 9b       	sbis	0x0e, 7	; 14
     f06:	fe cf       	rjmp	.-4      	; 0xf04 <string2lcd+0x1a>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     f08:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f0c:	98 60       	ori	r25, 0x08	; 8
     f0e:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f12:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f16:	97 7f       	andi	r25, 0xF7	; 247
     f18:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f1c:	85 ed       	ldi	r24, 0xD5	; 213
     f1e:	8a 95       	dec	r24
     f20:	f1 f7       	brne	.-4      	; 0xf1e <string2lcd+0x34>
     f22:	00 00       	nop
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
     f24:	6f 5f       	subi	r22, 0xFF	; 255
     f26:	46 2f       	mov	r20, r22
     f28:	50 e0       	ldi	r21, 0x00	; 0
     f2a:	df 01       	movw	r26, r30
     f2c:	0d 90       	ld	r0, X+
     f2e:	00 20       	and	r0, r0
     f30:	e9 f7       	brne	.-6      	; 0xf2c <string2lcd+0x42>
     f32:	9d 01       	movw	r18, r26
     f34:	2e 1b       	sub	r18, r30
     f36:	3f 0b       	sbc	r19, r31
     f38:	22 50       	subi	r18, 0x02	; 2
     f3a:	31 09       	sbc	r19, r1
     f3c:	24 17       	cp	r18, r20
     f3e:	35 07       	cpc	r19, r21
     f40:	c8 f6       	brcc	.-78     	; 0xef4 <string2lcd+0xa>
  _delay_us(40);  //execution takes 37us per character
  }                  
} 
     f42:	08 95       	ret

00000f44 <lcd_init>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     f44:	8f ef       	ldi	r24, 0xFF	; 255
     f46:	99 ef       	ldi	r25, 0xF9	; 249
     f48:	01 97       	sbiw	r24, 0x01	; 1
     f4a:	f1 f7       	brne	.-4      	; 0xf48 <lcd_init+0x4>
     f4c:	00 c0       	rjmp	.+0      	; 0xf4e <lcd_init+0xa>
     f4e:	00 00       	nop
//
void lcd_init(void){
  _delay_ms(16);      //power up delay
#if SPI_MODE==1       //assumption is that the SPI port is intialized
  //TODO: kludge alert! setting of DDRF should not be here, but is probably harmless.
  DDRF=0x08;          //port F bit 3 is enable for LCD in SPI mode
     f50:	88 e0       	ldi	r24, 0x08	; 8
     f52:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     f56:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f58:	77 9b       	sbis	0x0e, 7	; 14
     f5a:	fe cf       	rjmp	.-4      	; 0xf58 <lcd_init+0x14>
  SPDR = byte;                        //send payload
     f5c:	80 e3       	ldi	r24, 0x30	; 48
     f5e:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f60:	77 9b       	sbis	0x0e, 7	; 14
     f62:	fe cf       	rjmp	.-4      	; 0xf60 <lcd_init+0x1c>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     f64:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f68:	88 60       	ori	r24, 0x08	; 8
     f6a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f6e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f72:	87 7f       	andi	r24, 0xF7	; 247
     f74:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f78:	8f e5       	ldi	r24, 0x5F	; 95
     f7a:	9d e6       	ldi	r25, 0x6D	; 109
     f7c:	01 97       	sbiw	r24, 0x01	; 1
     f7e:	f1 f7       	brne	.-4      	; 0xf7c <lcd_init+0x38>
     f80:	00 c0       	rjmp	.+0      	; 0xf82 <lcd_init+0x3e>
     f82:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     f84:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f86:	77 9b       	sbis	0x0e, 7	; 14
     f88:	fe cf       	rjmp	.-4      	; 0xf86 <lcd_init+0x42>
  SPDR = byte;                        //send payload
     f8a:	80 e3       	ldi	r24, 0x30	; 48
     f8c:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f8e:	77 9b       	sbis	0x0e, 7	; 14
     f90:	fe cf       	rjmp	.-4      	; 0xf8e <lcd_init+0x4a>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     f92:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f96:	88 60       	ori	r24, 0x08	; 8
     f98:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f9c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fa0:	87 7f       	andi	r24, 0xF7	; 247
     fa2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fa6:	8f e5       	ldi	r24, 0x5F	; 95
     fa8:	9d e6       	ldi	r25, 0x6D	; 109
     faa:	01 97       	sbiw	r24, 0x01	; 1
     fac:	f1 f7       	brne	.-4      	; 0xfaa <lcd_init+0x66>
     fae:	00 c0       	rjmp	.+0      	; 0xfb0 <lcd_init+0x6c>
     fb0:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     fb2:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     fb4:	77 9b       	sbis	0x0e, 7	; 14
     fb6:	fe cf       	rjmp	.-4      	; 0xfb4 <lcd_init+0x70>
  SPDR = byte;                        //send payload
     fb8:	80 e3       	ldi	r24, 0x30	; 48
     fba:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     fbc:	77 9b       	sbis	0x0e, 7	; 14
     fbe:	fe cf       	rjmp	.-4      	; 0xfbc <lcd_init+0x78>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     fc0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fc4:	88 60       	ori	r24, 0x08	; 8
     fc6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fca:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fce:	87 7f       	andi	r24, 0xF7	; 247
     fd0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fd4:	8f e5       	ldi	r24, 0x5F	; 95
     fd6:	9d e6       	ldi	r25, 0x6D	; 109
     fd8:	01 97       	sbiw	r24, 0x01	; 1
     fda:	f1 f7       	brne	.-4      	; 0xfd8 <lcd_init+0x94>
     fdc:	00 c0       	rjmp	.+0      	; 0xfde <lcd_init+0x9a>
     fde:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     fe0:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     fe2:	77 9b       	sbis	0x0e, 7	; 14
     fe4:	fe cf       	rjmp	.-4      	; 0xfe2 <lcd_init+0x9e>
  SPDR = byte;                        //send payload
     fe6:	88 e3       	ldi	r24, 0x38	; 56
     fe8:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     fea:	77 9b       	sbis	0x0e, 7	; 14
     fec:	fe cf       	rjmp	.-4      	; 0xfea <lcd_init+0xa6>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     fee:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ff2:	88 60       	ori	r24, 0x08	; 8
     ff4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ff8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ffc:	87 7f       	andi	r24, 0xF7	; 247
     ffe:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1002:	8f e1       	ldi	r24, 0x1F	; 31
    1004:	9e e4       	ldi	r25, 0x4E	; 78
    1006:	01 97       	sbiw	r24, 0x01	; 1
    1008:	f1 f7       	brne	.-4      	; 0x1006 <lcd_init+0xc2>
    100a:	00 c0       	rjmp	.+0      	; 0x100c <lcd_init+0xc8>
    100c:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    100e:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1010:	77 9b       	sbis	0x0e, 7	; 14
    1012:	fe cf       	rjmp	.-4      	; 0x1010 <lcd_init+0xcc>
  SPDR = byte;                        //send payload
    1014:	88 e0       	ldi	r24, 0x08	; 8
    1016:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1018:	77 9b       	sbis	0x0e, 7	; 14
    101a:	fe cf       	rjmp	.-4      	; 0x1018 <lcd_init+0xd4>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    101c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1020:	88 60       	ori	r24, 0x08	; 8
    1022:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1026:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    102a:	87 7f       	andi	r24, 0xF7	; 247
    102c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1030:	8f e1       	ldi	r24, 0x1F	; 31
    1032:	9e e4       	ldi	r25, 0x4E	; 78
    1034:	01 97       	sbiw	r24, 0x01	; 1
    1036:	f1 f7       	brne	.-4      	; 0x1034 <lcd_init+0xf0>
    1038:	00 c0       	rjmp	.+0      	; 0x103a <lcd_init+0xf6>
    103a:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    103c:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    103e:	77 9b       	sbis	0x0e, 7	; 14
    1040:	fe cf       	rjmp	.-4      	; 0x103e <lcd_init+0xfa>
  SPDR = byte;                        //send payload
    1042:	81 e0       	ldi	r24, 0x01	; 1
    1044:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1046:	77 9b       	sbis	0x0e, 7	; 14
    1048:	fe cf       	rjmp	.-4      	; 0x1046 <lcd_init+0x102>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    104a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    104e:	88 60       	ori	r24, 0x08	; 8
    1050:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1054:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1058:	87 7f       	andi	r24, 0xF7	; 247
    105a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    105e:	8f e1       	ldi	r24, 0x1F	; 31
    1060:	9e e4       	ldi	r25, 0x4E	; 78
    1062:	01 97       	sbiw	r24, 0x01	; 1
    1064:	f1 f7       	brne	.-4      	; 0x1062 <lcd_init+0x11e>
    1066:	00 c0       	rjmp	.+0      	; 0x1068 <lcd_init+0x124>
    1068:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    106a:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    106c:	77 9b       	sbis	0x0e, 7	; 14
    106e:	fe cf       	rjmp	.-4      	; 0x106c <lcd_init+0x128>
  SPDR = byte;                        //send payload
    1070:	86 e0       	ldi	r24, 0x06	; 6
    1072:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1074:	77 9b       	sbis	0x0e, 7	; 14
    1076:	fe cf       	rjmp	.-4      	; 0x1074 <lcd_init+0x130>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    1078:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    107c:	88 60       	ori	r24, 0x08	; 8
    107e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1082:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1086:	87 7f       	andi	r24, 0xF7	; 247
    1088:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    108c:	8f e1       	ldi	r24, 0x1F	; 31
    108e:	9e e4       	ldi	r25, 0x4E	; 78
    1090:	01 97       	sbiw	r24, 0x01	; 1
    1092:	f1 f7       	brne	.-4      	; 0x1090 <lcd_init+0x14c>
    1094:	00 c0       	rjmp	.+0      	; 0x1096 <lcd_init+0x152>
    1096:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1098:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    109a:	77 9b       	sbis	0x0e, 7	; 14
    109c:	fe cf       	rjmp	.-4      	; 0x109a <lcd_init+0x156>
  SPDR = byte;                        //send payload
    109e:	8c e0       	ldi	r24, 0x0C	; 12
    10a0:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    10a2:	77 9b       	sbis	0x0e, 7	; 14
    10a4:	fe cf       	rjmp	.-4      	; 0x10a2 <lcd_init+0x15e>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    10a6:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10aa:	88 60       	ori	r24, 0x08	; 8
    10ac:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10b0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10b4:	87 7f       	andi	r24, 0xF7	; 247
    10b6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10ba:	8f e1       	ldi	r24, 0x1F	; 31
    10bc:	9e e4       	ldi	r25, 0x4E	; 78
    10be:	01 97       	sbiw	r24, 0x01	; 1
    10c0:	f1 f7       	brne	.-4      	; 0x10be <lcd_init+0x17a>
    10c2:	00 c0       	rjmp	.+0      	; 0x10c4 <lcd_init+0x180>
    10c4:	00 00       	nop
    10c6:	08 95       	ret

000010c8 <lcd_int32>:
void  lcd_int32(int32_t l,          //number to display
                uint8_t fieldwidth, //width of the field for display
                uint8_t decpos,     //0 if no decimal point, otherwise
                uint8_t bSigned,    //non-zero if the number should be treated as signed 
                uint8_t bZeroFill)  //non-zero if a specified fieldwidth is to be zero filled
{
    10c8:	4f 92       	push	r4
    10ca:	5f 92       	push	r5
    10cc:	6f 92       	push	r6
    10ce:	7f 92       	push	r7
    10d0:	8f 92       	push	r8
    10d2:	9f 92       	push	r9
    10d4:	af 92       	push	r10
    10d6:	bf 92       	push	r11
    10d8:	cf 92       	push	r12
    10da:	df 92       	push	r13
    10dc:	ef 92       	push	r14
    10de:	ff 92       	push	r15
    10e0:	0f 93       	push	r16
    10e2:	1f 93       	push	r17
    10e4:	cf 93       	push	r28
    10e6:	df 93       	push	r29
    10e8:	cd b7       	in	r28, 0x3d	; 61
    10ea:	de b7       	in	r29, 0x3e	; 62
    10ec:	69 97       	sbiw	r28, 0x19	; 25
    10ee:	0f b6       	in	r0, 0x3f	; 63
    10f0:	f8 94       	cli
    10f2:	de bf       	out	0x3e, r29	; 62
    10f4:	0f be       	out	0x3f, r0	; 63
    10f6:	cd bf       	out	0x3d, r28	; 61
    10f8:	14 2f       	mov	r17, r20
    10fa:	42 2e       	mov	r4, r18
    10fc:	5e 2c       	mov	r5, r14
      char    fillch;
      ldiv_t  qr;

      qr.quot = l; // initialize the quotient 

      if (bSigned){
    10fe:	00 23       	and	r16, r16
    1100:	79 f0       	breq	.+30     	; 0x1120 <__stack+0x21>
        bSigned = (qr.quot<0);
    1102:	6b 01       	movw	r12, r22
    1104:	7c 01       	movw	r14, r24
    1106:	cc 24       	eor	r12, r12
    1108:	f7 fc       	sbrc	r15, 7
    110a:	c3 94       	inc	r12
    110c:	dd 24       	eor	r13, r13
    110e:	ee 24       	eor	r14, r14
    1110:	ff 24       	eor	r15, r15
    1112:	0c 2d       	mov	r16, r12
        qr.quot = labs(qr.quot);
    1114:	6b 01       	movw	r12, r22
    1116:	7c 01       	movw	r14, r24
    1118:	97 fd       	sbrc	r25, 7
    111a:	a3 c0       	rjmp	.+326    	; 0x1262 <__stack+0x163>
    111c:	c7 01       	movw	r24, r14
    111e:	b6 01       	movw	r22, r12
      }

      // convert the digits to the right of the decimal point 
      if (decpos){
    1120:	44 20       	and	r4, r4
    1122:	09 f4       	brne	.+2      	; 0x1126 <__stack+0x27>
    1124:	96 c0       	rjmp	.+300    	; 0x1252 <__stack+0x153>
    1126:	9e 01       	movw	r18, r28
    1128:	2f 5f       	subi	r18, 0xFF	; 255
    112a:	3f 4f       	sbci	r19, 0xFF	; 255
    112c:	59 01       	movw	r10, r18
    112e:	49 01       	movw	r8, r18
    1130:	66 24       	eor	r6, r6
    1132:	6a 94       	dec	r6
    1134:	64 0c       	add	r6, r4
    1136:	71 2c       	mov	r7, r1
    1138:	3f ef       	ldi	r19, 0xFF	; 255
    113a:	63 1a       	sub	r6, r19
    113c:	73 0a       	sbc	r7, r19
    113e:	6a 0c       	add	r6, r10
    1140:	7b 1c       	adc	r7, r11
        for (; decpos ; decpos--){
          qr = ldiv(qr.quot, 10);
    1142:	2a e0       	ldi	r18, 0x0A	; 10
    1144:	30 e0       	ldi	r19, 0x00	; 0
    1146:	40 e0       	ldi	r20, 0x00	; 0
    1148:	50 e0       	ldi	r21, 0x00	; 0
    114a:	0e 94 64 0b 	call	0x16c8	; 0x16c8 <__divmodsi4>
    114e:	e6 2f       	mov	r30, r22
    1150:	2a 8b       	std	Y+18, r18	; 0x12
    1152:	3b 8b       	std	Y+19, r19	; 0x13
    1154:	4c 8b       	std	Y+20, r20	; 0x14
    1156:	5d 8b       	std	Y+21, r21	; 0x15
    1158:	6a 89       	ldd	r22, Y+18	; 0x12
    115a:	7b 89       	ldd	r23, Y+19	; 0x13
    115c:	8c 89       	ldd	r24, Y+20	; 0x14
    115e:	9d 89       	ldd	r25, Y+21	; 0x15
          sline[i++] = qr.rem + '0';
    1160:	20 e3       	ldi	r18, 0x30	; 48
    1162:	2e 0f       	add	r18, r30
    1164:	f4 01       	movw	r30, r8
    1166:	21 93       	st	Z+, r18
    1168:	4f 01       	movw	r8, r30
        qr.quot = labs(qr.quot);
      }

      // convert the digits to the right of the decimal point 
      if (decpos){
        for (; decpos ; decpos--){
    116a:	6e 16       	cp	r6, r30
    116c:	7f 06       	cpc	r7, r31
    116e:	49 f7       	brne	.-46     	; 0x1142 <__stack+0x43>
          qr = ldiv(qr.quot, 10);
          sline[i++] = qr.rem + '0';
        }
        sline[i++] = '.';
    1170:	99 24       	eor	r9, r9
    1172:	93 94       	inc	r9
    1174:	94 0c       	add	r9, r4
    1176:	f5 01       	movw	r30, r10
    1178:	e4 0d       	add	r30, r4
    117a:	f1 1d       	adc	r31, r1
    117c:	2e e2       	ldi	r18, 0x2E	; 46
    117e:	20 83       	st	Z, r18
      }

      // convert the digits to the left of the decimal point 
      do{
          qr = ldiv(qr.quot, 10);
    1180:	2a e0       	ldi	r18, 0x0A	; 10
    1182:	30 e0       	ldi	r19, 0x00	; 0
    1184:	40 e0       	ldi	r20, 0x00	; 0
    1186:	50 e0       	ldi	r21, 0x00	; 0
    1188:	0e 94 64 0b 	call	0x16c8	; 0x16c8 <__divmodsi4>
    118c:	e6 2f       	mov	r30, r22
    118e:	2a 8b       	std	Y+18, r18	; 0x12
    1190:	3b 8b       	std	Y+19, r19	; 0x13
    1192:	4c 8b       	std	Y+20, r20	; 0x14
    1194:	5d 8b       	std	Y+21, r21	; 0x15
    1196:	6e 8b       	std	Y+22, r22	; 0x16
    1198:	7f 8b       	std	Y+23, r23	; 0x17
    119a:	88 8f       	std	Y+24, r24	; 0x18
    119c:	99 8f       	std	Y+25, r25	; 0x19
    119e:	6a 89       	ldd	r22, Y+18	; 0x12
    11a0:	7b 89       	ldd	r23, Y+19	; 0x13
    11a2:	8c 89       	ldd	r24, Y+20	; 0x14
    11a4:	9d 89       	ldd	r25, Y+21	; 0x15
          sline[i++] = qr.rem + '0';
    11a6:	31 e0       	ldi	r19, 0x01	; 1
    11a8:	39 0d       	add	r19, r9
    11aa:	d5 01       	movw	r26, r10
    11ac:	a9 0d       	add	r26, r9
    11ae:	b1 1d       	adc	r27, r1
    11b0:	e0 5d       	subi	r30, 0xD0	; 208
    11b2:	ec 93       	st	X, r30
    11b4:	93 2e       	mov	r9, r19
        }while(qr.quot);
    11b6:	61 15       	cp	r22, r1
    11b8:	71 05       	cpc	r23, r1
    11ba:	81 05       	cpc	r24, r1
    11bc:	91 05       	cpc	r25, r1
    11be:	01 f7       	brne	.-64     	; 0x1180 <__stack+0x81>

      // fill the whole field if a width was specified
      if (fieldwidth){
    11c0:	11 23       	and	r17, r17
    11c2:	61 f0       	breq	.+24     	; 0x11dc <__stack+0xdd>
        fillch = bZeroFill? '0': ' '; // determine the fill character
    11c4:	51 10       	cpse	r5, r1
    11c6:	4b c0       	rjmp	.+150    	; 0x125e <__stack+0x15f>
    11c8:	90 e2       	ldi	r25, 0x20	; 32
        for (; i<fieldwidth ; ){sline[i++] = fillch;}
    11ca:	31 17       	cp	r19, r17
    11cc:	38 f4       	brcc	.+14     	; 0x11dc <__stack+0xdd>
    11ce:	f5 01       	movw	r30, r10
    11d0:	e3 0f       	add	r30, r19
    11d2:	f1 1d       	adc	r31, r1
    11d4:	90 83       	st	Z, r25
    11d6:	3f 5f       	subi	r19, 0xFF	; 255
    11d8:	13 13       	cpse	r17, r19
    11da:	f9 cf       	rjmp	.-14     	; 0x11ce <__stack+0xcf>
      }

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}
    11dc:	00 23       	and	r16, r16
    11de:	31 f0       	breq	.+12     	; 0x11ec <__stack+0xed>
    11e0:	f5 01       	movw	r30, r10
    11e2:	e3 0f       	add	r30, r19
    11e4:	f1 1d       	adc	r31, r1
    11e6:	9d e2       	ldi	r25, 0x2D	; 45
    11e8:	90 83       	st	Z, r25
    11ea:	3f 5f       	subi	r19, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    11ec:	21 e0       	ldi	r18, 0x01	; 1

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}

      // now output the formatted number
      do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    11ee:	31 50       	subi	r19, 0x01	; 1
    11f0:	f5 01       	movw	r30, r10
    11f2:	e3 0f       	add	r30, r19
    11f4:	f1 1d       	adc	r31, r1
    11f6:	90 81       	ld	r25, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    11f8:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    11fa:	77 9b       	sbis	0x0e, 7	; 14
    11fc:	fe cf       	rjmp	.-4      	; 0x11fa <__stack+0xfb>
  SPDR = byte;                        //send payload
    11fe:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1200:	77 9b       	sbis	0x0e, 7	; 14
    1202:	fe cf       	rjmp	.-4      	; 0x1200 <__stack+0x101>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    1204:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1208:	98 60       	ori	r25, 0x08	; 8
    120a:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    120e:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1212:	97 7f       	andi	r25, 0xF7	; 247
    1214:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1218:	85 ed       	ldi	r24, 0xD5	; 213
    121a:	8a 95       	dec	r24
    121c:	f1 f7       	brne	.-4      	; 0x121a <__stack+0x11b>
    121e:	00 00       	nop

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}

      // now output the formatted number
      do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    1220:	31 11       	cpse	r19, r1
    1222:	e5 cf       	rjmp	.-54     	; 0x11ee <__stack+0xef>

}
    1224:	69 96       	adiw	r28, 0x19	; 25
    1226:	0f b6       	in	r0, 0x3f	; 63
    1228:	f8 94       	cli
    122a:	de bf       	out	0x3e, r29	; 62
    122c:	0f be       	out	0x3f, r0	; 63
    122e:	cd bf       	out	0x3d, r28	; 61
    1230:	df 91       	pop	r29
    1232:	cf 91       	pop	r28
    1234:	1f 91       	pop	r17
    1236:	0f 91       	pop	r16
    1238:	ff 90       	pop	r15
    123a:	ef 90       	pop	r14
    123c:	df 90       	pop	r13
    123e:	cf 90       	pop	r12
    1240:	bf 90       	pop	r11
    1242:	af 90       	pop	r10
    1244:	9f 90       	pop	r9
    1246:	8f 90       	pop	r8
    1248:	7f 90       	pop	r7
    124a:	6f 90       	pop	r6
    124c:	5f 90       	pop	r5
    124e:	4f 90       	pop	r4
    1250:	08 95       	ret
                uint8_t decpos,     //0 if no decimal point, otherwise
                uint8_t bSigned,    //non-zero if the number should be treated as signed 
                uint8_t bZeroFill)  //non-zero if a specified fieldwidth is to be zero filled
{
      char    sline[NUM_LCD_CHARS+1];
      uint8_t i=0;
    1252:	91 2c       	mov	r9, r1
    1254:	9e 01       	movw	r18, r28
    1256:	2f 5f       	subi	r18, 0xFF	; 255
    1258:	3f 4f       	sbci	r19, 0xFF	; 255
    125a:	59 01       	movw	r10, r18
    125c:	91 cf       	rjmp	.-222    	; 0x1180 <__stack+0x81>
          sline[i++] = qr.rem + '0';
        }while(qr.quot);

      // fill the whole field if a width was specified
      if (fieldwidth){
        fillch = bZeroFill? '0': ' '; // determine the fill character
    125e:	90 e3       	ldi	r25, 0x30	; 48
    1260:	b4 cf       	rjmp	.-152    	; 0x11ca <__stack+0xcb>

      qr.quot = l; // initialize the quotient 

      if (bSigned){
        bSigned = (qr.quot<0);
        qr.quot = labs(qr.quot);
    1262:	f0 94       	com	r15
    1264:	e0 94       	com	r14
    1266:	d0 94       	com	r13
    1268:	c0 94       	com	r12
    126a:	c1 1c       	adc	r12, r1
    126c:	d1 1c       	adc	r13, r1
    126e:	e1 1c       	adc	r14, r1
    1270:	f1 1c       	adc	r15, r1
    1272:	54 cf       	rjmp	.-344    	; 0x111c <__stack+0x1d>

00001274 <lcd_int16>:
void    lcd_int16(int16_t l, 
                  uint8_t fieldwidth, 
                  uint8_t decpos, 
                  uint8_t bSigned,
                  uint8_t bZeroFill)
{
    1274:	5f 92       	push	r5
    1276:	6f 92       	push	r6
    1278:	7f 92       	push	r7
    127a:	8f 92       	push	r8
    127c:	9f 92       	push	r9
    127e:	af 92       	push	r10
    1280:	bf 92       	push	r11
    1282:	cf 92       	push	r12
    1284:	df 92       	push	r13
    1286:	ef 92       	push	r14
    1288:	ff 92       	push	r15
    128a:	0f 93       	push	r16
    128c:	1f 93       	push	r17
    128e:	cf 93       	push	r28
    1290:	df 93       	push	r29
    1292:	cd b7       	in	r28, 0x3d	; 61
    1294:	de b7       	in	r29, 0x3e	; 62
    1296:	61 97       	sbiw	r28, 0x11	; 17
    1298:	0f b6       	in	r0, 0x3f	; 63
    129a:	f8 94       	cli
    129c:	de bf       	out	0x3e, r29	; 62
    129e:	0f be       	out	0x3f, r0	; 63
    12a0:	cd bf       	out	0x3d, r28	; 61
    12a2:	5c 01       	movw	r10, r24
    12a4:	16 2f       	mov	r17, r22
    12a6:	74 2e       	mov	r7, r20
//        uint8_t bSigned;   Now an argument for signed or not

        // initialize the quotient 
        qr.quot = l;

        if ( (bSigned=(qr.quot<0)) )
    12a8:	6b 2c       	mov	r6, r11
    12aa:	66 1c       	adc	r6, r6
    12ac:	66 24       	eor	r6, r6
    12ae:	66 1c       	adc	r6, r6
    12b0:	56 2c       	mov	r5, r6
    12b2:	9c 01       	movw	r18, r24
    12b4:	97 fd       	sbrc	r25, 7
    12b6:	9b c0       	rjmp	.+310    	; 0x13ee <lcd_int16+0x17a>
                qr.quot = -qr.quot;

        // convert the digits to the right of the decimal point 
        if (decpos){
    12b8:	77 20       	and	r7, r7
    12ba:	09 f4       	brne	.+2      	; 0x12be <lcd_int16+0x4a>
    12bc:	8d c0       	rjmp	.+282    	; 0x13d8 <lcd_int16+0x164>
    12be:	ce 01       	movw	r24, r28
    12c0:	01 96       	adiw	r24, 0x01	; 1
    12c2:	7c 01       	movw	r14, r24
    12c4:	6c 01       	movw	r12, r24
    12c6:	88 24       	eor	r8, r8
    12c8:	8a 94       	dec	r8
    12ca:	87 0c       	add	r8, r7
    12cc:	91 2c       	mov	r9, r1
    12ce:	9f ef       	ldi	r25, 0xFF	; 255
    12d0:	89 1a       	sub	r8, r25
    12d2:	99 0a       	sbc	r9, r25
    12d4:	8e 0c       	add	r8, r14
    12d6:	9f 1c       	adc	r9, r15
          for (; decpos ; decpos--){
            qr = div(qr.quot, 10);
    12d8:	6a e0       	ldi	r22, 0x0A	; 10
    12da:	70 e0       	ldi	r23, 0x00	; 0
    12dc:	c9 01       	movw	r24, r18
    12de:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <__divmodhi4>
    12e2:	46 2f       	mov	r20, r22
    12e4:	24 2f       	mov	r18, r20
    12e6:	37 2f       	mov	r19, r23
            sline[i++] = qr.rem + '0';
    12e8:	80 5d       	subi	r24, 0xD0	; 208
    12ea:	f6 01       	movw	r30, r12
    12ec:	81 93       	st	Z+, r24
    12ee:	6f 01       	movw	r12, r30
        if ( (bSigned=(qr.quot<0)) )
                qr.quot = -qr.quot;

        // convert the digits to the right of the decimal point 
        if (decpos){
          for (; decpos ; decpos--){
    12f0:	e8 15       	cp	r30, r8
    12f2:	f9 05       	cpc	r31, r9
    12f4:	89 f7       	brne	.-30     	; 0x12d8 <lcd_int16+0x64>
            qr = div(qr.quot, 10);
            sline[i++] = qr.rem + '0';
          }
          sline[i++] = '.';
    12f6:	dd 24       	eor	r13, r13
    12f8:	d3 94       	inc	r13
    12fa:	d7 0c       	add	r13, r7
    12fc:	f7 01       	movw	r30, r14
    12fe:	e7 0d       	add	r30, r7
    1300:	f1 1d       	adc	r31, r1
    1302:	8e e2       	ldi	r24, 0x2E	; 46
    1304:	80 83       	st	Z, r24
    1306:	01 c0       	rjmp	.+2      	; 0x130a <lcd_int16+0x96>

        // convert the digits to the left of the decimal point 
        do
        {
                qr = div(qr.quot, 10);
                sline[i++] = qr.rem + '0';
    1308:	d9 2e       	mov	r13, r25
        }

        // convert the digits to the left of the decimal point 
        do
        {
                qr = div(qr.quot, 10);
    130a:	6a e0       	ldi	r22, 0x0A	; 10
    130c:	70 e0       	ldi	r23, 0x00	; 0
    130e:	c9 01       	movw	r24, r18
    1310:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <__divmodhi4>
    1314:	46 2f       	mov	r20, r22
    1316:	24 2f       	mov	r18, r20
    1318:	37 2f       	mov	r19, r23
                sline[i++] = qr.rem + '0';
    131a:	91 e0       	ldi	r25, 0x01	; 1
    131c:	9d 0d       	add	r25, r13
    131e:	f7 01       	movw	r30, r14
    1320:	ed 0d       	add	r30, r13
    1322:	f1 1d       	adc	r31, r1
    1324:	80 5d       	subi	r24, 0xD0	; 208
    1326:	80 83       	st	Z, r24
        }
        while(qr.quot);
    1328:	21 15       	cp	r18, r1
    132a:	31 05       	cpc	r19, r1
    132c:	69 f7       	brne	.-38     	; 0x1308 <lcd_int16+0x94>

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
    132e:	01 11       	cpse	r16, r1
    1330:	58 c0       	rjmp	.+176    	; 0x13e2 <lcd_int16+0x16e>
    1332:	b7 fc       	sbrc	r11, 7
    1334:	61 c0       	rjmp	.+194    	; 0x13f8 <lcd_int16+0x184>
                sline[i++] = '-';
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    1336:	11 23       	and	r17, r17
    1338:	a9 f0       	breq	.+42     	; 0x1364 <lcd_int16+0xf0>
    133a:	71 2c       	mov	r7, r1
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    133c:	80 e2       	ldi	r24, 0x20	; 32
          for (; i<(fieldwidth-bSigned) ; ){ sline[i++] = fillch;}
    133e:	29 2f       	mov	r18, r25
    1340:	30 e0       	ldi	r19, 0x00	; 0
    1342:	41 2f       	mov	r20, r17
    1344:	50 e0       	ldi	r21, 0x00	; 0
    1346:	46 19       	sub	r20, r6
    1348:	57 09       	sbc	r21, r7
    134a:	24 17       	cp	r18, r20
    134c:	35 07       	cpc	r19, r21
    134e:	54 f4       	brge	.+20     	; 0x1364 <lcd_int16+0xf0>
    1350:	9f 5f       	subi	r25, 0xFF	; 255
    1352:	f7 01       	movw	r30, r14
    1354:	e2 0f       	add	r30, r18
    1356:	f3 1f       	adc	r31, r19
    1358:	80 83       	st	Z, r24
    135a:	29 2f       	mov	r18, r25
    135c:	30 e0       	ldi	r19, 0x00	; 0
    135e:	24 17       	cp	r18, r20
    1360:	35 07       	cpc	r19, r21
    1362:	b4 f3       	brlt	.-20     	; 0x1350 <lcd_int16+0xdc>
        }

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}
    1364:	55 20       	and	r5, r5
    1366:	31 f0       	breq	.+12     	; 0x1374 <lcd_int16+0x100>
    1368:	f7 01       	movw	r30, r14
    136a:	e9 0f       	add	r30, r25
    136c:	f1 1d       	adc	r31, r1
    136e:	8d e2       	ldi	r24, 0x2D	; 45
    1370:	80 83       	st	Z, r24
    1372:	9f 5f       	subi	r25, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1374:	21 e0       	ldi	r18, 0x01	; 1

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}

        // now output the formatted number 
            do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    1376:	91 50       	subi	r25, 0x01	; 1
    1378:	f7 01       	movw	r30, r14
    137a:	e9 0f       	add	r30, r25
    137c:	f1 1d       	adc	r31, r1
    137e:	80 81       	ld	r24, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1380:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1382:	77 9b       	sbis	0x0e, 7	; 14
    1384:	fe cf       	rjmp	.-4      	; 0x1382 <lcd_int16+0x10e>
  SPDR = byte;                        //send payload
    1386:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1388:	77 9b       	sbis	0x0e, 7	; 14
    138a:	fe cf       	rjmp	.-4      	; 0x1388 <lcd_int16+0x114>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    138c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1390:	88 60       	ori	r24, 0x08	; 8
    1392:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1396:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    139a:	87 7f       	andi	r24, 0xF7	; 247
    139c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    13a0:	e5 ed       	ldi	r30, 0xD5	; 213
    13a2:	ea 95       	dec	r30
    13a4:	f1 f7       	brne	.-4      	; 0x13a2 <lcd_int16+0x12e>
    13a6:	00 00       	nop

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}

        // now output the formatted number 
            do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    13a8:	91 11       	cpse	r25, r1
    13aa:	e5 cf       	rjmp	.-54     	; 0x1376 <lcd_int16+0x102>
}
    13ac:	61 96       	adiw	r28, 0x11	; 17
    13ae:	0f b6       	in	r0, 0x3f	; 63
    13b0:	f8 94       	cli
    13b2:	de bf       	out	0x3e, r29	; 62
    13b4:	0f be       	out	0x3f, r0	; 63
    13b6:	cd bf       	out	0x3d, r28	; 61
    13b8:	df 91       	pop	r29
    13ba:	cf 91       	pop	r28
    13bc:	1f 91       	pop	r17
    13be:	0f 91       	pop	r16
    13c0:	ff 90       	pop	r15
    13c2:	ef 90       	pop	r14
    13c4:	df 90       	pop	r13
    13c6:	cf 90       	pop	r12
    13c8:	bf 90       	pop	r11
    13ca:	af 90       	pop	r10
    13cc:	9f 90       	pop	r9
    13ce:	8f 90       	pop	r8
    13d0:	7f 90       	pop	r7
    13d2:	6f 90       	pop	r6
    13d4:	5f 90       	pop	r5
    13d6:	08 95       	ret
                  uint8_t decpos, 
                  uint8_t bSigned,
                  uint8_t bZeroFill)
{
        char    sline[NUM_LCD_CHARS+1];
        uint8_t i=0;
    13d8:	d1 2c       	mov	r13, r1
    13da:	ce 01       	movw	r24, r28
    13dc:	01 96       	adiw	r24, 0x01	; 1
    13de:	7c 01       	movw	r14, r24
    13e0:	94 cf       	rjmp	.-216    	; 0x130a <lcd_int16+0x96>
                sline[i++] = '-';
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    13e2:	11 23       	and	r17, r17
    13e4:	09 f4       	brne	.+2      	; 0x13e8 <lcd_int16+0x174>
    13e6:	be cf       	rjmp	.-132    	; 0x1364 <lcd_int16+0xf0>
    13e8:	71 2c       	mov	r7, r1
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    13ea:	80 e3       	ldi	r24, 0x30	; 48
    13ec:	a8 cf       	rjmp	.-176    	; 0x133e <lcd_int16+0xca>
    13ee:	22 27       	eor	r18, r18
    13f0:	33 27       	eor	r19, r19
    13f2:	28 1b       	sub	r18, r24
    13f4:	39 0b       	sbc	r19, r25
    13f6:	60 cf       	rjmp	.-320    	; 0x12b8 <lcd_int16+0x44>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    13f8:	d3 94       	inc	r13
    13fa:	d3 94       	inc	r13
    13fc:	f7 01       	movw	r30, r14
    13fe:	e9 0f       	add	r30, r25
    1400:	f1 1d       	adc	r31, r1
    1402:	8d e2       	ldi	r24, 0x2D	; 45
    1404:	80 83       	st	Z, r24
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    1406:	11 23       	and	r17, r17
    1408:	59 f0       	breq	.+22     	; 0x1420 <lcd_int16+0x1ac>
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
          for (; i<(fieldwidth-bSigned) ; ){ sline[i++] = fillch;}
    140a:	2d 2d       	mov	r18, r13
    140c:	30 e0       	ldi	r19, 0x00	; 0
    140e:	41 2f       	mov	r20, r17
    1410:	50 e0       	ldi	r21, 0x00	; 0
    1412:	24 17       	cp	r18, r20
    1414:	35 07       	cpc	r19, r21
    1416:	24 f4       	brge	.+8      	; 0x1420 <lcd_int16+0x1ac>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    1418:	9d 2d       	mov	r25, r13
                bSigned = 0;
    141a:	51 2c       	mov	r5, r1
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    141c:	80 e2       	ldi	r24, 0x20	; 32
    141e:	98 cf       	rjmp	.-208    	; 0x1350 <lcd_int16+0xdc>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    1420:	9d 2d       	mov	r25, r13
    1422:	a8 cf       	rjmp	.-176    	; 0x1374 <lcd_int16+0x100>

00001424 <__vector_33>:

//****************************************************************************
//This is the TWI ISR. Different actions are taken depending upon the value
//of the TWI status register TWSR.
//****************************************************************************/
ISR(TWI_vect){
    1424:	1f 92       	push	r1
    1426:	0f 92       	push	r0
    1428:	0f b6       	in	r0, 0x3f	; 63
    142a:	0f 92       	push	r0
    142c:	11 24       	eor	r1, r1
    142e:	0b b6       	in	r0, 0x3b	; 59
    1430:	0f 92       	push	r0
    1432:	2f 93       	push	r18
    1434:	3f 93       	push	r19
    1436:	8f 93       	push	r24
    1438:	9f 93       	push	r25
    143a:	af 93       	push	r26
    143c:	bf 93       	push	r27
    143e:	ef 93       	push	r30
    1440:	ff 93       	push	r31
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    1442:	e0 91 71 00 	lds	r30, 0x0071	; 0x800071 <__TEXT_REGION_LENGTH__+0x7e0071>
    1446:	8e 2f       	mov	r24, r30
    1448:	90 e0       	ldi	r25, 0x00	; 0
    144a:	fc 01       	movw	r30, r24
    144c:	38 97       	sbiw	r30, 0x08	; 8
    144e:	e1 35       	cpi	r30, 0x51	; 81
    1450:	f1 05       	cpc	r31, r1
    1452:	b0 f0       	brcs	.+44     	; 0x1480 <__vector_33+0x5c>
      break;      
    case TW_MT_ARB_LOST:                //Arbitration lost 
      TWCR = TWCR_START;                //initiate RESTART 
      break;
    default:                            //Error occured, save TWSR 
      twi_state = TWSR;         
    1454:	80 91 71 00 	lds	r24, 0x0071	; 0x800071 <__TEXT_REGION_LENGTH__+0x7e0071>
    1458:	80 93 89 01 	sts	0x0189, r24	; 0x800189 <twi_state>
      TWCR = TWCR_RST;                  //Reset TWI, disable interupts 
    145c:	84 e0       	ldi	r24, 0x04	; 4
    145e:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
  }//switch
}//TWI_isr
    1462:	ff 91       	pop	r31
    1464:	ef 91       	pop	r30
    1466:	bf 91       	pop	r27
    1468:	af 91       	pop	r26
    146a:	9f 91       	pop	r25
    146c:	8f 91       	pop	r24
    146e:	3f 91       	pop	r19
    1470:	2f 91       	pop	r18
    1472:	0f 90       	pop	r0
    1474:	0b be       	out	0x3b, r0	; 59
    1476:	0f 90       	pop	r0
    1478:	0f be       	out	0x3f, r0	; 63
    147a:	0f 90       	pop	r0
    147c:	1f 90       	pop	r1
    147e:	18 95       	reti
//of the TWI status register TWSR.
//****************************************************************************/
ISR(TWI_vect){
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    1480:	ea 5b       	subi	r30, 0xBA	; 186
    1482:	ff 4f       	sbci	r31, 0xFF	; 255
    1484:	0c 94 83 0b 	jmp	0x1706	; 0x1706 <__tablejump2__>
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
      else                               {TWCR = TWCR_RNACK;} //NACK last byte 
      break; 
    case TW_MR_DATA_NACK: //Data byte was rcvd and NACK xmitted
      twi_buf[twi_buf_ptr] = TWDR;      //save last byte to buffer
    1488:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <twi_buf_ptr.1780>
    148c:	e0 91 8a 01 	lds	r30, 0x018A	; 0x80018a <twi_buf>
    1490:	f0 91 8b 01 	lds	r31, 0x018B	; 0x80018b <twi_buf+0x1>
    1494:	e8 0f       	add	r30, r24
    1496:	f1 1d       	adc	r31, r1
    1498:	80 91 73 00 	lds	r24, 0x0073	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
    149c:	80 83       	st	Z, r24
      TWCR = TWCR_STOP;                 //initiate a STOP
    149e:	84 e9       	ldi	r24, 0x94	; 148
    14a0:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
      break;      
    14a4:	de cf       	rjmp	.-68     	; 0x1462 <__vector_33+0x3e>
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    case TW_START:          //START has been xmitted, fall thorough
    case TW_REP_START:      //Repeated START was xmitted
      TWDR = twi_bus_addr;  //load up the twi bus address
    14a6:	80 91 8c 01 	lds	r24, 0x018C	; 0x80018c <twi_bus_addr>
    14aa:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
      twi_buf_ptr = 0;      //initalize buffer pointer 
    14ae:	10 92 56 01 	sts	0x0156, r1	; 0x800156 <twi_buf_ptr.1780>
      TWCR = TWCR_SEND;     //send SLA+RW
    14b2:	85 e8       	ldi	r24, 0x85	; 133
    14b4:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
      break;
    14b8:	d4 cf       	rjmp	.-88     	; 0x1462 <__vector_33+0x3e>
    case TW_MT_SLA_ACK:     //SLA+W was xmitted and ACK rcvd, fall through 
    case TW_MT_DATA_ACK:                //Data byte was xmitted and ACK rcvd
      if (twi_buf_ptr < twi_msg_size){  //send data till done
    14ba:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <twi_buf_ptr.1780>
    14be:	90 91 8d 01 	lds	r25, 0x018D	; 0x80018d <twi_msg_size>
    14c2:	89 17       	cp	r24, r25
    14c4:	60 f7       	brcc	.-40     	; 0x149e <__vector_33+0x7a>
        TWDR = twi_buf[twi_buf_ptr++];  //load next and postincrement index
    14c6:	e0 91 8a 01 	lds	r30, 0x018A	; 0x80018a <twi_buf>
    14ca:	f0 91 8b 01 	lds	r31, 0x018B	; 0x80018b <twi_buf+0x1>
    14ce:	91 e0       	ldi	r25, 0x01	; 1
    14d0:	98 0f       	add	r25, r24
    14d2:	90 93 56 01 	sts	0x0156, r25	; 0x800156 <twi_buf_ptr.1780>
    14d6:	e8 0f       	add	r30, r24
    14d8:	f1 1d       	adc	r31, r1
    14da:	80 81       	ld	r24, Z
    14dc:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
        TWCR = TWCR_SEND;               //send next byte 
    14e0:	85 e8       	ldi	r24, 0x85	; 133
    14e2:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
    14e6:	bd cf       	rjmp	.-134    	; 0x1462 <__vector_33+0x3e>
    case TW_MR_DATA_NACK: //Data byte was rcvd and NACK xmitted
      twi_buf[twi_buf_ptr] = TWDR;      //save last byte to buffer
      TWCR = TWCR_STOP;                 //initiate a STOP
      break;      
    case TW_MT_ARB_LOST:                //Arbitration lost 
      TWCR = TWCR_START;                //initiate RESTART 
    14e8:	85 ea       	ldi	r24, 0xA5	; 165
    14ea:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
      break;
    14ee:	b9 cf       	rjmp	.-142    	; 0x1462 <__vector_33+0x3e>
    14f0:	20 91 56 01 	lds	r18, 0x0156	; 0x800156 <twi_buf_ptr.1780>
      else{TWCR = TWCR_STOP;}           //last byte sent, send STOP 
      break;
    case TW_MR_DATA_ACK:                //Data byte has been rcvd, ACK xmitted, fall through
      twi_buf[twi_buf_ptr++] = TWDR;    //fill buffer with rcvd data
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
    14f4:	80 91 8d 01 	lds	r24, 0x018D	; 0x80018d <twi_msg_size>
    14f8:	30 e0       	ldi	r19, 0x00	; 0
    14fa:	90 e0       	ldi	r25, 0x00	; 0
    14fc:	01 97       	sbiw	r24, 0x01	; 1
    14fe:	28 17       	cp	r18, r24
    1500:	39 07       	cpc	r19, r25
    1502:	dc f4       	brge	.+54     	; 0x153a <__vector_33+0x116>
    1504:	85 ec       	ldi	r24, 0xC5	; 197
    1506:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
    150a:	ab cf       	rjmp	.-170    	; 0x1462 <__vector_33+0x3e>
        TWCR = TWCR_SEND;               //send next byte 
      }
      else{TWCR = TWCR_STOP;}           //last byte sent, send STOP 
      break;
    case TW_MR_DATA_ACK:                //Data byte has been rcvd, ACK xmitted, fall through
      twi_buf[twi_buf_ptr++] = TWDR;    //fill buffer with rcvd data
    150c:	e0 91 8a 01 	lds	r30, 0x018A	; 0x80018a <twi_buf>
    1510:	f0 91 8b 01 	lds	r31, 0x018B	; 0x80018b <twi_buf+0x1>
    1514:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <twi_buf_ptr.1780>
    1518:	21 e0       	ldi	r18, 0x01	; 1
    151a:	28 0f       	add	r18, r24
    151c:	20 93 56 01 	sts	0x0156, r18	; 0x800156 <twi_buf_ptr.1780>
    1520:	e8 0f       	add	r30, r24
    1522:	f1 1d       	adc	r31, r1
    1524:	80 91 73 00 	lds	r24, 0x0073	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
    1528:	80 83       	st	Z, r24
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
    152a:	80 91 8d 01 	lds	r24, 0x018D	; 0x80018d <twi_msg_size>
    152e:	30 e0       	ldi	r19, 0x00	; 0
    1530:	90 e0       	ldi	r25, 0x00	; 0
    1532:	01 97       	sbiw	r24, 0x01	; 1
    1534:	28 17       	cp	r18, r24
    1536:	39 07       	cpc	r19, r25
    1538:	2c f3       	brlt	.-54     	; 0x1504 <__vector_33+0xe0>
      else                               {TWCR = TWCR_RNACK;} //NACK last byte 
    153a:	85 e8       	ldi	r24, 0x85	; 133
    153c:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
    1540:	90 cf       	rjmp	.-224    	; 0x1462 <__vector_33+0x3e>

00001542 <twi_busy>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    1542:	80 91 74 00 	lds	r24, 0x0074	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
}
    1546:	81 70       	andi	r24, 0x01	; 1
    1548:	08 95       	ret

0000154a <twi_start_wr>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    154a:	90 91 74 00 	lds	r25, 0x0074	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
//Initiates a write transfer. Loads global variables. Sends START. ISR handles
//the rest.
//****************************************************************************
void twi_start_wr(uint8_t twi_addr, uint8_t *twi_data, uint8_t byte_cnt){

  while(twi_busy());                    //wait till TWI rdy for next xfer
    154e:	90 fd       	sbrc	r25, 0
    1550:	fc cf       	rjmp	.-8      	; 0x154a <twi_start_wr>
  twi_bus_addr = (twi_addr & ~TW_READ); //set twi bus address, mark as write 
    1552:	8e 7f       	andi	r24, 0xFE	; 254
    1554:	80 93 8c 01 	sts	0x018C, r24	; 0x80018c <twi_bus_addr>
  twi_buf = twi_data;                   //load pointer to write buffer
    1558:	70 93 8b 01 	sts	0x018B, r23	; 0x80018b <twi_buf+0x1>
    155c:	60 93 8a 01 	sts	0x018A, r22	; 0x80018a <twi_buf>
  twi_msg_size = byte_cnt;              //load size of xfer 
    1560:	40 93 8d 01 	sts	0x018D, r20	; 0x80018d <twi_msg_size>
  TWCR = TWCR_START;                    //initiate START
    1564:	85 ea       	ldi	r24, 0xA5	; 165
    1566:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
    156a:	08 95       	ret

0000156c <twi_start_rd>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    156c:	90 91 74 00 	lds	r25, 0x0074	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
//Initiates a read transfer. Loads global variables. Sends START. ISR handles
//the rest.
//****************************************************************************
void twi_start_rd(uint8_t twi_addr, uint8_t *twi_data, uint8_t byte_cnt){

  while(twi_busy());                   //wait till TWI rdy for next xfer
    1570:	90 fd       	sbrc	r25, 0
    1572:	fc cf       	rjmp	.-8      	; 0x156c <twi_start_rd>
  twi_bus_addr = (twi_addr | TW_READ); //set twi bus address, mark as read  
    1574:	81 60       	ori	r24, 0x01	; 1
    1576:	80 93 8c 01 	sts	0x018C, r24	; 0x80018c <twi_bus_addr>
  twi_buf = twi_data;                  //load pointer to write buffer
    157a:	70 93 8b 01 	sts	0x018B, r23	; 0x80018b <twi_buf+0x1>
    157e:	60 93 8a 01 	sts	0x018A, r22	; 0x80018a <twi_buf>
  twi_msg_size = byte_cnt;             //load size of xfer 
    1582:	40 93 8d 01 	sts	0x018D, r20	; 0x80018d <twi_msg_size>
  TWCR = TWCR_START;                   //initiate START
    1586:	85 ea       	ldi	r24, 0xA5	; 165
    1588:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
    158c:	08 95       	ret

0000158e <init_twi>:
//10K pullups are present on the board
//for alarm clock an additional 4.7K resistor is also there for pullup
//******************************************************************************

void init_twi(){
  TWDR = 0xFF;     //release SDA, default contents
    158e:	8f ef       	ldi	r24, 0xFF	; 255
    1590:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
  TWSR = 0x00;     //prescaler value = 1
    1594:	10 92 71 00 	sts	0x0071, r1	; 0x800071 <__TEXT_REGION_LENGTH__+0x7e0071>
  TWBR = TWI_TWBR; //defined in twi_master.h 
    1598:	8c e0       	ldi	r24, 0x0C	; 12
    159a:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x7e0070>
    159e:	08 95       	ret

000015a0 <lm73_temp_convert>:
   else{ //deg C

   }
//Yeah, this is for you to do! ;^)

}//lm73_temp_convert
    15a0:	08 95       	ret

000015a2 <main>:
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
    15a2:	87 b3       	in	r24, 0x17	; 23
    15a4:	87 60       	ori	r24, 0x07	; 7
    15a6:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
    15a8:	8d b1       	in	r24, 0x0d	; 13
    15aa:	8c 65       	ori	r24, 0x5C	; 92
    15ac:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
    15ae:	70 9a       	sbi	0x0e, 0	; 14
Description: Timer counter 0 is initialized in normal mode with no prescale
	and will be used as a seconds counter for the clock
Parameters: NA
**********************************************************************/
void tcnt0_init(){
   ASSR |= (1<<AS0);
    15b0:	80 b7       	in	r24, 0x30	; 48
    15b2:	88 60       	ori	r24, 0x08	; 8
    15b4:	80 bf       	out	0x30, r24	; 48
   TIMSK |= (1<<TOIE0);			//enable interrupts
    15b6:	87 b7       	in	r24, 0x37	; 55
    15b8:	81 60       	ori	r24, 0x01	; 1
    15ba:	87 bf       	out	0x37, r24	; 55
   TCCR0 |= (1<<CS00);			//normal mode, no prescale
    15bc:	83 b7       	in	r24, 0x33	; 51
    15be:	81 60       	ori	r24, 0x01	; 1
    15c0:	83 bf       	out	0x33, r24	; 51
Description: Timer counter 1 is initialized in CTC mode, 64 bit prescaler
	so that it can be used to generate an alarm frequency
Parameters: NA
**********************************************************************/
void tcnt1_init(){
   TCCR1B |= (1<<CS11) | (1<<CS10) | (1<<WGM12);		//CTC mode, 64bit prescaler
    15c2:	8e b5       	in	r24, 0x2e	; 46
    15c4:	8b 60       	ori	r24, 0x0B	; 11
    15c6:	8e bd       	out	0x2e, r24	; 46
   TCCR1C = 0x00;
    15c8:	10 92 7a 00 	sts	0x007A, r1	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
   TIMSK  |= (1<<OCIE1A);	//enable flag for interrupt 
    15cc:	87 b7       	in	r24, 0x37	; 55
    15ce:	80 61       	ori	r24, 0x10	; 16
    15d0:	87 bf       	out	0x37, r24	; 55
   OCR1A = 0x0040;		//compare match at 64
    15d2:	80 e4       	ldi	r24, 0x40	; 64
    15d4:	90 e0       	ldi	r25, 0x00	; 0
    15d6:	9b bd       	out	0x2b, r25	; 43
    15d8:	8a bd       	out	0x2a, r24	; 42
	normal mode with a 64 bit prescaler. OCRA2 is adjusted to change
	the pwn produced.
Parameters: NA
**********************************************************************/
void tcnt2_init(){
   TCCR2 |= (1<<WGM21) | (1<<WGM20)| (1<<CS20) | (1<<COM21);			
    15da:	85 b5       	in	r24, 0x25	; 37
    15dc:	89 66       	ori	r24, 0x69	; 105
    15de:	85 bd       	out	0x25, r24	; 37
Description: This timer is used as a volume control for the audio amp.
	I adjust the value of OCR3A to change the pwm.
Parameters: NA
**********************************************************************/
void tcnt3_init(){
   TCCR3A |= (1<<COM3A1) | (1<<WGM31);	 //Clear on OCR3A match
    15e0:	80 91 8b 00 	lds	r24, 0x008B	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
    15e4:	82 68       	ori	r24, 0x82	; 130
    15e6:	80 93 8b 00 	sts	0x008B, r24	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
   TCCR3B |= (1<<CS30) | (1<<WGM32) | (1<<WGM33);		//Fast PWM mode, no prescaler
    15ea:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
    15ee:	89 61       	ori	r24, 0x19	; 25
    15f0:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
   TCCR3C = 0x00;
    15f4:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x7e008c>
   ICR3 = 0x9F;				//Setting the TOP value
    15f8:	8f e9       	ldi	r24, 0x9F	; 159
    15fa:	90 e0       	ldi	r25, 0x00	; 0
    15fc:	90 93 81 00 	sts	0x0081, r25	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
    1600:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
   TCNT3 = 0x0000; 			//Initialize TNCT1 to 0
    1604:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    1608:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
   OCR3A = 0x9F;			//Volume Control 0x9F=Max 0x00=Min
    160c:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
    1610:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
   spi_init();				//Initalize spi, counters,adc, and lcd
   tcnt0_init();
   tcnt1_init();
   tcnt2_init();
   tcnt3_init();
   port_init();
    1614:	0e 94 49 04 	call	0x892	; 0x892 <port_init>
Description: Basic adc initialization used for single shot adc readings
Parameters: NA
**********************************************************************/
void adc_init(){
//Initalize ADC and its ports
   DDRF  &= ~(_BV(DDF7)); //make port F bit 7 is ADC input  
    1618:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
    161c:	8f 77       	andi	r24, 0x7F	; 127
    161e:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
   PORTF &= ~(_BV(PF7));  //port F bit 7 pullups must be off
    1622:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1626:	8f 77       	andi	r24, 0x7F	; 127
    1628:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
   ADMUX |= (1<<REFS0) | (1<<MUX2)| (1<<MUX1)| (1<<MUX0); //single-ended, input PORTF bit 7, right adjusted, 10 bits
    162c:	87 b1       	in	r24, 0x07	; 7
    162e:	87 64       	ori	r24, 0x47	; 71
    1630:	87 b9       	out	0x07, r24	; 7

   ADCSRA |= (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);//ADC enabled, don't start yet, single shot mode 
    1632:	86 b1       	in	r24, 0x06	; 6
    1634:	87 68       	ori	r24, 0x87	; 135
    1636:	86 b9       	out	0x06, r24	; 6
   tcnt1_init();
   tcnt2_init();
   tcnt3_init();
   port_init();
   adc_init();
   init_twi();
    1638:	0e 94 c7 0a 	call	0x158e	; 0x158e <init_twi>

   lcd_init();
    163c:	0e 94 a2 07 	call	0xf44	; 0xf44 <lcd_init>
   sei();				//Enable interrupts
    1640:	78 94       	sei
	 }
	 PORTA = segment_data[j];	//Writes the segment data to PORTA aka the segments
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
				//the digit to be displayed is in pin 4, 5, and 6 
         _delay_us(200);		//delay so that the display does not flicker
         PORTA = 0xFF;
    1642:	cf ef       	ldi	r28, 0xFF	; 255
Description: This function disables the snooze variable once the alarm
	seconds equals the normal seconds. 
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
    1644:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <snooze>
    1648:	81 11       	cpse	r24, r1
    164a:	27 c0       	rjmp	.+78     	; 0x169a <main+0xf8>
   lcd_init();
   sei();				//Enable interrupts
   while(1){
      //get_local_temp();
      snoozin();
      fetch_adc();
    164c:	0e 94 dd 04 	call	0x9ba	; 0x9ba <fetch_adc>
      clock_time();
    1650:	0e 94 81 03 	call	0x702	; 0x702 <clock_time>
      change_alarm_state();
    1654:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <change_alarm_state>
    1658:	ee e2       	ldi	r30, 0x2E	; 46
    165a:	f1 e0       	ldi	r31, 0x01	; 1
    165c:	80 e0       	ldi	r24, 0x00	; 0
      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
         if(alarm){
    165e:	90 91 3b 01 	lds	r25, 0x013B	; 0x80013b <alarm>
    1662:	99 23       	and	r25, r25
    1664:	29 f0       	breq	.+10     	; 0x1670 <main+0xce>
	    segment_data[2] &= 0b011;
    1666:	90 91 30 01 	lds	r25, 0x0130	; 0x800130 <__data_end+0x2>
    166a:	93 70       	andi	r25, 0x03	; 3
    166c:	90 93 30 01 	sts	0x0130, r25	; 0x800130 <__data_end+0x2>
	 }
	 PORTA = segment_data[j];	//Writes the segment data to PORTA aka the segments
    1670:	91 91       	ld	r25, Z+
    1672:	9b bb       	out	0x1b, r25	; 27
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
    1674:	98 2f       	mov	r25, r24
    1676:	92 95       	swap	r25
    1678:	90 7f       	andi	r25, 0xF0	; 240
    167a:	98 bb       	out	0x18, r25	; 24
    167c:	af e1       	ldi	r26, 0x1F	; 31
    167e:	b3 e0       	ldi	r27, 0x03	; 3
    1680:	11 97       	sbiw	r26, 0x01	; 1
    1682:	f1 f7       	brne	.-4      	; 0x1680 <main+0xde>
    1684:	00 c0       	rjmp	.+0      	; 0x1686 <main+0xe4>
    1686:	00 00       	nop
				//the digit to be displayed is in pin 4, 5, and 6 
         _delay_us(200);		//delay so that the display does not flicker
         PORTA = 0xFF;
    1688:	cb bb       	out	0x1b, r28	; 27
    168a:	8f 5f       	subi	r24, 0xFF	; 255
      //get_local_temp();
      snoozin();
      fetch_adc();
      clock_time();
      change_alarm_state();
      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
    168c:	85 30       	cpi	r24, 0x05	; 5
    168e:	39 f7       	brne	.-50     	; 0x165e <main+0xbc>
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
				//the digit to be displayed is in pin 4, 5, and 6 
         _delay_us(200);		//delay so that the display does not flicker
         PORTA = 0xFF;
      }
	PORTB = 0x00;;
    1690:	18 ba       	out	0x18, r1	; 24
Description: This function disables the snooze variable once the alarm
	seconds equals the normal seconds. 
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
    1692:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <snooze>
    1696:	88 23       	and	r24, r24
    1698:	c9 f2       	breq	.-78     	; 0x164c <main+0xaa>
    169a:	0e 94 b8 00 	call	0x170	; 0x170 <snoozin.part.1>
    169e:	d6 cf       	rjmp	.-84     	; 0x164c <main+0xaa>

000016a0 <__divmodhi4>:
    16a0:	97 fb       	bst	r25, 7
    16a2:	07 2e       	mov	r0, r23
    16a4:	16 f4       	brtc	.+4      	; 0x16aa <__divmodhi4+0xa>
    16a6:	00 94       	com	r0
    16a8:	07 d0       	rcall	.+14     	; 0x16b8 <__divmodhi4_neg1>
    16aa:	77 fd       	sbrc	r23, 7
    16ac:	09 d0       	rcall	.+18     	; 0x16c0 <__divmodhi4_neg2>
    16ae:	0e 94 8c 0b 	call	0x1718	; 0x1718 <__udivmodhi4>
    16b2:	07 fc       	sbrc	r0, 7
    16b4:	05 d0       	rcall	.+10     	; 0x16c0 <__divmodhi4_neg2>
    16b6:	3e f4       	brtc	.+14     	; 0x16c6 <__divmodhi4_exit>

000016b8 <__divmodhi4_neg1>:
    16b8:	90 95       	com	r25
    16ba:	81 95       	neg	r24
    16bc:	9f 4f       	sbci	r25, 0xFF	; 255
    16be:	08 95       	ret

000016c0 <__divmodhi4_neg2>:
    16c0:	70 95       	com	r23
    16c2:	61 95       	neg	r22
    16c4:	7f 4f       	sbci	r23, 0xFF	; 255

000016c6 <__divmodhi4_exit>:
    16c6:	08 95       	ret

000016c8 <__divmodsi4>:
    16c8:	05 2e       	mov	r0, r21
    16ca:	97 fb       	bst	r25, 7
    16cc:	1e f4       	brtc	.+6      	; 0x16d4 <__divmodsi4+0xc>
    16ce:	00 94       	com	r0
    16d0:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <__negsi2>
    16d4:	57 fd       	sbrc	r21, 7
    16d6:	07 d0       	rcall	.+14     	; 0x16e6 <__divmodsi4_neg2>
    16d8:	0e 94 a0 0b 	call	0x1740	; 0x1740 <__udivmodsi4>
    16dc:	07 fc       	sbrc	r0, 7
    16de:	03 d0       	rcall	.+6      	; 0x16e6 <__divmodsi4_neg2>
    16e0:	4e f4       	brtc	.+18     	; 0x16f4 <__divmodsi4_exit>
    16e2:	0c 94 7b 0b 	jmp	0x16f6	; 0x16f6 <__negsi2>

000016e6 <__divmodsi4_neg2>:
    16e6:	50 95       	com	r21
    16e8:	40 95       	com	r20
    16ea:	30 95       	com	r19
    16ec:	21 95       	neg	r18
    16ee:	3f 4f       	sbci	r19, 0xFF	; 255
    16f0:	4f 4f       	sbci	r20, 0xFF	; 255
    16f2:	5f 4f       	sbci	r21, 0xFF	; 255

000016f4 <__divmodsi4_exit>:
    16f4:	08 95       	ret

000016f6 <__negsi2>:
    16f6:	90 95       	com	r25
    16f8:	80 95       	com	r24
    16fa:	70 95       	com	r23
    16fc:	61 95       	neg	r22
    16fe:	7f 4f       	sbci	r23, 0xFF	; 255
    1700:	8f 4f       	sbci	r24, 0xFF	; 255
    1702:	9f 4f       	sbci	r25, 0xFF	; 255
    1704:	08 95       	ret

00001706 <__tablejump2__>:
    1706:	ee 0f       	add	r30, r30
    1708:	ff 1f       	adc	r31, r31
    170a:	00 24       	eor	r0, r0
    170c:	00 1c       	adc	r0, r0
    170e:	0b be       	out	0x3b, r0	; 59
    1710:	07 90       	elpm	r0, Z+
    1712:	f6 91       	elpm	r31, Z
    1714:	e0 2d       	mov	r30, r0
    1716:	09 94       	ijmp

00001718 <__udivmodhi4>:
    1718:	aa 1b       	sub	r26, r26
    171a:	bb 1b       	sub	r27, r27
    171c:	51 e1       	ldi	r21, 0x11	; 17
    171e:	07 c0       	rjmp	.+14     	; 0x172e <__udivmodhi4_ep>

00001720 <__udivmodhi4_loop>:
    1720:	aa 1f       	adc	r26, r26
    1722:	bb 1f       	adc	r27, r27
    1724:	a6 17       	cp	r26, r22
    1726:	b7 07       	cpc	r27, r23
    1728:	10 f0       	brcs	.+4      	; 0x172e <__udivmodhi4_ep>
    172a:	a6 1b       	sub	r26, r22
    172c:	b7 0b       	sbc	r27, r23

0000172e <__udivmodhi4_ep>:
    172e:	88 1f       	adc	r24, r24
    1730:	99 1f       	adc	r25, r25
    1732:	5a 95       	dec	r21
    1734:	a9 f7       	brne	.-22     	; 0x1720 <__udivmodhi4_loop>
    1736:	80 95       	com	r24
    1738:	90 95       	com	r25
    173a:	bc 01       	movw	r22, r24
    173c:	cd 01       	movw	r24, r26
    173e:	08 95       	ret

00001740 <__udivmodsi4>:
    1740:	a1 e2       	ldi	r26, 0x21	; 33
    1742:	1a 2e       	mov	r1, r26
    1744:	aa 1b       	sub	r26, r26
    1746:	bb 1b       	sub	r27, r27
    1748:	fd 01       	movw	r30, r26
    174a:	0d c0       	rjmp	.+26     	; 0x1766 <__udivmodsi4_ep>

0000174c <__udivmodsi4_loop>:
    174c:	aa 1f       	adc	r26, r26
    174e:	bb 1f       	adc	r27, r27
    1750:	ee 1f       	adc	r30, r30
    1752:	ff 1f       	adc	r31, r31
    1754:	a2 17       	cp	r26, r18
    1756:	b3 07       	cpc	r27, r19
    1758:	e4 07       	cpc	r30, r20
    175a:	f5 07       	cpc	r31, r21
    175c:	20 f0       	brcs	.+8      	; 0x1766 <__udivmodsi4_ep>
    175e:	a2 1b       	sub	r26, r18
    1760:	b3 0b       	sbc	r27, r19
    1762:	e4 0b       	sbc	r30, r20
    1764:	f5 0b       	sbc	r31, r21

00001766 <__udivmodsi4_ep>:
    1766:	66 1f       	adc	r22, r22
    1768:	77 1f       	adc	r23, r23
    176a:	88 1f       	adc	r24, r24
    176c:	99 1f       	adc	r25, r25
    176e:	1a 94       	dec	r1
    1770:	69 f7       	brne	.-38     	; 0x174c <__udivmodsi4_loop>
    1772:	60 95       	com	r22
    1774:	70 95       	com	r23
    1776:	80 95       	com	r24
    1778:	90 95       	com	r25
    177a:	9b 01       	movw	r18, r22
    177c:	ac 01       	movw	r20, r24
    177e:	bd 01       	movw	r22, r26
    1780:	cf 01       	movw	r24, r30
    1782:	08 95       	ret

00001784 <__itoa_ncheck>:
    1784:	bb 27       	eor	r27, r27
    1786:	4a 30       	cpi	r20, 0x0A	; 10
    1788:	31 f4       	brne	.+12     	; 0x1796 <__itoa_ncheck+0x12>
    178a:	99 23       	and	r25, r25
    178c:	22 f4       	brpl	.+8      	; 0x1796 <__itoa_ncheck+0x12>
    178e:	bd e2       	ldi	r27, 0x2D	; 45
    1790:	90 95       	com	r25
    1792:	81 95       	neg	r24
    1794:	9f 4f       	sbci	r25, 0xFF	; 255
    1796:	0c 94 ce 0b 	jmp	0x179c	; 0x179c <__utoa_common>

0000179a <__utoa_ncheck>:
    179a:	bb 27       	eor	r27, r27

0000179c <__utoa_common>:
    179c:	fb 01       	movw	r30, r22
    179e:	55 27       	eor	r21, r21
    17a0:	aa 27       	eor	r26, r26
    17a2:	88 0f       	add	r24, r24
    17a4:	99 1f       	adc	r25, r25
    17a6:	aa 1f       	adc	r26, r26
    17a8:	a4 17       	cp	r26, r20
    17aa:	10 f0       	brcs	.+4      	; 0x17b0 <__utoa_common+0x14>
    17ac:	a4 1b       	sub	r26, r20
    17ae:	83 95       	inc	r24
    17b0:	50 51       	subi	r21, 0x10	; 16
    17b2:	b9 f7       	brne	.-18     	; 0x17a2 <__utoa_common+0x6>
    17b4:	a0 5d       	subi	r26, 0xD0	; 208
    17b6:	aa 33       	cpi	r26, 0x3A	; 58
    17b8:	08 f0       	brcs	.+2      	; 0x17bc <__utoa_common+0x20>
    17ba:	a9 5d       	subi	r26, 0xD9	; 217
    17bc:	a1 93       	st	Z+, r26
    17be:	00 97       	sbiw	r24, 0x00	; 0
    17c0:	79 f7       	brne	.-34     	; 0x17a0 <__utoa_common+0x4>
    17c2:	b1 11       	cpse	r27, r1
    17c4:	b1 93       	st	Z+, r27
    17c6:	11 92       	st	Z+, r1
    17c8:	cb 01       	movw	r24, r22
    17ca:	0c 94 e7 0b 	jmp	0x17ce	; 0x17ce <strrev>

000017ce <strrev>:
    17ce:	dc 01       	movw	r26, r24
    17d0:	fc 01       	movw	r30, r24
    17d2:	67 2f       	mov	r22, r23
    17d4:	71 91       	ld	r23, Z+
    17d6:	77 23       	and	r23, r23
    17d8:	e1 f7       	brne	.-8      	; 0x17d2 <strrev+0x4>
    17da:	32 97       	sbiw	r30, 0x02	; 2
    17dc:	04 c0       	rjmp	.+8      	; 0x17e6 <strrev+0x18>
    17de:	7c 91       	ld	r23, X
    17e0:	6d 93       	st	X+, r22
    17e2:	70 83       	st	Z, r23
    17e4:	62 91       	ld	r22, -Z
    17e6:	ae 17       	cp	r26, r30
    17e8:	bf 07       	cpc	r27, r31
    17ea:	c8 f3       	brcs	.-14     	; 0x17de <strrev+0x10>
    17ec:	08 95       	ret

000017ee <_exit>:
    17ee:	f8 94       	cli

000017f0 <__stop_program>:
    17f0:	ff cf       	rjmp	.-2      	; 0x17f0 <__stop_program>
