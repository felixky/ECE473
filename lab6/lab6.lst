
lab6.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000003e  00800100  0000210c  000021a0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000210c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000010d  0080013e  0080013e  000021de  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000021de  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002210  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000c8  00000000  00000000  0000224c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003843  00000000  00000000  00002314  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000012e3  00000000  00000000  00005b57  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001b52  00000000  00000000  00006e3a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000069c  00000000  00000000  0000898c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000aaa  00000000  00000000  00009028  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000022e3  00000000  00000000  00009ad2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000e8  00000000  00000000  0000bdb5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 97 00 	jmp	0x12e	; 0x12e <__ctors_end>
       4:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
       8:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
       c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      10:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      14:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      18:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      1c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      20:	0c 94 ca 06 	jmp	0xd94	; 0xd94 <__vector_8>
      24:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      28:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      2c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      30:	0c 94 8b 06 	jmp	0xd16	; 0xd16 <__vector_12>
      34:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      38:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      3c:	0c 94 56 04 	jmp	0x8ac	; 0x8ac <__vector_15>
      40:	0c 94 20 04 	jmp	0x840	; 0x840 <__vector_16>
      44:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      48:	0c 94 03 07 	jmp	0xe06	; 0xe06 <__vector_18>
      4c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      50:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      54:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      58:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      5c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      60:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      64:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      68:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      6c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      70:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      74:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      78:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      7c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      80:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      84:	0c 94 e7 0b 	jmp	0x17ce	; 0x17ce <__vector_33>
      88:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      8c:	28 0c       	add	r2, r8
      8e:	ff 0b       	sbc	r31, r31
      90:	ff 0b       	sbc	r31, r31
      92:	ff 0b       	sbc	r31, r31
      94:	ff 0b       	sbc	r31, r31
      96:	ff 0b       	sbc	r31, r31
      98:	ff 0b       	sbc	r31, r31
      9a:	ff 0b       	sbc	r31, r31
      9c:	28 0c       	add	r2, r8
      9e:	ff 0b       	sbc	r31, r31
      a0:	ff 0b       	sbc	r31, r31
      a2:	ff 0b       	sbc	r31, r31
      a4:	ff 0b       	sbc	r31, r31
      a6:	ff 0b       	sbc	r31, r31
      a8:	ff 0b       	sbc	r31, r31
      aa:	ff 0b       	sbc	r31, r31
      ac:	32 0c       	add	r3, r2
      ae:	ff 0b       	sbc	r31, r31
      b0:	ff 0b       	sbc	r31, r31
      b2:	ff 0b       	sbc	r31, r31
      b4:	ff 0b       	sbc	r31, r31
      b6:	ff 0b       	sbc	r31, r31
      b8:	ff 0b       	sbc	r31, r31
      ba:	ff 0b       	sbc	r31, r31
      bc:	ff 0b       	sbc	r31, r31
      be:	ff 0b       	sbc	r31, r31
      c0:	ff 0b       	sbc	r31, r31
      c2:	ff 0b       	sbc	r31, r31
      c4:	ff 0b       	sbc	r31, r31
      c6:	ff 0b       	sbc	r31, r31
      c8:	ff 0b       	sbc	r31, r31
      ca:	ff 0b       	sbc	r31, r31
      cc:	32 0c       	add	r3, r2
      ce:	ff 0b       	sbc	r31, r31
      d0:	ff 0b       	sbc	r31, r31
      d2:	ff 0b       	sbc	r31, r31
      d4:	ff 0b       	sbc	r31, r31
      d6:	ff 0b       	sbc	r31, r31
      d8:	ff 0b       	sbc	r31, r31
      da:	ff 0b       	sbc	r31, r31
      dc:	ff 0b       	sbc	r31, r31
      de:	ff 0b       	sbc	r31, r31
      e0:	ff 0b       	sbc	r31, r31
      e2:	ff 0b       	sbc	r31, r31
      e4:	ff 0b       	sbc	r31, r31
      e6:	ff 0b       	sbc	r31, r31
      e8:	ff 0b       	sbc	r31, r31
      ea:	ff 0b       	sbc	r31, r31
      ec:	49 0c       	add	r4, r9
      ee:	ff 0b       	sbc	r31, r31
      f0:	ff 0b       	sbc	r31, r31
      f2:	ff 0b       	sbc	r31, r31
      f4:	ff 0b       	sbc	r31, r31
      f6:	ff 0b       	sbc	r31, r31
      f8:	ff 0b       	sbc	r31, r31
      fa:	ff 0b       	sbc	r31, r31
      fc:	4d 0c       	add	r4, r13
      fe:	ff 0b       	sbc	r31, r31
     100:	ff 0b       	sbc	r31, r31
     102:	ff 0b       	sbc	r31, r31
     104:	ff 0b       	sbc	r31, r31
     106:	ff 0b       	sbc	r31, r31
     108:	ff 0b       	sbc	r31, r31
     10a:	ff 0b       	sbc	r31, r31
     10c:	ff 0b       	sbc	r31, r31
     10e:	ff 0b       	sbc	r31, r31
     110:	ff 0b       	sbc	r31, r31
     112:	ff 0b       	sbc	r31, r31
     114:	ff 0b       	sbc	r31, r31
     116:	ff 0b       	sbc	r31, r31
     118:	ff 0b       	sbc	r31, r31
     11a:	ff 0b       	sbc	r31, r31
     11c:	5b 0c       	add	r5, r11
     11e:	ff 0b       	sbc	r31, r31
     120:	ff 0b       	sbc	r31, r31
     122:	ff 0b       	sbc	r31, r31
     124:	ff 0b       	sbc	r31, r31
     126:	ff 0b       	sbc	r31, r31
     128:	ff 0b       	sbc	r31, r31
     12a:	ff 0b       	sbc	r31, r31
     12c:	19 0c       	add	r1, r9

0000012e <__ctors_end>:
     12e:	11 24       	eor	r1, r1
     130:	1f be       	out	0x3f, r1	; 63
     132:	cf ef       	ldi	r28, 0xFF	; 255
     134:	d0 e1       	ldi	r29, 0x10	; 16
     136:	de bf       	out	0x3e, r29	; 62
     138:	cd bf       	out	0x3d, r28	; 61

0000013a <__do_copy_data>:
     13a:	11 e0       	ldi	r17, 0x01	; 1
     13c:	a0 e0       	ldi	r26, 0x00	; 0
     13e:	b1 e0       	ldi	r27, 0x01	; 1
     140:	ec e0       	ldi	r30, 0x0C	; 12
     142:	f1 e2       	ldi	r31, 0x21	; 33
     144:	00 e0       	ldi	r16, 0x00	; 0
     146:	0b bf       	out	0x3b, r16	; 59
     148:	02 c0       	rjmp	.+4      	; 0x14e <__do_copy_data+0x14>
     14a:	07 90       	elpm	r0, Z+
     14c:	0d 92       	st	X+, r0
     14e:	ae 33       	cpi	r26, 0x3E	; 62
     150:	b1 07       	cpc	r27, r17
     152:	d9 f7       	brne	.-10     	; 0x14a <__do_copy_data+0x10>

00000154 <__do_clear_bss>:
     154:	22 e0       	ldi	r18, 0x02	; 2
     156:	ae e3       	ldi	r26, 0x3E	; 62
     158:	b1 e0       	ldi	r27, 0x01	; 1
     15a:	01 c0       	rjmp	.+2      	; 0x15e <.do_clear_bss_start>

0000015c <.do_clear_bss_loop>:
     15c:	1d 92       	st	X+, r1

0000015e <.do_clear_bss_start>:
     15e:	ab 34       	cpi	r26, 0x4B	; 75
     160:	b2 07       	cpc	r27, r18
     162:	e1 f7       	brne	.-8      	; 0x15c <.do_clear_bss_loop>
     164:	0e 94 b0 0e 	call	0x1d60	; 0x1d60 <main>
     168:	0c 94 84 10 	jmp	0x2108	; 0x2108 <_exit>

0000016c <__bad_interrupt>:
     16c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000170 <snoozin.part.1>:
	seconds equals the normal seconds. 
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
      if(a_sec_count == sec_count)
     170:	90 91 4f 01 	lds	r25, 0x014F	; 0x80014f <a_sec_count>
     174:	80 91 52 01 	lds	r24, 0x0152	; 0x800152 <sec_count>
     178:	98 17       	cp	r25, r24
     17a:	21 f0       	breq	.+8      	; 0x184 <snoozin.part.1+0x14>
         snooze = 0;
      else 
         snooze = 1;
     17c:	81 e0       	ldi	r24, 0x01	; 1
     17e:	80 93 48 01 	sts	0x0148, r24	; 0x800148 <snooze>
     182:	08 95       	ret
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
      if(a_sec_count == sec_count)
         snooze = 0;
     184:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <snooze>
     188:	08 95       	ret

0000018a <spi_init>:
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
     18a:	87 b3       	in	r24, 0x17	; 23
     18c:	87 60       	ori	r24, 0x07	; 7
     18e:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
     190:	8d b1       	in	r24, 0x0d	; 13
     192:	8c 65       	ori	r24, 0x5C	; 92
     194:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
     196:	70 9a       	sbi	0x0e, 0	; 14
     198:	08 95       	ret

0000019a <tcnt0_init>:
Description: Timer counter 0 is initialized in normal mode with no prescale
	and will be used as a seconds counter for the clock
Parameters: NA
**********************************************************************/
void tcnt0_init(){
   ASSR |= (1<<AS0);
     19a:	80 b7       	in	r24, 0x30	; 48
     19c:	88 60       	ori	r24, 0x08	; 8
     19e:	80 bf       	out	0x30, r24	; 48
   TIMSK |= (1<<OCIE0) | (1<<TOIE0);			//enable interrupts
     1a0:	87 b7       	in	r24, 0x37	; 55
     1a2:	83 60       	ori	r24, 0x03	; 3
     1a4:	87 bf       	out	0x37, r24	; 55
   TCCR0 |= (1<<CS00);			//normal mode, no prescale
     1a6:	83 b7       	in	r24, 0x33	; 51
     1a8:	81 60       	ori	r24, 0x01	; 1
     1aa:	83 bf       	out	0x33, r24	; 51
   OCR0 = 0xFF;
     1ac:	8f ef       	ldi	r24, 0xFF	; 255
     1ae:	81 bf       	out	0x31, r24	; 49
     1b0:	08 95       	ret

000001b2 <tcnt1_init>:
Description: Timer counter 1 is initialized in CTC mode, 64 bit prescaler
	so that it can be used to generate an alarm frequency
Parameters: NA
**********************************************************************/
void tcnt1_init(){
   TCCR1B |= (1<<CS11) | (1<<CS10) | (1<<WGM12);		//CTC mode, 64bit prescaler
     1b2:	8e b5       	in	r24, 0x2e	; 46
     1b4:	8b 60       	ori	r24, 0x0B	; 11
     1b6:	8e bd       	out	0x2e, r24	; 46
   TCCR1C = 0x00;
     1b8:	10 92 7a 00 	sts	0x007A, r1	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
   TIMSK  |= (1<<OCIE1A) | (1<<TOIE1);	//enable flag for interrupt 
     1bc:	87 b7       	in	r24, 0x37	; 55
     1be:	84 61       	ori	r24, 0x14	; 20
     1c0:	87 bf       	out	0x37, r24	; 55
   OCR1A = 0x0040;		//compare match at 64
     1c2:	80 e4       	ldi	r24, 0x40	; 64
     1c4:	90 e0       	ldi	r25, 0x00	; 0
     1c6:	9b bd       	out	0x2b, r25	; 43
     1c8:	8a bd       	out	0x2a, r24	; 42
     1ca:	08 95       	ret

000001cc <tcnt2_init>:
	normal mode with a 64 bit prescaler. OCRA2 is adjusted to change
	the pwn produced.
Parameters: NA
**********************************************************************/
void tcnt2_init(){
   TCCR2 |= (1<<WGM21) | (1<<WGM20)| (1<<CS20) | (1<<COM21);			
     1cc:	85 b5       	in	r24, 0x25	; 37
     1ce:	89 66       	ori	r24, 0x69	; 105
     1d0:	85 bd       	out	0x25, r24	; 37
     1d2:	08 95       	ret

000001d4 <tcnt3_init>:
Description: This timer is used as a volume control for the audio amp.
	I adjust the value of OCR3A to change the pwm.
Parameters: NA
**********************************************************************/
void tcnt3_init(){
   TCCR3A |= (1<<COM3A1) | (1<<WGM31);	 //Clear on OCR3A match
     1d4:	eb e8       	ldi	r30, 0x8B	; 139
     1d6:	f0 e0       	ldi	r31, 0x00	; 0
     1d8:	80 81       	ld	r24, Z
     1da:	82 68       	ori	r24, 0x82	; 130
     1dc:	80 83       	st	Z, r24
   TCCR3B |= (1<<CS30) | (1<<WGM32) | (1<<WGM33);		//Fast PWM mode, no prescaler
     1de:	ea e8       	ldi	r30, 0x8A	; 138
     1e0:	f0 e0       	ldi	r31, 0x00	; 0
     1e2:	80 81       	ld	r24, Z
     1e4:	89 61       	ori	r24, 0x19	; 25
     1e6:	80 83       	st	Z, r24
   TCCR3C = 0x00;
     1e8:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x7e008c>
   ICR3 = 0x9F;				//Setting the TOP value
     1ec:	8f e9       	ldi	r24, 0x9F	; 159
     1ee:	90 e0       	ldi	r25, 0x00	; 0
     1f0:	90 93 81 00 	sts	0x0081, r25	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
     1f4:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
   TCNT3 = 0x0000; 			//Initialize TNCT1 to 0
     1f8:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     1fc:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
   OCR3A = 0x9F;			//Volume Control 0x9F=Max 0x00=Min
     200:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     204:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
     208:	08 95       	ret

0000020a <spi_read>:
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
     20a:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
     20c:	77 9b       	sbis	0x0e, 7	; 14
     20e:	fe cf       	rjmp	.-4      	; 0x20c <spi_read+0x2>
   return SPDR;
     210:	8f b1       	in	r24, 0x0f	; 15
}
     212:	08 95       	ret

00000214 <chk_buttons>:
	be implemented at the same time. Adapted to check all buttons from 
	Ganssel's "Guide to Debouncing" Expects active low pushbuttons on PINA 
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
     214:	48 2f       	mov	r20, r24
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
     216:	e8 2f       	mov	r30, r24
     218:	f0 e0       	ldi	r31, 0x00	; 0
     21a:	99 b3       	in	r25, 0x19	; 25
     21c:	ee 0f       	add	r30, r30
     21e:	ff 1f       	adc	r31, r31
     220:	e6 5a       	subi	r30, 0xA6	; 166
     222:	fe 4f       	sbci	r31, 0xFE	; 254
     224:	20 81       	ld	r18, Z
     226:	31 81       	ldd	r19, Z+1	; 0x01
     228:	22 0f       	add	r18, r18
     22a:	33 1f       	adc	r19, r19
     22c:	30 6e       	ori	r19, 0xE0	; 224
     22e:	89 2f       	mov	r24, r25
     230:	90 e0       	ldi	r25, 0x00	; 0
     232:	02 c0       	rjmp	.+4      	; 0x238 <chk_buttons+0x24>
     234:	95 95       	asr	r25
     236:	87 95       	ror	r24
     238:	4a 95       	dec	r20
     23a:	e2 f7       	brpl	.-8      	; 0x234 <chk_buttons+0x20>
     23c:	81 70       	andi	r24, 0x01	; 1
     23e:	99 27       	eor	r25, r25
     240:	28 2b       	or	r18, r24
     242:	39 2b       	or	r19, r25
     244:	31 83       	std	Z+1, r19	; 0x01
     246:	20 83       	st	Z, r18
     248:	81 e0       	ldi	r24, 0x01	; 1
     24a:	21 15       	cp	r18, r1
     24c:	30 4f       	sbci	r19, 0xF0	; 240
     24e:	09 f0       	breq	.+2      	; 0x252 <chk_buttons+0x3e>
     250:	80 e0       	ldi	r24, 0x00	; 0
  if (state[button] == 0xF000)
    return 1;
return 0;
}
     252:	08 95       	ret

00000254 <bars>:
Description:This function reads in the button board and updates the 
	LEDs on the bargraph through the serial port.
Parameters: NA
**********************************************************************/
void bars() {
   DDRA = 0x00;				//Set all as inputs
     254:	1a ba       	out	0x1a, r1	; 26
   PORTA = 0xFF;			//Pull up resistors
     256:	8f ef       	ldi	r24, 0xFF	; 255
     258:	8b bb       	out	0x1b, r24	; 27
   PORTB |= PINB | 0x70;		//Enable tristate buffer
     25a:	86 b3       	in	r24, 0x16	; 22
     25c:	98 b3       	in	r25, 0x18	; 24
     25e:	80 67       	ori	r24, 0x70	; 112
     260:	89 2b       	or	r24, r25
     262:	88 bb       	out	0x18, r24	; 24
     264:	ea e5       	ldi	r30, 0x5A	; 90
     266:	f1 e0       	ldi	r31, 0x01	; 1

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     268:	20 e0       	ldi	r18, 0x00	; 0
     26a:	30 e0       	ldi	r19, 0x00	; 0
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
     26c:	61 e0       	ldi	r22, 0x01	; 1
     26e:	70 e0       	ldi	r23, 0x00	; 0
     270:	05 c0       	rjmp	.+10     	; 0x27c <bars+0x28>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     272:	2f 5f       	subi	r18, 0xFF	; 255
     274:	3f 4f       	sbci	r19, 0xFF	; 255
     276:	28 30       	cpi	r18, 0x08	; 8
     278:	31 05       	cpc	r19, r1
     27a:	39 f1       	breq	.+78     	; 0x2ca <bars+0x76>
	port.  Debounce time is determined by external loop delay times 12. 
Parameters: A specific button number(0-7) to check if it is pressed
**********************************************************************/
uint8_t chk_buttons(uint8_t button) {
  static uint16_t state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  state[button] = (state[button] << 1) | (! bit_is_clear(PINA,button))| 0xE000;
     27c:	99 b3       	in	r25, 0x19	; 25
     27e:	40 81       	ld	r20, Z
     280:	51 81       	ldd	r21, Z+1	; 0x01
     282:	44 0f       	add	r20, r20
     284:	55 1f       	adc	r21, r21
     286:	89 2f       	mov	r24, r25
     288:	90 e0       	ldi	r25, 0x00	; 0
     28a:	02 2e       	mov	r0, r18
     28c:	02 c0       	rjmp	.+4      	; 0x292 <bars+0x3e>
     28e:	95 95       	asr	r25
     290:	87 95       	ror	r24
     292:	0a 94       	dec	r0
     294:	e2 f7       	brpl	.-8      	; 0x28e <bars+0x3a>
     296:	81 70       	andi	r24, 0x01	; 1
     298:	99 27       	eor	r25, r25
     29a:	84 2b       	or	r24, r20
     29c:	95 2b       	or	r25, r21
     29e:	90 6e       	ori	r25, 0xE0	; 224
     2a0:	81 93       	st	Z+, r24
     2a2:	91 93       	st	Z+, r25
  if (state[button] == 0xF000)
     2a4:	81 15       	cp	r24, r1
     2a6:	90 4f       	sbci	r25, 0xF0	; 240
     2a8:	21 f7       	brne	.-56     	; 0x272 <bars+0x1e>
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
     2aa:	cb 01       	movw	r24, r22
     2ac:	02 2e       	mov	r0, r18
     2ae:	02 c0       	rjmp	.+4      	; 0x2b4 <bars+0x60>
     2b0:	88 0f       	add	r24, r24
     2b2:	99 1f       	adc	r25, r25
     2b4:	0a 94       	dec	r0
     2b6:	e2 f7       	brpl	.-8      	; 0x2b0 <bars+0x5c>
     2b8:	90 93 46 01 	sts	0x0146, r25	; 0x800146 <mult+0x1>
     2bc:	80 93 45 01 	sts	0x0145, r24	; 0x800145 <mult>
void bars() {
   DDRA = 0x00;				//Set all as inputs
   PORTA = 0xFF;			//Pull up resistors
   PORTB |= PINB | 0x70;		//Enable tristate buffer

   for(int i = 0; i < 8; i++) {		//Increment through all buttons
     2c0:	2f 5f       	subi	r18, 0xFF	; 255
     2c2:	3f 4f       	sbci	r19, 0xFF	; 255
     2c4:	28 30       	cpi	r18, 0x08	; 8
     2c6:	31 05       	cpc	r19, r1
     2c8:	c9 f6       	brne	.-78     	; 0x27c <bars+0x28>
      if(chk_buttons(i) == 1) {		//Check if button is pressed
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
     2ca:	88 b3       	in	r24, 0x18	; 24
     2cc:	18 ba       	out	0x18, r1	; 24
   if(mult == 128){			//Button 8 toggles base 10 and 16
     2ce:	80 91 45 01 	lds	r24, 0x0145	; 0x800145 <mult>
     2d2:	90 91 46 01 	lds	r25, 0x0146	; 0x800146 <mult+0x1>
     2d6:	80 38       	cpi	r24, 0x80	; 128
     2d8:	91 05       	cpc	r25, r1
     2da:	09 f4       	brne	.+2      	; 0x2de <bars+0x8a>
     2dc:	b7 c0       	rjmp	.+366    	; 0x44c <__LOCK_REGION_LENGTH__+0x4c>
      alarm = !(alarm);			//on the LED display
   }
   if(mult == 64){		//Button 7 toggles snooze
     2de:	80 91 45 01 	lds	r24, 0x0145	; 0x800145 <mult>
     2e2:	90 91 46 01 	lds	r25, 0x0146	; 0x800146 <mult+0x1>
     2e6:	80 34       	cpi	r24, 0x40	; 64
     2e8:	91 05       	cpc	r25, r1
     2ea:	09 f4       	brne	.+2      	; 0x2ee <bars+0x9a>
     2ec:	76 c0       	rjmp	.+236    	; 0x3da <bars+0x186>
	    }
	 }  
      }
   }
//Two station presets
   if(mult == 32){
     2ee:	80 91 45 01 	lds	r24, 0x0145	; 0x800145 <mult>
     2f2:	90 91 46 01 	lds	r25, 0x0146	; 0x800146 <mult+0x1>
     2f6:	80 97       	sbiw	r24, 0x20	; 32
     2f8:	09 f4       	brne	.+2      	; 0x2fc <bars+0xa8>
     2fa:	61 c0       	rjmp	.+194    	; 0x3be <bars+0x16a>
      current_fm_freq = 9330;
      freq_change = 9330;
      tune = 1;
   }
   if(mult == 16){
     2fc:	80 91 45 01 	lds	r24, 0x0145	; 0x800145 <mult>
     300:	90 91 46 01 	lds	r25, 0x0146	; 0x800146 <mult+0x1>
     304:	40 97       	sbiw	r24, 0x10	; 16
     306:	09 f4       	brne	.+2      	; 0x30a <bars+0xb6>
     308:	46 c0       	rjmp	.+140    	; 0x396 <bars+0x142>
      current_fm_freq = st_preset;
      freq_change = st_preset;
      tune = 1;
   }
   if(mult == 8){
     30a:	80 91 45 01 	lds	r24, 0x0145	; 0x800145 <mult>
     30e:	90 91 46 01 	lds	r25, 0x0146	; 0x800146 <mult+0x1>
     312:	08 97       	sbiw	r24, 0x08	; 8
     314:	e1 f1       	breq	.+120    	; 0x38e <bars+0x13a>
      radio = 1;
   }
   if(mult > 4) {			//I only want values from the
     316:	80 91 45 01 	lds	r24, 0x0145	; 0x800145 <mult>
     31a:	90 91 46 01 	lds	r25, 0x0146	; 0x800146 <mult+0x1>
     31e:	05 97       	sbiw	r24, 0x05	; 5
     320:	20 f0       	brcs	.+8      	; 0x32a <bars+0xd6>
      mult = 0;				//first three buttons
     322:	10 92 46 01 	sts	0x0146, r1	; 0x800146 <mult+0x1>
     326:	10 92 45 01 	sts	0x0145, r1	; 0x800145 <mult>
   }
   //This switch statement is used to enable a 'toggle' functionality
   //so that modes can be selected an deselected
   switch(mult) {
     32a:	80 91 45 01 	lds	r24, 0x0145	; 0x800145 <mult>
     32e:	90 91 46 01 	lds	r25, 0x0146	; 0x800146 <mult+0x1>
     332:	82 30       	cpi	r24, 0x02	; 2
     334:	91 05       	cpc	r25, r1
     336:	59 f0       	breq	.+22     	; 0x34e <bars+0xfa>
     338:	84 30       	cpi	r24, 0x04	; 4
     33a:	91 05       	cpc	r25, r1
     33c:	41 f0       	breq	.+16     	; 0x34e <bars+0xfa>
     33e:	81 30       	cpi	r24, 0x01	; 1
     340:	91 05       	cpc	r25, r1
     342:	29 f0       	breq	.+10     	; 0x34e <bars+0xfa>
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
         break;
      default: //Stay in previous mode
	 mode_sel = mode_sel;		//no/invalid button press
     344:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <mode_sel>
     348:	90 91 44 01 	lds	r25, 0x0144	; 0x800144 <mode_sel+0x1>
     34c:	0c c0       	rjmp	.+24     	; 0x366 <bars+0x112>
	 else
	    mode_sel = 2;		//If not, then change mode
         
         break;
      case 4: //Frequency Change mode
	 if((mode_sel ^ mult) == 0){//if cur &prev are diff
     34e:	40 91 43 01 	lds	r20, 0x0143	; 0x800143 <mode_sel>
     352:	50 91 44 01 	lds	r21, 0x0144	; 0x800144 <mode_sel+0x1>
     356:	20 91 45 01 	lds	r18, 0x0145	; 0x800145 <mult>
     35a:	30 91 46 01 	lds	r19, 0x0146	; 0x800146 <mult+0x1>
     35e:	42 17       	cp	r20, r18
     360:	53 07       	cpc	r21, r19
     362:	09 f4       	brne	.+2      	; 0x366 <bars+0x112>
     364:	7b c0       	rjmp	.+246    	; 0x45c <__LOCK_REGION_LENGTH__+0x5c>
	 }
	 else
	    mode_sel = 4;		//If not, then change mode
         break;
      default: //Stay in previous mode
	 mode_sel = mode_sel;		//no/invalid button press
     366:	90 93 44 01 	sts	0x0144, r25	; 0x800144 <mode_sel+0x1>
     36a:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <mode_sel>
   }   
   mult = 0;				//clear mult for next pass
     36e:	10 92 46 01 	sts	0x0146, r1	; 0x800146 <mult+0x1>
     372:	10 92 45 01 	sts	0x0145, r1	; 0x800145 <mult>

   DDRA = 0xFF;				//Set A to alloutputs
     376:	8f ef       	ldi	r24, 0xFF	; 255
     378:	8a bb       	out	0x1a, r24	; 26
   SPDR = mode_sel;			//Write mode to the Bargraph
     37a:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <mode_sel>
     37e:	90 91 44 01 	lds	r25, 0x0144	; 0x800144 <mode_sel+0x1>
     382:	8f b9       	out	0x0f, r24	; 15
   while(bit_is_clear(SPSR, SPIF)){}	
     384:	77 9b       	sbis	0x0e, 7	; 14
     386:	fe cf       	rjmp	.-4      	; 0x384 <bars+0x130>
   PORTB |= (1<<PB0);			//Rgclk high on bargraph
     388:	c0 9a       	sbi	0x18, 0	; 24
   PORTB &= 0xFE;			//Rgclk low on bargraph
     38a:	c0 98       	cbi	0x18, 0	; 24
   
return ;
     38c:	08 95       	ret
      current_fm_freq = st_preset;
      freq_change = st_preset;
      tune = 1;
   }
   if(mult == 8){
      radio = 1;
     38e:	81 e0       	ldi	r24, 0x01	; 1
     390:	80 93 47 01 	sts	0x0147, r24	; 0x800147 <radio>
     394:	c0 cf       	rjmp	.-128    	; 0x316 <bars+0xc2>
      current_fm_freq = 9330;
      freq_change = 9330;
      tune = 1;
   }
   if(mult == 16){
      current_fm_freq = st_preset;
     396:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <st_preset>
     39a:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <st_preset+0x1>
     39e:	90 93 28 01 	sts	0x0128, r25	; 0x800128 <current_fm_freq+0x1>
     3a2:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <current_fm_freq>
      freq_change = st_preset;
     3a6:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <st_preset>
     3aa:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <st_preset+0x1>
     3ae:	90 93 13 01 	sts	0x0113, r25	; 0x800113 <freq_change+0x1>
     3b2:	80 93 12 01 	sts	0x0112, r24	; 0x800112 <freq_change>
      tune = 1;
     3b6:	81 e0       	ldi	r24, 0x01	; 1
     3b8:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <tune>
     3bc:	a6 cf       	rjmp	.-180    	; 0x30a <bars+0xb6>
	 }  
      }
   }
//Two station presets
   if(mult == 32){
      current_fm_freq = 9330;
     3be:	82 e7       	ldi	r24, 0x72	; 114
     3c0:	94 e2       	ldi	r25, 0x24	; 36
     3c2:	90 93 28 01 	sts	0x0128, r25	; 0x800128 <current_fm_freq+0x1>
     3c6:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <current_fm_freq>
      freq_change = 9330;
     3ca:	90 93 13 01 	sts	0x0113, r25	; 0x800113 <freq_change+0x1>
     3ce:	80 93 12 01 	sts	0x0112, r24	; 0x800112 <freq_change>
      tune = 1;
     3d2:	81 e0       	ldi	r24, 0x01	; 1
     3d4:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <tune>
     3d8:	91 cf       	rjmp	.-222    	; 0x2fc <bars+0xa8>
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
   }
   if(mult == 64){		//Button 7 toggles snooze
      snooze = !(snooze);		//10 second snooze functionality
     3da:	90 91 48 01 	lds	r25, 0x0148	; 0x800148 <snooze>
     3de:	81 e0       	ldi	r24, 0x01	; 1
     3e0:	91 11       	cpse	r25, r1
     3e2:	45 c0       	rjmp	.+138    	; 0x46e <__LOCK_REGION_LENGTH__+0x6e>
     3e4:	80 93 48 01 	sts	0x0148, r24	; 0x800148 <snooze>
      a_sec_count = sec_count + 10;
     3e8:	80 91 52 01 	lds	r24, 0x0152	; 0x800152 <sec_count>
     3ec:	86 5f       	subi	r24, 0xF6	; 246
     3ee:	80 93 4f 01 	sts	0x014F, r24	; 0x80014f <a_sec_count>
      if(a_sec_count > 60){
     3f2:	80 91 4f 01 	lds	r24, 0x014F	; 0x80014f <a_sec_count>
     3f6:	8d 33       	cpi	r24, 0x3D	; 61
     3f8:	08 f4       	brcc	.+2      	; 0x3fc <bars+0x1a8>
     3fa:	79 cf       	rjmp	.-270    	; 0x2ee <bars+0x9a>
         a_sec_count = a_sec_count % 60;
     3fc:	90 91 4f 01 	lds	r25, 0x014F	; 0x80014f <a_sec_count>
     400:	89 e8       	ldi	r24, 0x89	; 137
     402:	98 9f       	mul	r25, r24
     404:	81 2d       	mov	r24, r1
     406:	11 24       	eor	r1, r1
     408:	82 95       	swap	r24
     40a:	86 95       	lsr	r24
     40c:	87 70       	andi	r24, 0x07	; 7
     40e:	2c e3       	ldi	r18, 0x3C	; 60
     410:	82 9f       	mul	r24, r18
     412:	90 19       	sub	r25, r0
     414:	11 24       	eor	r1, r1
     416:	90 93 4f 01 	sts	0x014F, r25	; 0x80014f <a_sec_count>
	 a_min_count++;
     41a:	80 91 4e 01 	lds	r24, 0x014E	; 0x80014e <a_min_count>
     41e:	8f 5f       	subi	r24, 0xFF	; 255
     420:	80 93 4e 01 	sts	0x014E, r24	; 0x80014e <a_min_count>
	 if(a_min_count == 60){
     424:	80 91 4e 01 	lds	r24, 0x014E	; 0x80014e <a_min_count>
     428:	8c 33       	cpi	r24, 0x3C	; 60
     42a:	09 f0       	breq	.+2      	; 0x42e <__LOCK_REGION_LENGTH__+0x2e>
     42c:	60 cf       	rjmp	.-320    	; 0x2ee <bars+0x9a>
	    a_hour_count++;
     42e:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <a_hour_count>
     432:	8f 5f       	subi	r24, 0xFF	; 255
     434:	80 93 4d 01 	sts	0x014D, r24	; 0x80014d <a_hour_count>
	    a_min_count = 0;
     438:	10 92 4e 01 	sts	0x014E, r1	; 0x80014e <a_min_count>
	    if(a_hour_count == 24){
     43c:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <a_hour_count>
     440:	88 31       	cpi	r24, 0x18	; 24
     442:	09 f0       	breq	.+2      	; 0x446 <__LOCK_REGION_LENGTH__+0x46>
     444:	54 cf       	rjmp	.-344    	; 0x2ee <bars+0x9a>
	       a_hour_count = 0;
     446:	10 92 4d 01 	sts	0x014D, r1	; 0x80014d <a_hour_count>
     44a:	51 cf       	rjmp	.-350    	; 0x2ee <bars+0x9a>
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
     44c:	90 91 49 01 	lds	r25, 0x0149	; 0x800149 <alarm>
     450:	81 e0       	ldi	r24, 0x01	; 1
     452:	91 11       	cpse	r25, r1
     454:	08 c0       	rjmp	.+16     	; 0x466 <__LOCK_REGION_LENGTH__+0x66>
     456:	80 93 49 01 	sts	0x0149, r24	; 0x800149 <alarm>
     45a:	41 cf       	rjmp	.-382    	; 0x2de <bars+0x8a>
	    mode_sel = 2;		//If not, then change mode
         
         break;
      case 4: //Frequency Change mode
	 if((mode_sel ^ mult) == 0){//if cur &prev are diff
	    mode_sel = 0;//and prev isn't = 1 then two modes are selected
     45c:	10 92 44 01 	sts	0x0144, r1	; 0x800144 <mode_sel+0x1>
     460:	10 92 43 01 	sts	0x0143, r1	; 0x800143 <mode_sel>
     464:	84 cf       	rjmp	.-248    	; 0x36e <bars+0x11a>
   	 mult = (1<<i);			//mult gets 2^i
      }
   }
   PORTB &= 0x00;
   if(mult == 128){			//Button 8 toggles base 10 and 16
      alarm = !(alarm);			//on the LED display
     466:	80 e0       	ldi	r24, 0x00	; 0
     468:	80 93 49 01 	sts	0x0149, r24	; 0x800149 <alarm>
     46c:	38 cf       	rjmp	.-400    	; 0x2de <bars+0x8a>
   }
   if(mult == 64){		//Button 7 toggles snooze
      snooze = !(snooze);		//10 second snooze functionality
     46e:	80 e0       	ldi	r24, 0x00	; 0
     470:	b9 cf       	rjmp	.-142    	; 0x3e4 <bars+0x190>

00000472 <read_encoder>:
   int8_t value = 0x00;
   uint8_t ec_a;
   uint8_t ec_b;

   //Shift_LD_N low
   PORTE &= 0xBF;	//Begining of SHIFT_LD_N pulse. It is low here
     472:	1e 98       	cbi	0x03, 6	; 3
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     474:	87 ec       	ldi	r24, 0xC7	; 199
     476:	90 e0       	ldi	r25, 0x00	; 0
     478:	01 97       	sbiw	r24, 0x01	; 1
     47a:	f1 f7       	brne	.-4      	; 0x478 <read_encoder+0x6>
     47c:	00 c0       	rjmp	.+0      	; 0x47e <read_encoder+0xc>
     47e:	00 00       	nop
   _delay_us(50);
   PORTE |= 0x40;	//End of SHIFT_LD_N pulse. back to high
     480:	1e 9a       	sbi	0x03, 6	; 3
   PORTD &= 0x0F;	//CLK_INH low
     482:	82 b3       	in	r24, 0x12	; 18
     484:	8f 70       	andi	r24, 0x0F	; 15
     486:	82 bb       	out	0x12, r24	; 18
Description: This function reads data from the SPI serially and returns 
	the 8 bit value that it read.
Parameters: NA
**********************************************************************/
uint8_t spi_read() {
   SPDR = 0x00;				//'Dummy' write to SPI
     488:	1f b8       	out	0x0f, r1	; 15
   while(bit_is_clear(SPSR, SPIF)){}	//Reads the 8 bits serially
     48a:	77 9b       	sbis	0x0e, 7	; 14
     48c:	fe cf       	rjmp	.-4      	; 0x48a <read_encoder+0x18>
   return SPDR;
     48e:	9f b1       	in	r25, 0x0f	; 15
   _delay_us(50);
   PORTE |= 0x40;	//End of SHIFT_LD_N pulse. back to high
   PORTD &= 0x0F;	//CLK_INH low

   encoder_value = spi_read();
   PORTD |= 0xF0;	//CLK_INH high
     490:	82 b3       	in	r24, 0x12	; 18
     492:	80 6f       	ori	r24, 0xF0	; 240
     494:	82 bb       	out	0x12, r24	; 18
   value = mode_sel;
     496:	20 91 43 01 	lds	r18, 0x0143	; 0x800143 <mode_sel>
     49a:	30 91 44 01 	lds	r19, 0x0144	; 0x800144 <mode_sel+0x1>
     49e:	82 2f       	mov	r24, r18
   ec_a = encoder_value & 0x03;  //Only grabs these bits 0000_0011
     4a0:	69 2f       	mov	r22, r25
     4a2:	63 70       	andi	r22, 0x03	; 3
   ec_b = encoder_value & 0x0C;  //Only grabs these bits 0000_1100 
     4a4:	9c 70       	andi	r25, 0x0C	; 12
   ec_b = (ec_b >> 2);
     4a6:	96 95       	lsr	r25
     4a8:	96 95       	lsr	r25

//mode_sel == 0 means that no mode has been selected and the speaker volume can be adjusted
   if(mode_sel == 0){
     4aa:	20 91 43 01 	lds	r18, 0x0143	; 0x800143 <mode_sel>
     4ae:	30 91 44 01 	lds	r19, 0x0144	; 0x800144 <mode_sel+0x1>
     4b2:	23 2b       	or	r18, r19
     4b4:	09 f5       	brne	.+66     	; 0x4f8 <read_encoder+0x86>
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     4b6:	20 91 90 01 	lds	r18, 0x0190	; 0x800190 <EC_a_prev>
     4ba:	46 2f       	mov	r20, r22
     4bc:	50 e0       	ldi	r21, 0x00	; 0
     4be:	02 2e       	mov	r0, r18
     4c0:	00 0c       	add	r0, r0
     4c2:	33 0b       	sbc	r19, r19
     4c4:	42 17       	cp	r20, r18
     4c6:	53 07       	cpc	r21, r19
     4c8:	b9 f0       	breq	.+46     	; 0x4f8 <read_encoder+0x86>
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     4ca:	20 91 90 01 	lds	r18, 0x0190	; 0x800190 <EC_a_prev>
     4ce:	21 11       	cpse	r18, r1
     4d0:	2e c0       	rjmp	.+92     	; 0x52e <read_encoder+0xbc>
     4d2:	61 30       	cpi	r22, 0x01	; 1
     4d4:	61 f5       	brne	.+88     	; 0x52e <read_encoder+0xbc>
            volume += 10;	//increment volume
     4d6:	20 91 16 01 	lds	r18, 0x0116	; 0x800116 <volume>
     4da:	26 5f       	subi	r18, 0xF6	; 246
     4dc:	20 93 16 01 	sts	0x0116, r18	; 0x800116 <volume>
	    if(volume <= 0x9F){
     4e0:	20 91 16 01 	lds	r18, 0x0116	; 0x800116 <volume>
     4e4:	20 3a       	cpi	r18, 0xA0	; 160
     4e6:	08 f0       	brcs	.+2      	; 0x4ea <read_encoder+0x78>
     4e8:	76 c1       	rjmp	.+748    	; 0x7d6 <read_encoder+0x364>
	    }
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
	    volume -= 10;	//decrement volume 
	    if(volume >= 0x00){
		OCR3A = volume;	//minimum volume
     4ea:	20 91 16 01 	lds	r18, 0x0116	; 0x800116 <volume>
     4ee:	30 e0       	ldi	r19, 0x00	; 0
     4f0:	30 93 87 00 	sts	0x0087, r19	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     4f4:	20 93 86 00 	sts	0x0086, r18	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
	 volume = volume;
      }
   }

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
     4f8:	20 91 43 01 	lds	r18, 0x0143	; 0x800143 <mode_sel>
     4fc:	30 91 44 01 	lds	r19, 0x0144	; 0x800144 <mode_sel+0x1>
     500:	21 30       	cpi	r18, 0x01	; 1
     502:	31 05       	cpc	r19, r1
     504:	31 f1       	breq	.+76     	; 0x552 <read_encoder+0xe0>
         else
	    value = 0;
      }
   }
//mode_sel == 2 means that the user has selected the "alarm time change" mode
   if(mode_sel == 2){
     506:	20 91 43 01 	lds	r18, 0x0143	; 0x800143 <mode_sel>
     50a:	30 91 44 01 	lds	r19, 0x0144	; 0x800144 <mode_sel+0x1>
     50e:	22 30       	cpi	r18, 0x02	; 2
     510:	31 05       	cpc	r19, r1
     512:	f1 f1       	breq	.+124    	; 0x590 <read_encoder+0x11e>
         else
	    value = 0;
      }
   }
//If mode_sel = 4 the user selected frequency change mode
   if(mode_sel == 4){
     514:	20 91 43 01 	lds	r18, 0x0143	; 0x800143 <mode_sel>
     518:	30 91 44 01 	lds	r19, 0x0144	; 0x800144 <mode_sel+0x1>
     51c:	24 30       	cpi	r18, 0x04	; 4
     51e:	31 05       	cpc	r19, r1
     520:	09 f4       	brne	.+2      	; 0x524 <read_encoder+0xb2>
     522:	56 c0       	rjmp	.+172    	; 0x5d0 <read_encoder+0x15e>
         else	//If not one of the state changes above, do nothing
	 tune = 1;
      }
   }
//Saves previous values into volatile variables
EC_a_prev = ec_a;
     524:	60 93 90 01 	sts	0x0190, r22	; 0x800190 <EC_a_prev>
EC_b_prev = ec_b;
     528:	90 93 7a 01 	sts	0x017A, r25	; 0x80017a <EC_b_prev>

return value;
}
     52c:	08 95       	ret
	    else {
		volume = 0x9F;
		OCR3A = 0x9F;
	    }
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     52e:	20 91 90 01 	lds	r18, 0x0190	; 0x800190 <EC_a_prev>
     532:	21 11       	cpse	r18, r1
     534:	03 c0       	rjmp	.+6      	; 0x53c <read_encoder+0xca>
     536:	62 30       	cpi	r22, 0x02	; 2
     538:	09 f4       	brne	.+2      	; 0x53c <read_encoder+0xca>
     53a:	05 c1       	rjmp	.+522    	; 0x746 <read_encoder+0x2d4>
		volume = 0x00;
		OCR3A = 0x00;
	    }
         }
         else	//If not one of the state changes above, do nothing
	 volume = volume;
     53c:	20 91 16 01 	lds	r18, 0x0116	; 0x800116 <volume>
     540:	20 93 16 01 	sts	0x0116, r18	; 0x800116 <volume>
      }
   }

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
     544:	20 91 43 01 	lds	r18, 0x0143	; 0x800143 <mode_sel>
     548:	30 91 44 01 	lds	r19, 0x0144	; 0x800144 <mode_sel+0x1>
     54c:	21 30       	cpi	r18, 0x01	; 1
     54e:	31 05       	cpc	r19, r1
     550:	d1 f6       	brne	.-76     	; 0x506 <read_encoder+0x94>
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     552:	20 91 90 01 	lds	r18, 0x0190	; 0x800190 <EC_a_prev>
     556:	46 2f       	mov	r20, r22
     558:	50 e0       	ldi	r21, 0x00	; 0
     55a:	02 2e       	mov	r0, r18
     55c:	00 0c       	add	r0, r0
     55e:	33 0b       	sbc	r19, r19
     560:	42 17       	cp	r20, r18
     562:	53 07       	cpc	r21, r19
     564:	09 f4       	brne	.+2      	; 0x568 <read_encoder+0xf6>
     566:	71 c0       	rjmp	.+226    	; 0x64a <read_encoder+0x1d8>
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     568:	20 91 90 01 	lds	r18, 0x0190	; 0x800190 <EC_a_prev>
     56c:	22 23       	and	r18, r18
     56e:	09 f4       	brne	.+2      	; 0x572 <read_encoder+0x100>
     570:	50 c0       	rjmp	.+160    	; 0x612 <read_encoder+0x1a0>
            hour_count = hour_count + 1;//value = value;
	    if(hour_count == 24)
	       hour_count = 0;
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     572:	20 91 90 01 	lds	r18, 0x0190	; 0x800190 <EC_a_prev>
     576:	21 11       	cpse	r18, r1
     578:	03 c0       	rjmp	.+6      	; 0x580 <read_encoder+0x10e>
     57a:	62 30       	cpi	r22, 0x02	; 2
     57c:	09 f4       	brne	.+2      	; 0x580 <read_encoder+0x10e>
     57e:	97 c0       	rjmp	.+302    	; 0x6ae <read_encoder+0x23c>
	    hour_count = hour_count - 1;//value = -(value);
	    if(hour_count < 0)
	       hour_count = 23; 
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
     580:	80 e0       	ldi	r24, 0x00	; 0
         else
	    value = 0;
      }
   }
//mode_sel == 2 means that the user has selected the "alarm time change" mode
   if(mode_sel == 2){
     582:	20 91 43 01 	lds	r18, 0x0143	; 0x800143 <mode_sel>
     586:	30 91 44 01 	lds	r19, 0x0144	; 0x800144 <mode_sel+0x1>
     58a:	22 30       	cpi	r18, 0x02	; 2
     58c:	31 05       	cpc	r19, r1
     58e:	11 f6       	brne	.-124    	; 0x514 <read_encoder+0xa2>
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     590:	20 91 90 01 	lds	r18, 0x0190	; 0x800190 <EC_a_prev>
     594:	46 2f       	mov	r20, r22
     596:	50 e0       	ldi	r21, 0x00	; 0
     598:	02 2e       	mov	r0, r18
     59a:	00 0c       	add	r0, r0
     59c:	33 0b       	sbc	r19, r19
     59e:	42 17       	cp	r20, r18
     5a0:	53 07       	cpc	r21, r19
     5a2:	09 f4       	brne	.+2      	; 0x5a6 <read_encoder+0x134>
     5a4:	91 c0       	rjmp	.+290    	; 0x6c8 <read_encoder+0x256>
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     5a6:	20 91 90 01 	lds	r18, 0x0190	; 0x800190 <EC_a_prev>
     5aa:	22 23       	and	r18, r18
     5ac:	09 f4       	brne	.+2      	; 0x5b0 <read_encoder+0x13e>
     5ae:	3f c0       	rjmp	.+126    	; 0x62e <read_encoder+0x1bc>
            a_hour_count = a_hour_count + 1;//value = value;
	    if(a_hour_count == 24)
	       a_hour_count = 0;
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     5b0:	20 91 90 01 	lds	r18, 0x0190	; 0x800190 <EC_a_prev>
     5b4:	21 11       	cpse	r18, r1
     5b6:	03 c0       	rjmp	.+6      	; 0x5be <read_encoder+0x14c>
     5b8:	62 30       	cpi	r22, 0x02	; 2
     5ba:	09 f4       	brne	.+2      	; 0x5be <read_encoder+0x14c>
     5bc:	b7 c0       	rjmp	.+366    	; 0x72c <read_encoder+0x2ba>
	    a_hour_count = a_hour_count - 1;//value = -(value);
	    if(a_hour_count < 0)
	       a_hour_count = 23; 
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
     5be:	80 e0       	ldi	r24, 0x00	; 0
         else
	    value = 0;
      }
   }
//If mode_sel = 4 the user selected frequency change mode
   if(mode_sel == 4){
     5c0:	20 91 43 01 	lds	r18, 0x0143	; 0x800143 <mode_sel>
     5c4:	30 91 44 01 	lds	r19, 0x0144	; 0x800144 <mode_sel+0x1>
     5c8:	24 30       	cpi	r18, 0x04	; 4
     5ca:	31 05       	cpc	r19, r1
     5cc:	09 f0       	breq	.+2      	; 0x5d0 <read_encoder+0x15e>
     5ce:	aa cf       	rjmp	.-172    	; 0x524 <read_encoder+0xb2>
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
     5d0:	20 91 90 01 	lds	r18, 0x0190	; 0x800190 <EC_a_prev>
     5d4:	46 2f       	mov	r20, r22
     5d6:	50 e0       	ldi	r21, 0x00	; 0
     5d8:	02 2e       	mov	r0, r18
     5da:	00 0c       	add	r0, r0
     5dc:	33 0b       	sbc	r19, r19
     5de:	42 17       	cp	r20, r18
     5e0:	53 07       	cpc	r21, r19
     5e2:	09 f4       	brne	.+2      	; 0x5e6 <read_encoder+0x174>
     5e4:	9f cf       	rjmp	.-194    	; 0x524 <read_encoder+0xb2>
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     5e6:	20 91 90 01 	lds	r18, 0x0190	; 0x800190 <EC_a_prev>
     5ea:	21 11       	cpse	r18, r1
     5ec:	03 c0       	rjmp	.+6      	; 0x5f4 <read_encoder+0x182>
     5ee:	61 30       	cpi	r22, 0x01	; 1
     5f0:	09 f4       	brne	.+2      	; 0x5f4 <read_encoder+0x182>
     5f2:	b1 c0       	rjmp	.+354    	; 0x756 <read_encoder+0x2e4>
	    else {
		freq_change = 10790;
		current_fm_freq = freq_change;
	    }
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
     5f4:	20 91 90 01 	lds	r18, 0x0190	; 0x800190 <EC_a_prev>
     5f8:	21 11       	cpse	r18, r1
     5fa:	03 c0       	rjmp	.+6      	; 0x602 <read_encoder+0x190>
     5fc:	62 30       	cpi	r22, 0x02	; 2
     5fe:	09 f4       	brne	.+2      	; 0x602 <read_encoder+0x190>
     600:	ca c0       	rjmp	.+404    	; 0x796 <read_encoder+0x324>
		freq_change = 8810;
		current_fm_freq = freq_change;
	    }
         }
         else	//If not one of the state changes above, do nothing
	 tune = 1;
     602:	21 e0       	ldi	r18, 0x01	; 1
     604:	20 93 4a 01 	sts	0x014A, r18	; 0x80014a <tune>
      }
   }
//Saves previous values into volatile variables
EC_a_prev = ec_a;
     608:	60 93 90 01 	sts	0x0190, r22	; 0x800190 <EC_a_prev>
EC_b_prev = ec_b;
     60c:	90 93 7a 01 	sts	0x017A, r25	; 0x80017a <EC_b_prev>

return value;
}
     610:	08 95       	ret
   }

//mode_sel == 1 means that the user has selected the "time change" mode
   if(mode_sel == 1){
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     612:	61 30       	cpi	r22, 0x01	; 1
     614:	09 f0       	breq	.+2      	; 0x618 <read_encoder+0x1a6>
     616:	ad cf       	rjmp	.-166    	; 0x572 <read_encoder+0x100>
            hour_count = hour_count + 1;//value = value;
     618:	20 91 50 01 	lds	r18, 0x0150	; 0x800150 <hour_count>
     61c:	2f 5f       	subi	r18, 0xFF	; 255
     61e:	20 93 50 01 	sts	0x0150, r18	; 0x800150 <hour_count>
	    if(hour_count == 24)
     622:	20 91 50 01 	lds	r18, 0x0150	; 0x800150 <hour_count>
     626:	28 31       	cpi	r18, 0x18	; 24
     628:	09 f0       	breq	.+2      	; 0x62c <read_encoder+0x1ba>
     62a:	6d cf       	rjmp	.-294    	; 0x506 <read_encoder+0x94>
     62c:	2a c0       	rjmp	.+84     	; 0x682 <read_encoder+0x210>
      }
   }
//mode_sel == 2 means that the user has selected the "alarm time change" mode
   if(mode_sel == 2){
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
     62e:	61 30       	cpi	r22, 0x01	; 1
     630:	09 f0       	breq	.+2      	; 0x634 <read_encoder+0x1c2>
     632:	be cf       	rjmp	.-132    	; 0x5b0 <read_encoder+0x13e>
            a_hour_count = a_hour_count + 1;//value = value;
     634:	20 91 4d 01 	lds	r18, 0x014D	; 0x80014d <a_hour_count>
     638:	2f 5f       	subi	r18, 0xFF	; 255
     63a:	20 93 4d 01 	sts	0x014D, r18	; 0x80014d <a_hour_count>
	    if(a_hour_count == 24)
     63e:	20 91 4d 01 	lds	r18, 0x014D	; 0x80014d <a_hour_count>
     642:	28 31       	cpi	r18, 0x18	; 24
     644:	09 f0       	breq	.+2      	; 0x648 <read_encoder+0x1d6>
     646:	66 cf       	rjmp	.-308    	; 0x514 <read_encoder+0xa2>
     648:	5b c0       	rjmp	.+182    	; 0x700 <read_encoder+0x28e>
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
     64a:	20 91 7a 01 	lds	r18, 0x017A	; 0x80017a <EC_b_prev>
     64e:	21 11       	cpse	r18, r1
     650:	1b c0       	rjmp	.+54     	; 0x688 <read_encoder+0x216>
     652:	91 30       	cpi	r25, 0x01	; 1
     654:	c9 f4       	brne	.+50     	; 0x688 <read_encoder+0x216>
            min_count = min_count + 1;//value = value;
     656:	20 91 51 01 	lds	r18, 0x0151	; 0x800151 <min_count>
     65a:	2f 5f       	subi	r18, 0xFF	; 255
     65c:	20 93 51 01 	sts	0x0151, r18	; 0x800151 <min_count>
	    if(min_count == 60){
     660:	20 91 51 01 	lds	r18, 0x0151	; 0x800151 <min_count>
     664:	2c 33       	cpi	r18, 0x3C	; 60
     666:	09 f0       	breq	.+2      	; 0x66a <read_encoder+0x1f8>
     668:	4e cf       	rjmp	.-356    	; 0x506 <read_encoder+0x94>
	       min_count = 0; 
     66a:	10 92 51 01 	sts	0x0151, r1	; 0x800151 <min_count>
	       hour_count++;
     66e:	20 91 50 01 	lds	r18, 0x0150	; 0x800150 <hour_count>
     672:	2f 5f       	subi	r18, 0xFF	; 255
     674:	20 93 50 01 	sts	0x0150, r18	; 0x800150 <hour_count>
	       if(hour_count > 23)
     678:	20 91 50 01 	lds	r18, 0x0150	; 0x800150 <hour_count>
     67c:	28 31       	cpi	r18, 0x18	; 24
     67e:	0c f4       	brge	.+2      	; 0x682 <read_encoder+0x210>
     680:	42 cf       	rjmp	.-380    	; 0x506 <read_encoder+0x94>
	          hour_count = 0;
     682:	10 92 50 01 	sts	0x0150, r1	; 0x800150 <hour_count>
     686:	3f cf       	rjmp	.-386    	; 0x506 <read_encoder+0x94>
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
     688:	20 91 7a 01 	lds	r18, 0x017A	; 0x80017a <EC_b_prev>
     68c:	21 11       	cpse	r18, r1
     68e:	78 cf       	rjmp	.-272    	; 0x580 <read_encoder+0x10e>
     690:	92 30       	cpi	r25, 0x02	; 2
     692:	09 f0       	breq	.+2      	; 0x696 <read_encoder+0x224>
     694:	75 cf       	rjmp	.-278    	; 0x580 <read_encoder+0x10e>
	    min_count = min_count - 1; //value = -(value);
     696:	20 91 51 01 	lds	r18, 0x0151	; 0x800151 <min_count>
     69a:	21 50       	subi	r18, 0x01	; 1
     69c:	20 93 51 01 	sts	0x0151, r18	; 0x800151 <min_count>
	    if(min_count < 0){
     6a0:	20 91 51 01 	lds	r18, 0x0151	; 0x800151 <min_count>
     6a4:	27 ff       	sbrs	r18, 7
     6a6:	2f cf       	rjmp	.-418    	; 0x506 <read_encoder+0x94>
	       min_count = 59;
     6a8:	2b e3       	ldi	r18, 0x3B	; 59
     6aa:	20 93 51 01 	sts	0x0151, r18	; 0x800151 <min_count>
	       hour_count--;
     6ae:	20 91 50 01 	lds	r18, 0x0150	; 0x800150 <hour_count>
     6b2:	21 50       	subi	r18, 0x01	; 1
     6b4:	20 93 50 01 	sts	0x0150, r18	; 0x800150 <hour_count>
	       if(hour_count < 0){
     6b8:	20 91 50 01 	lds	r18, 0x0150	; 0x800150 <hour_count>
     6bc:	27 ff       	sbrs	r18, 7
     6be:	23 cf       	rjmp	.-442    	; 0x506 <read_encoder+0x94>
	          hour_count = 23;
     6c0:	27 e1       	ldi	r18, 0x17	; 23
     6c2:	20 93 50 01 	sts	0x0150, r18	; 0x800150 <hour_count>
     6c6:	1f cf       	rjmp	.-450    	; 0x506 <read_encoder+0x94>
         }
         else	//If not one of the state changes above, do nothing
	 value = 0;
      }
      else {	//This is for encoder B
         if(!(EC_b_prev) && (ec_b == 0x01)){//CW Rotation
     6c8:	20 91 7a 01 	lds	r18, 0x017A	; 0x80017a <EC_b_prev>
     6cc:	21 11       	cpse	r18, r1
     6ce:	1b c0       	rjmp	.+54     	; 0x706 <read_encoder+0x294>
     6d0:	91 30       	cpi	r25, 0x01	; 1
     6d2:	c9 f4       	brne	.+50     	; 0x706 <read_encoder+0x294>
            a_min_count = a_min_count + 1;//value = value;
     6d4:	20 91 4e 01 	lds	r18, 0x014E	; 0x80014e <a_min_count>
     6d8:	2f 5f       	subi	r18, 0xFF	; 255
     6da:	20 93 4e 01 	sts	0x014E, r18	; 0x80014e <a_min_count>
	    if(a_min_count == 60){
     6de:	20 91 4e 01 	lds	r18, 0x014E	; 0x80014e <a_min_count>
     6e2:	2c 33       	cpi	r18, 0x3C	; 60
     6e4:	09 f0       	breq	.+2      	; 0x6e8 <read_encoder+0x276>
     6e6:	16 cf       	rjmp	.-468    	; 0x514 <read_encoder+0xa2>
	       a_min_count = 0; 
     6e8:	10 92 4e 01 	sts	0x014E, r1	; 0x80014e <a_min_count>
	       a_hour_count++;
     6ec:	20 91 4d 01 	lds	r18, 0x014D	; 0x80014d <a_hour_count>
     6f0:	2f 5f       	subi	r18, 0xFF	; 255
     6f2:	20 93 4d 01 	sts	0x014D, r18	; 0x80014d <a_hour_count>
	       if(a_hour_count > 23)
     6f6:	20 91 4d 01 	lds	r18, 0x014D	; 0x80014d <a_hour_count>
     6fa:	28 31       	cpi	r18, 0x18	; 24
     6fc:	0c f4       	brge	.+2      	; 0x700 <read_encoder+0x28e>
     6fe:	0a cf       	rjmp	.-492    	; 0x514 <read_encoder+0xa2>
	          a_hour_count = 0;
     700:	10 92 4d 01 	sts	0x014D, r1	; 0x80014d <a_hour_count>
     704:	07 cf       	rjmp	.-498    	; 0x514 <read_encoder+0xa2>
	    }
         }
         else if(!(EC_b_prev) && (ec_b == 0x02)){//CCW Rotation
     706:	20 91 7a 01 	lds	r18, 0x017A	; 0x80017a <EC_b_prev>
     70a:	21 11       	cpse	r18, r1
     70c:	58 cf       	rjmp	.-336    	; 0x5be <read_encoder+0x14c>
     70e:	92 30       	cpi	r25, 0x02	; 2
     710:	09 f0       	breq	.+2      	; 0x714 <read_encoder+0x2a2>
     712:	55 cf       	rjmp	.-342    	; 0x5be <read_encoder+0x14c>
	    a_min_count = a_min_count - 1; //value = -(value);
     714:	20 91 4e 01 	lds	r18, 0x014E	; 0x80014e <a_min_count>
     718:	21 50       	subi	r18, 0x01	; 1
     71a:	20 93 4e 01 	sts	0x014E, r18	; 0x80014e <a_min_count>
	    if(a_min_count < 0){
     71e:	20 91 4e 01 	lds	r18, 0x014E	; 0x80014e <a_min_count>
     722:	27 ff       	sbrs	r18, 7
     724:	f7 ce       	rjmp	.-530    	; 0x514 <read_encoder+0xa2>
	       a_min_count = 59;
     726:	2b e3       	ldi	r18, 0x3B	; 59
     728:	20 93 4e 01 	sts	0x014E, r18	; 0x80014e <a_min_count>
	       a_hour_count--;
     72c:	20 91 4d 01 	lds	r18, 0x014D	; 0x80014d <a_hour_count>
     730:	21 50       	subi	r18, 0x01	; 1
     732:	20 93 4d 01 	sts	0x014D, r18	; 0x80014d <a_hour_count>
	       if(a_hour_count < 0){
     736:	20 91 4d 01 	lds	r18, 0x014D	; 0x80014d <a_hour_count>
     73a:	27 ff       	sbrs	r18, 7
     73c:	eb ce       	rjmp	.-554    	; 0x514 <read_encoder+0xa2>
	          a_hour_count = 23;
     73e:	27 e1       	ldi	r18, 0x17	; 23
     740:	20 93 4d 01 	sts	0x014D, r18	; 0x80014d <a_hour_count>
     744:	e7 ce       	rjmp	.-562    	; 0x514 <read_encoder+0xa2>
		volume = 0x9F;
		OCR3A = 0x9F;
	    }
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
	    volume -= 10;	//decrement volume 
     746:	20 91 16 01 	lds	r18, 0x0116	; 0x800116 <volume>
     74a:	2a 50       	subi	r18, 0x0A	; 10
     74c:	20 93 16 01 	sts	0x0116, r18	; 0x800116 <volume>
	    if(volume >= 0x00){
     750:	20 91 16 01 	lds	r18, 0x0116	; 0x800116 <volume>
     754:	ca ce       	rjmp	.-620    	; 0x4ea <read_encoder+0x78>
   }
//If mode_sel = 4 the user selected frequency change mode
   if(mode_sel == 4){
      if(ec_a != EC_a_prev){ //Compares curr encoder value to ast value 
         if(!(EC_a_prev) && (ec_a == 0x01)){//Determines CW rotation
            freq_change += 20;	//increment frequency by .02kHz
     756:	20 91 12 01 	lds	r18, 0x0112	; 0x800112 <freq_change>
     75a:	30 91 13 01 	lds	r19, 0x0113	; 0x800113 <freq_change+0x1>
     75e:	2c 5e       	subi	r18, 0xEC	; 236
     760:	3f 4f       	sbci	r19, 0xFF	; 255
     762:	30 93 13 01 	sts	0x0113, r19	; 0x800113 <freq_change+0x1>
     766:	20 93 12 01 	sts	0x0112, r18	; 0x800112 <freq_change>
	    if(freq_change <= 10790 ){ //When freqency is greater than 107.9 change to 88.1
     76a:	20 91 12 01 	lds	r18, 0x0112	; 0x800112 <freq_change>
     76e:	30 91 13 01 	lds	r19, 0x0113	; 0x800113 <freq_change+0x1>
     772:	27 32       	cpi	r18, 0x27	; 39
     774:	3a 42       	sbci	r19, 0x2A	; 42
     776:	30 f0       	brcs	.+12     	; 0x784 <read_encoder+0x312>
		current_fm_freq = freq_change;	//maximum frequency
	    }
	    else {
		freq_change = 10790;
     778:	26 e2       	ldi	r18, 0x26	; 38
     77a:	3a e2       	ldi	r19, 0x2A	; 42
     77c:	30 93 13 01 	sts	0x0113, r19	; 0x800113 <freq_change+0x1>
     780:	20 93 12 01 	sts	0x0112, r18	; 0x800112 <freq_change>
		current_fm_freq = freq_change;
     784:	20 91 12 01 	lds	r18, 0x0112	; 0x800112 <freq_change>
     788:	30 91 13 01 	lds	r19, 0x0113	; 0x800113 <freq_change+0x1>
     78c:	30 93 28 01 	sts	0x0128, r19	; 0x800128 <current_fm_freq+0x1>
     790:	20 93 27 01 	sts	0x0127, r18	; 0x800127 <current_fm_freq>
     794:	c7 ce       	rjmp	.-626    	; 0x524 <read_encoder+0xb2>
	    }
         }
         else if(!(EC_a_prev) && (ec_a == 0x02)){//Determines CCW rotation
	    freq_change -= 20;	//decrement frequency 
     796:	20 91 12 01 	lds	r18, 0x0112	; 0x800112 <freq_change>
     79a:	30 91 13 01 	lds	r19, 0x0113	; 0x800113 <freq_change+0x1>
     79e:	24 51       	subi	r18, 0x14	; 20
     7a0:	31 09       	sbc	r19, r1
     7a2:	30 93 13 01 	sts	0x0113, r19	; 0x800113 <freq_change+0x1>
     7a6:	20 93 12 01 	sts	0x0112, r18	; 0x800112 <freq_change>
	    if(freq_change >= 8810){ //When frequency is less than 88.1 change to 107.9
     7aa:	20 91 12 01 	lds	r18, 0x0112	; 0x800112 <freq_change>
     7ae:	30 91 13 01 	lds	r19, 0x0113	; 0x800113 <freq_change+0x1>
     7b2:	2a 36       	cpi	r18, 0x6A	; 106
     7b4:	32 42       	sbci	r19, 0x22	; 34
     7b6:	30 f7       	brcc	.-52     	; 0x784 <read_encoder+0x312>
		current_fm_freq = freq_change;	//minimum frequency
	    }
	    else {
		freq_change = 8810;
     7b8:	2a e6       	ldi	r18, 0x6A	; 106
     7ba:	32 e2       	ldi	r19, 0x22	; 34
     7bc:	30 93 13 01 	sts	0x0113, r19	; 0x800113 <freq_change+0x1>
     7c0:	20 93 12 01 	sts	0x0112, r18	; 0x800112 <freq_change>
		current_fm_freq = freq_change;
     7c4:	20 91 12 01 	lds	r18, 0x0112	; 0x800112 <freq_change>
     7c8:	30 91 13 01 	lds	r19, 0x0113	; 0x800113 <freq_change+0x1>
     7cc:	30 93 28 01 	sts	0x0128, r19	; 0x800128 <current_fm_freq+0x1>
     7d0:	20 93 27 01 	sts	0x0127, r18	; 0x800127 <current_fm_freq>
     7d4:	a7 ce       	rjmp	.-690    	; 0x524 <read_encoder+0xb2>
            volume += 10;	//increment volume
	    if(volume <= 0x9F){
		OCR3A = volume;	//maximum volume
	    }
	    else {
		volume = 0x9F;
     7d6:	2f e9       	ldi	r18, 0x9F	; 159
     7d8:	20 93 16 01 	sts	0x0116, r18	; 0x800116 <volume>
		OCR3A = 0x9F;
     7dc:	2f e9       	ldi	r18, 0x9F	; 159
     7de:	30 e0       	ldi	r19, 0x00	; 0
     7e0:	30 93 87 00 	sts	0x0087, r19	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     7e4:	20 93 86 00 	sts	0x0086, r18	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
     7e8:	87 ce       	rjmp	.-754    	; 0x4f8 <read_encoder+0x86>

000007ea <get_local_temp>:
**********************************************************************/
void get_local_temp(){
uint16_t lm73_temp;

  //_delay_ms(65); //tenth second wait
  twi_start_rd(LM73_ADDRESS, lm73_rd_buf, 2); //read temperature data from LM73 (2 bytes) 
     7ea:	42 e0       	ldi	r20, 0x02	; 2
     7ec:	68 ec       	ldi	r22, 0xC8	; 200
     7ee:	71 e0       	ldi	r23, 0x01	; 1
     7f0:	80 e9       	ldi	r24, 0x90	; 144
     7f2:	0e 94 8b 0c 	call	0x1916	; 0x1916 <twi_start_rd>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     7f6:	8f e9       	ldi	r24, 0x9F	; 159
     7f8:	9f e0       	ldi	r25, 0x0F	; 15
     7fa:	01 97       	sbiw	r24, 0x01	; 1
     7fc:	f1 f7       	brne	.-4      	; 0x7fa <get_local_temp+0x10>
     7fe:	00 c0       	rjmp	.+0      	; 0x800 <get_local_temp+0x16>
     800:	00 00       	nop
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
     802:	80 91 c8 01 	lds	r24, 0x01C8	; 0x8001c8 <lm73_rd_buf>
     806:	90 91 c9 01 	lds	r25, 0x01C9	; 0x8001c9 <lm73_rd_buf+0x1>
     80a:	98 27       	eor	r25, r24
     80c:	89 27       	eor	r24, r25
     80e:	98 27       	eor	r25, r24
     810:	4a e0       	ldi	r20, 0x0A	; 10
     812:	61 e9       	ldi	r22, 0x91	; 145
     814:	71 e0       	ldi	r23, 0x01	; 1
     816:	88 0f       	add	r24, r24
     818:	89 2f       	mov	r24, r25
     81a:	88 1f       	adc	r24, r24
     81c:	99 0b       	sbc	r25, r25
     81e:	91 95       	neg	r25
     820:	0e 94 1f 10 	call	0x203e	; 0x203e <__itoa_ncheck>
  lm73_temp = lm73_rd_buf[0]; //save high temperature byte into lm73_temp
  lm73_temp = lm73_temp << 8; //shift it into upper byte 
  lm73_temp |= lm73_rd_buf[1]; //"OR" in the low temp byte to lm73_temp 
  itoa(lm73_temp >> 7, lcd_string_array, 10); //convert to string in array with itoa() from avr-libc                           

  line2_col1();
     824:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <line2_col1>
  lcd_array[2] = lcd_string_array[0];
     828:	e7 e1       	ldi	r30, 0x17	; 23
     82a:	f1 e0       	ldi	r31, 0x01	; 1
     82c:	a1 e9       	ldi	r26, 0x91	; 145
     82e:	b1 e0       	ldi	r27, 0x01	; 1
     830:	8c 91       	ld	r24, X
     832:	82 83       	std	Z+2, r24	; 0x02
  lcd_array[3] = lcd_string_array[1];
     834:	11 96       	adiw	r26, 0x01	; 1
     836:	8c 91       	ld	r24, X
     838:	83 83       	std	Z+3, r24	; 0x03
  string2lcd(lcd_array);
     83a:	cf 01       	movw	r24, r30
     83c:	0c 94 4a 09 	jmp	0x1294	; 0x1294 <string2lcd>

00000840 <__vector_16>:
	update the mode and bargraph. Then I change the sum based on	
	the value returned from the encoder reading. Sum is then bounded
	from 0-1023. 1023+1=1 and 0-any number > 0 = 1023.
Parameters: NA
**********************************************************************/
ISR(TIMER0_OVF_vect) { 
     840:	1f 92       	push	r1
     842:	0f 92       	push	r0
     844:	0f b6       	in	r0, 0x3f	; 63
     846:	0f 92       	push	r0
     848:	11 24       	eor	r1, r1
     84a:	0b b6       	in	r0, 0x3b	; 59
     84c:	0f 92       	push	r0
     84e:	2f 93       	push	r18
     850:	3f 93       	push	r19
     852:	4f 93       	push	r20
     854:	5f 93       	push	r21
     856:	6f 93       	push	r22
     858:	7f 93       	push	r23
     85a:	8f 93       	push	r24
     85c:	9f 93       	push	r25
     85e:	af 93       	push	r26
     860:	bf 93       	push	r27
     862:	ef 93       	push	r30
     864:	ff 93       	push	r31
   static uint8_t count_7_8125ms = 0;

   count_7_8125ms++;
     866:	80 91 59 01 	lds	r24, 0x0159	; 0x800159 <count_7_8125ms.2222>
     86a:	8f 5f       	subi	r24, 0xFF	; 255
     86c:	80 93 59 01 	sts	0x0159, r24	; 0x800159 <count_7_8125ms.2222>
   if((count_7_8125ms % 128) == 0) { //interrupts every 1 second
     870:	8f 77       	andi	r24, 0x7F	; 127
     872:	29 f4       	brne	.+10     	; 0x87e <__vector_16+0x3e>
      sec_count++;
     874:	80 91 52 01 	lds	r24, 0x0152	; 0x800152 <sec_count>
     878:	8f 5f       	subi	r24, 0xFF	; 255
     87a:	80 93 52 01 	sts	0x0152, r24	; 0x800152 <sec_count>
   }
   bars();  
     87e:	0e 94 2a 01 	call	0x254	; 0x254 <bars>
   read_encoder();      
     882:	0e 94 39 02 	call	0x472	; 0x472 <read_encoder>

}
     886:	ff 91       	pop	r31
     888:	ef 91       	pop	r30
     88a:	bf 91       	pop	r27
     88c:	af 91       	pop	r26
     88e:	9f 91       	pop	r25
     890:	8f 91       	pop	r24
     892:	7f 91       	pop	r23
     894:	6f 91       	pop	r22
     896:	5f 91       	pop	r21
     898:	4f 91       	pop	r20
     89a:	3f 91       	pop	r19
     89c:	2f 91       	pop	r18
     89e:	0f 90       	pop	r0
     8a0:	0b be       	out	0x3b, r0	; 59
     8a2:	0f 90       	pop	r0
     8a4:	0f be       	out	0x3f, r0	; 63
     8a6:	0f 90       	pop	r0
     8a8:	1f 90       	pop	r1
     8aa:	18 95       	reti

000008ac <__vector_15>:

ISR(TIMER0_COMP_vect) {
     8ac:	1f 92       	push	r1
     8ae:	0f 92       	push	r0
     8b0:	0f b6       	in	r0, 0x3f	; 63
     8b2:	0f 92       	push	r0
     8b4:	11 24       	eor	r1, r1
     8b6:	0b b6       	in	r0, 0x3b	; 59
     8b8:	0f 92       	push	r0
     8ba:	2f 93       	push	r18
     8bc:	3f 93       	push	r19
     8be:	4f 93       	push	r20
     8c0:	5f 93       	push	r21
     8c2:	6f 93       	push	r22
     8c4:	7f 93       	push	r23
     8c6:	8f 93       	push	r24
     8c8:	9f 93       	push	r25
     8ca:	af 93       	push	r26
     8cc:	bf 93       	push	r27
     8ce:	ef 93       	push	r30
     8d0:	ff 93       	push	r31
   static uint8_t count7_8125ms = 0;

   count7_8125ms++;
     8d2:	80 91 58 01 	lds	r24, 0x0158	; 0x800158 <count7_8125ms.2228>
     8d6:	8f 5f       	subi	r24, 0xFF	; 255
     8d8:	80 93 58 01 	sts	0x0158, r24	; 0x800158 <count7_8125ms.2228>
   if((count7_8125ms % 128) == 0) { //interrupts every 1 second
     8dc:	8f 77       	andi	r24, 0x7F	; 127
     8de:	49 f4       	brne	.+18     	; 0x8f2 <__vector_15+0x46>
      get_local_temp();
     8e0:	0e 94 f5 03 	call	0x7ea	; 0x7ea <get_local_temp>
      uart_puts("A");	//Transmits an 'A' every second to ask for temp
     8e4:	89 e2       	ldi	r24, 0x29	; 41
     8e6:	91 e0       	ldi	r25, 0x01	; 1
     8e8:	0e 94 ad 0c 	call	0x195a	; 0x195a <uart_puts>
      uart_putc('\0');
     8ec:	80 e0       	ldi	r24, 0x00	; 0
     8ee:	0e 94 a7 0c 	call	0x194e	; 0x194e <uart_putc>
   }

}
     8f2:	ff 91       	pop	r31
     8f4:	ef 91       	pop	r30
     8f6:	bf 91       	pop	r27
     8f8:	af 91       	pop	r26
     8fa:	9f 91       	pop	r25
     8fc:	8f 91       	pop	r24
     8fe:	7f 91       	pop	r23
     900:	6f 91       	pop	r22
     902:	5f 91       	pop	r21
     904:	4f 91       	pop	r20
     906:	3f 91       	pop	r19
     908:	2f 91       	pop	r18
     90a:	0f 90       	pop	r0
     90c:	0b be       	out	0x3b, r0	; 59
     90e:	0f 90       	pop	r0
     910:	0f be       	out	0x3f, r0	; 63
     912:	0f 90       	pop	r0
     914:	1f 90       	pop	r1
     916:	18 95       	reti

00000918 <clock_time>:
	selected alarm time or normal time is displayed.
Parameters: NA
**********************************************************************/
void clock_time(){ //by default we use military time
//This block is used to increment the time based on an increasing seconds count   
   if(sec_count == 60){
     918:	80 91 52 01 	lds	r24, 0x0152	; 0x800152 <sec_count>
     91c:	8c 33       	cpi	r24, 0x3C	; 60
     91e:	09 f4       	brne	.+2      	; 0x922 <clock_time+0xa>
     920:	be c0       	rjmp	.+380    	; 0xa9e <clock_time+0x186>
	 }//hours	
      }//mins
   }//secs

//This is where the digits are written to the data array
      if(mode_sel == 2){	//display alarm time
     922:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <mode_sel>
     926:	90 91 44 01 	lds	r25, 0x0144	; 0x800144 <mode_sel+0x1>
     92a:	02 97       	sbiw	r24, 0x02	; 2
     92c:	09 f4       	brne	.+2      	; 0x930 <clock_time+0x18>
     92e:	61 c0       	rjmp	.+194    	; 0x9f2 <clock_time+0xda>
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
         else {segment_data[2] = 0b111;}		//Turn colon off
         segment_data[1] = dec_to_7seg[a_min_count/10];
         segment_data[0] = dec_to_7seg[a_min_count%10];
      }
      else if(mode_sel == 4){	//display frequency
     930:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <mode_sel>
     934:	90 91 44 01 	lds	r25, 0x0144	; 0x800144 <mode_sel+0x1>
     938:	04 97       	sbiw	r24, 0x04	; 4
     93a:	09 f4       	brne	.+2      	; 0x93e <clock_time+0x26>
     93c:	cb c0       	rjmp	.+406    	; 0xad4 <clock_time+0x1bc>
         segment_data[2] = 0b111;
         segment_data[1] = dec_to_7seg[(current_fm_freq/100)%10];
         segment_data[0] = dec_to_7seg[(current_fm_freq/10)%10];
      }
      else{			//display military time
         segment_data[4] = dec_to_7seg[hour_count/10];
     93e:	90 91 50 01 	lds	r25, 0x0150	; 0x800150 <hour_count>
     942:	87 e6       	ldi	r24, 0x67	; 103
     944:	98 02       	muls	r25, r24
     946:	e1 2d       	mov	r30, r1
     948:	11 24       	eor	r1, r1
     94a:	e5 95       	asr	r30
     94c:	e5 95       	asr	r30
     94e:	97 fd       	sbrc	r25, 7
     950:	e3 95       	inc	r30
     952:	0e 2e       	mov	r0, r30
     954:	00 0c       	add	r0, r0
     956:	ff 0b       	sbc	r31, r31
     958:	e0 50       	subi	r30, 0x00	; 0
     95a:	ff 4f       	sbci	r31, 0xFF	; 255
     95c:	90 81       	ld	r25, Z
     95e:	90 93 42 01 	sts	0x0142, r25	; 0x800142 <__data_end+0x4>
         segment_data[3] = dec_to_7seg[hour_count%10];
     962:	e0 91 50 01 	lds	r30, 0x0150	; 0x800150 <hour_count>
     966:	e8 02       	muls	r30, r24
     968:	81 2d       	mov	r24, r1
     96a:	11 24       	eor	r1, r1
     96c:	85 95       	asr	r24
     96e:	85 95       	asr	r24
     970:	e7 fd       	sbrc	r30, 7
     972:	83 95       	inc	r24
     974:	9a e0       	ldi	r25, 0x0A	; 10
     976:	89 9f       	mul	r24, r25
     978:	e0 19       	sub	r30, r0
     97a:	11 24       	eor	r1, r1
     97c:	0e 2e       	mov	r0, r30
     97e:	00 0c       	add	r0, r0
     980:	ff 0b       	sbc	r31, r31
     982:	e0 50       	subi	r30, 0x00	; 0
     984:	ff 4f       	sbci	r31, 0xFF	; 255
     986:	80 81       	ld	r24, Z
     988:	80 93 41 01 	sts	0x0141, r24	; 0x800141 <__data_end+0x3>
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     98c:	80 91 52 01 	lds	r24, 0x0152	; 0x800152 <sec_count>
     990:	80 fd       	sbrc	r24, 0
     992:	2b c0       	rjmp	.+86     	; 0x9ea <clock_time+0xd2>
         else {segment_data[2] = 0b111;}		//Turn colon off
     994:	87 e0       	ldi	r24, 0x07	; 7
     996:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <__data_end+0x2>
         segment_data[1] = dec_to_7seg[min_count/10];
     99a:	90 91 51 01 	lds	r25, 0x0151	; 0x800151 <min_count>
     99e:	87 e6       	ldi	r24, 0x67	; 103
     9a0:	98 02       	muls	r25, r24
     9a2:	e1 2d       	mov	r30, r1
     9a4:	11 24       	eor	r1, r1
     9a6:	e5 95       	asr	r30
     9a8:	e5 95       	asr	r30
     9aa:	97 fd       	sbrc	r25, 7
     9ac:	e3 95       	inc	r30
     9ae:	0e 2e       	mov	r0, r30
     9b0:	00 0c       	add	r0, r0
     9b2:	ff 0b       	sbc	r31, r31
     9b4:	e0 50       	subi	r30, 0x00	; 0
     9b6:	ff 4f       	sbci	r31, 0xFF	; 255
     9b8:	90 81       	ld	r25, Z
     9ba:	90 93 3f 01 	sts	0x013F, r25	; 0x80013f <__data_end+0x1>
         segment_data[0] = dec_to_7seg[min_count%10];
     9be:	e0 91 51 01 	lds	r30, 0x0151	; 0x800151 <min_count>
     9c2:	e8 02       	muls	r30, r24
     9c4:	81 2d       	mov	r24, r1
     9c6:	11 24       	eor	r1, r1
     9c8:	85 95       	asr	r24
     9ca:	85 95       	asr	r24
     9cc:	e7 fd       	sbrc	r30, 7
     9ce:	83 95       	inc	r24
     9d0:	2a e0       	ldi	r18, 0x0A	; 10
     9d2:	82 9f       	mul	r24, r18
     9d4:	e0 19       	sub	r30, r0
     9d6:	11 24       	eor	r1, r1
     9d8:	0e 2e       	mov	r0, r30
     9da:	00 0c       	add	r0, r0
     9dc:	ff 0b       	sbc	r31, r31
     9de:	e0 50       	subi	r30, 0x00	; 0
     9e0:	ff 4f       	sbci	r31, 0xFF	; 255
     9e2:	80 81       	ld	r24, Z
     9e4:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <__data_end>
     9e8:	08 95       	ret
         segment_data[0] = dec_to_7seg[(current_fm_freq/10)%10];
      }
      else{			//display military time
         segment_data[4] = dec_to_7seg[hour_count/10];
         segment_data[3] = dec_to_7seg[hour_count%10];
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     9ea:	84 e0       	ldi	r24, 0x04	; 4
     9ec:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <__data_end+0x2>
     9f0:	d4 cf       	rjmp	.-88     	; 0x99a <clock_time+0x82>
      }//mins
   }//secs

//This is where the digits are written to the data array
      if(mode_sel == 2){	//display alarm time
         segment_data[4] = dec_to_7seg[a_hour_count/10];
     9f2:	90 91 4d 01 	lds	r25, 0x014D	; 0x80014d <a_hour_count>
     9f6:	87 e6       	ldi	r24, 0x67	; 103
     9f8:	98 02       	muls	r25, r24
     9fa:	e1 2d       	mov	r30, r1
     9fc:	11 24       	eor	r1, r1
     9fe:	e5 95       	asr	r30
     a00:	e5 95       	asr	r30
     a02:	97 fd       	sbrc	r25, 7
     a04:	e3 95       	inc	r30
     a06:	0e 2e       	mov	r0, r30
     a08:	00 0c       	add	r0, r0
     a0a:	ff 0b       	sbc	r31, r31
     a0c:	e0 50       	subi	r30, 0x00	; 0
     a0e:	ff 4f       	sbci	r31, 0xFF	; 255
     a10:	90 81       	ld	r25, Z
     a12:	90 93 42 01 	sts	0x0142, r25	; 0x800142 <__data_end+0x4>
         segment_data[3] = dec_to_7seg[a_hour_count%10];
     a16:	e0 91 4d 01 	lds	r30, 0x014D	; 0x80014d <a_hour_count>
     a1a:	e8 02       	muls	r30, r24
     a1c:	81 2d       	mov	r24, r1
     a1e:	11 24       	eor	r1, r1
     a20:	85 95       	asr	r24
     a22:	85 95       	asr	r24
     a24:	e7 fd       	sbrc	r30, 7
     a26:	83 95       	inc	r24
     a28:	2a e0       	ldi	r18, 0x0A	; 10
     a2a:	82 9f       	mul	r24, r18
     a2c:	e0 19       	sub	r30, r0
     a2e:	11 24       	eor	r1, r1
     a30:	0e 2e       	mov	r0, r30
     a32:	00 0c       	add	r0, r0
     a34:	ff 0b       	sbc	r31, r31
     a36:	e0 50       	subi	r30, 0x00	; 0
     a38:	ff 4f       	sbci	r31, 0xFF	; 255
     a3a:	80 81       	ld	r24, Z
     a3c:	80 93 41 01 	sts	0x0141, r24	; 0x800141 <__data_end+0x3>
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     a40:	80 91 52 01 	lds	r24, 0x0152	; 0x800152 <sec_count>
     a44:	80 fd       	sbrc	r24, 0
     a46:	de c0       	rjmp	.+444    	; 0xc04 <clock_time+0x2ec>
         else {segment_data[2] = 0b111;}		//Turn colon off
     a48:	87 e0       	ldi	r24, 0x07	; 7
     a4a:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <__data_end+0x2>
         segment_data[1] = dec_to_7seg[a_min_count/10];
     a4e:	90 91 4e 01 	lds	r25, 0x014E	; 0x80014e <a_min_count>
     a52:	87 e6       	ldi	r24, 0x67	; 103
     a54:	98 02       	muls	r25, r24
     a56:	e1 2d       	mov	r30, r1
     a58:	11 24       	eor	r1, r1
     a5a:	e5 95       	asr	r30
     a5c:	e5 95       	asr	r30
     a5e:	97 fd       	sbrc	r25, 7
     a60:	e3 95       	inc	r30
     a62:	0e 2e       	mov	r0, r30
     a64:	00 0c       	add	r0, r0
     a66:	ff 0b       	sbc	r31, r31
     a68:	e0 50       	subi	r30, 0x00	; 0
     a6a:	ff 4f       	sbci	r31, 0xFF	; 255
     a6c:	90 81       	ld	r25, Z
     a6e:	90 93 3f 01 	sts	0x013F, r25	; 0x80013f <__data_end+0x1>
         segment_data[0] = dec_to_7seg[a_min_count%10];
     a72:	e0 91 4e 01 	lds	r30, 0x014E	; 0x80014e <a_min_count>
     a76:	e8 02       	muls	r30, r24
     a78:	81 2d       	mov	r24, r1
     a7a:	11 24       	eor	r1, r1
     a7c:	85 95       	asr	r24
     a7e:	85 95       	asr	r24
     a80:	e7 fd       	sbrc	r30, 7
     a82:	83 95       	inc	r24
     a84:	9a e0       	ldi	r25, 0x0A	; 10
     a86:	89 9f       	mul	r24, r25
     a88:	e0 19       	sub	r30, r0
     a8a:	11 24       	eor	r1, r1
     a8c:	0e 2e       	mov	r0, r30
     a8e:	00 0c       	add	r0, r0
     a90:	ff 0b       	sbc	r31, r31
     a92:	e0 50       	subi	r30, 0x00	; 0
     a94:	ff 4f       	sbci	r31, 0xFF	; 255
     a96:	80 81       	ld	r24, Z
     a98:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <__data_end>
     a9c:	08 95       	ret
Parameters: NA
**********************************************************************/
void clock_time(){ //by default we use military time
//This block is used to increment the time based on an increasing seconds count   
   if(sec_count == 60){
      min_count++;
     a9e:	80 91 51 01 	lds	r24, 0x0151	; 0x800151 <min_count>
     aa2:	8f 5f       	subi	r24, 0xFF	; 255
     aa4:	80 93 51 01 	sts	0x0151, r24	; 0x800151 <min_count>
      sec_count = 0;
     aa8:	10 92 52 01 	sts	0x0152, r1	; 0x800152 <sec_count>
      if(min_count == 60){
     aac:	80 91 51 01 	lds	r24, 0x0151	; 0x800151 <min_count>
     ab0:	8c 33       	cpi	r24, 0x3C	; 60
     ab2:	09 f0       	breq	.+2      	; 0xab6 <clock_time+0x19e>
     ab4:	36 cf       	rjmp	.-404    	; 0x922 <clock_time+0xa>
	 hour_count++;
     ab6:	80 91 50 01 	lds	r24, 0x0150	; 0x800150 <hour_count>
     aba:	8f 5f       	subi	r24, 0xFF	; 255
     abc:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <hour_count>
	 min_count = 0;
     ac0:	10 92 51 01 	sts	0x0151, r1	; 0x800151 <min_count>
	 if(hour_count == 24){
     ac4:	80 91 50 01 	lds	r24, 0x0150	; 0x800150 <hour_count>
     ac8:	88 31       	cpi	r24, 0x18	; 24
     aca:	09 f0       	breq	.+2      	; 0xace <clock_time+0x1b6>
     acc:	2a cf       	rjmp	.-428    	; 0x922 <clock_time+0xa>
	    hour_count = 0;
     ace:	10 92 50 01 	sts	0x0150, r1	; 0x800150 <hour_count>
     ad2:	27 cf       	rjmp	.-434    	; 0x922 <clock_time+0xa>
         else {segment_data[2] = 0b111;}		//Turn colon off
         segment_data[1] = dec_to_7seg[a_min_count/10];
         segment_data[0] = dec_to_7seg[a_min_count%10];
      }
      else if(mode_sel == 4){	//display frequency
         if(current_fm_freq > 9999){
     ad4:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <current_fm_freq>
     ad8:	90 91 28 01 	lds	r25, 0x0128	; 0x800128 <current_fm_freq+0x1>
     adc:	80 31       	cpi	r24, 0x10	; 16
     ade:	97 42       	sbci	r25, 0x27	; 39
     ae0:	08 f0       	brcs	.+2      	; 0xae4 <clock_time+0x1cc>
     ae2:	94 c0       	rjmp	.+296    	; 0xc0c <clock_time+0x2f4>
	 segment_data[4] = dec_to_7seg[(current_fm_freq/10000)%10];
	 }
	 else
	 segment_data[4] = 0b11111111;
     ae4:	8f ef       	ldi	r24, 0xFF	; 255
     ae6:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <__data_end+0x4>
		
         segment_data[3] = dec_to_7seg[(current_fm_freq/1000)%10];
     aea:	20 91 27 01 	lds	r18, 0x0127	; 0x800127 <current_fm_freq>
     aee:	30 91 28 01 	lds	r19, 0x0128	; 0x800128 <current_fm_freq+0x1>
     af2:	36 95       	lsr	r19
     af4:	27 95       	ror	r18
     af6:	36 95       	lsr	r19
     af8:	27 95       	ror	r18
     afa:	36 95       	lsr	r19
     afc:	27 95       	ror	r18
     afe:	a5 ec       	ldi	r26, 0xC5	; 197
     b00:	b0 e2       	ldi	r27, 0x20	; 32
     b02:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <__umulhisi3>
     b06:	ac 01       	movw	r20, r24
     b08:	52 95       	swap	r21
     b0a:	42 95       	swap	r20
     b0c:	4f 70       	andi	r20, 0x0F	; 15
     b0e:	45 27       	eor	r20, r21
     b10:	5f 70       	andi	r21, 0x0F	; 15
     b12:	45 27       	eor	r20, r21
     b14:	9a 01       	movw	r18, r20
     b16:	ad ec       	ldi	r26, 0xCD	; 205
     b18:	bc ec       	ldi	r27, 0xCC	; 204
     b1a:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <__umulhisi3>
     b1e:	96 95       	lsr	r25
     b20:	87 95       	ror	r24
     b22:	96 95       	lsr	r25
     b24:	87 95       	ror	r24
     b26:	96 95       	lsr	r25
     b28:	87 95       	ror	r24
     b2a:	9c 01       	movw	r18, r24
     b2c:	22 0f       	add	r18, r18
     b2e:	33 1f       	adc	r19, r19
     b30:	88 0f       	add	r24, r24
     b32:	99 1f       	adc	r25, r25
     b34:	88 0f       	add	r24, r24
     b36:	99 1f       	adc	r25, r25
     b38:	88 0f       	add	r24, r24
     b3a:	99 1f       	adc	r25, r25
     b3c:	82 0f       	add	r24, r18
     b3e:	93 1f       	adc	r25, r19
     b40:	48 1b       	sub	r20, r24
     b42:	59 0b       	sbc	r21, r25
     b44:	fa 01       	movw	r30, r20
     b46:	e0 50       	subi	r30, 0x00	; 0
     b48:	ff 4f       	sbci	r31, 0xFF	; 255
     b4a:	80 81       	ld	r24, Z
     b4c:	80 93 41 01 	sts	0x0141, r24	; 0x800141 <__data_end+0x3>
         segment_data[2] = 0b111;
     b50:	87 e0       	ldi	r24, 0x07	; 7
     b52:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <__data_end+0x2>
         segment_data[1] = dec_to_7seg[(current_fm_freq/100)%10];
     b56:	20 91 27 01 	lds	r18, 0x0127	; 0x800127 <current_fm_freq>
     b5a:	30 91 28 01 	lds	r19, 0x0128	; 0x800128 <current_fm_freq+0x1>
     b5e:	36 95       	lsr	r19
     b60:	27 95       	ror	r18
     b62:	36 95       	lsr	r19
     b64:	27 95       	ror	r18
     b66:	ab e7       	ldi	r26, 0x7B	; 123
     b68:	b4 e1       	ldi	r27, 0x14	; 20
     b6a:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <__umulhisi3>
     b6e:	ac 01       	movw	r20, r24
     b70:	56 95       	lsr	r21
     b72:	47 95       	ror	r20
     b74:	9a 01       	movw	r18, r20
     b76:	ad ec       	ldi	r26, 0xCD	; 205
     b78:	bc ec       	ldi	r27, 0xCC	; 204
     b7a:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <__umulhisi3>
     b7e:	96 95       	lsr	r25
     b80:	87 95       	ror	r24
     b82:	96 95       	lsr	r25
     b84:	87 95       	ror	r24
     b86:	96 95       	lsr	r25
     b88:	87 95       	ror	r24
     b8a:	9c 01       	movw	r18, r24
     b8c:	22 0f       	add	r18, r18
     b8e:	33 1f       	adc	r19, r19
     b90:	88 0f       	add	r24, r24
     b92:	99 1f       	adc	r25, r25
     b94:	88 0f       	add	r24, r24
     b96:	99 1f       	adc	r25, r25
     b98:	88 0f       	add	r24, r24
     b9a:	99 1f       	adc	r25, r25
     b9c:	82 0f       	add	r24, r18
     b9e:	93 1f       	adc	r25, r19
     ba0:	48 1b       	sub	r20, r24
     ba2:	59 0b       	sbc	r21, r25
     ba4:	fa 01       	movw	r30, r20
     ba6:	e0 50       	subi	r30, 0x00	; 0
     ba8:	ff 4f       	sbci	r31, 0xFF	; 255
     baa:	80 81       	ld	r24, Z
     bac:	80 93 3f 01 	sts	0x013F, r24	; 0x80013f <__data_end+0x1>
         segment_data[0] = dec_to_7seg[(current_fm_freq/10)%10];
     bb0:	20 91 27 01 	lds	r18, 0x0127	; 0x800127 <current_fm_freq>
     bb4:	30 91 28 01 	lds	r19, 0x0128	; 0x800128 <current_fm_freq+0x1>
     bb8:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <__umulhisi3>
     bbc:	ac 01       	movw	r20, r24
     bbe:	56 95       	lsr	r21
     bc0:	47 95       	ror	r20
     bc2:	56 95       	lsr	r21
     bc4:	47 95       	ror	r20
     bc6:	56 95       	lsr	r21
     bc8:	47 95       	ror	r20
     bca:	9a 01       	movw	r18, r20
     bcc:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <__umulhisi3>
     bd0:	96 95       	lsr	r25
     bd2:	87 95       	ror	r24
     bd4:	96 95       	lsr	r25
     bd6:	87 95       	ror	r24
     bd8:	96 95       	lsr	r25
     bda:	87 95       	ror	r24
     bdc:	9c 01       	movw	r18, r24
     bde:	22 0f       	add	r18, r18
     be0:	33 1f       	adc	r19, r19
     be2:	88 0f       	add	r24, r24
     be4:	99 1f       	adc	r25, r25
     be6:	88 0f       	add	r24, r24
     be8:	99 1f       	adc	r25, r25
     bea:	88 0f       	add	r24, r24
     bec:	99 1f       	adc	r25, r25
     bee:	82 0f       	add	r24, r18
     bf0:	93 1f       	adc	r25, r19
     bf2:	48 1b       	sub	r20, r24
     bf4:	59 0b       	sbc	r21, r25
     bf6:	fa 01       	movw	r30, r20
     bf8:	e0 50       	subi	r30, 0x00	; 0
     bfa:	ff 4f       	sbci	r31, 0xFF	; 255
     bfc:	80 81       	ld	r24, Z
     bfe:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <__data_end>
     c02:	08 95       	ret

//This is where the digits are written to the data array
      if(mode_sel == 2){	//display alarm time
         segment_data[4] = dec_to_7seg[a_hour_count/10];
         segment_data[3] = dec_to_7seg[a_hour_count%10];
         if(sec_count%2){segment_data[2] = 0b100;}		//Turn colon on
     c04:	84 e0       	ldi	r24, 0x04	; 4
     c06:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <__data_end+0x2>
     c0a:	21 cf       	rjmp	.-446    	; 0xa4e <clock_time+0x136>
         segment_data[1] = dec_to_7seg[a_min_count/10];
         segment_data[0] = dec_to_7seg[a_min_count%10];
      }
      else if(mode_sel == 4){	//display frequency
         if(current_fm_freq > 9999){
	 segment_data[4] = dec_to_7seg[(current_fm_freq/10000)%10];
     c0c:	20 91 27 01 	lds	r18, 0x0127	; 0x800127 <current_fm_freq>
     c10:	30 91 28 01 	lds	r19, 0x0128	; 0x800128 <current_fm_freq+0x1>
     c14:	32 95       	swap	r19
     c16:	22 95       	swap	r18
     c18:	2f 70       	andi	r18, 0x0F	; 15
     c1a:	23 27       	eor	r18, r19
     c1c:	3f 70       	andi	r19, 0x0F	; 15
     c1e:	23 27       	eor	r18, r19
     c20:	a7 e4       	ldi	r26, 0x47	; 71
     c22:	b3 e0       	ldi	r27, 0x03	; 3
     c24:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <__umulhisi3>
     c28:	96 95       	lsr	r25
     c2a:	87 95       	ror	r24
     c2c:	96 95       	lsr	r25
     c2e:	87 95       	ror	r24
     c30:	96 95       	lsr	r25
     c32:	87 95       	ror	r24
     c34:	fc 01       	movw	r30, r24
     c36:	e0 50       	subi	r30, 0x00	; 0
     c38:	ff 4f       	sbci	r31, 0xFF	; 255
     c3a:	80 81       	ld	r24, Z
     c3c:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <__data_end+0x4>
     c40:	54 cf       	rjmp	.-344    	; 0xaea <clock_time+0x1d2>

00000c42 <port_init>:
Function: port_init
Description: General port initialization and setting pull up resistors
Parameters: NA
**********************************************************************/
void port_init(){
   DDRC |= 0xFF; 
     c42:	84 b3       	in	r24, 0x14	; 20
     c44:	8f ef       	ldi	r24, 0xFF	; 255
     c46:	84 bb       	out	0x14, r24	; 20
   DDRB |= 0xF0;				//PB4-6 is SEL0-2, PB7 is PWM
     c48:	97 b3       	in	r25, 0x17	; 23
     c4a:	90 6f       	ori	r25, 0xF0	; 240
     c4c:	97 bb       	out	0x17, r25	; 23
   DDRE |= 0x4F;				//PE6 is SHIFT_LD_N
     c4e:	92 b1       	in	r25, 0x02	; 2
     c50:	9f 64       	ori	r25, 0x4F	; 79
     c52:	92 b9       	out	0x02, r25	; 2
   DDRD |= 0xFF;				//PE1 is CLK_INH and PE2 is SRCLK
     c54:	91 b3       	in	r25, 0x11	; 17
     c56:	81 bb       	out	0x11, r24	; 17
   DDRF |= 0x08;
     c58:	e1 e6       	ldi	r30, 0x61	; 97
     c5a:	f0 e0       	ldi	r31, 0x00	; 0
     c5c:	90 81       	ld	r25, Z
     c5e:	98 60       	ori	r25, 0x08	; 8
     c60:	90 83       	st	Z, r25

   PORTC |= 0x01;
     c62:	a8 9a       	sbi	0x15, 0	; 21
   PORTD |= 0xFF;
     c64:	92 b3       	in	r25, 0x12	; 18
     c66:	82 bb       	out	0x12, r24	; 18
   PORTE |= 0xFF;
     c68:	93 b1       	in	r25, 0x03	; 3
     c6a:	83 b9       	out	0x03, r24	; 3
   PORTF |= 0x02;//(0<<PF1);
     c6c:	e2 e6       	ldi	r30, 0x62	; 98
     c6e:	f0 e0       	ldi	r31, 0x00	; 0
     c70:	80 81       	ld	r24, Z
     c72:	82 60       	ori	r24, 0x02	; 2
     c74:	80 83       	st	Z, r24

   EICRB |= (1<<ISC71) | (1<<ISC70);
     c76:	8a b7       	in	r24, 0x3a	; 58
     c78:	80 6c       	ori	r24, 0xC0	; 192
     c7a:	8a bf       	out	0x3a, r24	; 58
   EIMSK |= (1<<INT7);
     c7c:	89 b7       	in	r24, 0x39	; 57
     c7e:	80 68       	ori	r24, 0x80	; 128
     c80:	89 bf       	out	0x39, r24	; 57
     c82:	08 95       	ret

00000c84 <change_alarm_state>:
	and what time it is set for on the LCD.
Parameters: NA
**********************************************************************/
void change_alarm_state(){
   static uint8_t curr = 0;
   if(alarm && (curr ==0)){
     c84:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <alarm>
     c88:	88 23       	and	r24, r24
     c8a:	21 f0       	breq	.+8      	; 0xc94 <change_alarm_state+0x10>
     c8c:	80 91 57 01 	lds	r24, 0x0157	; 0x800157 <curr.2235>
     c90:	88 23       	and	r24, r24
     c92:	89 f0       	breq	.+34     	; 0xcb6 <change_alarm_state+0x32>
      line1_col1();
      string2lcd("Alarm");
      curr = 1;
   }
   else if((!alarm) && (curr == 1)){
     c94:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <alarm>
     c98:	81 11       	cpse	r24, r1
     c9a:	04 c0       	rjmp	.+8      	; 0xca4 <change_alarm_state+0x20>
     c9c:	80 91 57 01 	lds	r24, 0x0157	; 0x800157 <curr.2235>
     ca0:	81 30       	cpi	r24, 0x01	; 1
     ca2:	09 f0       	breq	.+2      	; 0xca6 <change_alarm_state+0x22>
     ca4:	08 95       	ret
      curr = 0;
     ca6:	10 92 57 01 	sts	0x0157, r1	; 0x800157 <curr.2235>
      line1_col1();
     caa:	0e 94 08 09 	call	0x1210	; 0x1210 <line1_col1>
      string2lcd("     ");	//clears the lcd of the alarm 
     cae:	81 e3       	ldi	r24, 0x31	; 49
     cb0:	91 e0       	ldi	r25, 0x01	; 1
     cb2:	0c 94 4a 09 	jmp	0x1294	; 0x1294 <string2lcd>
Parameters: NA
**********************************************************************/
void change_alarm_state(){
   static uint8_t curr = 0;
   if(alarm && (curr ==0)){
      line1_col1();
     cb6:	0e 94 08 09 	call	0x1210	; 0x1210 <line1_col1>
      string2lcd("Alarm");
     cba:	8b e2       	ldi	r24, 0x2B	; 43
     cbc:	91 e0       	ldi	r25, 0x01	; 1
     cbe:	0e 94 4a 09 	call	0x1294	; 0x1294 <string2lcd>
      curr = 1;
     cc2:	81 e0       	ldi	r24, 0x01	; 1
     cc4:	80 93 57 01 	sts	0x0157, r24	; 0x800157 <curr.2235>
     cc8:	08 95       	ret

00000cca <adc_init>:
Description: Basic adc initialization used for single shot adc readings
Parameters: NA
**********************************************************************/
void adc_init(){
//Initalize ADC and its ports
   DDRF  &= ~(_BV(DDF7)); //make port F bit 7 is ADC input  
     cca:	e1 e6       	ldi	r30, 0x61	; 97
     ccc:	f0 e0       	ldi	r31, 0x00	; 0
     cce:	80 81       	ld	r24, Z
     cd0:	8f 77       	andi	r24, 0x7F	; 127
     cd2:	80 83       	st	Z, r24
   PORTF &= ~(_BV(PF7));  //port F bit 7 pullups must be off
     cd4:	e2 e6       	ldi	r30, 0x62	; 98
     cd6:	f0 e0       	ldi	r31, 0x00	; 0
     cd8:	80 81       	ld	r24, Z
     cda:	8f 77       	andi	r24, 0x7F	; 127
     cdc:	80 83       	st	Z, r24
   ADMUX |= (1<<REFS0) | (1<<MUX2)| (1<<MUX1)| (1<<MUX0); //single-ended, input PORTF bit 7, right adjusted, 10 bits
     cde:	87 b1       	in	r24, 0x07	; 7
     ce0:	87 64       	ori	r24, 0x47	; 71
     ce2:	87 b9       	out	0x07, r24	; 7

   ADCSRA |= (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);//ADC enabled, don't start yet, single shot mode 
     ce4:	86 b1       	in	r24, 0x06	; 6
     ce6:	87 68       	ori	r24, 0x87	; 135
     ce8:	86 b9       	out	0x06, r24	; 6
     cea:	08 95       	ret

00000cec <fetch_adc>:
void fetch_adc(){
   uint16_t adc_result;
   uint16_t step;   
   uint16_t step2;   

   ADCSRA |= (1<<ADSC); //poke ADSC and start conversion
     cec:	36 9a       	sbi	0x06, 6	; 6
   while(bit_is_clear(ADCSRA, ADIF)){} //spin while interrupt flag not set
     cee:	34 9b       	sbis	0x06, 4	; 6
     cf0:	fe cf       	rjmp	.-4      	; 0xcee <fetch_adc+0x2>
   ACSR |= (1<<ACI); //its done, clear flag by writing a one 
     cf2:	44 9a       	sbi	0x08, 4	; 8
   adc_result = ADC;                      //read the ADC output as 16 bits
     cf4:	24 b1       	in	r18, 0x04	; 4
     cf6:	35 b1       	in	r19, 0x05	; 5

   step = adc_result/4;//scales the adc result from 0-255
   step2 =  255 - step;//I need the complement to the adc result
     cf8:	36 95       	lsr	r19
     cfa:	27 95       	ror	r18
     cfc:	36 95       	lsr	r19
     cfe:	27 95       	ror	r18
   if(step2 > 235){	//this is a minimum brightness level
      step2 = 235;
   }

   OCR2 = step2;	//Write brightness level to tnct2 compare match register
     d00:	8f ef       	ldi	r24, 0xFF	; 255
     d02:	90 e0       	ldi	r25, 0x00	; 0
     d04:	82 1b       	sub	r24, r18
     d06:	93 0b       	sbc	r25, r19
     d08:	8c 3e       	cpi	r24, 0xEC	; 236
     d0a:	91 05       	cpc	r25, r1
     d0c:	10 f0       	brcs	.+4      	; 0xd12 <fetch_adc+0x26>
     d0e:	8b ee       	ldi	r24, 0xEB	; 235
     d10:	90 e0       	ldi	r25, 0x00	; 0
     d12:	83 bd       	out	0x23, r24	; 35
     d14:	08 95       	ret

00000d16 <__vector_12>:
Function: TIMER!_COMPA_vect
Description: This ISR creates the alarm frequency on PORTD but 3 the is used
	for the alarm tone.
Parameters: NA
**********************************************************************/
ISR(TIMER1_COMPA_vect){
     d16:	1f 92       	push	r1
     d18:	0f 92       	push	r0
     d1a:	0f b6       	in	r0, 0x3f	; 63
     d1c:	0f 92       	push	r0
     d1e:	11 24       	eor	r1, r1
     d20:	8f 93       	push	r24
     d22:	9f 93       	push	r25
if(!snooze){ //alarm has not been snoozed
     d24:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <snooze>
     d28:	81 11       	cpse	r24, r1
     d2a:	0a c0       	rjmp	.+20     	; 0xd40 <__vector_12+0x2a>
//checks to see alarm is on and the alarm time matches clock time
   if(alarm && ((hour_count == a_hour_count) && (min_count == a_min_count))){
     d2c:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <alarm>
     d30:	88 23       	and	r24, r24
     d32:	31 f0       	breq	.+12     	; 0xd40 <__vector_12+0x2a>
     d34:	90 91 50 01 	lds	r25, 0x0150	; 0x800150 <hour_count>
     d38:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <a_hour_count>
     d3c:	98 17       	cp	r25, r24
     d3e:	39 f0       	breq	.+14     	; 0xd4e <__vector_12+0x38>
      PORTD = PIND ^ 0b00000100;//toggles PD3 to create frequency
   }
}
}
     d40:	9f 91       	pop	r25
     d42:	8f 91       	pop	r24
     d44:	0f 90       	pop	r0
     d46:	0f be       	out	0x3f, r0	; 63
     d48:	0f 90       	pop	r0
     d4a:	1f 90       	pop	r1
     d4c:	18 95       	reti
Parameters: NA
**********************************************************************/
ISR(TIMER1_COMPA_vect){
if(!snooze){ //alarm has not been snoozed
//checks to see alarm is on and the alarm time matches clock time
   if(alarm && ((hour_count == a_hour_count) && (min_count == a_min_count))){
     d4e:	90 91 51 01 	lds	r25, 0x0151	; 0x800151 <min_count>
     d52:	80 91 4e 01 	lds	r24, 0x014E	; 0x80014e <a_min_count>
     d56:	98 13       	cpse	r25, r24
     d58:	f3 cf       	rjmp	.-26     	; 0xd40 <__vector_12+0x2a>
      PORTD = PIND ^ 0b00000100;//toggles PD3 to create frequency
     d5a:	90 b3       	in	r25, 0x10	; 16
     d5c:	84 e0       	ldi	r24, 0x04	; 4
     d5e:	89 27       	eor	r24, r25
     d60:	82 bb       	out	0x12, r24	; 18
   }
}
}
     d62:	ee cf       	rjmp	.-36     	; 0xd40 <__vector_12+0x2a>

00000d64 <snoozin>:
Description: This function disables the snooze variable once the alarm
	seconds equals the normal seconds. 
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
     d64:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <snooze>
     d68:	81 11       	cpse	r24, r1
     d6a:	0c 94 b8 00 	jmp	0x170	; 0x170 <snoozin.part.1>
     d6e:	08 95       	ret

00000d70 <local_temp_init>:
Description: Initialized the lm73
Parameters: NA
**********************************************************************/
void local_temp_init(){

lm73_wr_buf[0] = 0x00; //load lm73_wr_buf[0] with temperature pointer address
     d70:	10 92 c6 01 	sts	0x01C6, r1	; 0x8001c6 <lm73_wr_buf>
twi_start_wr(LM73_ADDRESS, lm73_rd_buf, 1); //start the TWI write process
     d74:	41 e0       	ldi	r20, 0x01	; 1
     d76:	68 ec       	ldi	r22, 0xC8	; 200
     d78:	71 e0       	ldi	r23, 0x01	; 1
     d7a:	80 e9       	ldi	r24, 0x90	; 144
     d7c:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <twi_start_wr>
     d80:	2f ef       	ldi	r18, 0xFF	; 255
     d82:	81 ee       	ldi	r24, 0xE1	; 225
     d84:	94 e0       	ldi	r25, 0x04	; 4
     d86:	21 50       	subi	r18, 0x01	; 1
     d88:	80 40       	sbci	r24, 0x00	; 0
     d8a:	90 40       	sbci	r25, 0x00	; 0
     d8c:	e1 f7       	brne	.-8      	; 0xd86 <local_temp_init+0x16>
     d8e:	00 c0       	rjmp	.+0      	; 0xd90 <local_temp_init+0x20>
     d90:	00 00       	nop
     d92:	08 95       	ret

00000d94 <__vector_8>:
//******************************************************************************
// External interrupt 7 is on Port E bit 7. The interrupt is triggered on the
// rising edge of Port E bit 7.  The i/o clock must be running to detect the
// edge (not asynchronouslly triggered)
//******************************************************************************
ISR(INT7_vect){ //interrupt being used in the radio
     d94:	1f 92       	push	r1
     d96:	0f 92       	push	r0
     d98:	0f b6       	in	r0, 0x3f	; 63
     d9a:	0f 92       	push	r0
     d9c:	11 24       	eor	r1, r1
     d9e:	0b b6       	in	r0, 0x3b	; 59
     da0:	0f 92       	push	r0
     da2:	8f 93       	push	r24
     da4:	9f 93       	push	r25
     da6:	ef 93       	push	r30
     da8:	ff 93       	push	r31
	STC_interrupt = TRUE;
     daa:	81 e0       	ldi	r24, 0x01	; 1
     dac:	80 93 3b 02 	sts	0x023B, r24	; 0x80023b <STC_interrupt>
	PORTF ^= (1 << PF1);
     db0:	e2 e6       	ldi	r30, 0x62	; 98
     db2:	f0 e0       	ldi	r31, 0x00	; 0
     db4:	90 81       	ld	r25, Z
     db6:	82 e0       	ldi	r24, 0x02	; 2
     db8:	89 27       	eor	r24, r25
     dba:	80 83       	st	Z, r24
}
     dbc:	ff 91       	pop	r31
     dbe:	ef 91       	pop	r30
     dc0:	9f 91       	pop	r25
     dc2:	8f 91       	pop	r24
     dc4:	0f 90       	pop	r0
     dc6:	0b be       	out	0x3b, r0	; 59
     dc8:	0f 90       	pop	r0
     dca:	0f be       	out	0x3f, r0	; 63
     dcc:	0f 90       	pop	r0
     dce:	1f 90       	pop	r1
     dd0:	18 95       	reti

00000dd2 <radio_function>:
/***********************************************************************/
 void radio_function(){ 
	PORTE &= ~(1<<PE7); //int2 initially low to sense TWI mode
     dd2:	1f 98       	cbi	0x03, 7	; 3
	 DDRE  |= 0x80;      //turn on Port E bit 7 to drive it low
     dd4:	17 9a       	sbi	0x02, 7	; 2
	 PORTE |=  (1<<PE2); //hardware reset Si4734 
     dd6:	1a 9a       	sbi	0x03, 2	; 3
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     dd8:	8f e1       	ldi	r24, 0x1F	; 31
     dda:	93 e0       	ldi	r25, 0x03	; 3
     ddc:	01 97       	sbiw	r24, 0x01	; 1
     dde:	f1 f7       	brne	.-4      	; 0xddc <radio_function+0xa>
     de0:	00 c0       	rjmp	.+0      	; 0xde2 <radio_function+0x10>
     de2:	00 00       	nop
	 _delay_us(200);     //hold for 200us, 100us by spec         
	 PORTE &= ~(1<<PE2); //release reset 
     de4:	1a 98       	cbi	0x03, 2	; 3
     de6:	90 ea       	ldi	r25, 0xA0	; 160
     de8:	9a 95       	dec	r25
     dea:	f1 f7       	brne	.-4      	; 0xde8 <radio_function+0x16>
	 _delay_us(30);      
		//Si code in "low" has 30us delay...no explaination
	 DDRE  &= ~(0x80);   //now Port E bit 7 becomes input from the radio interrupt
     dec:	17 98       	cbi	0x02, 7	; 2

	 fm_pwr_up(); //powerup the radio as appropriate
     dee:	0e 94 26 0e 	call	0x1c4c	; 0x1c4c <fm_pwr_up>
	 current_fm_freq = freq_change; 
     df2:	80 91 12 01 	lds	r24, 0x0112	; 0x800112 <freq_change>
     df6:	90 91 13 01 	lds	r25, 0x0113	; 0x800113 <freq_change+0x1>
     dfa:	90 93 28 01 	sts	0x0128, r25	; 0x800128 <current_fm_freq+0x1>
     dfe:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <current_fm_freq>
	 fm_tune_freq(); //tune radio to frequency in current_fm_freq
     e02:	0c 94 06 0d 	jmp	0x1a0c	; 0x1a0c <fm_tune_freq>

00000e06 <__vector_18>:
/**********************************************************************
Function: ISR(USART0_RX_vect)
Description: reads the data being transferd via usart
Parameters: NA
**********************************************************************/
ISR(USART0_RX_vect){
     e06:	1f 92       	push	r1
     e08:	0f 92       	push	r0
     e0a:	0f b6       	in	r0, 0x3f	; 63
     e0c:	0f 92       	push	r0
     e0e:	11 24       	eor	r1, r1
     e10:	0b b6       	in	r0, 0x3b	; 59
     e12:	0f 92       	push	r0
     e14:	8f 93       	push	r24
     e16:	9f 93       	push	r25
     e18:	ef 93       	push	r30
     e1a:	ff 93       	push	r31
static  uint8_t  i;
  rx_char = UDR0;              //get character
     e1c:	8c b1       	in	r24, 0x0c	; 12
     e1e:	80 93 8f 01 	sts	0x018F, r24	; 0x80018f <rx_char>
  lcd_str_array[i++]=rx_char;  //store in array 
     e22:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <i.2267>
     e26:	91 e0       	ldi	r25, 0x01	; 1
     e28:	9e 0f       	add	r25, r30
     e2a:	90 93 56 01 	sts	0x0156, r25	; 0x800156 <i.2267>
     e2e:	f0 e0       	ldi	r31, 0x00	; 0
     e30:	e5 58       	subi	r30, 0x85	; 133
     e32:	fe 4f       	sbci	r31, 0xFE	; 254
     e34:	80 83       	st	Z, r24
 //if entire string has arrived, set flag, reset index
  if(rx_char == '\0'){
     e36:	81 11       	cpse	r24, r1
     e38:	09 c0       	rjmp	.+18     	; 0xe4c <__vector_18+0x46>
    rcv_rdy=1; 
     e3a:	81 e0       	ldi	r24, 0x01	; 1
     e3c:	80 93 6f 01 	sts	0x016F, r24	; 0x80016f <rcv_rdy>
    lcd_str_array[--i]  = (' ');     //clear the count field
     e40:	80 e2       	ldi	r24, 0x20	; 32
     e42:	80 83       	st	Z, r24
    lcd_str_array[i+1]  = (' ');
     e44:	81 83       	std	Z+1, r24	; 0x01
    lcd_str_array[i+2]  = (' ');
     e46:	82 83       	std	Z+2, r24	; 0x02
    i=0;  
     e48:	10 92 56 01 	sts	0x0156, r1	; 0x800156 <i.2267>
  }
}
     e4c:	ff 91       	pop	r31
     e4e:	ef 91       	pop	r30
     e50:	9f 91       	pop	r25
     e52:	8f 91       	pop	r24
     e54:	0f 90       	pop	r0
     e56:	0b be       	out	0x3b, r0	; 59
     e58:	0f 90       	pop	r0
     e5a:	0f be       	out	0x3f, r0	; 63
     e5c:	0f 90       	pop	r0
     e5e:	1f 90       	pop	r1
     e60:	18 95       	reti

00000e62 <send_lcd>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e62:	91 e0       	ldi	r25, 0x01	; 1
     e64:	81 11       	cpse	r24, r1
     e66:	01 c0       	rjmp	.+2      	; 0xe6a <send_lcd+0x8>
     e68:	90 e0       	ldi	r25, 0x00	; 0
     e6a:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e6c:	77 9b       	sbis	0x0e, 7	; 14
     e6e:	fe cf       	rjmp	.-4      	; 0xe6c <send_lcd+0xa>
  SPDR = byte;                        //send payload
     e70:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e72:	77 9b       	sbis	0x0e, 7	; 14
     e74:	fe cf       	rjmp	.-4      	; 0xe72 <send_lcd+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     e76:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e7a:	88 60       	ori	r24, 0x08	; 8
     e7c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e80:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e84:	87 7f       	andi	r24, 0xF7	; 247
     e86:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     e8a:	08 95       	ret

00000e8c <refresh_lcd>:
//
void refresh_lcd(char lcd_string_array[]) {

  static uint8_t i=0;           // index into string array 

 send_lcd(CHAR_BYTE,lcd_string_array[i]);
     e8c:	20 91 6a 01 	lds	r18, 0x016A	; 0x80016a <i.2095>
     e90:	82 0f       	add	r24, r18
     e92:	91 1d       	adc	r25, r1
     e94:	fc 01       	movw	r30, r24
     e96:	80 81       	ld	r24, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     e98:	91 e0       	ldi	r25, 0x01	; 1
     e9a:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     e9c:	77 9b       	sbis	0x0e, 7	; 14
     e9e:	fe cf       	rjmp	.-4      	; 0xe9c <refresh_lcd+0x10>
  SPDR = byte;                        //send payload
     ea0:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ea2:	77 9b       	sbis	0x0e, 7	; 14
     ea4:	fe cf       	rjmp	.-4      	; 0xea2 <refresh_lcd+0x16>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     ea6:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     eaa:	88 60       	ori	r24, 0x08	; 8
     eac:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     eb0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     eb4:	87 7f       	andi	r24, 0xF7	; 247
     eb6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
void refresh_lcd(char lcd_string_array[]) {

  static uint8_t i=0;           // index into string array 

 send_lcd(CHAR_BYTE,lcd_string_array[i]);
 i++;   //increment to next character
     eba:	80 91 6a 01 	lds	r24, 0x016A	; 0x80016a <i.2095>
     ebe:	8f 5f       	subi	r24, 0xFF	; 255
     ec0:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <i.2095>
 //delays are inserted to allow character to be written before moving
 //the cursor to the next line.
 if(i == 16){_delay_us(40); line2_col1();      } //goto line 2, 1st char 
     ec4:	80 31       	cpi	r24, 0x10	; 16
     ec6:	f9 f0       	breq	.+62     	; 0xf06 <refresh_lcd+0x7a>
 if(i == 32){_delay_us(40); line1_col1(); i=0; } //goto line 1, 1st char 
     ec8:	80 32       	cpi	r24, 0x20	; 32
     eca:	09 f0       	breq	.+2      	; 0xece <refresh_lcd+0x42>
     ecc:	08 95       	ret
     ece:	e5 ed       	ldi	r30, 0xD5	; 213
     ed0:	ea 95       	dec	r30
     ed2:	f1 f7       	brne	.-4      	; 0xed0 <refresh_lcd+0x44>
     ed4:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     ed6:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ed8:	77 9b       	sbis	0x0e, 7	; 14
     eda:	fe cf       	rjmp	.-4      	; 0xed8 <refresh_lcd+0x4c>
  SPDR = byte;                        //send payload
     edc:	80 e8       	ldi	r24, 0x80	; 128
     ede:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     ee0:	77 9b       	sbis	0x0e, 7	; 14
     ee2:	fe cf       	rjmp	.-4      	; 0xee0 <refresh_lcd+0x54>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     ee4:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ee8:	88 60       	ori	r24, 0x08	; 8
     eea:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     eee:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ef2:	87 7f       	andi	r24, 0xF7	; 247
     ef4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ef8:	f5 ed       	ldi	r31, 0xD5	; 213
     efa:	fa 95       	dec	r31
     efc:	f1 f7       	brne	.-4      	; 0xefa <refresh_lcd+0x6e>
     efe:	00 00       	nop
 send_lcd(CHAR_BYTE,lcd_string_array[i]);
 i++;   //increment to next character
 //delays are inserted to allow character to be written before moving
 //the cursor to the next line.
 if(i == 16){_delay_us(40); line2_col1();      } //goto line 2, 1st char 
 if(i == 32){_delay_us(40); line1_col1(); i=0; } //goto line 1, 1st char 
     f00:	10 92 6a 01 	sts	0x016A, r1	; 0x80016a <i.2095>
     f04:	08 95       	ret
     f06:	f5 ed       	ldi	r31, 0xD5	; 213
     f08:	fa 95       	dec	r31
     f0a:	f1 f7       	brne	.-4      	; 0xf08 <refresh_lcd+0x7c>
     f0c:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     f0e:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f10:	77 9b       	sbis	0x0e, 7	; 14
     f12:	fe cf       	rjmp	.-4      	; 0xf10 <refresh_lcd+0x84>
  SPDR = byte;                        //send payload
     f14:	80 ec       	ldi	r24, 0xC0	; 192
     f16:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f18:	77 9b       	sbis	0x0e, 7	; 14
     f1a:	fe cf       	rjmp	.-4      	; 0xf18 <refresh_lcd+0x8c>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     f1c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f20:	88 60       	ori	r24, 0x08	; 8
     f22:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f26:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f2a:	87 7f       	andi	r24, 0xF7	; 247
     f2c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f30:	85 ed       	ldi	r24, 0xD5	; 213
     f32:	8a 95       	dec	r24
     f34:	f1 f7       	brne	.-4      	; 0xf32 <refresh_lcd+0xa6>
     f36:	00 00       	nop
     f38:	80 91 6a 01 	lds	r24, 0x016A	; 0x80016a <i.2095>
     f3c:	c5 cf       	rjmp	.-118    	; 0xec8 <refresh_lcd+0x3c>

00000f3e <set_custom_character>:
//address, such as send_lcd(CHAR_BYTE, 0x01, 1) or it can be insteretd into a string 
//via a forward slash escape as in string2lcd("this is my music note \1")

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
     f3e:	66 0f       	add	r22, r22
     f40:	66 0f       	add	r22, r22
     f42:	66 0f       	add	r22, r22
     f44:	60 5c       	subi	r22, 0xC0	; 192
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     f46:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f48:	77 9b       	sbis	0x0e, 7	; 14
     f4a:	fe cf       	rjmp	.-4      	; 0xf48 <set_custom_character+0xa>
  SPDR = byte;                        //send payload
     f4c:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f4e:	77 9b       	sbis	0x0e, 7	; 14
     f50:	fe cf       	rjmp	.-4      	; 0xf4e <set_custom_character+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     f52:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f56:	28 60       	ori	r18, 0x08	; 8
     f58:	20 93 62 00 	sts	0x0062, r18	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f5c:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f60:	27 7f       	andi	r18, 0xF7	; 247
     f62:	20 93 62 00 	sts	0x0062, r18	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f66:	25 ed       	ldi	r18, 0xD5	; 213
     f68:	2a 95       	dec	r18
     f6a:	f1 f7       	brne	.-4      	; 0xf68 <set_custom_character+0x2a>
     f6c:	00 00       	nop
     f6e:	fc 01       	movw	r30, r24
     f70:	9c 01       	movw	r18, r24
     f72:	28 5f       	subi	r18, 0xF8	; 248
     f74:	3f 4f       	sbci	r19, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     f76:	91 e0       	ldi	r25, 0x01	; 1

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
    for(i=0; i<8; i++){
      send_lcd(CHAR_BYTE, data[i]); _delay_us(40); //each char byte takes 37us to execute
     f78:	81 91       	ld	r24, Z+
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     f7a:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f7c:	77 9b       	sbis	0x0e, 7	; 14
     f7e:	fe cf       	rjmp	.-4      	; 0xf7c <set_custom_character+0x3e>
  SPDR = byte;                        //send payload
     f80:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     f82:	77 9b       	sbis	0x0e, 7	; 14
     f84:	fe cf       	rjmp	.-4      	; 0xf82 <set_custom_character+0x44>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     f86:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f8a:	88 60       	ori	r24, 0x08	; 8
     f8c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f90:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f94:	87 7f       	andi	r24, 0xF7	; 247
     f96:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     f9a:	85 ed       	ldi	r24, 0xD5	; 213
     f9c:	8a 95       	dec	r24
     f9e:	f1 f7       	brne	.-4      	; 0xf9c <set_custom_character+0x5e>
     fa0:	00 00       	nop
//via a forward slash escape as in string2lcd("this is my music note \1")

void set_custom_character(uint8_t data[], uint8_t address){
    uint8_t i;
    send_lcd(CMD_BYTE, 0x40 + (address << 3)); _delay_us(40);  //only needs 37uS
    for(i=0; i<8; i++){
     fa2:	e2 17       	cp	r30, r18
     fa4:	f3 07       	cpc	r31, r19
     fa6:	41 f7       	brne	.-48     	; 0xf78 <set_custom_character+0x3a>
      send_lcd(CHAR_BYTE, data[i]); _delay_us(40); //each char byte takes 37us to execute
    }
}
     fa8:	08 95       	ret

00000faa <set_cursor>:
//                          set_cursor 
//
//Sets the cursor to an arbitrary potition on the screen, row is either 1 or 2
//col is a number form 0-15, counting from left to right
void set_cursor(uint8_t row, uint8_t col){
    send_lcd(CMD_BYTE, 0x80 + col + ((row-1)*0x40));
     faa:	90 e4       	ldi	r25, 0x40	; 64
     fac:	89 9f       	mul	r24, r25
     fae:	60 0d       	add	r22, r0
     fb0:	11 24       	eor	r1, r1
     fb2:	60 5c       	subi	r22, 0xC0	; 192
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     fb4:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     fb6:	77 9b       	sbis	0x0e, 7	; 14
     fb8:	fe cf       	rjmp	.-4      	; 0xfb6 <set_cursor+0xc>
  SPDR = byte;                        //send payload
     fba:	6f b9       	out	0x0f, r22	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     fbc:	77 9b       	sbis	0x0e, 7	; 14
     fbe:	fe cf       	rjmp	.-4      	; 0xfbc <set_cursor+0x12>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     fc0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fc4:	88 60       	ori	r24, 0x08	; 8
     fc6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fca:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fce:	87 7f       	andi	r24, 0xF7	; 247
     fd0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fd4:	08 95       	ret

00000fd6 <uint2lcd>:
//not displayed.  
//TODO: optimize by removing the mod operators
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
     fd6:	81 11       	cpse	r24, r1
     fd8:	13 c0       	rjmp	.+38     	; 0x1000 <uint2lcd+0x2a>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
     fda:	81 e0       	ldi	r24, 0x01	; 1
     fdc:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     fde:	77 9b       	sbis	0x0e, 7	; 14
     fe0:	fe cf       	rjmp	.-4      	; 0xfde <uint2lcd+0x8>
  SPDR = byte;                        //send payload
     fe2:	80 e3       	ldi	r24, 0x30	; 48
     fe4:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
     fe6:	77 9b       	sbis	0x0e, 7	; 14
     fe8:	fe cf       	rjmp	.-4      	; 0xfe6 <uint2lcd+0x10>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
     fea:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     fee:	88 60       	ori	r24, 0x08	; 8
     ff0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ff4:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ff8:	87 7f       	andi	r24, 0xF7	; 247
     ffa:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
     ffe:	08 95       	ret
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
    1000:	84 36       	cpi	r24, 0x64	; 100
    1002:	b0 f4       	brcc	.+44     	; 0x1030 <uint2lcd+0x5a>
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
    1004:	8a 30       	cpi	r24, 0x0A	; 10
    1006:	60 f5       	brcc	.+88     	; 0x1060 <uint2lcd+0x8a>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1008:	91 e0       	ldi	r25, 0x01	; 1
    100a:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    100c:	77 9b       	sbis	0x0e, 7	; 14
    100e:	fe cf       	rjmp	.-4      	; 0x100c <uint2lcd+0x36>
void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
      if(number >= 1)  {send_lcd(CHAR_BYTE, 0x30+(number%10)    ); }
    1010:	9d ec       	ldi	r25, 0xCD	; 205
    1012:	89 9f       	mul	r24, r25
    1014:	91 2d       	mov	r25, r1
    1016:	11 24       	eor	r1, r1
    1018:	96 95       	lsr	r25
    101a:	96 95       	lsr	r25
    101c:	96 95       	lsr	r25
    101e:	2a e0       	ldi	r18, 0x0A	; 10
    1020:	92 9f       	mul	r25, r18
    1022:	80 19       	sub	r24, r0
    1024:	11 24       	eor	r1, r1
    1026:	80 5d       	subi	r24, 0xD0	; 208
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
  SPDR = byte;                        //send payload
    1028:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    102a:	77 9b       	sbis	0x0e, 7	; 14
    102c:	fe cf       	rjmp	.-4      	; 0x102a <uint2lcd+0x54>
    102e:	dd cf       	rjmp	.-70     	; 0xfea <uint2lcd+0x14>
//TODO: Should be renamed uint8_2lcd(). Also, implement a uint16_2lcd() function

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
    1030:	99 e2       	ldi	r25, 0x29	; 41
    1032:	89 9f       	mul	r24, r25
    1034:	91 2d       	mov	r25, r1
    1036:	11 24       	eor	r1, r1
    1038:	92 95       	swap	r25
    103a:	9f 70       	andi	r25, 0x0F	; 15
    103c:	90 5d       	subi	r25, 0xD0	; 208
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    103e:	21 e0       	ldi	r18, 0x01	; 1
    1040:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1042:	77 9b       	sbis	0x0e, 7	; 14
    1044:	fe cf       	rjmp	.-4      	; 0x1042 <uint2lcd+0x6c>
  SPDR = byte;                        //send payload
    1046:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1048:	77 9b       	sbis	0x0e, 7	; 14
    104a:	fe cf       	rjmp	.-4      	; 0x1048 <uint2lcd+0x72>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    104c:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1050:	98 60       	ori	r25, 0x08	; 8
    1052:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1056:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    105a:	97 7f       	andi	r25, 0xF7	; 247
    105c:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>

void uint2lcd(uint8_t number){
    if  (number == 0)  {send_lcd(CHAR_BYTE, 0x30                ); }
    else{
      if(number >= 100){send_lcd(CHAR_BYTE, 0x30+number/100     ); }
      if(number >= 10) {send_lcd(CHAR_BYTE, 0x30+(number%100)/10); }
    1060:	99 e2       	ldi	r25, 0x29	; 41
    1062:	89 9f       	mul	r24, r25
    1064:	91 2d       	mov	r25, r1
    1066:	11 24       	eor	r1, r1
    1068:	92 95       	swap	r25
    106a:	9f 70       	andi	r25, 0x0F	; 15
    106c:	38 2f       	mov	r19, r24
    106e:	24 e6       	ldi	r18, 0x64	; 100
    1070:	92 9f       	mul	r25, r18
    1072:	30 19       	sub	r19, r0
    1074:	11 24       	eor	r1, r1
    1076:	2d ec       	ldi	r18, 0xCD	; 205
    1078:	32 9f       	mul	r19, r18
    107a:	91 2d       	mov	r25, r1
    107c:	11 24       	eor	r1, r1
    107e:	96 95       	lsr	r25
    1080:	96 95       	lsr	r25
    1082:	96 95       	lsr	r25
    1084:	90 5d       	subi	r25, 0xD0	; 208
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1086:	21 e0       	ldi	r18, 0x01	; 1
    1088:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    108a:	77 9b       	sbis	0x0e, 7	; 14
    108c:	fe cf       	rjmp	.-4      	; 0x108a <uint2lcd+0xb4>
  SPDR = byte;                        //send payload
    108e:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1090:	77 9b       	sbis	0x0e, 7	; 14
    1092:	fe cf       	rjmp	.-4      	; 0x1090 <uint2lcd+0xba>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    1094:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1098:	98 60       	ori	r25, 0x08	; 8
    109a:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    109e:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10a2:	97 7f       	andi	r25, 0xF7	; 247
    10a4:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10a8:	af cf       	rjmp	.-162    	; 0x1008 <uint2lcd+0x32>

000010aa <int2lcd>:
//Takes a 8bit signed and displays it in base ten on the LCD. Leading 0's are 
//not displayed.
//
void int2lcd(int8_t number){
    //if < 0, print minus sign, then take 2's complement of number and display
    if(number < 0){send_lcd(CHAR_BYTE, '-'); _delay_us(40); uint2lcd(~number+1);}  
    10aa:	87 ff       	sbrs	r24, 7
    else          {uint2lcd(number);                                            }
    10ac:	0c 94 eb 07 	jmp	0xfd6	; 0xfd6 <uint2lcd>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    10b0:	91 e0       	ldi	r25, 0x01	; 1
    10b2:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    10b4:	77 9b       	sbis	0x0e, 7	; 14
    10b6:	fe cf       	rjmp	.-4      	; 0x10b4 <int2lcd+0xa>
  SPDR = byte;                        //send payload
    10b8:	9d e2       	ldi	r25, 0x2D	; 45
    10ba:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    10bc:	77 9b       	sbis	0x0e, 7	; 14
    10be:	fe cf       	rjmp	.-4      	; 0x10bc <int2lcd+0x12>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    10c0:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10c4:	98 60       	ori	r25, 0x08	; 8
    10c6:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10ca:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10ce:	97 7f       	andi	r25, 0xF7	; 247
    10d0:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10d4:	95 ed       	ldi	r25, 0xD5	; 213
    10d6:	9a 95       	dec	r25
    10d8:	f1 f7       	brne	.-4      	; 0x10d6 <int2lcd+0x2c>
    10da:	00 00       	nop
//Takes a 8bit signed and displays it in base ten on the LCD. Leading 0's are 
//not displayed.
//
void int2lcd(int8_t number){
    //if < 0, print minus sign, then take 2's complement of number and display
    if(number < 0){send_lcd(CHAR_BYTE, '-'); _delay_us(40); uint2lcd(~number+1);}  
    10dc:	81 95       	neg	r24
    10de:	0c 94 eb 07 	jmp	0xfd6	; 0xfd6 <uint2lcd>

000010e2 <cursor_on>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    10e2:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    10e4:	77 9b       	sbis	0x0e, 7	; 14
    10e6:	fe cf       	rjmp	.-4      	; 0x10e4 <cursor_on+0x2>
  SPDR = byte;                        //send payload
    10e8:	8e e0       	ldi	r24, 0x0E	; 14
    10ea:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    10ec:	77 9b       	sbis	0x0e, 7	; 14
    10ee:	fe cf       	rjmp	.-4      	; 0x10ec <cursor_on+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    10f0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10f4:	88 60       	ori	r24, 0x08	; 8
    10f6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10fa:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    10fe:	87 7f       	andi	r24, 0xF7	; 247
    1100:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1104:	08 95       	ret

00001106 <cursor_off>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1106:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1108:	77 9b       	sbis	0x0e, 7	; 14
    110a:	fe cf       	rjmp	.-4      	; 0x1108 <cursor_off+0x2>
  SPDR = byte;                        //send payload
    110c:	8c e0       	ldi	r24, 0x0C	; 12
    110e:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1110:	77 9b       	sbis	0x0e, 7	; 14
    1112:	fe cf       	rjmp	.-4      	; 0x1110 <cursor_off+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    1114:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1118:	88 60       	ori	r24, 0x08	; 8
    111a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    111e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1122:	87 7f       	andi	r24, 0xF7	; 247
    1124:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1128:	08 95       	ret

0000112a <shift_right>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    112a:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    112c:	77 9b       	sbis	0x0e, 7	; 14
    112e:	fe cf       	rjmp	.-4      	; 0x112c <shift_right+0x2>
  SPDR = byte;                        //send payload
    1130:	8e e1       	ldi	r24, 0x1E	; 30
    1132:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1134:	77 9b       	sbis	0x0e, 7	; 14
    1136:	fe cf       	rjmp	.-4      	; 0x1134 <shift_right+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    1138:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    113c:	88 60       	ori	r24, 0x08	; 8
    113e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1142:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1146:	87 7f       	andi	r24, 0xF7	; 247
    1148:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    114c:	08 95       	ret

0000114e <shift_left>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    114e:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1150:	77 9b       	sbis	0x0e, 7	; 14
    1152:	fe cf       	rjmp	.-4      	; 0x1150 <shift_left+0x2>
  SPDR = byte;                        //send payload
    1154:	88 e1       	ldi	r24, 0x18	; 24
    1156:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1158:	77 9b       	sbis	0x0e, 7	; 14
    115a:	fe cf       	rjmp	.-4      	; 0x1158 <shift_left+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    115c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1160:	88 60       	ori	r24, 0x08	; 8
    1162:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1166:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    116a:	87 7f       	andi	r24, 0xF7	; 247
    116c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1170:	08 95       	ret

00001172 <strobe_lcd>:
    1172:	e2 e6       	ldi	r30, 0x62	; 98
    1174:	f0 e0       	ldi	r31, 0x00	; 0
    1176:	80 81       	ld	r24, Z
    1178:	88 60       	ori	r24, 0x08	; 8
    117a:	80 83       	st	Z, r24
    117c:	80 81       	ld	r24, Z
    117e:	87 7f       	andi	r24, 0xF7	; 247
    1180:	80 83       	st	Z, r24
    1182:	08 95       	ret

00001184 <clear_display>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1184:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1186:	77 9b       	sbis	0x0e, 7	; 14
    1188:	fe cf       	rjmp	.-4      	; 0x1186 <clear_display+0x2>
  SPDR = byte;                        //send payload
    118a:	81 e0       	ldi	r24, 0x01	; 1
    118c:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    118e:	77 9b       	sbis	0x0e, 7	; 14
    1190:	fe cf       	rjmp	.-4      	; 0x118e <clear_display+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    1192:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1196:	88 60       	ori	r24, 0x08	; 8
    1198:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    119c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    11a0:	87 7f       	andi	r24, 0xF7	; 247
    11a2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    11a6:	8f e1       	ldi	r24, 0x1F	; 31
    11a8:	9c e1       	ldi	r25, 0x1C	; 28
    11aa:	01 97       	sbiw	r24, 0x01	; 1
    11ac:	f1 f7       	brne	.-4      	; 0x11aa <clear_display+0x26>
    11ae:	00 c0       	rjmp	.+0      	; 0x11b0 <clear_display+0x2c>
    11b0:	00 00       	nop
    11b2:	08 95       	ret

000011b4 <cursor_home>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    11b4:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    11b6:	77 9b       	sbis	0x0e, 7	; 14
    11b8:	fe cf       	rjmp	.-4      	; 0x11b6 <cursor_home+0x2>
  SPDR = byte;                        //send payload
    11ba:	82 e0       	ldi	r24, 0x02	; 2
    11bc:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    11be:	77 9b       	sbis	0x0e, 7	; 14
    11c0:	fe cf       	rjmp	.-4      	; 0x11be <cursor_home+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    11c2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    11c6:	88 60       	ori	r24, 0x08	; 8
    11c8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    11cc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    11d0:	87 7f       	andi	r24, 0xF7	; 247
    11d2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    11d6:	8f e6       	ldi	r24, 0x6F	; 111
    11d8:	97 e1       	ldi	r25, 0x17	; 23
    11da:	01 97       	sbiw	r24, 0x01	; 1
    11dc:	f1 f7       	brne	.-4      	; 0x11da <cursor_home+0x26>
    11de:	00 c0       	rjmp	.+0      	; 0x11e0 <cursor_home+0x2c>
    11e0:	00 00       	nop
    11e2:	08 95       	ret

000011e4 <line2_col1>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    11e4:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    11e6:	77 9b       	sbis	0x0e, 7	; 14
    11e8:	fe cf       	rjmp	.-4      	; 0x11e6 <line2_col1+0x2>
  SPDR = byte;                        //send payload
    11ea:	80 ec       	ldi	r24, 0xC0	; 192
    11ec:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    11ee:	77 9b       	sbis	0x0e, 7	; 14
    11f0:	fe cf       	rjmp	.-4      	; 0x11ee <line2_col1+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    11f2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    11f6:	88 60       	ori	r24, 0x08	; 8
    11f8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    11fc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1200:	87 7f       	andi	r24, 0xF7	; 247
    1202:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1206:	85 ed       	ldi	r24, 0xD5	; 213
    1208:	8a 95       	dec	r24
    120a:	f1 f7       	brne	.-4      	; 0x1208 <line2_col1+0x24>
    120c:	00 00       	nop
    120e:	08 95       	ret

00001210 <line1_col1>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1210:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1212:	77 9b       	sbis	0x0e, 7	; 14
    1214:	fe cf       	rjmp	.-4      	; 0x1212 <line1_col1+0x2>
  SPDR = byte;                        //send payload
    1216:	80 e8       	ldi	r24, 0x80	; 128
    1218:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    121a:	77 9b       	sbis	0x0e, 7	; 14
    121c:	fe cf       	rjmp	.-4      	; 0x121a <line1_col1+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    121e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1222:	88 60       	ori	r24, 0x08	; 8
    1224:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1228:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    122c:	87 7f       	andi	r24, 0xF7	; 247
    122e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1232:	85 ed       	ldi	r24, 0xD5	; 213
    1234:	8a 95       	dec	r24
    1236:	f1 f7       	brne	.-4      	; 0x1234 <line1_col1+0x24>
    1238:	00 00       	nop
    123a:	08 95       	ret

0000123c <fill_spaces>:

//-----------------------------------------------------------------------------
//                          fill_spaces   
//
//Fill an entire line with spaces.
void fill_spaces(void){
    123c:	90 e1       	ldi	r25, 0x10	; 16
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    123e:	31 e0       	ldi	r19, 0x01	; 1
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
  SPDR = byte;                        //send payload
    1240:	20 e2       	ldi	r18, 0x20	; 32
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1242:	3f b9       	out	0x0f, r19	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1244:	77 9b       	sbis	0x0e, 7	; 14
    1246:	fe cf       	rjmp	.-4      	; 0x1244 <fill_spaces+0x8>
  SPDR = byte;                        //send payload
    1248:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    124a:	77 9b       	sbis	0x0e, 7	; 14
    124c:	fe cf       	rjmp	.-4      	; 0x124a <fill_spaces+0xe>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    124e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1252:	88 60       	ori	r24, 0x08	; 8
    1254:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1258:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    125c:	87 7f       	andi	r24, 0xF7	; 247
    125e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1262:	85 ed       	ldi	r24, 0xD5	; 213
    1264:	8a 95       	dec	r24
    1266:	f1 f7       	brne	.-4      	; 0x1264 <fill_spaces+0x28>
    1268:	00 00       	nop
    126a:	91 50       	subi	r25, 0x01	; 1
//                          fill_spaces   
//
//Fill an entire line with spaces.
void fill_spaces(void){
	uint8_t i;
	for (i=0; i<=(NUM_LCD_CHARS-1); i++){
    126c:	51 f7       	brne	.-44     	; 0x1242 <fill_spaces+0x6>
		send_lcd(CHAR_BYTE, ' '); 
                _delay_us(40);  //40us wait between characters
	}
}  
    126e:	08 95       	ret

00001270 <char2lcd>:
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1270:	91 e0       	ldi	r25, 0x01	; 1
    1272:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1274:	77 9b       	sbis	0x0e, 7	; 14
    1276:	fe cf       	rjmp	.-4      	; 0x1274 <char2lcd+0x4>
  SPDR = byte;                        //send payload
    1278:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    127a:	77 9b       	sbis	0x0e, 7	; 14
    127c:	fe cf       	rjmp	.-4      	; 0x127a <char2lcd+0xa>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    127e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1282:	88 60       	ori	r24, 0x08	; 8
    1284:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1288:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    128c:	87 7f       	andi	r24, 0xF7	; 247
    128e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1292:	08 95       	ret

00001294 <string2lcd>:

//----------------------------------------------------------------------------
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
    1294:	fc 01       	movw	r30, r24
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
    1296:	40 e0       	ldi	r20, 0x00	; 0
    1298:	50 e0       	ldi	r21, 0x00	; 0
    129a:	60 e0       	ldi	r22, 0x00	; 0
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    129c:	71 e0       	ldi	r23, 0x01	; 1
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
    129e:	df 01       	movw	r26, r30
    12a0:	a4 0f       	add	r26, r20
    12a2:	b5 1f       	adc	r27, r21
    12a4:	8c 91       	ld	r24, X
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    12a6:	7f b9       	out	0x0f, r23	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    12a8:	77 9b       	sbis	0x0e, 7	; 14
    12aa:	fe cf       	rjmp	.-4      	; 0x12a8 <string2lcd+0x14>
  SPDR = byte;                        //send payload
    12ac:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    12ae:	77 9b       	sbis	0x0e, 7	; 14
    12b0:	fe cf       	rjmp	.-4      	; 0x12ae <string2lcd+0x1a>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    12b2:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    12b6:	98 60       	ori	r25, 0x08	; 8
    12b8:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    12bc:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    12c0:	97 7f       	andi	r25, 0xF7	; 247
    12c2:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    12c6:	85 ed       	ldi	r24, 0xD5	; 213
    12c8:	8a 95       	dec	r24
    12ca:	f1 f7       	brne	.-4      	; 0x12c8 <string2lcd+0x34>
    12cc:	00 00       	nop
//                            string2lcd
//                            
//Send a ascii string to the LCD.
void string2lcd(char *lcd_str){ 
  uint8_t i;
  for (i=0; i<=(strlen(lcd_str)-1); i++){send_lcd(CHAR_BYTE, lcd_str[i]);
    12ce:	6f 5f       	subi	r22, 0xFF	; 255
    12d0:	46 2f       	mov	r20, r22
    12d2:	50 e0       	ldi	r21, 0x00	; 0
    12d4:	df 01       	movw	r26, r30
    12d6:	0d 90       	ld	r0, X+
    12d8:	00 20       	and	r0, r0
    12da:	e9 f7       	brne	.-6      	; 0x12d6 <string2lcd+0x42>
    12dc:	9d 01       	movw	r18, r26
    12de:	2e 1b       	sub	r18, r30
    12e0:	3f 0b       	sbc	r19, r31
    12e2:	22 50       	subi	r18, 0x02	; 2
    12e4:	31 09       	sbc	r19, r1
    12e6:	24 17       	cp	r18, r20
    12e8:	35 07       	cpc	r19, r21
    12ea:	c8 f6       	brcc	.-78     	; 0x129e <string2lcd+0xa>
  _delay_us(40);  //execution takes 37us per character
  }                  
} 
    12ec:	08 95       	ret

000012ee <lcd_init>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    12ee:	8f ef       	ldi	r24, 0xFF	; 255
    12f0:	99 ef       	ldi	r25, 0xF9	; 249
    12f2:	01 97       	sbiw	r24, 0x01	; 1
    12f4:	f1 f7       	brne	.-4      	; 0x12f2 <lcd_init+0x4>
    12f6:	00 c0       	rjmp	.+0      	; 0x12f8 <lcd_init+0xa>
    12f8:	00 00       	nop
//
void lcd_init(void){
  _delay_ms(16);      //power up delay
#if SPI_MODE==1       //assumption is that the SPI port is intialized
  //TODO: kludge alert! setting of DDRF should not be here, but is probably harmless.
  DDRF=0x08;          //port F bit 3 is enable for LCD in SPI mode
    12fa:	88 e0       	ldi	r24, 0x08	; 8
    12fc:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1300:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1302:	77 9b       	sbis	0x0e, 7	; 14
    1304:	fe cf       	rjmp	.-4      	; 0x1302 <lcd_init+0x14>
  SPDR = byte;                        //send payload
    1306:	80 e3       	ldi	r24, 0x30	; 48
    1308:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    130a:	77 9b       	sbis	0x0e, 7	; 14
    130c:	fe cf       	rjmp	.-4      	; 0x130a <lcd_init+0x1c>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    130e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1312:	88 60       	ori	r24, 0x08	; 8
    1314:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1318:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    131c:	87 7f       	andi	r24, 0xF7	; 247
    131e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1322:	8f e5       	ldi	r24, 0x5F	; 95
    1324:	9d e6       	ldi	r25, 0x6D	; 109
    1326:	01 97       	sbiw	r24, 0x01	; 1
    1328:	f1 f7       	brne	.-4      	; 0x1326 <lcd_init+0x38>
    132a:	00 c0       	rjmp	.+0      	; 0x132c <lcd_init+0x3e>
    132c:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    132e:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1330:	77 9b       	sbis	0x0e, 7	; 14
    1332:	fe cf       	rjmp	.-4      	; 0x1330 <lcd_init+0x42>
  SPDR = byte;                        //send payload
    1334:	80 e3       	ldi	r24, 0x30	; 48
    1336:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1338:	77 9b       	sbis	0x0e, 7	; 14
    133a:	fe cf       	rjmp	.-4      	; 0x1338 <lcd_init+0x4a>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    133c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1340:	88 60       	ori	r24, 0x08	; 8
    1342:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1346:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    134a:	87 7f       	andi	r24, 0xF7	; 247
    134c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1350:	8f e5       	ldi	r24, 0x5F	; 95
    1352:	9d e6       	ldi	r25, 0x6D	; 109
    1354:	01 97       	sbiw	r24, 0x01	; 1
    1356:	f1 f7       	brne	.-4      	; 0x1354 <lcd_init+0x66>
    1358:	00 c0       	rjmp	.+0      	; 0x135a <lcd_init+0x6c>
    135a:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    135c:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    135e:	77 9b       	sbis	0x0e, 7	; 14
    1360:	fe cf       	rjmp	.-4      	; 0x135e <lcd_init+0x70>
  SPDR = byte;                        //send payload
    1362:	80 e3       	ldi	r24, 0x30	; 48
    1364:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1366:	77 9b       	sbis	0x0e, 7	; 14
    1368:	fe cf       	rjmp	.-4      	; 0x1366 <lcd_init+0x78>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    136a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    136e:	88 60       	ori	r24, 0x08	; 8
    1370:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1374:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1378:	87 7f       	andi	r24, 0xF7	; 247
    137a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    137e:	8f e5       	ldi	r24, 0x5F	; 95
    1380:	9d e6       	ldi	r25, 0x6D	; 109
    1382:	01 97       	sbiw	r24, 0x01	; 1
    1384:	f1 f7       	brne	.-4      	; 0x1382 <lcd_init+0x94>
    1386:	00 c0       	rjmp	.+0      	; 0x1388 <lcd_init+0x9a>
    1388:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    138a:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    138c:	77 9b       	sbis	0x0e, 7	; 14
    138e:	fe cf       	rjmp	.-4      	; 0x138c <lcd_init+0x9e>
  SPDR = byte;                        //send payload
    1390:	88 e3       	ldi	r24, 0x38	; 56
    1392:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1394:	77 9b       	sbis	0x0e, 7	; 14
    1396:	fe cf       	rjmp	.-4      	; 0x1394 <lcd_init+0xa6>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    1398:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    139c:	88 60       	ori	r24, 0x08	; 8
    139e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    13a2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    13a6:	87 7f       	andi	r24, 0xF7	; 247
    13a8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    13ac:	8f e1       	ldi	r24, 0x1F	; 31
    13ae:	9e e4       	ldi	r25, 0x4E	; 78
    13b0:	01 97       	sbiw	r24, 0x01	; 1
    13b2:	f1 f7       	brne	.-4      	; 0x13b0 <lcd_init+0xc2>
    13b4:	00 c0       	rjmp	.+0      	; 0x13b6 <lcd_init+0xc8>
    13b6:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    13b8:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    13ba:	77 9b       	sbis	0x0e, 7	; 14
    13bc:	fe cf       	rjmp	.-4      	; 0x13ba <lcd_init+0xcc>
  SPDR = byte;                        //send payload
    13be:	88 e0       	ldi	r24, 0x08	; 8
    13c0:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    13c2:	77 9b       	sbis	0x0e, 7	; 14
    13c4:	fe cf       	rjmp	.-4      	; 0x13c2 <lcd_init+0xd4>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    13c6:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    13ca:	88 60       	ori	r24, 0x08	; 8
    13cc:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    13d0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    13d4:	87 7f       	andi	r24, 0xF7	; 247
    13d6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    13da:	8f e1       	ldi	r24, 0x1F	; 31
    13dc:	9e e4       	ldi	r25, 0x4E	; 78
    13de:	01 97       	sbiw	r24, 0x01	; 1
    13e0:	f1 f7       	brne	.-4      	; 0x13de <lcd_init+0xf0>
    13e2:	00 c0       	rjmp	.+0      	; 0x13e4 <lcd_init+0xf6>
    13e4:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    13e6:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    13e8:	77 9b       	sbis	0x0e, 7	; 14
    13ea:	fe cf       	rjmp	.-4      	; 0x13e8 <lcd_init+0xfa>
  SPDR = byte;                        //send payload
    13ec:	81 e0       	ldi	r24, 0x01	; 1
    13ee:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    13f0:	77 9b       	sbis	0x0e, 7	; 14
    13f2:	fe cf       	rjmp	.-4      	; 0x13f0 <lcd_init+0x102>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    13f4:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    13f8:	88 60       	ori	r24, 0x08	; 8
    13fa:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    13fe:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1402:	87 7f       	andi	r24, 0xF7	; 247
    1404:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1408:	8f e1       	ldi	r24, 0x1F	; 31
    140a:	9e e4       	ldi	r25, 0x4E	; 78
    140c:	01 97       	sbiw	r24, 0x01	; 1
    140e:	f1 f7       	brne	.-4      	; 0x140c <lcd_init+0x11e>
    1410:	00 c0       	rjmp	.+0      	; 0x1412 <lcd_init+0x124>
    1412:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1414:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1416:	77 9b       	sbis	0x0e, 7	; 14
    1418:	fe cf       	rjmp	.-4      	; 0x1416 <lcd_init+0x128>
  SPDR = byte;                        //send payload
    141a:	86 e0       	ldi	r24, 0x06	; 6
    141c:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    141e:	77 9b       	sbis	0x0e, 7	; 14
    1420:	fe cf       	rjmp	.-4      	; 0x141e <lcd_init+0x130>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    1422:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1426:	88 60       	ori	r24, 0x08	; 8
    1428:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    142c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1430:	87 7f       	andi	r24, 0xF7	; 247
    1432:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1436:	8f e1       	ldi	r24, 0x1F	; 31
    1438:	9e e4       	ldi	r25, 0x4E	; 78
    143a:	01 97       	sbiw	r24, 0x01	; 1
    143c:	f1 f7       	brne	.-4      	; 0x143a <lcd_init+0x14c>
    143e:	00 c0       	rjmp	.+0      	; 0x1440 <lcd_init+0x152>
    1440:	00 00       	nop
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1442:	1f b8       	out	0x0f, r1	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1444:	77 9b       	sbis	0x0e, 7	; 14
    1446:	fe cf       	rjmp	.-4      	; 0x1444 <lcd_init+0x156>
  SPDR = byte;                        //send payload
    1448:	8c e0       	ldi	r24, 0x0C	; 12
    144a:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    144c:	77 9b       	sbis	0x0e, 7	; 14
    144e:	fe cf       	rjmp	.-4      	; 0x144c <lcd_init+0x15e>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    1450:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1454:	88 60       	ori	r24, 0x08	; 8
    1456:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    145a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    145e:	87 7f       	andi	r24, 0xF7	; 247
    1460:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1464:	8f e1       	ldi	r24, 0x1F	; 31
    1466:	9e e4       	ldi	r25, 0x4E	; 78
    1468:	01 97       	sbiw	r24, 0x01	; 1
    146a:	f1 f7       	brne	.-4      	; 0x1468 <lcd_init+0x17a>
    146c:	00 c0       	rjmp	.+0      	; 0x146e <lcd_init+0x180>
    146e:	00 00       	nop
    1470:	08 95       	ret

00001472 <lcd_int32>:
void  lcd_int32(int32_t l,          //number to display
                uint8_t fieldwidth, //width of the field for display
                uint8_t decpos,     //0 if no decimal point, otherwise
                uint8_t bSigned,    //non-zero if the number should be treated as signed 
                uint8_t bZeroFill)  //non-zero if a specified fieldwidth is to be zero filled
{
    1472:	4f 92       	push	r4
    1474:	5f 92       	push	r5
    1476:	6f 92       	push	r6
    1478:	7f 92       	push	r7
    147a:	8f 92       	push	r8
    147c:	9f 92       	push	r9
    147e:	af 92       	push	r10
    1480:	bf 92       	push	r11
    1482:	cf 92       	push	r12
    1484:	df 92       	push	r13
    1486:	ef 92       	push	r14
    1488:	ff 92       	push	r15
    148a:	0f 93       	push	r16
    148c:	1f 93       	push	r17
    148e:	cf 93       	push	r28
    1490:	df 93       	push	r29
    1492:	cd b7       	in	r28, 0x3d	; 61
    1494:	de b7       	in	r29, 0x3e	; 62
    1496:	69 97       	sbiw	r28, 0x19	; 25
    1498:	0f b6       	in	r0, 0x3f	; 63
    149a:	f8 94       	cli
    149c:	de bf       	out	0x3e, r29	; 62
    149e:	0f be       	out	0x3f, r0	; 63
    14a0:	cd bf       	out	0x3d, r28	; 61
    14a2:	14 2f       	mov	r17, r20
    14a4:	42 2e       	mov	r4, r18
    14a6:	5e 2c       	mov	r5, r14
      char    fillch;
      ldiv_t  qr;

      qr.quot = l; // initialize the quotient 

      if (bSigned){
    14a8:	00 23       	and	r16, r16
    14aa:	79 f0       	breq	.+30     	; 0x14ca <lcd_int32+0x58>
        bSigned = (qr.quot<0);
    14ac:	6b 01       	movw	r12, r22
    14ae:	7c 01       	movw	r14, r24
    14b0:	cc 24       	eor	r12, r12
    14b2:	f7 fc       	sbrc	r15, 7
    14b4:	c3 94       	inc	r12
    14b6:	dd 24       	eor	r13, r13
    14b8:	ee 24       	eor	r14, r14
    14ba:	ff 24       	eor	r15, r15
    14bc:	0c 2d       	mov	r16, r12
        qr.quot = labs(qr.quot);
    14be:	6b 01       	movw	r12, r22
    14c0:	7c 01       	movw	r14, r24
    14c2:	97 fd       	sbrc	r25, 7
    14c4:	a3 c0       	rjmp	.+326    	; 0x160c <lcd_int32+0x19a>
    14c6:	c7 01       	movw	r24, r14
    14c8:	b6 01       	movw	r22, r12
      }

      // convert the digits to the right of the decimal point 
      if (decpos){
    14ca:	44 20       	and	r4, r4
    14cc:	09 f4       	brne	.+2      	; 0x14d0 <lcd_int32+0x5e>
    14ce:	96 c0       	rjmp	.+300    	; 0x15fc <lcd_int32+0x18a>
    14d0:	9e 01       	movw	r18, r28
    14d2:	2f 5f       	subi	r18, 0xFF	; 255
    14d4:	3f 4f       	sbci	r19, 0xFF	; 255
    14d6:	59 01       	movw	r10, r18
    14d8:	49 01       	movw	r8, r18
    14da:	66 24       	eor	r6, r6
    14dc:	6a 94       	dec	r6
    14de:	64 0c       	add	r6, r4
    14e0:	71 2c       	mov	r7, r1
    14e2:	3f ef       	ldi	r19, 0xFF	; 255
    14e4:	63 1a       	sub	r6, r19
    14e6:	73 0a       	sbc	r7, r19
    14e8:	6a 0c       	add	r6, r10
    14ea:	7b 1c       	adc	r7, r11
        for (; decpos ; decpos--){
          qr = ldiv(qr.quot, 10);
    14ec:	2a e0       	ldi	r18, 0x0A	; 10
    14ee:	30 e0       	ldi	r19, 0x00	; 0
    14f0:	40 e0       	ldi	r20, 0x00	; 0
    14f2:	50 e0       	ldi	r21, 0x00	; 0
    14f4:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <__divmodsi4>
    14f8:	e6 2f       	mov	r30, r22
    14fa:	2a 8b       	std	Y+18, r18	; 0x12
    14fc:	3b 8b       	std	Y+19, r19	; 0x13
    14fe:	4c 8b       	std	Y+20, r20	; 0x14
    1500:	5d 8b       	std	Y+21, r21	; 0x15
    1502:	6a 89       	ldd	r22, Y+18	; 0x12
    1504:	7b 89       	ldd	r23, Y+19	; 0x13
    1506:	8c 89       	ldd	r24, Y+20	; 0x14
    1508:	9d 89       	ldd	r25, Y+21	; 0x15
          sline[i++] = qr.rem + '0';
    150a:	20 e3       	ldi	r18, 0x30	; 48
    150c:	2e 0f       	add	r18, r30
    150e:	f4 01       	movw	r30, r8
    1510:	21 93       	st	Z+, r18
    1512:	4f 01       	movw	r8, r30
        qr.quot = labs(qr.quot);
      }

      // convert the digits to the right of the decimal point 
      if (decpos){
        for (; decpos ; decpos--){
    1514:	6e 16       	cp	r6, r30
    1516:	7f 06       	cpc	r7, r31
    1518:	49 f7       	brne	.-46     	; 0x14ec <lcd_int32+0x7a>
          qr = ldiv(qr.quot, 10);
          sline[i++] = qr.rem + '0';
        }
        sline[i++] = '.';
    151a:	99 24       	eor	r9, r9
    151c:	93 94       	inc	r9
    151e:	94 0c       	add	r9, r4
    1520:	f5 01       	movw	r30, r10
    1522:	e4 0d       	add	r30, r4
    1524:	f1 1d       	adc	r31, r1
    1526:	2e e2       	ldi	r18, 0x2E	; 46
    1528:	20 83       	st	Z, r18
      }

      // convert the digits to the left of the decimal point 
      do{
          qr = ldiv(qr.quot, 10);
    152a:	2a e0       	ldi	r18, 0x0A	; 10
    152c:	30 e0       	ldi	r19, 0x00	; 0
    152e:	40 e0       	ldi	r20, 0x00	; 0
    1530:	50 e0       	ldi	r21, 0x00	; 0
    1532:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <__divmodsi4>
    1536:	e6 2f       	mov	r30, r22
    1538:	2a 8b       	std	Y+18, r18	; 0x12
    153a:	3b 8b       	std	Y+19, r19	; 0x13
    153c:	4c 8b       	std	Y+20, r20	; 0x14
    153e:	5d 8b       	std	Y+21, r21	; 0x15
    1540:	6e 8b       	std	Y+22, r22	; 0x16
    1542:	7f 8b       	std	Y+23, r23	; 0x17
    1544:	88 8f       	std	Y+24, r24	; 0x18
    1546:	99 8f       	std	Y+25, r25	; 0x19
    1548:	6a 89       	ldd	r22, Y+18	; 0x12
    154a:	7b 89       	ldd	r23, Y+19	; 0x13
    154c:	8c 89       	ldd	r24, Y+20	; 0x14
    154e:	9d 89       	ldd	r25, Y+21	; 0x15
          sline[i++] = qr.rem + '0';
    1550:	31 e0       	ldi	r19, 0x01	; 1
    1552:	39 0d       	add	r19, r9
    1554:	d5 01       	movw	r26, r10
    1556:	a9 0d       	add	r26, r9
    1558:	b1 1d       	adc	r27, r1
    155a:	e0 5d       	subi	r30, 0xD0	; 208
    155c:	ec 93       	st	X, r30
    155e:	93 2e       	mov	r9, r19
        }while(qr.quot);
    1560:	61 15       	cp	r22, r1
    1562:	71 05       	cpc	r23, r1
    1564:	81 05       	cpc	r24, r1
    1566:	91 05       	cpc	r25, r1
    1568:	01 f7       	brne	.-64     	; 0x152a <lcd_int32+0xb8>

      // fill the whole field if a width was specified
      if (fieldwidth){
    156a:	11 23       	and	r17, r17
    156c:	61 f0       	breq	.+24     	; 0x1586 <lcd_int32+0x114>
        fillch = bZeroFill? '0': ' '; // determine the fill character
    156e:	51 10       	cpse	r5, r1
    1570:	4b c0       	rjmp	.+150    	; 0x1608 <lcd_int32+0x196>
    1572:	90 e2       	ldi	r25, 0x20	; 32
        for (; i<fieldwidth ; ){sline[i++] = fillch;}
    1574:	31 17       	cp	r19, r17
    1576:	38 f4       	brcc	.+14     	; 0x1586 <lcd_int32+0x114>
    1578:	f5 01       	movw	r30, r10
    157a:	e3 0f       	add	r30, r19
    157c:	f1 1d       	adc	r31, r1
    157e:	90 83       	st	Z, r25
    1580:	3f 5f       	subi	r19, 0xFF	; 255
    1582:	13 13       	cpse	r17, r19
    1584:	f9 cf       	rjmp	.-14     	; 0x1578 <lcd_int32+0x106>
      }

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}
    1586:	00 23       	and	r16, r16
    1588:	31 f0       	breq	.+12     	; 0x1596 <lcd_int32+0x124>
    158a:	f5 01       	movw	r30, r10
    158c:	e3 0f       	add	r30, r19
    158e:	f1 1d       	adc	r31, r1
    1590:	9d e2       	ldi	r25, 0x2D	; 45
    1592:	90 83       	st	Z, r25
    1594:	3f 5f       	subi	r19, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    1596:	21 e0       	ldi	r18, 0x01	; 1

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}

      // now output the formatted number
      do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    1598:	31 50       	subi	r19, 0x01	; 1
    159a:	f5 01       	movw	r30, r10
    159c:	e3 0f       	add	r30, r19
    159e:	f1 1d       	adc	r31, r1
    15a0:	90 81       	ld	r25, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    15a2:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    15a4:	77 9b       	sbis	0x0e, 7	; 14
    15a6:	fe cf       	rjmp	.-4      	; 0x15a4 <lcd_int32+0x132>
  SPDR = byte;                        //send payload
    15a8:	9f b9       	out	0x0f, r25	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    15aa:	77 9b       	sbis	0x0e, 7	; 14
    15ac:	fe cf       	rjmp	.-4      	; 0x15aa <lcd_int32+0x138>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    15ae:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    15b2:	98 60       	ori	r25, 0x08	; 8
    15b4:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    15b8:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    15bc:	97 7f       	andi	r25, 0xF7	; 247
    15be:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    15c2:	85 ed       	ldi	r24, 0xD5	; 213
    15c4:	8a 95       	dec	r24
    15c6:	f1 f7       	brne	.-4      	; 0x15c4 <lcd_int32+0x152>
    15c8:	00 00       	nop

      // output the sign, if we need to
      if (bSigned){sline[i++] = '-';}

      // now output the formatted number
      do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    15ca:	31 11       	cpse	r19, r1
    15cc:	e5 cf       	rjmp	.-54     	; 0x1598 <lcd_int32+0x126>

}
    15ce:	69 96       	adiw	r28, 0x19	; 25
    15d0:	0f b6       	in	r0, 0x3f	; 63
    15d2:	f8 94       	cli
    15d4:	de bf       	out	0x3e, r29	; 62
    15d6:	0f be       	out	0x3f, r0	; 63
    15d8:	cd bf       	out	0x3d, r28	; 61
    15da:	df 91       	pop	r29
    15dc:	cf 91       	pop	r28
    15de:	1f 91       	pop	r17
    15e0:	0f 91       	pop	r16
    15e2:	ff 90       	pop	r15
    15e4:	ef 90       	pop	r14
    15e6:	df 90       	pop	r13
    15e8:	cf 90       	pop	r12
    15ea:	bf 90       	pop	r11
    15ec:	af 90       	pop	r10
    15ee:	9f 90       	pop	r9
    15f0:	8f 90       	pop	r8
    15f2:	7f 90       	pop	r7
    15f4:	6f 90       	pop	r6
    15f6:	5f 90       	pop	r5
    15f8:	4f 90       	pop	r4
    15fa:	08 95       	ret
                uint8_t decpos,     //0 if no decimal point, otherwise
                uint8_t bSigned,    //non-zero if the number should be treated as signed 
                uint8_t bZeroFill)  //non-zero if a specified fieldwidth is to be zero filled
{
      char    sline[NUM_LCD_CHARS+1];
      uint8_t i=0;
    15fc:	91 2c       	mov	r9, r1
    15fe:	9e 01       	movw	r18, r28
    1600:	2f 5f       	subi	r18, 0xFF	; 255
    1602:	3f 4f       	sbci	r19, 0xFF	; 255
    1604:	59 01       	movw	r10, r18
    1606:	91 cf       	rjmp	.-222    	; 0x152a <lcd_int32+0xb8>
          sline[i++] = qr.rem + '0';
        }while(qr.quot);

      // fill the whole field if a width was specified
      if (fieldwidth){
        fillch = bZeroFill? '0': ' '; // determine the fill character
    1608:	90 e3       	ldi	r25, 0x30	; 48
    160a:	b4 cf       	rjmp	.-152    	; 0x1574 <lcd_int32+0x102>

      qr.quot = l; // initialize the quotient 

      if (bSigned){
        bSigned = (qr.quot<0);
        qr.quot = labs(qr.quot);
    160c:	f0 94       	com	r15
    160e:	e0 94       	com	r14
    1610:	d0 94       	com	r13
    1612:	c0 94       	com	r12
    1614:	c1 1c       	adc	r12, r1
    1616:	d1 1c       	adc	r13, r1
    1618:	e1 1c       	adc	r14, r1
    161a:	f1 1c       	adc	r15, r1
    161c:	54 cf       	rjmp	.-344    	; 0x14c6 <lcd_int32+0x54>

0000161e <lcd_int16>:
void    lcd_int16(int16_t l, 
                  uint8_t fieldwidth, 
                  uint8_t decpos, 
                  uint8_t bSigned,
                  uint8_t bZeroFill)
{
    161e:	5f 92       	push	r5
    1620:	6f 92       	push	r6
    1622:	7f 92       	push	r7
    1624:	8f 92       	push	r8
    1626:	9f 92       	push	r9
    1628:	af 92       	push	r10
    162a:	bf 92       	push	r11
    162c:	cf 92       	push	r12
    162e:	df 92       	push	r13
    1630:	ef 92       	push	r14
    1632:	ff 92       	push	r15
    1634:	0f 93       	push	r16
    1636:	1f 93       	push	r17
    1638:	cf 93       	push	r28
    163a:	df 93       	push	r29
    163c:	cd b7       	in	r28, 0x3d	; 61
    163e:	de b7       	in	r29, 0x3e	; 62
    1640:	61 97       	sbiw	r28, 0x11	; 17
    1642:	0f b6       	in	r0, 0x3f	; 63
    1644:	f8 94       	cli
    1646:	de bf       	out	0x3e, r29	; 62
    1648:	0f be       	out	0x3f, r0	; 63
    164a:	cd bf       	out	0x3d, r28	; 61
    164c:	5c 01       	movw	r10, r24
    164e:	16 2f       	mov	r17, r22
    1650:	74 2e       	mov	r7, r20
//        uint8_t bSigned;   Now an argument for signed or not

        // initialize the quotient 
        qr.quot = l;

        if ( (bSigned=(qr.quot<0)) )
    1652:	6b 2c       	mov	r6, r11
    1654:	66 1c       	adc	r6, r6
    1656:	66 24       	eor	r6, r6
    1658:	66 1c       	adc	r6, r6
    165a:	56 2c       	mov	r5, r6
    165c:	9c 01       	movw	r18, r24
    165e:	97 fd       	sbrc	r25, 7
    1660:	9b c0       	rjmp	.+310    	; 0x1798 <lcd_int16+0x17a>
                qr.quot = -qr.quot;

        // convert the digits to the right of the decimal point 
        if (decpos){
    1662:	77 20       	and	r7, r7
    1664:	09 f4       	brne	.+2      	; 0x1668 <lcd_int16+0x4a>
    1666:	8d c0       	rjmp	.+282    	; 0x1782 <lcd_int16+0x164>
    1668:	ce 01       	movw	r24, r28
    166a:	01 96       	adiw	r24, 0x01	; 1
    166c:	7c 01       	movw	r14, r24
    166e:	6c 01       	movw	r12, r24
    1670:	88 24       	eor	r8, r8
    1672:	8a 94       	dec	r8
    1674:	87 0c       	add	r8, r7
    1676:	91 2c       	mov	r9, r1
    1678:	9f ef       	ldi	r25, 0xFF	; 255
    167a:	89 1a       	sub	r8, r25
    167c:	99 0a       	sbc	r9, r25
    167e:	8e 0c       	add	r8, r14
    1680:	9f 1c       	adc	r9, r15
          for (; decpos ; decpos--){
            qr = div(qr.quot, 10);
    1682:	6a e0       	ldi	r22, 0x0A	; 10
    1684:	70 e0       	ldi	r23, 0x00	; 0
    1686:	c9 01       	movw	r24, r18
    1688:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <__divmodhi4>
    168c:	46 2f       	mov	r20, r22
    168e:	24 2f       	mov	r18, r20
    1690:	37 2f       	mov	r19, r23
            sline[i++] = qr.rem + '0';
    1692:	80 5d       	subi	r24, 0xD0	; 208
    1694:	f6 01       	movw	r30, r12
    1696:	81 93       	st	Z+, r24
    1698:	6f 01       	movw	r12, r30
        if ( (bSigned=(qr.quot<0)) )
                qr.quot = -qr.quot;

        // convert the digits to the right of the decimal point 
        if (decpos){
          for (; decpos ; decpos--){
    169a:	e8 15       	cp	r30, r8
    169c:	f9 05       	cpc	r31, r9
    169e:	89 f7       	brne	.-30     	; 0x1682 <lcd_int16+0x64>
            qr = div(qr.quot, 10);
            sline[i++] = qr.rem + '0';
          }
          sline[i++] = '.';
    16a0:	dd 24       	eor	r13, r13
    16a2:	d3 94       	inc	r13
    16a4:	d7 0c       	add	r13, r7
    16a6:	f7 01       	movw	r30, r14
    16a8:	e7 0d       	add	r30, r7
    16aa:	f1 1d       	adc	r31, r1
    16ac:	8e e2       	ldi	r24, 0x2E	; 46
    16ae:	80 83       	st	Z, r24
    16b0:	01 c0       	rjmp	.+2      	; 0x16b4 <lcd_int16+0x96>

        // convert the digits to the left of the decimal point 
        do
        {
                qr = div(qr.quot, 10);
                sline[i++] = qr.rem + '0';
    16b2:	d9 2e       	mov	r13, r25
        }

        // convert the digits to the left of the decimal point 
        do
        {
                qr = div(qr.quot, 10);
    16b4:	6a e0       	ldi	r22, 0x0A	; 10
    16b6:	70 e0       	ldi	r23, 0x00	; 0
    16b8:	c9 01       	movw	r24, r18
    16ba:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <__divmodhi4>
    16be:	46 2f       	mov	r20, r22
    16c0:	24 2f       	mov	r18, r20
    16c2:	37 2f       	mov	r19, r23
                sline[i++] = qr.rem + '0';
    16c4:	91 e0       	ldi	r25, 0x01	; 1
    16c6:	9d 0d       	add	r25, r13
    16c8:	f7 01       	movw	r30, r14
    16ca:	ed 0d       	add	r30, r13
    16cc:	f1 1d       	adc	r31, r1
    16ce:	80 5d       	subi	r24, 0xD0	; 208
    16d0:	80 83       	st	Z, r24
        }
        while(qr.quot);
    16d2:	21 15       	cp	r18, r1
    16d4:	31 05       	cpc	r19, r1
    16d6:	69 f7       	brne	.-38     	; 0x16b2 <lcd_int16+0x94>

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
    16d8:	01 11       	cpse	r16, r1
    16da:	58 c0       	rjmp	.+176    	; 0x178c <lcd_int16+0x16e>
    16dc:	b7 fc       	sbrc	r11, 7
    16de:	61 c0       	rjmp	.+194    	; 0x17a2 <lcd_int16+0x184>
                sline[i++] = '-';
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    16e0:	11 23       	and	r17, r17
    16e2:	a9 f0       	breq	.+42     	; 0x170e <lcd_int16+0xf0>
    16e4:	71 2c       	mov	r7, r1
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    16e6:	80 e2       	ldi	r24, 0x20	; 32
          for (; i<(fieldwidth-bSigned) ; ){ sline[i++] = fillch;}
    16e8:	29 2f       	mov	r18, r25
    16ea:	30 e0       	ldi	r19, 0x00	; 0
    16ec:	41 2f       	mov	r20, r17
    16ee:	50 e0       	ldi	r21, 0x00	; 0
    16f0:	46 19       	sub	r20, r6
    16f2:	57 09       	sbc	r21, r7
    16f4:	24 17       	cp	r18, r20
    16f6:	35 07       	cpc	r19, r21
    16f8:	54 f4       	brge	.+20     	; 0x170e <lcd_int16+0xf0>
    16fa:	9f 5f       	subi	r25, 0xFF	; 255
    16fc:	f7 01       	movw	r30, r14
    16fe:	e2 0f       	add	r30, r18
    1700:	f3 1f       	adc	r31, r19
    1702:	80 83       	st	Z, r24
    1704:	29 2f       	mov	r18, r25
    1706:	30 e0       	ldi	r19, 0x00	; 0
    1708:	24 17       	cp	r18, r20
    170a:	35 07       	cpc	r19, r21
    170c:	b4 f3       	brlt	.-20     	; 0x16fa <lcd_int16+0xdc>
        }

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}
    170e:	55 20       	and	r5, r5
    1710:	31 f0       	breq	.+12     	; 0x171e <lcd_int16+0x100>
    1712:	f7 01       	movw	r30, r14
    1714:	e9 0f       	add	r30, r25
    1716:	f1 1d       	adc	r31, r1
    1718:	8d e2       	ldi	r24, 0x2D	; 45
    171a:	80 83       	st	Z, r24
    171c:	9f 5f       	subi	r25, 0xFF	; 255
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    171e:	21 e0       	ldi	r18, 0x01	; 1

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}

        // now output the formatted number 
            do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    1720:	91 50       	subi	r25, 0x01	; 1
    1722:	f7 01       	movw	r30, r14
    1724:	e9 0f       	add	r30, r25
    1726:	f1 1d       	adc	r31, r1
    1728:	80 81       	ld	r24, Z
// Commnads that require more time have delays built in for them.
//
void send_lcd(uint8_t cmd_or_char, uint8_t byte){

#if SPI_MODE==1
  SPDR = (cmd_or_char)? 0x01 : 0x00;  //send the proper value for intent
    172a:	2f b9       	out	0x0f, r18	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    172c:	77 9b       	sbis	0x0e, 7	; 14
    172e:	fe cf       	rjmp	.-4      	; 0x172c <lcd_int16+0x10e>
  SPDR = byte;                        //send payload
    1730:	8f b9       	out	0x0f, r24	; 15
  while (bit_is_clear(SPSR,SPIF)){}   //wait till byte is sent out
    1732:	77 9b       	sbis	0x0e, 7	; 14
    1734:	fe cf       	rjmp	.-4      	; 0x1732 <lcd_int16+0x114>
//pulse width for a 4 Mhz clock.
//TODO: make number of nops executed dependent on F_CPU, not hardcoded
//
void strobe_lcd(void){ 
#if SPI_MODE==1
 PORTF |=  0x08; PORTF &= ~0x08; //toggle port F bit 3, LCD strobe trigger
    1736:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    173a:	88 60       	ori	r24, 0x08	; 8
    173c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1740:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1744:	87 7f       	andi	r24, 0xF7	; 247
    1746:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    174a:	e5 ed       	ldi	r30, 0xD5	; 213
    174c:	ea 95       	dec	r30
    174e:	f1 f7       	brne	.-4      	; 0x174c <lcd_int16+0x12e>
    1750:	00 00       	nop

        // output the sign, if we need to 
        if (bSigned){sline[i++] = '-';}

        // now output the formatted number 
            do{send_lcd(CHAR_BYTE, sline[--i]); _delay_us(40);} while(i);
    1752:	91 11       	cpse	r25, r1
    1754:	e5 cf       	rjmp	.-54     	; 0x1720 <lcd_int16+0x102>
}
    1756:	61 96       	adiw	r28, 0x11	; 17
    1758:	0f b6       	in	r0, 0x3f	; 63
    175a:	f8 94       	cli
    175c:	de bf       	out	0x3e, r29	; 62
    175e:	0f be       	out	0x3f, r0	; 63
    1760:	cd bf       	out	0x3d, r28	; 61
    1762:	df 91       	pop	r29
    1764:	cf 91       	pop	r28
    1766:	1f 91       	pop	r17
    1768:	0f 91       	pop	r16
    176a:	ff 90       	pop	r15
    176c:	ef 90       	pop	r14
    176e:	df 90       	pop	r13
    1770:	cf 90       	pop	r12
    1772:	bf 90       	pop	r11
    1774:	af 90       	pop	r10
    1776:	9f 90       	pop	r9
    1778:	8f 90       	pop	r8
    177a:	7f 90       	pop	r7
    177c:	6f 90       	pop	r6
    177e:	5f 90       	pop	r5
    1780:	08 95       	ret
                  uint8_t decpos, 
                  uint8_t bSigned,
                  uint8_t bZeroFill)
{
        char    sline[NUM_LCD_CHARS+1];
        uint8_t i=0;
    1782:	d1 2c       	mov	r13, r1
    1784:	ce 01       	movw	r24, r28
    1786:	01 96       	adiw	r24, 0x01	; 1
    1788:	7c 01       	movw	r14, r24
    178a:	94 cf       	rjmp	.-216    	; 0x16b4 <lcd_int16+0x96>
                sline[i++] = '-';
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    178c:	11 23       	and	r17, r17
    178e:	09 f4       	brne	.+2      	; 0x1792 <lcd_int16+0x174>
    1790:	be cf       	rjmp	.-132    	; 0x170e <lcd_int16+0xf0>
    1792:	71 2c       	mov	r7, r1
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    1794:	80 e3       	ldi	r24, 0x30	; 48
    1796:	a8 cf       	rjmp	.-176    	; 0x16e8 <lcd_int16+0xca>
    1798:	22 27       	eor	r18, r18
    179a:	33 27       	eor	r19, r19
    179c:	28 1b       	sub	r18, r24
    179e:	39 0b       	sbc	r19, r25
    17a0:	60 cf       	rjmp	.-320    	; 0x1662 <lcd_int16+0x44>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    17a2:	d3 94       	inc	r13
    17a4:	d3 94       	inc	r13
    17a6:	f7 01       	movw	r30, r14
    17a8:	e9 0f       	add	r30, r25
    17aa:	f1 1d       	adc	r31, r1
    17ac:	8d e2       	ldi	r24, 0x2D	; 45
    17ae:	80 83       	st	Z, r24
                bSigned = 0;
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
    17b0:	11 23       	and	r17, r17
    17b2:	59 f0       	breq	.+22     	; 0x17ca <lcd_int16+0x1ac>
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
          for (; i<(fieldwidth-bSigned) ; ){ sline[i++] = fillch;}
    17b4:	2d 2d       	mov	r18, r13
    17b6:	30 e0       	ldi	r19, 0x00	; 0
    17b8:	41 2f       	mov	r20, r17
    17ba:	50 e0       	ldi	r21, 0x00	; 0
    17bc:	24 17       	cp	r18, r20
    17be:	35 07       	cpc	r19, r21
    17c0:	24 f4       	brge	.+8      	; 0x17ca <lcd_int16+0x1ac>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    17c2:	9d 2d       	mov	r25, r13
                bSigned = 0;
    17c4:	51 2c       	mov	r5, r1
        }

        // fill the whole field if a width was specified 
        if (fieldwidth){
          // determine the fill character 
          fillch = bZeroFill? '0': ' ';
    17c6:	80 e2       	ldi	r24, 0x20	; 32
    17c8:	98 cf       	rjmp	.-208    	; 0x16fa <lcd_int16+0xdc>
        while(qr.quot);

        // add the sign now if we don't pad the number with zeros 
        if (!bZeroFill && bSigned)
        {
                sline[i++] = '-';
    17ca:	9d 2d       	mov	r25, r13
    17cc:	a8 cf       	rjmp	.-176    	; 0x171e <lcd_int16+0x100>

000017ce <__vector_33>:

//****************************************************************************
//This is the TWI ISR. Different actions are taken depending upon the value
//of the TWI status register TWSR.
//****************************************************************************/
ISR(TWI_vect){
    17ce:	1f 92       	push	r1
    17d0:	0f 92       	push	r0
    17d2:	0f b6       	in	r0, 0x3f	; 63
    17d4:	0f 92       	push	r0
    17d6:	11 24       	eor	r1, r1
    17d8:	0b b6       	in	r0, 0x3b	; 59
    17da:	0f 92       	push	r0
    17dc:	2f 93       	push	r18
    17de:	3f 93       	push	r19
    17e0:	8f 93       	push	r24
    17e2:	9f 93       	push	r25
    17e4:	af 93       	push	r26
    17e6:	bf 93       	push	r27
    17e8:	ef 93       	push	r30
    17ea:	ff 93       	push	r31
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    17ec:	e0 91 71 00 	lds	r30, 0x0071	; 0x800071 <__TEXT_REGION_LENGTH__+0x7e0071>
    17f0:	8e 2f       	mov	r24, r30
    17f2:	90 e0       	ldi	r25, 0x00	; 0
    17f4:	fc 01       	movw	r30, r24
    17f6:	38 97       	sbiw	r30, 0x08	; 8
    17f8:	e1 35       	cpi	r30, 0x51	; 81
    17fa:	f1 05       	cpc	r31, r1
    17fc:	b0 f0       	brcs	.+44     	; 0x182a <__vector_33+0x5c>
      break;      
    case TW_MT_ARB_LOST:                //Arbitration lost 
      TWCR = TWCR_START;                //initiate RESTART 
      break;
    default:                            //Error occured, save TWSR 
      twi_state = TWSR;         
    17fe:	80 91 71 00 	lds	r24, 0x0071	; 0x800071 <__TEXT_REGION_LENGTH__+0x7e0071>
    1802:	80 93 c1 01 	sts	0x01C1, r24	; 0x8001c1 <twi_state>
      TWCR = TWCR_RST;                  //Reset TWI, disable interupts 
    1806:	84 e0       	ldi	r24, 0x04	; 4
    1808:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
  }//switch
}//TWI_isr
    180c:	ff 91       	pop	r31
    180e:	ef 91       	pop	r30
    1810:	bf 91       	pop	r27
    1812:	af 91       	pop	r26
    1814:	9f 91       	pop	r25
    1816:	8f 91       	pop	r24
    1818:	3f 91       	pop	r19
    181a:	2f 91       	pop	r18
    181c:	0f 90       	pop	r0
    181e:	0b be       	out	0x3b, r0	; 59
    1820:	0f 90       	pop	r0
    1822:	0f be       	out	0x3f, r0	; 63
    1824:	0f 90       	pop	r0
    1826:	1f 90       	pop	r1
    1828:	18 95       	reti
//of the TWI status register TWSR.
//****************************************************************************/
ISR(TWI_vect){
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    182a:	ea 5b       	subi	r30, 0xBA	; 186
    182c:	ff 4f       	sbci	r31, 0xFF	; 255
    182e:	0c 94 d1 0f 	jmp	0x1fa2	; 0x1fa2 <__tablejump2__>
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
      else                               {TWCR = TWCR_RNACK;} //NACK last byte 
      break; 
    case TW_MR_DATA_NACK: //Data byte was rcvd and NACK xmitted
      twi_buf[twi_buf_ptr] = TWDR;      //save last byte to buffer
    1832:	80 91 6b 01 	lds	r24, 0x016B	; 0x80016b <twi_buf_ptr.1780>
    1836:	e0 91 c2 01 	lds	r30, 0x01C2	; 0x8001c2 <twi_buf>
    183a:	f0 91 c3 01 	lds	r31, 0x01C3	; 0x8001c3 <twi_buf+0x1>
    183e:	e8 0f       	add	r30, r24
    1840:	f1 1d       	adc	r31, r1
    1842:	80 91 73 00 	lds	r24, 0x0073	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
    1846:	80 83       	st	Z, r24
      TWCR = TWCR_STOP;                 //initiate a STOP
    1848:	84 e9       	ldi	r24, 0x94	; 148
    184a:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
      break;      
    184e:	de cf       	rjmp	.-68     	; 0x180c <__vector_33+0x3e>
  static uint8_t twi_buf_ptr;  //index into the buffer being used 

  switch (TWSR) {
    case TW_START:          //START has been xmitted, fall thorough
    case TW_REP_START:      //Repeated START was xmitted
      TWDR = twi_bus_addr;  //load up the twi bus address
    1850:	80 91 c4 01 	lds	r24, 0x01C4	; 0x8001c4 <twi_bus_addr>
    1854:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
      twi_buf_ptr = 0;      //initalize buffer pointer 
    1858:	10 92 6b 01 	sts	0x016B, r1	; 0x80016b <twi_buf_ptr.1780>
      TWCR = TWCR_SEND;     //send SLA+RW
    185c:	85 e8       	ldi	r24, 0x85	; 133
    185e:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
      break;
    1862:	d4 cf       	rjmp	.-88     	; 0x180c <__vector_33+0x3e>
    case TW_MT_SLA_ACK:     //SLA+W was xmitted and ACK rcvd, fall through 
    case TW_MT_DATA_ACK:                //Data byte was xmitted and ACK rcvd
      if (twi_buf_ptr < twi_msg_size){  //send data till done
    1864:	80 91 6b 01 	lds	r24, 0x016B	; 0x80016b <twi_buf_ptr.1780>
    1868:	90 91 c5 01 	lds	r25, 0x01C5	; 0x8001c5 <twi_msg_size>
    186c:	89 17       	cp	r24, r25
    186e:	60 f7       	brcc	.-40     	; 0x1848 <__vector_33+0x7a>
        TWDR = twi_buf[twi_buf_ptr++];  //load next and postincrement index
    1870:	e0 91 c2 01 	lds	r30, 0x01C2	; 0x8001c2 <twi_buf>
    1874:	f0 91 c3 01 	lds	r31, 0x01C3	; 0x8001c3 <twi_buf+0x1>
    1878:	91 e0       	ldi	r25, 0x01	; 1
    187a:	98 0f       	add	r25, r24
    187c:	90 93 6b 01 	sts	0x016B, r25	; 0x80016b <twi_buf_ptr.1780>
    1880:	e8 0f       	add	r30, r24
    1882:	f1 1d       	adc	r31, r1
    1884:	80 81       	ld	r24, Z
    1886:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
        TWCR = TWCR_SEND;               //send next byte 
    188a:	85 e8       	ldi	r24, 0x85	; 133
    188c:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
    1890:	bd cf       	rjmp	.-134    	; 0x180c <__vector_33+0x3e>
    case TW_MR_DATA_NACK: //Data byte was rcvd and NACK xmitted
      twi_buf[twi_buf_ptr] = TWDR;      //save last byte to buffer
      TWCR = TWCR_STOP;                 //initiate a STOP
      break;      
    case TW_MT_ARB_LOST:                //Arbitration lost 
      TWCR = TWCR_START;                //initiate RESTART 
    1892:	85 ea       	ldi	r24, 0xA5	; 165
    1894:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
      break;
    1898:	b9 cf       	rjmp	.-142    	; 0x180c <__vector_33+0x3e>
    189a:	20 91 6b 01 	lds	r18, 0x016B	; 0x80016b <twi_buf_ptr.1780>
      else{TWCR = TWCR_STOP;}           //last byte sent, send STOP 
      break;
    case TW_MR_DATA_ACK:                //Data byte has been rcvd, ACK xmitted, fall through
      twi_buf[twi_buf_ptr++] = TWDR;    //fill buffer with rcvd data
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
    189e:	80 91 c5 01 	lds	r24, 0x01C5	; 0x8001c5 <twi_msg_size>
    18a2:	30 e0       	ldi	r19, 0x00	; 0
    18a4:	90 e0       	ldi	r25, 0x00	; 0
    18a6:	01 97       	sbiw	r24, 0x01	; 1
    18a8:	28 17       	cp	r18, r24
    18aa:	39 07       	cpc	r19, r25
    18ac:	dc f4       	brge	.+54     	; 0x18e4 <__vector_33+0x116>
    18ae:	85 ec       	ldi	r24, 0xC5	; 197
    18b0:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
    18b4:	ab cf       	rjmp	.-170    	; 0x180c <__vector_33+0x3e>
        TWCR = TWCR_SEND;               //send next byte 
      }
      else{TWCR = TWCR_STOP;}           //last byte sent, send STOP 
      break;
    case TW_MR_DATA_ACK:                //Data byte has been rcvd, ACK xmitted, fall through
      twi_buf[twi_buf_ptr++] = TWDR;    //fill buffer with rcvd data
    18b6:	e0 91 c2 01 	lds	r30, 0x01C2	; 0x8001c2 <twi_buf>
    18ba:	f0 91 c3 01 	lds	r31, 0x01C3	; 0x8001c3 <twi_buf+0x1>
    18be:	80 91 6b 01 	lds	r24, 0x016B	; 0x80016b <twi_buf_ptr.1780>
    18c2:	21 e0       	ldi	r18, 0x01	; 1
    18c4:	28 0f       	add	r18, r24
    18c6:	20 93 6b 01 	sts	0x016B, r18	; 0x80016b <twi_buf_ptr.1780>
    18ca:	e8 0f       	add	r30, r24
    18cc:	f1 1d       	adc	r31, r1
    18ce:	80 91 73 00 	lds	r24, 0x0073	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
    18d2:	80 83       	st	Z, r24
    case TW_MR_SLA_ACK:                 //SLA+R xmitted and ACK rcvd
      if (twi_buf_ptr < (twi_msg_size-1)){TWCR = TWCR_RACK;}  //ACK each byte
    18d4:	80 91 c5 01 	lds	r24, 0x01C5	; 0x8001c5 <twi_msg_size>
    18d8:	30 e0       	ldi	r19, 0x00	; 0
    18da:	90 e0       	ldi	r25, 0x00	; 0
    18dc:	01 97       	sbiw	r24, 0x01	; 1
    18de:	28 17       	cp	r18, r24
    18e0:	39 07       	cpc	r19, r25
    18e2:	2c f3       	brlt	.-54     	; 0x18ae <__vector_33+0xe0>
      else                               {TWCR = TWCR_RNACK;} //NACK last byte 
    18e4:	85 e8       	ldi	r24, 0x85	; 133
    18e6:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
    18ea:	90 cf       	rjmp	.-224    	; 0x180c <__vector_33+0x3e>

000018ec <twi_busy>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    18ec:	80 91 74 00 	lds	r24, 0x0074	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
}
    18f0:	81 70       	andi	r24, 0x01	; 1
    18f2:	08 95       	ret

000018f4 <twi_start_wr>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    18f4:	90 91 74 00 	lds	r25, 0x0074	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
//Initiates a write transfer. Loads global variables. Sends START. ISR handles
//the rest.
//****************************************************************************
void twi_start_wr(uint8_t twi_addr, uint8_t *twi_data, uint8_t byte_cnt){

  while(twi_busy());                    //wait till TWI rdy for next xfer
    18f8:	90 fd       	sbrc	r25, 0
    18fa:	fc cf       	rjmp	.-8      	; 0x18f4 <twi_start_wr>
  twi_bus_addr = (twi_addr & ~TW_READ); //set twi bus address, mark as write 
    18fc:	8e 7f       	andi	r24, 0xFE	; 254
    18fe:	80 93 c4 01 	sts	0x01C4, r24	; 0x8001c4 <twi_bus_addr>
  twi_buf = twi_data;                   //load pointer to write buffer
    1902:	70 93 c3 01 	sts	0x01C3, r23	; 0x8001c3 <twi_buf+0x1>
    1906:	60 93 c2 01 	sts	0x01C2, r22	; 0x8001c2 <twi_buf>
  twi_msg_size = byte_cnt;              //load size of xfer 
    190a:	40 93 c5 01 	sts	0x01C5, r20	; 0x8001c5 <twi_msg_size>
  TWCR = TWCR_START;                    //initiate START
    190e:	85 ea       	ldi	r24, 0xA5	; 165
    1910:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
    1914:	08 95       	ret

00001916 <twi_start_rd>:
//Call this function to test if the TWI unit is busy transferring data. The TWI
//code uses the the interrupt enable bit (TWIE) to indicate if the TWI unit
//is busy or not.  This protocol must be maintained for correct operation.
//*****************************************************************************
uint8_t twi_busy(void){
  return (bit_is_set(TWCR,TWIE)); //if interrupt is enabled, twi is busy
    1916:	90 91 74 00 	lds	r25, 0x0074	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
//Initiates a read transfer. Loads global variables. Sends START. ISR handles
//the rest.
//****************************************************************************
void twi_start_rd(uint8_t twi_addr, uint8_t *twi_data, uint8_t byte_cnt){

  while(twi_busy());                   //wait till TWI rdy for next xfer
    191a:	90 fd       	sbrc	r25, 0
    191c:	fc cf       	rjmp	.-8      	; 0x1916 <twi_start_rd>
  twi_bus_addr = (twi_addr | TW_READ); //set twi bus address, mark as read  
    191e:	81 60       	ori	r24, 0x01	; 1
    1920:	80 93 c4 01 	sts	0x01C4, r24	; 0x8001c4 <twi_bus_addr>
  twi_buf = twi_data;                  //load pointer to write buffer
    1924:	70 93 c3 01 	sts	0x01C3, r23	; 0x8001c3 <twi_buf+0x1>
    1928:	60 93 c2 01 	sts	0x01C2, r22	; 0x8001c2 <twi_buf>
  twi_msg_size = byte_cnt;             //load size of xfer 
    192c:	40 93 c5 01 	sts	0x01C5, r20	; 0x8001c5 <twi_msg_size>
  TWCR = TWCR_START;                   //initiate START
    1930:	85 ea       	ldi	r24, 0xA5	; 165
    1932:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
    1936:	08 95       	ret

00001938 <init_twi>:
//10K pullups are present on the board
//for alarm clock an additional 4.7K resistor is also there for pullup
//******************************************************************************

void init_twi(){
  TWDR = 0xFF;     //release SDA, default contents
    1938:	8f ef       	ldi	r24, 0xFF	; 255
    193a:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
  TWSR = 0x00;     //prescaler value = 1
    193e:	10 92 71 00 	sts	0x0071, r1	; 0x800071 <__TEXT_REGION_LENGTH__+0x7e0071>
  TWBR = TWI_TWBR; //defined in twi_master.h 
    1942:	8c e0       	ldi	r24, 0x0C	; 12
    1944:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x7e0070>
    1948:	08 95       	ret

0000194a <lm73_temp_convert>:
   else{ //deg C

   }
//Yeah, this is for you to do! ;^)
return 0b11111111;
}//lm73_temp_convert
    194a:	8f ef       	ldi	r24, 0xFF	; 255
    194c:	08 95       	ret

0000194e <uart_putc>:
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    194e:	5d 9b       	sbis	0x0b, 5	; 11
    1950:	fe cf       	rjmp	.-4      	; 0x194e <uart_putc>
    UDR0 = data;    // Send data byte
    1952:	8c b9       	out	0x0c, r24	; 12
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    1954:	5d 9b       	sbis	0x0b, 5	; 11
    1956:	fe cf       	rjmp	.-4      	; 0x1954 <uart_putc+0x6>
}
    1958:	08 95       	ret

0000195a <uart_puts>:

//******************************************************************
//                        uart_puts
// Takes a string and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts(char *str) {
    195a:	fc 01       	movw	r30, r24
    int i = 0;
    while(str[i] != '\0') { // Loop through string, sending each character
    195c:	90 81       	ld	r25, Z
    195e:	99 23       	and	r25, r25
    1960:	49 f0       	breq	.+18     	; 0x1974 <uart_puts+0x1a>
    1962:	31 96       	adiw	r30, 0x01	; 1
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    1964:	5d 9b       	sbis	0x0b, 5	; 11
    1966:	fe cf       	rjmp	.-4      	; 0x1964 <uart_puts+0xa>
    UDR0 = data;    // Send data byte
    1968:	9c b9       	out	0x0c, r25	; 12
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    196a:	5d 9b       	sbis	0x0b, 5	; 11
    196c:	fe cf       	rjmp	.-4      	; 0x196a <uart_puts+0x10>
//                        uart_puts
// Takes a string and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts(char *str) {
    int i = 0;
    while(str[i] != '\0') { // Loop through string, sending each character
    196e:	91 91       	ld	r25, Z+
    1970:	91 11       	cpse	r25, r1
    1972:	f8 cf       	rjmp	.-16     	; 0x1964 <uart_puts+0xa>
    1974:	08 95       	ret

00001976 <uart_puts_p>:
//******************************************************************
//                        uart_puts_p
// Takes a string in flash memory and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts_p(const char *str) {
    while(pgm_read_byte(str) != 0x00) { // Loop through string, sending each character
    1976:	9c 01       	movw	r18, r24
    1978:	fc 01       	movw	r30, r24
    197a:	44 91       	lpm	r20, Z
    197c:	44 23       	and	r20, r20
    197e:	69 f0       	breq	.+26     	; 0x199a <uart_puts_p+0x24>
        uart_putc(pgm_read_byte(str++));
    1980:	01 96       	adiw	r24, 0x01	; 1
    1982:	f9 01       	movw	r30, r18
    1984:	24 91       	lpm	r18, Z
//                        uart_putc
//
// Takes a character and sends it to USART0
//
void uart_putc(char data) {
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    1986:	5d 9b       	sbis	0x0b, 5	; 11
    1988:	fe cf       	rjmp	.-4      	; 0x1986 <uart_puts_p+0x10>
    UDR0 = data;    // Send data byte
    198a:	2c b9       	out	0x0c, r18	; 12
    while (!(UCSR0A&(1<<UDRE0)));    // Wait for previous transmissions
    198c:	5d 9b       	sbis	0x0b, 5	; 11
    198e:	fe cf       	rjmp	.-4      	; 0x198c <uart_puts_p+0x16>
//******************************************************************
//                        uart_puts_p
// Takes a string in flash memory and sends each charater to be sent to USART0
//void uart_puts(unsigned char *str) {
void uart_puts_p(const char *str) {
    while(pgm_read_byte(str) != 0x00) { // Loop through string, sending each character
    1990:	9c 01       	movw	r18, r24
    1992:	fc 01       	movw	r30, r24
    1994:	44 91       	lpm	r20, Z
    1996:	41 11       	cpse	r20, r1
    1998:	f3 cf       	rjmp	.-26     	; 0x1980 <uart_puts_p+0xa>
        uart_putc(pgm_read_byte(str++));
    }
}
    199a:	08 95       	ret

0000199c <uart_init>:
//Jumpers J14 and J16 (mega128.1) or Jumpers J7 and J9 (mega128.2)
//must be in place for the MAX232 chip to get data.

void uart_init(){
//rx and tx enable, receive interrupt enabled, 8 bit characters
  UCSR0B |= (1<<RXEN0) | (1<<TXEN0) | (1<<RXCIE0);
    199c:	8a b1       	in	r24, 0x0a	; 10
    199e:	88 69       	ori	r24, 0x98	; 152
    19a0:	8a b9       	out	0x0a, r24	; 10
//  UCSR0B |= (1<<RXEN0) | (1<<TXEN0);  //INTERRUPS DISABLED!!!

//  UCSR0B |= (1<<RXEN0) | (1<<TXEN0) ;
//async operation, no parity,  one stop bit, 8-bit characters
UCSR0C |= (1<<UCSZ01) | (1<<UCSZ00);
    19a2:	e5 e9       	ldi	r30, 0x95	; 149
    19a4:	f0 e0       	ldi	r31, 0x00	; 0
    19a6:	80 81       	ld	r24, Z
    19a8:	86 60       	ori	r24, 0x06	; 6
    19aa:	80 83       	st	Z, r24
UBRR0H = (BAUDVALUE >>8 ); //load upper byte of the baud rate into UBRR 
    19ac:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
UBRR0L =  BAUDVALUE;       //load lower byte of the baud rate into UBRR 
    19b0:	87 e6       	ldi	r24, 0x67	; 103
    19b2:	89 b9       	out	0x09, r24	; 9
    19b4:	08 95       	ret

000019b6 <uart_getc>:
//Modified to not block indefinately in the case of a lost byte
//
char uart_getc(void) {
  uint16_t timer = 0;

  while (!(UCSR0A & (1<<RXC0))) {
    19b6:	80 e8       	ldi	r24, 0x80	; 128
    19b8:	9e e3       	ldi	r25, 0x3E	; 62
    19ba:	02 c0       	rjmp	.+4      	; 0x19c0 <uart_getc+0xa>
    19bc:	01 97       	sbiw	r24, 0x01	; 1
  timer++;
  if(timer >= 16000){ return(0);}
    19be:	21 f0       	breq	.+8      	; 0x19c8 <uart_getc+0x12>
//Modified to not block indefinately in the case of a lost byte
//
char uart_getc(void) {
  uint16_t timer = 0;

  while (!(UCSR0A & (1<<RXC0))) {
    19c0:	5f 9b       	sbis	0x0b, 7	; 11
    19c2:	fc cf       	rjmp	.-8      	; 0x19bc <uart_getc+0x6>
  //what should we return if nothing comes in?
  //return the data into a global variable
  //give uart_getc the address of the variable
  //return a -1 if no data comes back.
  } // Wait for byte to arrive
  return(UDR0); //return the received data
    19c4:	8c b1       	in	r24, 0x0c	; 12
    19c6:	08 95       	ret
char uart_getc(void) {
  uint16_t timer = 0;

  while (!(UCSR0A & (1<<RXC0))) {
  timer++;
  if(timer >= 16000){ return(0);}
    19c8:	80 e0       	ldi	r24, 0x00	; 0
  //return the data into a global variable
  //give uart_getc the address of the variable
  //return a -1 if no data comes back.
  } // Wait for byte to arrive
  return(UDR0); //return the received data
}
    19ca:	08 95       	ret

000019cc <get_int_status>:
//
//TODO: update for interrupts
// 
uint8_t get_int_status(){

    si4734_wr_buf[0] = GET_INT_STATUS;              
    19cc:	84 e1       	ldi	r24, 0x14	; 20
    19ce:	80 93 1a 02 	sts	0x021A, r24	; 0x80021a <si4734_wr_buf>
    twi_start_wr(SI4734_ADDRESS, si4734_wr_buf, 1); //send get_int_status command
    19d2:	41 e0       	ldi	r20, 0x01	; 1
    19d4:	6a e1       	ldi	r22, 0x1A	; 26
    19d6:	72 e0       	ldi	r23, 0x02	; 2
    19d8:	82 e2       	ldi	r24, 0x22	; 34
    19da:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <twi_start_wr>
    while( twi_busy() ){}; //spin while previous TWI transaction finshes
    19de:	0e 94 76 0c 	call	0x18ec	; 0x18ec <twi_busy>
    19e2:	81 11       	cpse	r24, r1
    19e4:	fc cf       	rjmp	.-8      	; 0x19de <get_int_status+0x12>
    19e6:	8f ea       	ldi	r24, 0xAF	; 175
    19e8:	94 e0       	ldi	r25, 0x04	; 4
    19ea:	01 97       	sbiw	r24, 0x01	; 1
    19ec:	f1 f7       	brne	.-4      	; 0x19ea <get_int_status+0x1e>
    19ee:	00 c0       	rjmp	.+0      	; 0x19f0 <get_int_status+0x24>
    19f0:	00 00       	nop
    _delay_us(300);        //si4734 process delay
    twi_start_rd(SI4734_ADDRESS, si4734_rd_buf, 1); //get the interrupt status 
    19f2:	41 e0       	ldi	r20, 0x01	; 1
    19f4:	6c e3       	ldi	r22, 0x3C	; 60
    19f6:	72 e0       	ldi	r23, 0x02	; 2
    19f8:	82 e2       	ldi	r24, 0x22	; 34
    19fa:	0e 94 8b 0c 	call	0x1916	; 0x1916 <twi_start_rd>
    while( twi_busy() ){}; //spin while previous TWI transaction finshes
    19fe:	0e 94 76 0c 	call	0x18ec	; 0x18ec <twi_busy>
    1a02:	81 11       	cpse	r24, r1
    1a04:	fc cf       	rjmp	.-8      	; 0x19fe <get_int_status+0x32>
    return(si4734_rd_buf[0]);
}
    1a06:	80 91 3c 02 	lds	r24, 0x023C	; 0x80023c <si4734_rd_buf>
    1a0a:	08 95       	ret

00001a0c <fm_tune_freq>:
//
//takes current_fm_freq and sends it to the radio chip
//

void fm_tune_freq(){
  si4734_wr_buf[0] = 0x20;  //fm tune command
    1a0c:	80 e2       	ldi	r24, 0x20	; 32
    1a0e:	80 93 1a 02 	sts	0x021A, r24	; 0x80021a <si4734_wr_buf>
  si4734_wr_buf[1] = 0x00;  //no FREEZE and no FAST tune
    1a12:	10 92 1b 02 	sts	0x021B, r1	; 0x80021b <si4734_wr_buf+0x1>
  si4734_wr_buf[2] = (uint8_t)(current_fm_freq >> 8); //freq high byte
    1a16:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <current_fm_freq>
    1a1a:	90 91 28 01 	lds	r25, 0x0128	; 0x800128 <current_fm_freq+0x1>
    1a1e:	90 93 1c 02 	sts	0x021C, r25	; 0x80021c <si4734_wr_buf+0x2>
  si4734_wr_buf[3] = (uint8_t)(current_fm_freq);      //freq low byte
    1a22:	80 93 1d 02 	sts	0x021D, r24	; 0x80021d <si4734_wr_buf+0x3>
  si4734_wr_buf[4] = 0x00;  //antenna tuning capactior
    1a26:	10 92 1e 02 	sts	0x021E, r1	; 0x80021e <si4734_wr_buf+0x4>
  //send fm tune command
  STC_interrupt = FALSE;
    1a2a:	10 92 3b 02 	sts	0x023B, r1	; 0x80023b <STC_interrupt>
  twi_start_wr(SI4734_ADDRESS, si4734_wr_buf, 5);
    1a2e:	45 e0       	ldi	r20, 0x05	; 5
    1a30:	6a e1       	ldi	r22, 0x1A	; 26
    1a32:	72 e0       	ldi	r23, 0x02	; 2
    1a34:	82 e2       	ldi	r24, 0x22	; 34
    1a36:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <twi_start_wr>
  while( ! STC_interrupt ){}; //spin until the tune command finishes 
    1a3a:	80 91 3b 02 	lds	r24, 0x023B	; 0x80023b <STC_interrupt>
    1a3e:	88 23       	and	r24, r24
    1a40:	e1 f3       	breq	.-8      	; 0x1a3a <fm_tune_freq+0x2e>
}
    1a42:	08 95       	ret

00001a44 <am_tune_freq>:
//
//takes current_am_freq and sends it to the radio chip
//

void am_tune_freq(){
  si4734_wr_buf[0] = AM_TUNE_FREQ; //am tune command
    1a44:	80 e4       	ldi	r24, 0x40	; 64
    1a46:	80 93 1a 02 	sts	0x021A, r24	; 0x80021a <si4734_wr_buf>
  si4734_wr_buf[1] = 0x00;         //no FAST tune
    1a4a:	10 92 1b 02 	sts	0x021B, r1	; 0x80021b <si4734_wr_buf+0x1>
  si4734_wr_buf[2] = (uint8_t)(current_am_freq >> 8); //freq high byte
    1a4e:	80 91 78 01 	lds	r24, 0x0178	; 0x800178 <current_am_freq>
    1a52:	90 91 79 01 	lds	r25, 0x0179	; 0x800179 <current_am_freq+0x1>
    1a56:	90 93 1c 02 	sts	0x021C, r25	; 0x80021c <si4734_wr_buf+0x2>
  si4734_wr_buf[3] = (uint8_t)(current_am_freq);      //freq low byte
    1a5a:	80 93 1d 02 	sts	0x021D, r24	; 0x80021d <si4734_wr_buf+0x3>
  si4734_wr_buf[4] = 0x00;  //antenna tuning capactior high byte
    1a5e:	10 92 1e 02 	sts	0x021E, r1	; 0x80021e <si4734_wr_buf+0x4>
  si4734_wr_buf[5] = 0x00;  //antenna tuning capactior low byte
    1a62:	10 92 1f 02 	sts	0x021F, r1	; 0x80021f <si4734_wr_buf+0x5>
  //send am tune command
  STC_interrupt = FALSE;
    1a66:	10 92 3b 02 	sts	0x023B, r1	; 0x80023b <STC_interrupt>
  twi_start_wr(SI4734_ADDRESS, si4734_wr_buf, 6);
    1a6a:	46 e0       	ldi	r20, 0x06	; 6
    1a6c:	6a e1       	ldi	r22, 0x1A	; 26
    1a6e:	72 e0       	ldi	r23, 0x02	; 2
    1a70:	82 e2       	ldi	r24, 0x22	; 34
    1a72:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <twi_start_wr>
  while( ! STC_interrupt ){}; //spin until the tune command finishes 
    1a76:	80 91 3b 02 	lds	r24, 0x023B	; 0x80023b <STC_interrupt>
    1a7a:	88 23       	and	r24, r24
    1a7c:	e1 f3       	breq	.-8      	; 0x1a76 <am_tune_freq+0x32>
}
    1a7e:	08 95       	ret

00001a80 <sw_tune_freq>:
//
//takes current_sw_freq and sends it to the radio chip
//antcap low byte is 0x01 as per datasheet

void sw_tune_freq(){
  si4734_wr_buf[0] = 0x40;  //am tune command
    1a80:	ea e1       	ldi	r30, 0x1A	; 26
    1a82:	f2 e0       	ldi	r31, 0x02	; 2
    1a84:	80 e4       	ldi	r24, 0x40	; 64
    1a86:	80 83       	st	Z, r24
  si4734_wr_buf[1] = 0x00;  //no FAST tune
    1a88:	11 82       	std	Z+1, r1	; 0x01
  si4734_wr_buf[2] = (uint8_t)(current_sw_freq >> 8); //freq high byte
    1a8a:	80 91 8b 01 	lds	r24, 0x018B	; 0x80018b <current_sw_freq>
    1a8e:	90 91 8c 01 	lds	r25, 0x018C	; 0x80018c <current_sw_freq+0x1>
    1a92:	92 83       	std	Z+2, r25	; 0x02
  si4734_wr_buf[3] = (uint8_t)(current_sw_freq);      //freq low byte
    1a94:	83 83       	std	Z+3, r24	; 0x03
  si4734_wr_buf[4] = 0x00;  //antenna tuning capactior high byte
    1a96:	14 82       	std	Z+4, r1	; 0x04
  si4734_wr_buf[5] = 0x01;  //antenna tuning capactior low byte 
    1a98:	81 e0       	ldi	r24, 0x01	; 1
    1a9a:	85 83       	std	Z+5, r24	; 0x05
  //send am tune command
  twi_start_wr(SI4734_ADDRESS, si4734_wr_buf, 6);
    1a9c:	46 e0       	ldi	r20, 0x06	; 6
    1a9e:	bf 01       	movw	r22, r30
    1aa0:	82 e2       	ldi	r24, 0x22	; 34
    1aa2:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <twi_start_wr>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1aa6:	2f ef       	ldi	r18, 0xFF	; 255
    1aa8:	87 ee       	ldi	r24, 0xE7	; 231
    1aaa:	93 e0       	ldi	r25, 0x03	; 3
    1aac:	21 50       	subi	r18, 0x01	; 1
    1aae:	80 40       	sbci	r24, 0x00	; 0
    1ab0:	90 40       	sbci	r25, 0x00	; 0
    1ab2:	e1 f7       	brne	.-8      	; 0x1aac <sw_tune_freq+0x2c>
    1ab4:	00 c0       	rjmp	.+0      	; 0x1ab6 <sw_tune_freq+0x36>
    1ab6:	00 00       	nop
    1ab8:	08 95       	ret

00001aba <radio_pwr_dwn>:
//

void radio_pwr_dwn(){

//save current frequency to EEPROM
switch(current_radio_band){
    1aba:	80 91 54 01 	lds	r24, 0x0154	; 0x800154 <current_radio_band>
    1abe:	90 91 55 01 	lds	r25, 0x0155	; 0x800155 <current_radio_band+0x1>
    1ac2:	81 30       	cpi	r24, 0x01	; 1
    1ac4:	91 05       	cpc	r25, r1
    1ac6:	51 f1       	breq	.+84     	; 0x1b1c <radio_pwr_dwn+0x62>
    1ac8:	00 f1       	brcs	.+64     	; 0x1b0a <radio_pwr_dwn+0x50>
    1aca:	02 97       	sbiw	r24, 0x02	; 2
    1acc:	41 f4       	brne	.+16     	; 0x1ade <radio_pwr_dwn+0x24>
  case(FM) : eeprom_write_word(&eeprom_fm_freq, current_fm_freq); break;
  case(AM) : eeprom_write_word(&eeprom_am_freq, current_am_freq); break;
  case(SW) : eeprom_write_word(&eeprom_sw_freq, current_sw_freq); break;
    1ace:	60 91 8b 01 	lds	r22, 0x018B	; 0x80018b <current_sw_freq>
    1ad2:	70 91 8c 01 	lds	r23, 0x018C	; 0x80018c <current_sw_freq+0x1>
    1ad6:	8d e8       	ldi	r24, 0x8D	; 141
    1ad8:	91 e0       	ldi	r25, 0x01	; 1
    1ada:	0e 94 6f 10 	call	0x20de	; 0x20de <eeprom_write_word>
  default  : break;
}//switch      

  eeprom_write_byte(&eeprom_volume, current_volume); //save current volume level
    1ade:	60 91 72 01 	lds	r22, 0x0172	; 0x800172 <current_volume>
    1ae2:	8c e6       	ldi	r24, 0x6C	; 108
    1ae4:	91 e0       	ldi	r25, 0x01	; 1
    1ae6:	0e 94 62 10 	call	0x20c4	; 0x20c4 <eeprom_write_byte>

//send fm power down command
    si4734_wr_buf[0] = 0x11;
    1aea:	81 e1       	ldi	r24, 0x11	; 17
    1aec:	80 93 1a 02 	sts	0x021A, r24	; 0x80021a <si4734_wr_buf>
    twi_start_wr(SI4734_ADDRESS, si4734_wr_buf, 1);
    1af0:	41 e0       	ldi	r20, 0x01	; 1
    1af2:	6a e1       	ldi	r22, 0x1A	; 26
    1af4:	72 e0       	ldi	r23, 0x02	; 2
    1af6:	82 e2       	ldi	r24, 0x22	; 34
    1af8:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <twi_start_wr>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1afc:	87 ed       	ldi	r24, 0xD7	; 215
    1afe:	94 e0       	ldi	r25, 0x04	; 4
    1b00:	01 97       	sbiw	r24, 0x01	; 1
    1b02:	f1 f7       	brne	.-4      	; 0x1b00 <radio_pwr_dwn+0x46>
    1b04:	00 c0       	rjmp	.+0      	; 0x1b06 <radio_pwr_dwn+0x4c>
    1b06:	00 00       	nop
    1b08:	08 95       	ret

void radio_pwr_dwn(){

//save current frequency to EEPROM
switch(current_radio_band){
  case(FM) : eeprom_write_word(&eeprom_fm_freq, current_fm_freq); break;
    1b0a:	60 91 27 01 	lds	r22, 0x0127	; 0x800127 <current_fm_freq>
    1b0e:	70 91 28 01 	lds	r23, 0x0128	; 0x800128 <current_fm_freq+0x1>
    1b12:	8d e6       	ldi	r24, 0x6D	; 109
    1b14:	91 e0       	ldi	r25, 0x01	; 1
    1b16:	0e 94 6f 10 	call	0x20de	; 0x20de <eeprom_write_word>
    1b1a:	e1 cf       	rjmp	.-62     	; 0x1ade <radio_pwr_dwn+0x24>
  case(AM) : eeprom_write_word(&eeprom_am_freq, current_am_freq); break;
    1b1c:	60 91 78 01 	lds	r22, 0x0178	; 0x800178 <current_am_freq>
    1b20:	70 91 79 01 	lds	r23, 0x0179	; 0x800179 <current_am_freq+0x1>
    1b24:	80 e7       	ldi	r24, 0x70	; 112
    1b26:	91 e0       	ldi	r25, 0x01	; 1
    1b28:	0e 94 6f 10 	call	0x20de	; 0x20de <eeprom_write_word>
    1b2c:	d8 cf       	rjmp	.-80     	; 0x1ade <radio_pwr_dwn+0x24>

00001b2e <fm_rsq_status>:
//inside the chip. 
//TODO: Dang, thats a big delay, could cause problems, best check out.
//
void fm_rsq_status(){

    si4734_wr_buf[0] = FM_RSQ_STATUS;            //fm_rsq_status command
    1b2e:	83 e2       	ldi	r24, 0x23	; 35
    1b30:	80 93 1a 02 	sts	0x021A, r24	; 0x80021a <si4734_wr_buf>
    si4734_wr_buf[1] = FM_RSQ_STATUS_IN_INTACK;  //clear STCINT bit if set
    1b34:	81 e0       	ldi	r24, 0x01	; 1
    1b36:	80 93 1b 02 	sts	0x021B, r24	; 0x80021b <si4734_wr_buf+0x1>
    twi_start_wr(SI4734_ADDRESS, si4734_wr_buf, 2);
    1b3a:	42 e0       	ldi	r20, 0x02	; 2
    1b3c:	6a e1       	ldi	r22, 0x1A	; 26
    1b3e:	72 e0       	ldi	r23, 0x02	; 2
    1b40:	82 e2       	ldi	r24, 0x22	; 34
    1b42:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <twi_start_wr>
    while(twi_busy()){}; //spin while previous TWI transaction finshes
    1b46:	0e 94 76 0c 	call	0x18ec	; 0x18ec <twi_busy>
    1b4a:	81 11       	cpse	r24, r1
    1b4c:	fc cf       	rjmp	.-8      	; 0x1b46 <fm_rsq_status+0x18>
    1b4e:	8f ea       	ldi	r24, 0xAF	; 175
    1b50:	94 e0       	ldi	r25, 0x04	; 4
    1b52:	01 97       	sbiw	r24, 0x01	; 1
    1b54:	f1 f7       	brne	.-4      	; 0x1b52 <fm_rsq_status+0x24>
    1b56:	00 c0       	rjmp	.+0      	; 0x1b58 <fm_rsq_status+0x2a>
    1b58:	00 00       	nop
    _delay_us(300);      //delay for si4734 to process
    //This is a blind wait. Waiting for CTS interrupt here would tell you 
    //when the command is received and has been processed.
    //get the fm tune status 
    twi_start_rd(SI4734_ADDRESS, si4734_tune_status_buf, 8);
    1b5a:	48 e0       	ldi	r20, 0x08	; 8
    1b5c:	63 e2       	ldi	r22, 0x23	; 35
    1b5e:	72 e0       	ldi	r23, 0x02	; 2
    1b60:	82 e2       	ldi	r24, 0x22	; 34
    1b62:	0e 94 8b 0c 	call	0x1916	; 0x1916 <twi_start_rd>
    while(twi_busy()){}; //spin while previous TWI transaction finshes
    1b66:	0e 94 76 0c 	call	0x18ec	; 0x18ec <twi_busy>
    1b6a:	81 11       	cpse	r24, r1
    1b6c:	fc cf       	rjmp	.-8      	; 0x1b66 <fm_rsq_status+0x38>
}
    1b6e:	08 95       	ret

00001b70 <fm_tune_status>:
//is cleared.
//TODO: Dang, thats a big delay, could cause problems, best check out.
//
void fm_tune_status(){

    si4734_wr_buf[0] = FM_TUNE_STATUS;            //fm_tune_status command
    1b70:	82 e2       	ldi	r24, 0x22	; 34
    1b72:	80 93 1a 02 	sts	0x021A, r24	; 0x80021a <si4734_wr_buf>
    si4734_wr_buf[1] = FM_TUNE_STATUS_IN_INTACK;  //clear STCINT bit if set
    1b76:	81 e0       	ldi	r24, 0x01	; 1
    1b78:	80 93 1b 02 	sts	0x021B, r24	; 0x80021b <si4734_wr_buf+0x1>
    twi_start_wr(SI4734_ADDRESS, si4734_wr_buf, 2);
    1b7c:	42 e0       	ldi	r20, 0x02	; 2
    1b7e:	6a e1       	ldi	r22, 0x1A	; 26
    1b80:	72 e0       	ldi	r23, 0x02	; 2
    1b82:	82 e2       	ldi	r24, 0x22	; 34
    1b84:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <twi_start_wr>
    while(twi_busy()){}; //spin while previous TWI transaction finshes
    1b88:	0e 94 76 0c 	call	0x18ec	; 0x18ec <twi_busy>
    1b8c:	81 11       	cpse	r24, r1
    1b8e:	fc cf       	rjmp	.-8      	; 0x1b88 <fm_tune_status+0x18>
    1b90:	8f ea       	ldi	r24, 0xAF	; 175
    1b92:	94 e0       	ldi	r25, 0x04	; 4
    1b94:	01 97       	sbiw	r24, 0x01	; 1
    1b96:	f1 f7       	brne	.-4      	; 0x1b94 <fm_tune_status+0x24>
    1b98:	00 c0       	rjmp	.+0      	; 0x1b9a <fm_tune_status+0x2a>
    1b9a:	00 00       	nop
    _delay_us(300);        //delay for si4734 to process
    //get the fm tune status 
    twi_start_rd(SI4734_ADDRESS, si4734_tune_status_buf, 8);
    1b9c:	48 e0       	ldi	r20, 0x08	; 8
    1b9e:	63 e2       	ldi	r22, 0x23	; 35
    1ba0:	72 e0       	ldi	r23, 0x02	; 2
    1ba2:	82 e2       	ldi	r24, 0x22	; 34
    1ba4:	0e 94 8b 0c 	call	0x1916	; 0x1916 <twi_start_rd>
    while( twi_busy() ){}; //spin till TWI read transaction finshes
    1ba8:	0e 94 76 0c 	call	0x18ec	; 0x18ec <twi_busy>
    1bac:	81 11       	cpse	r24, r1
    1bae:	fc cf       	rjmp	.-8      	; 0x1ba8 <fm_tune_status+0x38>
}
    1bb0:	08 95       	ret

00001bb2 <am_tune_status>:
//TODO: could probably just have one tune_status() function
//TODO: Dang, thats a big delay, could cause problems, best check out.

void am_tune_status(){

    si4734_wr_buf[0] = AM_TUNE_STATUS;            //fm_tune_status command
    1bb2:	82 e4       	ldi	r24, 0x42	; 66
    1bb4:	80 93 1a 02 	sts	0x021A, r24	; 0x80021a <si4734_wr_buf>
    si4734_wr_buf[1] = AM_TUNE_STATUS_IN_INTACK;  //clear STCINT bit if set
    1bb8:	81 e0       	ldi	r24, 0x01	; 1
    1bba:	80 93 1b 02 	sts	0x021B, r24	; 0x80021b <si4734_wr_buf+0x1>
    twi_start_wr(SI4734_ADDRESS, si4734_wr_buf, 2);
    1bbe:	42 e0       	ldi	r20, 0x02	; 2
    1bc0:	6a e1       	ldi	r22, 0x1A	; 26
    1bc2:	72 e0       	ldi	r23, 0x02	; 2
    1bc4:	82 e2       	ldi	r24, 0x22	; 34
    1bc6:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <twi_start_wr>
    while(twi_busy()){}; //spin while previous TWI transaction finshes
    1bca:	0e 94 76 0c 	call	0x18ec	; 0x18ec <twi_busy>
    1bce:	81 11       	cpse	r24, r1
    1bd0:	fc cf       	rjmp	.-8      	; 0x1bca <am_tune_status+0x18>
    1bd2:	8f ea       	ldi	r24, 0xAF	; 175
    1bd4:	94 e0       	ldi	r25, 0x04	; 4
    1bd6:	01 97       	sbiw	r24, 0x01	; 1
    1bd8:	f1 f7       	brne	.-4      	; 0x1bd6 <am_tune_status+0x24>
    1bda:	00 c0       	rjmp	.+0      	; 0x1bdc <am_tune_status+0x2a>
    1bdc:	00 00       	nop
    _delay_us(300);        //delay for si4734 to process command
    //get the am tune status 
    twi_start_rd(SI4734_ADDRESS, si4734_tune_status_buf, 8);
    1bde:	48 e0       	ldi	r20, 0x08	; 8
    1be0:	63 e2       	ldi	r22, 0x23	; 35
    1be2:	72 e0       	ldi	r23, 0x02	; 2
    1be4:	82 e2       	ldi	r24, 0x22	; 34
    1be6:	0c 94 8b 0c 	jmp	0x1916	; 0x1916 <twi_start_rd>

00001bea <am_rsq_status>:
//
//TODO: Dang, thats a big delay, could cause problems, best check out.

void am_rsq_status(){

    si4734_wr_buf[0] = AM_RSQ_STATUS;            //am_rsq_status command
    1bea:	83 e4       	ldi	r24, 0x43	; 67
    1bec:	80 93 1a 02 	sts	0x021A, r24	; 0x80021a <si4734_wr_buf>
    si4734_wr_buf[1] = AM_RSQ_STATUS_IN_INTACK;  //clear STCINT bit if set
    1bf0:	81 e0       	ldi	r24, 0x01	; 1
    1bf2:	80 93 1b 02 	sts	0x021B, r24	; 0x80021b <si4734_wr_buf+0x1>
    twi_start_wr(SI4734_ADDRESS, si4734_wr_buf, 2);
    1bf6:	42 e0       	ldi	r20, 0x02	; 2
    1bf8:	6a e1       	ldi	r22, 0x1A	; 26
    1bfa:	72 e0       	ldi	r23, 0x02	; 2
    1bfc:	82 e2       	ldi	r24, 0x22	; 34
    1bfe:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <twi_start_wr>
    while(twi_busy()){}; //spin while previous TWI transaction finshes
    1c02:	0e 94 76 0c 	call	0x18ec	; 0x18ec <twi_busy>
    1c06:	81 11       	cpse	r24, r1
    1c08:	fc cf       	rjmp	.-8      	; 0x1c02 <am_rsq_status+0x18>
    1c0a:	8f ea       	ldi	r24, 0xAF	; 175
    1c0c:	94 e0       	ldi	r25, 0x04	; 4
    1c0e:	01 97       	sbiw	r24, 0x01	; 1
    1c10:	f1 f7       	brne	.-4      	; 0x1c0e <am_rsq_status+0x24>
    1c12:	00 c0       	rjmp	.+0      	; 0x1c14 <am_rsq_status+0x2a>
    1c14:	00 00       	nop
    _delay_us(300);        //delay for si4734 to process command
    //get the fm tune status 
    twi_start_rd(SI4734_ADDRESS, si4734_tune_status_buf, 8);
    1c16:	48 e0       	ldi	r20, 0x08	; 8
    1c18:	63 e2       	ldi	r22, 0x23	; 35
    1c1a:	72 e0       	ldi	r23, 0x02	; 2
    1c1c:	82 e2       	ldi	r24, 0x22	; 34
    1c1e:	0c 94 8b 0c 	jmp	0x1916	; 0x1916 <twi_start_rd>

00001c22 <set_property>:
//The set property command does not have a indication that it has completed. This
//command is guarnteed by design to finish in 10ms. 
//
void set_property(uint16_t property, uint16_t property_value){

    si4734_wr_buf[0] = SET_PROPERTY;                   //set property command
    1c22:	ea e1       	ldi	r30, 0x1A	; 26
    1c24:	f2 e0       	ldi	r31, 0x02	; 2
    1c26:	22 e1       	ldi	r18, 0x12	; 18
    1c28:	20 83       	st	Z, r18
    si4734_wr_buf[1] = 0x00;                           //all zeros
    1c2a:	11 82       	std	Z+1, r1	; 0x01
    si4734_wr_buf[2] = (uint8_t)(property >> 8);       //property high byte
    1c2c:	92 83       	std	Z+2, r25	; 0x02
    si4734_wr_buf[3] = (uint8_t)(property);            //property low byte
    1c2e:	83 83       	std	Z+3, r24	; 0x03
    si4734_wr_buf[4] = (uint8_t)(property_value >> 8); //property value high byte
    1c30:	74 83       	std	Z+4, r23	; 0x04
    si4734_wr_buf[5] = (uint8_t)(property_value);      //property value low byte
    1c32:	65 83       	std	Z+5, r22	; 0x05
    twi_start_wr(SI4734_ADDRESS, si4734_wr_buf, 6);
    1c34:	46 e0       	ldi	r20, 0x06	; 6
    1c36:	bf 01       	movw	r22, r30
    1c38:	82 e2       	ldi	r24, 0x22	; 34
    1c3a:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <twi_start_wr>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1c3e:	8f e3       	ldi	r24, 0x3F	; 63
    1c40:	9c e9       	ldi	r25, 0x9C	; 156
    1c42:	01 97       	sbiw	r24, 0x01	; 1
    1c44:	f1 f7       	brne	.-4      	; 0x1c42 <set_property+0x20>
    1c46:	00 c0       	rjmp	.+0      	; 0x1c48 <set_property+0x26>
    1c48:	00 00       	nop
    1c4a:	08 95       	ret

00001c4c <fm_pwr_up>:
//********************************************************************************
//                            fm_pwr_up()
//
void fm_pwr_up(){
//restore the previous fm frequency  
 current_fm_freq = eeprom_read_word(&eeprom_fm_freq); //TODO: only this one does not work 
    1c4c:	8d e6       	ldi	r24, 0x6D	; 109
    1c4e:	91 e0       	ldi	r25, 0x01	; 1
    1c50:	0e 94 5c 10 	call	0x20b8	; 0x20b8 <eeprom_read_word>
    1c54:	90 93 28 01 	sts	0x0128, r25	; 0x800128 <current_fm_freq+0x1>
    1c58:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <current_fm_freq>
 current_volume  = eeprom_read_byte(&eeprom_volume); //TODO: only this one does not work 
    1c5c:	8c e6       	ldi	r24, 0x6C	; 108
    1c5e:	91 e0       	ldi	r25, 0x01	; 1
    1c60:	0e 94 54 10 	call	0x20a8	; 0x20a8 <eeprom_read_byte>
    1c64:	80 93 72 01 	sts	0x0172, r24	; 0x800172 <current_volume>

//send fm power up command
  si4734_wr_buf[0] = FM_PWR_UP; //powerup command byte
    1c68:	ea e1       	ldi	r30, 0x1A	; 26
    1c6a:	f2 e0       	ldi	r31, 0x02	; 2
    1c6c:	81 e0       	ldi	r24, 0x01	; 1
    1c6e:	80 83       	st	Z, r24
  si4734_wr_buf[1] = 0x50;      //GPO2O enabled, STCINT enabled, use ext. 32khz osc.
    1c70:	80 e5       	ldi	r24, 0x50	; 80
    1c72:	81 83       	std	Z+1, r24	; 0x01
  si4734_wr_buf[2] = 0x05;      //OPMODE = 0x05; analog audio output
    1c74:	85 e0       	ldi	r24, 0x05	; 5
    1c76:	82 83       	std	Z+2, r24	; 0x02
  twi_start_wr(SI4734_ADDRESS, si4734_wr_buf, 3);
    1c78:	43 e0       	ldi	r20, 0x03	; 3
    1c7a:	bf 01       	movw	r22, r30
    1c7c:	82 e2       	ldi	r24, 0x22	; 34
    1c7e:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <twi_start_wr>
    1c82:	2f ef       	ldi	r18, 0xFF	; 255
    1c84:	8b ed       	ldi	r24, 0xDB	; 219
    1c86:	95 e0       	ldi	r25, 0x05	; 5
    1c88:	21 50       	subi	r18, 0x01	; 1
    1c8a:	80 40       	sbci	r24, 0x00	; 0
    1c8c:	90 40       	sbci	r25, 0x00	; 0
    1c8e:	e1 f7       	brne	.-8      	; 0x1c88 <fm_pwr_up+0x3c>
    1c90:	00 c0       	rjmp	.+0      	; 0x1c92 <fm_pwr_up+0x46>
    1c92:	00 00       	nop
  _delay_ms(120);               //startup delay as specified 
  //The seek/tune interrupt is enabled here. If the STCINT bit is set, a 1.5us
  //low pulse will be output from GPIO2/INT when tune or seek is completed.
  set_property(GPO_IEN, GPO_IEN_STCIEN); //seek_tune complete interrupt
    1c94:	61 e0       	ldi	r22, 0x01	; 1
    1c96:	70 e0       	ldi	r23, 0x00	; 0
    1c98:	81 e0       	ldi	r24, 0x01	; 1
    1c9a:	90 e0       	ldi	r25, 0x00	; 0
    1c9c:	0c 94 11 0e 	jmp	0x1c22	; 0x1c22 <set_property>

00001ca0 <am_pwr_up>:
//********************************************************************************
//                            am_pwr_up()
//
void am_pwr_up(){
//restore the previous am frequency  
  current_am_freq = eeprom_read_word(&eeprom_am_freq);
    1ca0:	80 e7       	ldi	r24, 0x70	; 112
    1ca2:	91 e0       	ldi	r25, 0x01	; 1
    1ca4:	0e 94 5c 10 	call	0x20b8	; 0x20b8 <eeprom_read_word>
    1ca8:	90 93 79 01 	sts	0x0179, r25	; 0x800179 <current_am_freq+0x1>
    1cac:	80 93 78 01 	sts	0x0178, r24	; 0x800178 <current_am_freq>
  current_volume  = eeprom_read_byte(&eeprom_volume); //TODO: only this one does not work 
    1cb0:	8c e6       	ldi	r24, 0x6C	; 108
    1cb2:	91 e0       	ldi	r25, 0x01	; 1
    1cb4:	0e 94 54 10 	call	0x20a8	; 0x20a8 <eeprom_read_byte>
    1cb8:	80 93 72 01 	sts	0x0172, r24	; 0x800172 <current_volume>

//send am power up command
  si4734_wr_buf[0] = AM_PWR_UP;
    1cbc:	ea e1       	ldi	r30, 0x1A	; 26
    1cbe:	f2 e0       	ldi	r31, 0x02	; 2
    1cc0:	81 e0       	ldi	r24, 0x01	; 1
    1cc2:	80 83       	st	Z, r24
  si4734_wr_buf[1] = 0x51;//GPO2OEN and XOSCEN selected
    1cc4:	81 e5       	ldi	r24, 0x51	; 81
    1cc6:	81 83       	std	Z+1, r24	; 0x01
  si4734_wr_buf[2] = 0x05;
    1cc8:	85 e0       	ldi	r24, 0x05	; 5
    1cca:	82 83       	std	Z+2, r24	; 0x02
  twi_start_wr(SI4734_ADDRESS, si4734_wr_buf, 3);
    1ccc:	43 e0       	ldi	r20, 0x03	; 3
    1cce:	bf 01       	movw	r22, r30
    1cd0:	82 e2       	ldi	r24, 0x22	; 34
    1cd2:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <twi_start_wr>
    1cd6:	2f ef       	ldi	r18, 0xFF	; 255
    1cd8:	8b ed       	ldi	r24, 0xDB	; 219
    1cda:	95 e0       	ldi	r25, 0x05	; 5
    1cdc:	21 50       	subi	r18, 0x01	; 1
    1cde:	80 40       	sbci	r24, 0x00	; 0
    1ce0:	90 40       	sbci	r25, 0x00	; 0
    1ce2:	e1 f7       	brne	.-8      	; 0x1cdc <am_pwr_up+0x3c>
    1ce4:	00 c0       	rjmp	.+0      	; 0x1ce6 <am_pwr_up+0x46>
    1ce6:	00 00       	nop
  _delay_ms(120);   
  set_property(GPO_IEN, GPO_IEN_STCIEN);    //Seek/Tune Complete interrupt
    1ce8:	61 e0       	ldi	r22, 0x01	; 1
    1cea:	70 e0       	ldi	r23, 0x00	; 0
    1cec:	81 e0       	ldi	r24, 0x01	; 1
    1cee:	90 e0       	ldi	r25, 0x00	; 0
    1cf0:	0c 94 11 0e 	jmp	0x1c22	; 0x1c22 <set_property>

00001cf4 <sw_pwr_up>:
//                            sw_pwr_up()
//

void sw_pwr_up(){
//restore the previous sw frequency  
  current_sw_freq = eeprom_read_word(&eeprom_sw_freq);
    1cf4:	8d e8       	ldi	r24, 0x8D	; 141
    1cf6:	91 e0       	ldi	r25, 0x01	; 1
    1cf8:	0e 94 5c 10 	call	0x20b8	; 0x20b8 <eeprom_read_word>
    1cfc:	90 93 8c 01 	sts	0x018C, r25	; 0x80018c <current_sw_freq+0x1>
    1d00:	80 93 8b 01 	sts	0x018B, r24	; 0x80018b <current_sw_freq>
  current_volume  = eeprom_read_byte(&eeprom_volume); //TODO: only this one does not work 
    1d04:	8c e6       	ldi	r24, 0x6C	; 108
    1d06:	91 e0       	ldi	r25, 0x01	; 1
    1d08:	0e 94 54 10 	call	0x20a8	; 0x20a8 <eeprom_read_byte>
    1d0c:	80 93 72 01 	sts	0x0172, r24	; 0x800172 <current_volume>

//send sw power up command (same as am, only tuning rate is different)
    si4734_wr_buf[0] = AM_PWR_UP; //same cmd as for AM
    1d10:	ea e1       	ldi	r30, 0x1A	; 26
    1d12:	f2 e0       	ldi	r31, 0x02	; 2
    1d14:	81 e0       	ldi	r24, 0x01	; 1
    1d16:	80 83       	st	Z, r24
    si4734_wr_buf[1] = 0x51;
    1d18:	81 e5       	ldi	r24, 0x51	; 81
    1d1a:	81 83       	std	Z+1, r24	; 0x01
    si4734_wr_buf[2] = 0x05;
    1d1c:	85 e0       	ldi	r24, 0x05	; 5
    1d1e:	82 83       	std	Z+2, r24	; 0x02
    twi_start_wr(SI4734_ADDRESS, si4734_wr_buf, 3);
    1d20:	43 e0       	ldi	r20, 0x03	; 3
    1d22:	bf 01       	movw	r22, r30
    1d24:	82 e2       	ldi	r24, 0x22	; 34
    1d26:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <twi_start_wr>
    1d2a:	2f ef       	ldi	r18, 0xFF	; 255
    1d2c:	8b ed       	ldi	r24, 0xDB	; 219
    1d2e:	95 e0       	ldi	r25, 0x05	; 5
    1d30:	21 50       	subi	r18, 0x01	; 1
    1d32:	80 40       	sbci	r24, 0x00	; 0
    1d34:	90 40       	sbci	r25, 0x00	; 0
    1d36:	e1 f7       	brne	.-8      	; 0x1d30 <sw_pwr_up+0x3c>
    1d38:	00 c0       	rjmp	.+0      	; 0x1d3a <sw_pwr_up+0x46>
    1d3a:	00 00       	nop
    _delay_ms(120);   //start up delay

  //set property to disable soft muting for shortwave broadcasts
  set_property(AM_SOFT_MUTE_MAX_ATTENUATION, 0x0000); //cut off soft mute  
    1d3c:	60 e0       	ldi	r22, 0x00	; 0
    1d3e:	70 e0       	ldi	r23, 0x00	; 0
    1d40:	82 e0       	ldi	r24, 0x02	; 2
    1d42:	93 e3       	ldi	r25, 0x33	; 51
    1d44:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <set_property>
  //select 4khz filter BW and engage power line filter
  set_property(AM_CHANNEL_FILTER, (AM_CHFILT_4KHZ | AM_PWR_LINE_NOISE_REJT_FILTER)); 
    1d48:	61 e0       	ldi	r22, 0x01	; 1
    1d4a:	71 e0       	ldi	r23, 0x01	; 1
    1d4c:	82 e0       	ldi	r24, 0x02	; 2
    1d4e:	91 e3       	ldi	r25, 0x31	; 49
    1d50:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <set_property>
  set_property(GPO_IEN, GPO_IEN_STCIEN); //Seek/Tune Complete interrupt
    1d54:	61 e0       	ldi	r22, 0x01	; 1
    1d56:	70 e0       	ldi	r23, 0x00	; 0
    1d58:	81 e0       	ldi	r24, 0x01	; 1
    1d5a:	90 e0       	ldi	r25, 0x00	; 0
    1d5c:	0c 94 11 0e 	jmp	0x1c22	; 0x1c22 <set_property>

00001d60 <main>:
Description: Initialization of the serial port interface. More specifics
	in the function below. 
Parameters: NA
**********************************************************************/
void spi_init(){
   DDRB |= (1<<DDB0) | (1<<DDB1) | (1<<DDB2);	//output mode for SS, MOSI, SCLK 
    1d60:	87 b3       	in	r24, 0x17	; 23
    1d62:	87 60       	ori	r24, 0x07	; 7
    1d64:	87 bb       	out	0x17, r24	; 23
   SPCR |= (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPE);//master mode, clk low on idle,
    1d66:	8d b1       	in	r24, 0x0d	; 13
    1d68:	8c 65       	ori	r24, 0x5C	; 92
    1d6a:	8d b9       	out	0x0d, r24	; 13
// leading edge smaple , and spi enable 
   SPSR |= (1<<SPI2X);			//double speed operation  
    1d6c:	70 9a       	sbi	0x0e, 0	; 14
Description: Timer counter 0 is initialized in normal mode with no prescale
	and will be used as a seconds counter for the clock
Parameters: NA
**********************************************************************/
void tcnt0_init(){
   ASSR |= (1<<AS0);
    1d6e:	80 b7       	in	r24, 0x30	; 48
    1d70:	88 60       	ori	r24, 0x08	; 8
    1d72:	80 bf       	out	0x30, r24	; 48
   TIMSK |= (1<<OCIE0) | (1<<TOIE0);			//enable interrupts
    1d74:	87 b7       	in	r24, 0x37	; 55
    1d76:	83 60       	ori	r24, 0x03	; 3
    1d78:	87 bf       	out	0x37, r24	; 55
   TCCR0 |= (1<<CS00);			//normal mode, no prescale
    1d7a:	83 b7       	in	r24, 0x33	; 51
    1d7c:	81 60       	ori	r24, 0x01	; 1
    1d7e:	83 bf       	out	0x33, r24	; 51
   OCR0 = 0xFF;
    1d80:	8f ef       	ldi	r24, 0xFF	; 255
    1d82:	81 bf       	out	0x31, r24	; 49
Description: Timer counter 1 is initialized in CTC mode, 64 bit prescaler
	so that it can be used to generate an alarm frequency
Parameters: NA
**********************************************************************/
void tcnt1_init(){
   TCCR1B |= (1<<CS11) | (1<<CS10) | (1<<WGM12);		//CTC mode, 64bit prescaler
    1d84:	8e b5       	in	r24, 0x2e	; 46
    1d86:	8b 60       	ori	r24, 0x0B	; 11
    1d88:	8e bd       	out	0x2e, r24	; 46
   TCCR1C = 0x00;
    1d8a:	10 92 7a 00 	sts	0x007A, r1	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
   TIMSK  |= (1<<OCIE1A) | (1<<TOIE1);	//enable flag for interrupt 
    1d8e:	87 b7       	in	r24, 0x37	; 55
    1d90:	84 61       	ori	r24, 0x14	; 20
    1d92:	87 bf       	out	0x37, r24	; 55
   OCR1A = 0x0040;		//compare match at 64
    1d94:	80 e4       	ldi	r24, 0x40	; 64
    1d96:	90 e0       	ldi	r25, 0x00	; 0
    1d98:	9b bd       	out	0x2b, r25	; 43
    1d9a:	8a bd       	out	0x2a, r24	; 42
	normal mode with a 64 bit prescaler. OCRA2 is adjusted to change
	the pwn produced.
Parameters: NA
**********************************************************************/
void tcnt2_init(){
   TCCR2 |= (1<<WGM21) | (1<<WGM20)| (1<<CS20) | (1<<COM21);			
    1d9c:	85 b5       	in	r24, 0x25	; 37
    1d9e:	89 66       	ori	r24, 0x69	; 105
    1da0:	85 bd       	out	0x25, r24	; 37
Description: This timer is used as a volume control for the audio amp.
	I adjust the value of OCR3A to change the pwm.
Parameters: NA
**********************************************************************/
void tcnt3_init(){
   TCCR3A |= (1<<COM3A1) | (1<<WGM31);	 //Clear on OCR3A match
    1da2:	80 91 8b 00 	lds	r24, 0x008B	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
    1da6:	82 68       	ori	r24, 0x82	; 130
    1da8:	80 93 8b 00 	sts	0x008B, r24	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
   TCCR3B |= (1<<CS30) | (1<<WGM32) | (1<<WGM33);		//Fast PWM mode, no prescaler
    1dac:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
    1db0:	89 61       	ori	r24, 0x19	; 25
    1db2:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
   TCCR3C = 0x00;
    1db6:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x7e008c>
   ICR3 = 0x9F;				//Setting the TOP value
    1dba:	8f e9       	ldi	r24, 0x9F	; 159
    1dbc:	90 e0       	ldi	r25, 0x00	; 0
    1dbe:	90 93 81 00 	sts	0x0081, r25	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
    1dc2:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
   TCNT3 = 0x0000; 			//Initialize TNCT1 to 0
    1dc6:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    1dca:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
   OCR3A = 0x9F;			//Volume Control 0x9F=Max 0x00=Min
    1dce:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
    1dd2:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
Description: Basic adc initialization used for single shot adc readings
Parameters: NA
**********************************************************************/
void adc_init(){
//Initalize ADC and its ports
   DDRF  &= ~(_BV(DDF7)); //make port F bit 7 is ADC input  
    1dd6:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
    1dda:	8f 77       	andi	r24, 0x7F	; 127
    1ddc:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
   PORTF &= ~(_BV(PF7));  //port F bit 7 pullups must be off
    1de0:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
    1de4:	8f 77       	andi	r24, 0x7F	; 127
    1de6:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__TEXT_REGION_LENGTH__+0x7e0062>
   ADMUX |= (1<<REFS0) | (1<<MUX2)| (1<<MUX1)| (1<<MUX0); //single-ended, input PORTF bit 7, right adjusted, 10 bits
    1dea:	87 b1       	in	r24, 0x07	; 7
    1dec:	87 64       	ori	r24, 0x47	; 71
    1dee:	87 b9       	out	0x07, r24	; 7

   ADCSRA |= (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);//ADC enabled, don't start yet, single shot mode 
    1df0:	86 b1       	in	r24, 0x06	; 6
    1df2:	87 68       	ori	r24, 0x87	; 135
    1df4:	86 b9       	out	0x06, r24	; 6
   tcnt0_init();
   tcnt1_init();
   tcnt2_init();
   tcnt3_init();
   adc_init();
   port_init();
    1df6:	0e 94 21 06 	call	0xc42	; 0xc42 <port_init>
   init_twi();
    1dfa:	0e 94 9c 0c 	call	0x1938	; 0x1938 <init_twi>
Description: Initialized the lm73
Parameters: NA
**********************************************************************/
void local_temp_init(){

lm73_wr_buf[0] = 0x00; //load lm73_wr_buf[0] with temperature pointer address
    1dfe:	10 92 c6 01 	sts	0x01C6, r1	; 0x8001c6 <lm73_wr_buf>
twi_start_wr(LM73_ADDRESS, lm73_rd_buf, 1); //start the TWI write process
    1e02:	41 e0       	ldi	r20, 0x01	; 1
    1e04:	68 ec       	ldi	r22, 0xC8	; 200
    1e06:	71 e0       	ldi	r23, 0x01	; 1
    1e08:	80 e9       	ldi	r24, 0x90	; 144
    1e0a:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <twi_start_wr>
    1e0e:	2f ef       	ldi	r18, 0xFF	; 255
    1e10:	81 ee       	ldi	r24, 0xE1	; 225
    1e12:	94 e0       	ldi	r25, 0x04	; 4
    1e14:	21 50       	subi	r18, 0x01	; 1
    1e16:	80 40       	sbci	r24, 0x00	; 0
    1e18:	90 40       	sbci	r25, 0x00	; 0
    1e1a:	e1 f7       	brne	.-8      	; 0x1e14 <main+0xb4>
    1e1c:	00 c0       	rjmp	.+0      	; 0x1e1e <main+0xbe>
    1e1e:	00 00       	nop
   adc_init();
   port_init();
   init_twi();
   local_temp_init();   

   uart_init();
    1e20:	0e 94 ce 0c 	call	0x199c	; 0x199c <uart_init>
   lcd_init();
    1e24:	0e 94 77 09 	call	0x12ee	; 0x12ee <lcd_init>
   sei();				//Enable interrupts
    1e28:	78 94       	sei
	}
	else{
	 line1_col1();
	 string2lcd("RADIO");	//printing radio on the lcd
	 radio = 0;	//radio, turn off, and alarm are flags used elsewhere
	 turn_off = 1;
    1e2a:	d1 e0       	ldi	r29, 0x01	; 1
	 }
	 PORTA = segment_data[j];	//Writes the segment data to PORTA aka the segments
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
				//the digit to be displayed is in pin 4, 5, and 6 
         _delay_us(150);		//delay so that the display does not flicker
         PORTA = 0xFF;
    1e2c:	cf ef       	ldi	r28, 0xFF	; 255
   lcd_init();
   sei();				//Enable interrupts
   while(1){

//***************  start rcv portion ***************
      if(rcv_rdy==1){	//read received uart data into my array that will be displayed
    1e2e:	80 91 6f 01 	lds	r24, 0x016F	; 0x80016f <rcv_rdy>
    1e32:	81 30       	cpi	r24, 0x01	; 1
    1e34:	09 f4       	brne	.+2      	; 0x1e38 <main+0xd8>
    1e36:	50 c0       	rjmp	.+160    	; 0x1ed8 <main+0x178>
Description: This function disables the snooze variable once the alarm
	seconds equals the normal seconds. 
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
    1e38:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <snooze>
    1e3c:	81 11       	cpse	r24, r1
    1e3e:	5b c0       	rjmp	.+182    	; 0x1ef6 <main+0x196>
  	 lcd_array[9] = lcd_str_array[1];
	 rcv_rdy=0;
      }//if 
//**************  end rcv portion ***************
      snoozin();	//Snooze function
      fetch_adc();	//get adc value
    1e40:	0e 94 76 06 	call	0xcec	; 0xcec <fetch_adc>
      clock_time();	//update the clock time
    1e44:	0e 94 8c 04 	call	0x918	; 0x918 <clock_time>
      change_alarm_state();
    1e48:	0e 94 42 06 	call	0xc84	; 0xc84 <change_alarm_state>
      if(radio){	//1 when the radio on/off button is pressed
    1e4c:	80 91 47 01 	lds	r24, 0x0147	; 0x800147 <radio>
    1e50:	88 23       	and	r24, r24
    1e52:	89 f0       	breq	.+34     	; 0x1e76 <main+0x116>
	if(turn_off){
    1e54:	80 91 4b 01 	lds	r24, 0x014B	; 0x80014b <turn_off>
    1e58:	88 23       	and	r24, r24
    1e5a:	09 f4       	brne	.+2      	; 0x1e5e <main+0xfe>
    1e5c:	55 c0       	rjmp	.+170    	; 0x1f08 <main+0x1a8>
	 line1_col1();
    1e5e:	0e 94 08 09 	call	0x1210	; 0x1210 <line1_col1>
	 string2lcd("     ");	//clears the top row of the lcd
    1e62:	81 e3       	ldi	r24, 0x31	; 49
    1e64:	91 e0       	ldi	r25, 0x01	; 1
    1e66:	0e 94 4a 09 	call	0x1294	; 0x1294 <string2lcd>
	 radio = 0;
    1e6a:	10 92 47 01 	sts	0x0147, r1	; 0x800147 <radio>
	 radio_pwr_dwn();	//turn the radio off
    1e6e:	0e 94 5d 0d 	call	0x1aba	; 0x1aba <radio_pwr_dwn>
	 turn_off = 0;
    1e72:	10 92 4b 01 	sts	0x014B, r1	; 0x80014b <turn_off>
	 alarm = 0;
	 radio_function();	//Powers up the radio
	 radio_function();	//Spamming power up is the only way I got it to turn on
	}
      }
      if(tune && turn_off){	//if the frequency was changed via the encoder and the radio is on
    1e76:	80 91 4a 01 	lds	r24, 0x014A	; 0x80014a <tune>
    1e7a:	88 23       	and	r24, r24
    1e7c:	21 f0       	breq	.+8      	; 0x1e86 <main+0x126>
    1e7e:	80 91 4b 01 	lds	r24, 0x014B	; 0x80014b <turn_off>
    1e82:	81 11       	cpse	r24, r1
    1e84:	52 c0       	rjmp	.+164    	; 0x1f2a <main+0x1ca>
    1e86:	ee e3       	ldi	r30, 0x3E	; 62
    1e88:	f1 e0       	ldi	r31, 0x01	; 1
Description: Program interrupts are enabled, initial port declarations,
	and while loop are defined. The LED display is updated continuously 
	in the loop.
Parameters: NA
**********************************************************************/
int main() {
    1e8a:	80 e0       	ldi	r24, 0x00	; 0
      if(tune && turn_off){	//if the frequency was changed via the encoder and the radio is on
	 tune = 0;		//then tune the fm radio
	 fm_tune_freq(current_fm_freq);
      }
      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
         if(alarm){
    1e8c:	90 91 49 01 	lds	r25, 0x0149	; 0x800149 <alarm>
    1e90:	99 23       	and	r25, r25
    1e92:	29 f0       	breq	.+10     	; 0x1e9e <main+0x13e>
	    segment_data[2] &= 0b011;
    1e94:	90 91 40 01 	lds	r25, 0x0140	; 0x800140 <__data_end+0x2>
    1e98:	93 70       	andi	r25, 0x03	; 3
    1e9a:	90 93 40 01 	sts	0x0140, r25	; 0x800140 <__data_end+0x2>
	 }
	 if(mode_sel==4){		//This turns on the decimal point for the frequency
    1e9e:	20 91 43 01 	lds	r18, 0x0143	; 0x800143 <mode_sel>
    1ea2:	30 91 44 01 	lds	r19, 0x0144	; 0x800144 <mode_sel+0x1>
    1ea6:	24 30       	cpi	r18, 0x04	; 4
    1ea8:	31 05       	cpc	r19, r1
    1eaa:	41 f1       	breq	.+80     	; 0x1efc <main+0x19c>
	    segment_data[1] &= 0b01111111;
	 }
	 PORTA = segment_data[j];	//Writes the segment data to PORTA aka the segments
    1eac:	91 91       	ld	r25, Z+
    1eae:	9b bb       	out	0x1b, r25	; 27
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
    1eb0:	98 2f       	mov	r25, r24
    1eb2:	92 95       	swap	r25
    1eb4:	90 7f       	andi	r25, 0xF0	; 240
    1eb6:	98 bb       	out	0x18, r25	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1eb8:	a7 e5       	ldi	r26, 0x57	; 87
    1eba:	b2 e0       	ldi	r27, 0x02	; 2
    1ebc:	11 97       	sbiw	r26, 0x01	; 1
    1ebe:	f1 f7       	brne	.-4      	; 0x1ebc <main+0x15c>
    1ec0:	00 c0       	rjmp	.+0      	; 0x1ec2 <main+0x162>
    1ec2:	00 00       	nop
				//the digit to be displayed is in pin 4, 5, and 6 
         _delay_us(150);		//delay so that the display does not flicker
         PORTA = 0xFF;
    1ec4:	cb bb       	out	0x1b, r28	; 27
    1ec6:	8f 5f       	subi	r24, 0xFF	; 255
      }
      if(tune && turn_off){	//if the frequency was changed via the encoder and the radio is on
	 tune = 0;		//then tune the fm radio
	 fm_tune_freq(current_fm_freq);
      }
      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
    1ec8:	85 30       	cpi	r24, 0x05	; 5
    1eca:	01 f7       	brne	.-64     	; 0x1e8c <main+0x12c>
         PORTB = j << 4;		//J is bound 0-4 and that value is shifted left 4 so that 
				//the digit to be displayed is in pin 4, 5, and 6 
         _delay_us(150);		//delay so that the display does not flicker
         PORTA = 0xFF;
      }
	PORTB = 0x00;
    1ecc:	18 ba       	out	0x18, r1	; 24
   lcd_init();
   sei();				//Enable interrupts
   while(1){

//***************  start rcv portion ***************
      if(rcv_rdy==1){	//read received uart data into my array that will be displayed
    1ece:	80 91 6f 01 	lds	r24, 0x016F	; 0x80016f <rcv_rdy>
    1ed2:	81 30       	cpi	r24, 0x01	; 1
    1ed4:	09 f0       	breq	.+2      	; 0x1ed8 <main+0x178>
    1ed6:	b0 cf       	rjmp	.-160    	; 0x1e38 <main+0xd8>
         lcd_array[8] = lcd_str_array[0];
    1ed8:	80 91 7b 01 	lds	r24, 0x017B	; 0x80017b <lcd_str_array>
    1edc:	80 93 1f 01 	sts	0x011F, r24	; 0x80011f <lcd_array+0x8>
  	 lcd_array[9] = lcd_str_array[1];
    1ee0:	80 91 7c 01 	lds	r24, 0x017C	; 0x80017c <lcd_str_array+0x1>
    1ee4:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <lcd_array+0x9>
	 rcv_rdy=0;
    1ee8:	10 92 6f 01 	sts	0x016F, r1	; 0x80016f <rcv_rdy>
Description: This function disables the snooze variable once the alarm
	seconds equals the normal seconds. 
Parameters: NA
**********************************************************************/
void snoozin() {
   if(snooze){
    1eec:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <snooze>
    1ef0:	88 23       	and	r24, r24
    1ef2:	09 f4       	brne	.+2      	; 0x1ef6 <main+0x196>
    1ef4:	a5 cf       	rjmp	.-182    	; 0x1e40 <main+0xe0>
    1ef6:	0e 94 b8 00 	call	0x170	; 0x170 <snoozin.part.1>
    1efa:	a2 cf       	rjmp	.-188    	; 0x1e40 <main+0xe0>
      for( int j = 0; j < 5; j++) {	//cycles through each of the five digits
         if(alarm){
	    segment_data[2] &= 0b011;
	 }
	 if(mode_sel==4){		//This turns on the decimal point for the frequency
	    segment_data[1] &= 0b01111111;
    1efc:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <__data_end+0x1>
    1f00:	9f 77       	andi	r25, 0x7F	; 127
    1f02:	90 93 3f 01 	sts	0x013F, r25	; 0x80013f <__data_end+0x1>
    1f06:	d2 cf       	rjmp	.-92     	; 0x1eac <main+0x14c>
	 radio = 0;
	 radio_pwr_dwn();	//turn the radio off
	 turn_off = 0;
	}
	else{
	 line1_col1();
    1f08:	0e 94 08 09 	call	0x1210	; 0x1210 <line1_col1>
	 string2lcd("RADIO");	//printing radio on the lcd
    1f0c:	87 e3       	ldi	r24, 0x37	; 55
    1f0e:	91 e0       	ldi	r25, 0x01	; 1
    1f10:	0e 94 4a 09 	call	0x1294	; 0x1294 <string2lcd>
	 radio = 0;	//radio, turn off, and alarm are flags used elsewhere
    1f14:	10 92 47 01 	sts	0x0147, r1	; 0x800147 <radio>
	 turn_off = 1;
    1f18:	d0 93 4b 01 	sts	0x014B, r29	; 0x80014b <turn_off>
	 alarm = 0;
    1f1c:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <alarm>
	 radio_function();	//Powers up the radio
    1f20:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <radio_function>
	 radio_function();	//Spamming power up is the only way I got it to turn on
    1f24:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <radio_function>
    1f28:	a6 cf       	rjmp	.-180    	; 0x1e76 <main+0x116>
	}
      }
      if(tune && turn_off){	//if the frequency was changed via the encoder and the radio is on
	 tune = 0;		//then tune the fm radio
    1f2a:	10 92 4a 01 	sts	0x014A, r1	; 0x80014a <tune>
	 fm_tune_freq(current_fm_freq);
    1f2e:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <current_fm_freq>
    1f32:	90 91 28 01 	lds	r25, 0x0128	; 0x800128 <current_fm_freq+0x1>
    1f36:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <fm_tune_freq>
    1f3a:	a5 cf       	rjmp	.-182    	; 0x1e86 <main+0x126>

00001f3c <__divmodhi4>:
    1f3c:	97 fb       	bst	r25, 7
    1f3e:	07 2e       	mov	r0, r23
    1f40:	16 f4       	brtc	.+4      	; 0x1f46 <__divmodhi4+0xa>
    1f42:	00 94       	com	r0
    1f44:	07 d0       	rcall	.+14     	; 0x1f54 <__divmodhi4_neg1>
    1f46:	77 fd       	sbrc	r23, 7
    1f48:	09 d0       	rcall	.+18     	; 0x1f5c <__divmodhi4_neg2>
    1f4a:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <__udivmodhi4>
    1f4e:	07 fc       	sbrc	r0, 7
    1f50:	05 d0       	rcall	.+10     	; 0x1f5c <__divmodhi4_neg2>
    1f52:	3e f4       	brtc	.+14     	; 0x1f62 <__divmodhi4_exit>

00001f54 <__divmodhi4_neg1>:
    1f54:	90 95       	com	r25
    1f56:	81 95       	neg	r24
    1f58:	9f 4f       	sbci	r25, 0xFF	; 255
    1f5a:	08 95       	ret

00001f5c <__divmodhi4_neg2>:
    1f5c:	70 95       	com	r23
    1f5e:	61 95       	neg	r22
    1f60:	7f 4f       	sbci	r23, 0xFF	; 255

00001f62 <__divmodhi4_exit>:
    1f62:	08 95       	ret

00001f64 <__divmodsi4>:
    1f64:	05 2e       	mov	r0, r21
    1f66:	97 fb       	bst	r25, 7
    1f68:	1e f4       	brtc	.+6      	; 0x1f70 <__divmodsi4+0xc>
    1f6a:	00 94       	com	r0
    1f6c:	0e 94 c9 0f 	call	0x1f92	; 0x1f92 <__negsi2>
    1f70:	57 fd       	sbrc	r21, 7
    1f72:	07 d0       	rcall	.+14     	; 0x1f82 <__divmodsi4_neg2>
    1f74:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <__udivmodsi4>
    1f78:	07 fc       	sbrc	r0, 7
    1f7a:	03 d0       	rcall	.+6      	; 0x1f82 <__divmodsi4_neg2>
    1f7c:	4e f4       	brtc	.+18     	; 0x1f90 <__divmodsi4_exit>
    1f7e:	0c 94 c9 0f 	jmp	0x1f92	; 0x1f92 <__negsi2>

00001f82 <__divmodsi4_neg2>:
    1f82:	50 95       	com	r21
    1f84:	40 95       	com	r20
    1f86:	30 95       	com	r19
    1f88:	21 95       	neg	r18
    1f8a:	3f 4f       	sbci	r19, 0xFF	; 255
    1f8c:	4f 4f       	sbci	r20, 0xFF	; 255
    1f8e:	5f 4f       	sbci	r21, 0xFF	; 255

00001f90 <__divmodsi4_exit>:
    1f90:	08 95       	ret

00001f92 <__negsi2>:
    1f92:	90 95       	com	r25
    1f94:	80 95       	com	r24
    1f96:	70 95       	com	r23
    1f98:	61 95       	neg	r22
    1f9a:	7f 4f       	sbci	r23, 0xFF	; 255
    1f9c:	8f 4f       	sbci	r24, 0xFF	; 255
    1f9e:	9f 4f       	sbci	r25, 0xFF	; 255
    1fa0:	08 95       	ret

00001fa2 <__tablejump2__>:
    1fa2:	ee 0f       	add	r30, r30
    1fa4:	ff 1f       	adc	r31, r31
    1fa6:	00 24       	eor	r0, r0
    1fa8:	00 1c       	adc	r0, r0
    1faa:	0b be       	out	0x3b, r0	; 59
    1fac:	07 90       	elpm	r0, Z+
    1fae:	f6 91       	elpm	r31, Z
    1fb0:	e0 2d       	mov	r30, r0
    1fb2:	09 94       	ijmp

00001fb4 <__umulhisi3>:
    1fb4:	a2 9f       	mul	r26, r18
    1fb6:	b0 01       	movw	r22, r0
    1fb8:	b3 9f       	mul	r27, r19
    1fba:	c0 01       	movw	r24, r0
    1fbc:	a3 9f       	mul	r26, r19
    1fbe:	70 0d       	add	r23, r0
    1fc0:	81 1d       	adc	r24, r1
    1fc2:	11 24       	eor	r1, r1
    1fc4:	91 1d       	adc	r25, r1
    1fc6:	b2 9f       	mul	r27, r18
    1fc8:	70 0d       	add	r23, r0
    1fca:	81 1d       	adc	r24, r1
    1fcc:	11 24       	eor	r1, r1
    1fce:	91 1d       	adc	r25, r1
    1fd0:	08 95       	ret

00001fd2 <__udivmodhi4>:
    1fd2:	aa 1b       	sub	r26, r26
    1fd4:	bb 1b       	sub	r27, r27
    1fd6:	51 e1       	ldi	r21, 0x11	; 17
    1fd8:	07 c0       	rjmp	.+14     	; 0x1fe8 <__udivmodhi4_ep>

00001fda <__udivmodhi4_loop>:
    1fda:	aa 1f       	adc	r26, r26
    1fdc:	bb 1f       	adc	r27, r27
    1fde:	a6 17       	cp	r26, r22
    1fe0:	b7 07       	cpc	r27, r23
    1fe2:	10 f0       	brcs	.+4      	; 0x1fe8 <__udivmodhi4_ep>
    1fe4:	a6 1b       	sub	r26, r22
    1fe6:	b7 0b       	sbc	r27, r23

00001fe8 <__udivmodhi4_ep>:
    1fe8:	88 1f       	adc	r24, r24
    1fea:	99 1f       	adc	r25, r25
    1fec:	5a 95       	dec	r21
    1fee:	a9 f7       	brne	.-22     	; 0x1fda <__udivmodhi4_loop>
    1ff0:	80 95       	com	r24
    1ff2:	90 95       	com	r25
    1ff4:	bc 01       	movw	r22, r24
    1ff6:	cd 01       	movw	r24, r26
    1ff8:	08 95       	ret

00001ffa <__udivmodsi4>:
    1ffa:	a1 e2       	ldi	r26, 0x21	; 33
    1ffc:	1a 2e       	mov	r1, r26
    1ffe:	aa 1b       	sub	r26, r26
    2000:	bb 1b       	sub	r27, r27
    2002:	fd 01       	movw	r30, r26
    2004:	0d c0       	rjmp	.+26     	; 0x2020 <__udivmodsi4_ep>

00002006 <__udivmodsi4_loop>:
    2006:	aa 1f       	adc	r26, r26
    2008:	bb 1f       	adc	r27, r27
    200a:	ee 1f       	adc	r30, r30
    200c:	ff 1f       	adc	r31, r31
    200e:	a2 17       	cp	r26, r18
    2010:	b3 07       	cpc	r27, r19
    2012:	e4 07       	cpc	r30, r20
    2014:	f5 07       	cpc	r31, r21
    2016:	20 f0       	brcs	.+8      	; 0x2020 <__udivmodsi4_ep>
    2018:	a2 1b       	sub	r26, r18
    201a:	b3 0b       	sbc	r27, r19
    201c:	e4 0b       	sbc	r30, r20
    201e:	f5 0b       	sbc	r31, r21

00002020 <__udivmodsi4_ep>:
    2020:	66 1f       	adc	r22, r22
    2022:	77 1f       	adc	r23, r23
    2024:	88 1f       	adc	r24, r24
    2026:	99 1f       	adc	r25, r25
    2028:	1a 94       	dec	r1
    202a:	69 f7       	brne	.-38     	; 0x2006 <__udivmodsi4_loop>
    202c:	60 95       	com	r22
    202e:	70 95       	com	r23
    2030:	80 95       	com	r24
    2032:	90 95       	com	r25
    2034:	9b 01       	movw	r18, r22
    2036:	ac 01       	movw	r20, r24
    2038:	bd 01       	movw	r22, r26
    203a:	cf 01       	movw	r24, r30
    203c:	08 95       	ret

0000203e <__itoa_ncheck>:
    203e:	bb 27       	eor	r27, r27
    2040:	4a 30       	cpi	r20, 0x0A	; 10
    2042:	31 f4       	brne	.+12     	; 0x2050 <__itoa_ncheck+0x12>
    2044:	99 23       	and	r25, r25
    2046:	22 f4       	brpl	.+8      	; 0x2050 <__itoa_ncheck+0x12>
    2048:	bd e2       	ldi	r27, 0x2D	; 45
    204a:	90 95       	com	r25
    204c:	81 95       	neg	r24
    204e:	9f 4f       	sbci	r25, 0xFF	; 255
    2050:	0c 94 2b 10 	jmp	0x2056	; 0x2056 <__utoa_common>

00002054 <__utoa_ncheck>:
    2054:	bb 27       	eor	r27, r27

00002056 <__utoa_common>:
    2056:	fb 01       	movw	r30, r22
    2058:	55 27       	eor	r21, r21
    205a:	aa 27       	eor	r26, r26
    205c:	88 0f       	add	r24, r24
    205e:	99 1f       	adc	r25, r25
    2060:	aa 1f       	adc	r26, r26
    2062:	a4 17       	cp	r26, r20
    2064:	10 f0       	brcs	.+4      	; 0x206a <__utoa_common+0x14>
    2066:	a4 1b       	sub	r26, r20
    2068:	83 95       	inc	r24
    206a:	50 51       	subi	r21, 0x10	; 16
    206c:	b9 f7       	brne	.-18     	; 0x205c <__utoa_common+0x6>
    206e:	a0 5d       	subi	r26, 0xD0	; 208
    2070:	aa 33       	cpi	r26, 0x3A	; 58
    2072:	08 f0       	brcs	.+2      	; 0x2076 <__utoa_common+0x20>
    2074:	a9 5d       	subi	r26, 0xD9	; 217
    2076:	a1 93       	st	Z+, r26
    2078:	00 97       	sbiw	r24, 0x00	; 0
    207a:	79 f7       	brne	.-34     	; 0x205a <__utoa_common+0x4>
    207c:	b1 11       	cpse	r27, r1
    207e:	b1 93       	st	Z+, r27
    2080:	11 92       	st	Z+, r1
    2082:	cb 01       	movw	r24, r22
    2084:	0c 94 44 10 	jmp	0x2088	; 0x2088 <strrev>

00002088 <strrev>:
    2088:	dc 01       	movw	r26, r24
    208a:	fc 01       	movw	r30, r24
    208c:	67 2f       	mov	r22, r23
    208e:	71 91       	ld	r23, Z+
    2090:	77 23       	and	r23, r23
    2092:	e1 f7       	brne	.-8      	; 0x208c <strrev+0x4>
    2094:	32 97       	sbiw	r30, 0x02	; 2
    2096:	04 c0       	rjmp	.+8      	; 0x20a0 <strrev+0x18>
    2098:	7c 91       	ld	r23, X
    209a:	6d 93       	st	X+, r22
    209c:	70 83       	st	Z, r23
    209e:	62 91       	ld	r22, -Z
    20a0:	ae 17       	cp	r26, r30
    20a2:	bf 07       	cpc	r27, r31
    20a4:	c8 f3       	brcs	.-14     	; 0x2098 <strrev+0x10>
    20a6:	08 95       	ret

000020a8 <eeprom_read_byte>:
    20a8:	e1 99       	sbic	0x1c, 1	; 28
    20aa:	fe cf       	rjmp	.-4      	; 0x20a8 <eeprom_read_byte>
    20ac:	9f bb       	out	0x1f, r25	; 31
    20ae:	8e bb       	out	0x1e, r24	; 30
    20b0:	e0 9a       	sbi	0x1c, 0	; 28
    20b2:	99 27       	eor	r25, r25
    20b4:	8d b3       	in	r24, 0x1d	; 29
    20b6:	08 95       	ret

000020b8 <eeprom_read_word>:
    20b8:	a8 e1       	ldi	r26, 0x18	; 24
    20ba:	b0 e0       	ldi	r27, 0x00	; 0
    20bc:	42 e0       	ldi	r20, 0x02	; 2
    20be:	50 e0       	ldi	r21, 0x00	; 0
    20c0:	0c 94 76 10 	jmp	0x20ec	; 0x20ec <eeprom_read_blraw>

000020c4 <eeprom_write_byte>:
    20c4:	26 2f       	mov	r18, r22

000020c6 <eeprom_write_r18>:
    20c6:	e1 99       	sbic	0x1c, 1	; 28
    20c8:	fe cf       	rjmp	.-4      	; 0x20c6 <eeprom_write_r18>
    20ca:	9f bb       	out	0x1f, r25	; 31
    20cc:	8e bb       	out	0x1e, r24	; 30
    20ce:	2d bb       	out	0x1d, r18	; 29
    20d0:	0f b6       	in	r0, 0x3f	; 63
    20d2:	f8 94       	cli
    20d4:	e2 9a       	sbi	0x1c, 2	; 28
    20d6:	e1 9a       	sbi	0x1c, 1	; 28
    20d8:	0f be       	out	0x3f, r0	; 63
    20da:	01 96       	adiw	r24, 0x01	; 1
    20dc:	08 95       	ret

000020de <eeprom_write_word>:
    20de:	0e 94 62 10 	call	0x20c4	; 0x20c4 <eeprom_write_byte>
    20e2:	27 2f       	mov	r18, r23
    20e4:	0c 94 63 10 	jmp	0x20c6	; 0x20c6 <eeprom_write_r18>

000020e8 <eeprom_read_block>:
    20e8:	dc 01       	movw	r26, r24
    20ea:	cb 01       	movw	r24, r22

000020ec <eeprom_read_blraw>:
    20ec:	fc 01       	movw	r30, r24
    20ee:	e1 99       	sbic	0x1c, 1	; 28
    20f0:	fe cf       	rjmp	.-4      	; 0x20ee <eeprom_read_blraw+0x2>
    20f2:	06 c0       	rjmp	.+12     	; 0x2100 <eeprom_read_blraw+0x14>
    20f4:	ff bb       	out	0x1f, r31	; 31
    20f6:	ee bb       	out	0x1e, r30	; 30
    20f8:	e0 9a       	sbi	0x1c, 0	; 28
    20fa:	31 96       	adiw	r30, 0x01	; 1
    20fc:	0d b2       	in	r0, 0x1d	; 29
    20fe:	0d 92       	st	X+, r0
    2100:	41 50       	subi	r20, 0x01	; 1
    2102:	50 40       	sbci	r21, 0x00	; 0
    2104:	b8 f7       	brcc	.-18     	; 0x20f4 <eeprom_read_blraw+0x8>
    2106:	08 95       	ret

00002108 <_exit>:
    2108:	f8 94       	cli

0000210a <__stop_program>:
    210a:	ff cf       	rjmp	.-2      	; 0x210a <__stop_program>
